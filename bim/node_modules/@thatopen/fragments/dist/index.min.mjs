var t=Object.defineProperty,e=(e,s,r)=>(((e,s,r)=>{s in e?t(e,s,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[s]=r})(e,"symbol"!=typeof s?s+"":s,r),r);import*as s from"three";import{BufferAttribute as r,Vector3 as i,Vector2 as n,Plane as o,Line3 as a,Triangle as c,Sphere as b,Matrix4 as h,Box3 as d,BackSide as l,DoubleSide as f,FrontSide as u,Mesh as _,Ray as p,BufferGeometry as m}from"three";class g extends s.InstancedMesh{constructor(t,s,r,i){if(super(t,s,r),e(this,"fragment"),e(this,"material"),e(this,"geometry"),Array.isArray(s)||(s=[s]),this.material=s,!t.index)throw new Error("The geometry for fragments must be indexed!");this.geometry=t,this.fragment=i;const n=t.index.count;t.groups.length||t.groups.push({start:0,count:n,materialIndex:0})}exportData(){const t=this.geometry.attributes.position.array,e=this.geometry.attributes.normal.array,r=Array.from(this.geometry.index.array),i=[];for(const t of this.geometry.groups){const e=t.materialIndex||0,{start:s,count:r}=t;i.push(s,r,e)}const n=[];if(Array.isArray(this.material))for(const t of this.material){const e=t.opacity,r=t.transparent?1:0,i=new s.Color(t.color).toArray();n.push(e,r,...i)}const o=Array.from(this.instanceMatrix.array);let a;return a=null!==this.instanceColor?Array.from(this.instanceColor.array):[],{position:t,normal:e,index:r,groups:i,materials:n,matrices:o,colors:a}}clone(t){throw new Error("Fragment meshes can't be cloned directly. Use mesh.fragment.clone instead!")}}const y=1.25,w=65535,I=Math.pow(2,-24),v=Symbol("SKIP_GENERATION");function x(t){return function(t){return t.index?t.index.count:t.attributes.position.count}(t)/3}function A(t,e){if(!t.index){const s=t.attributes.position.count,i=function(t,e=ArrayBuffer){return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}(s,e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);t.setIndex(new r(i,1));for(let t=0;t<s;t++)i[t]=t}}function V(t){const e=x(t),s=t.drawRange,r=s.start/3,i=(s.start+s.count)/3,n=Math.max(0,r),o=Math.min(e,i)-n;return[{offset:Math.floor(n),count:Math.floor(o)}]}function F(t){if(!t.groups||!t.groups.length)return V(t);const e=[],s=new Set,r=t.drawRange,i=r.start/3,n=(r.start+r.count)/3;for(const e of t.groups){const t=e.start/3,r=(e.start+e.count)/3;s.add(Math.max(i,t)),s.add(Math.min(n,r))}const o=Array.from(s.values()).sort(((t,e)=>t-e));for(let t=0;t<o.length-1;t++){const s=o[t],r=o[t+1];e.push({offset:Math.floor(s),count:Math.floor(r-s)})}return e}function B(t,e,s){return s.min.x=e[t],s.min.y=e[t+1],s.min.z=e[t+2],s.max.x=e[t+3],s.max.y=e[t+4],s.max.z=e[t+5],s}function M(t){let e=-1,s=-1/0;for(let r=0;r<3;r++){const i=t[r+3]-t[r];i>s&&(s=i,e=r)}return e}function C(t,e){e.set(t)}function O(t,e,s){let r,i;for(let n=0;n<3;n++){const o=n+3;r=t[n],i=e[n],s[n]=r<i?r:i,r=t[o],i=e[o],s[o]=r>i?r:i}}function P(t,e,s){for(let r=0;r<3;r++){const i=e[t+2*r],n=e[t+2*r+1],o=i-n,a=i+n;o<s[r]&&(s[r]=o),a>s[r+3]&&(s[r+3]=a)}}function T(t){const e=t[3]-t[0],s=t[4]-t[1],r=t[5]-t[2];return 2*(e*s+s*r+r*e)}function S(t,e,s,r,i=null){let n=1/0,o=1/0,a=1/0,c=-1/0,b=-1/0,h=-1/0,d=1/0,l=1/0,f=1/0,u=-1/0,_=-1/0,p=-1/0;const m=null!==i;for(let r=6*e,i=6*(e+s);r<i;r+=6){const e=t[r+0],s=t[r+1],i=e-s,g=e+s;i<n&&(n=i),g>c&&(c=g),m&&e<d&&(d=e),m&&e>u&&(u=e);const y=t[r+2],w=t[r+3],I=y-w,v=y+w;I<o&&(o=I),v>b&&(b=v),m&&y<l&&(l=y),m&&y>_&&(_=y);const x=t[r+4],A=t[r+5],V=x-A,F=x+A;V<a&&(a=V),F>h&&(h=F),m&&x<f&&(f=x),m&&x>p&&(p=x)}r[0]=n,r[1]=o,r[2]=a,r[3]=c,r[4]=b,r[5]=h,m&&(i[0]=d,i[1]=l,i[2]=f,i[3]=u,i[4]=_,i[5]=p)}const U=32,D=(t,e)=>t.candidate-e.candidate,G=new Array(U).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),L=new Float32Array(6);class z{constructor(){}}function E(t,e,s,r,i,n){let o=r,a=r+i-1;const c=n.pos,b=2*n.axis;for(;;){for(;o<=a&&s[6*o+b]<c;)o++;for(;o<=a&&s[6*a+b]>=c;)a--;if(!(o<a))return o;for(let t=0;t<3;t++){let s=e[3*o+t];e[3*o+t]=e[3*a+t],e[3*a+t]=s}for(let t=0;t<6;t++){let e=s[6*o+t];s[6*o+t]=s[6*a+t],s[6*a+t]=e}o++,a--}}function N(t,e,s,r,i,n){let o=r,a=r+i-1;const c=n.pos,b=2*n.axis;for(;;){for(;o<=a&&s[6*o+b]<c;)o++;for(;o<=a&&s[6*a+b]>=c;)a--;if(!(o<a))return o;{let e=t[o];t[o]=t[a],t[a]=e;for(let t=0;t<6;t++){let e=s[6*o+t];s[6*o+t]=s[6*a+t],s[6*a+t]=e}o++,a--}}}function R(t,e){const s=t.geometry,r=s.index?s.index.array:null,i=e.maxDepth,n=e.verbose,o=e.maxLeafTris,a=e.strategy,c=e.onProgress,b=x(s),h=t._indirectBuffer;let d=!1;const l=new Float32Array(6),f=new Float32Array(6),u=function(t,e){var s;(s=e)[0]=s[1]=s[2]=1/0,s[3]=s[4]=s[5]=-1/0;const r=t.attributes.position,i=t.index?t.index.array:null,n=x(t),o=new Float32Array(6*n),a=r.normalized,c=r.array,b=r.offset||0;let h=3;r.isInterleavedBufferAttribute&&(h=r.data.stride);const d=["getX","getY","getZ"];for(let t=0;t<n;t++){const s=3*t,n=6*t;let l=s+0,f=s+1,u=s+2;i&&(l=i[l],f=i[f],u=i[u]),a||(l=l*h+b,f=f*h+b,u=u*h+b);for(let t=0;t<3;t++){let s,i,b;a?(s=r[d[t]](l),i=r[d[t]](f),b=r[d[t]](u)):(s=c[l+t],i=c[f+t],b=c[u+t]);let h=s;i<h&&(h=i),b<h&&(h=b);let _=s;i>_&&(_=i),b>_&&(_=b);const p=(_-h)/2,m=2*t;o[n+m+0]=h+p,o[n+m+1]=p+(Math.abs(h)+p)*I,h<e[t]&&(e[t]=h),_>e[t+3]&&(e[t+3]=_)}}return o}(s,l),_=e.indirect?N:E,p=[],m=e.indirect?V(s):F(s);if(1===m.length){const t=m[0],e=new z;e.boundingData=l,function(t,e,s,r){let i=1/0,n=1/0,o=1/0,a=-1/0,c=-1/0,b=-1/0;for(let r=6*e,h=6*(e+s);r<h;r+=6){const e=t[r+0];e<i&&(i=e),e>a&&(a=e);const s=t[r+2];s<n&&(n=s),s>c&&(c=s);const h=t[r+4];h<o&&(o=h),h>b&&(b=h)}r[0]=i,r[1]=n,r[2]=o,r[3]=a,r[4]=c,r[5]=b}(u,t.offset,t.count,f),w(e,t.offset,t.count,f),p.push(e)}else for(let t of m){const e=new z;e.boundingData=new Float32Array(6),S(u,t.offset,t.count,e.boundingData,f),w(e,t.offset,t.count,f),p.push(e)}return p;function g(t){c&&c(t/b)}function w(t,e,c,b=null,l=0){if(!d&&l>=i&&(d=!0,n&&(console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`),console.warn(s))),c<=o||l>=i)return g(e+c),t.offset=e,t.count=c,t;const p=function(t,e,s,r,i,n){let o=-1,a=0;if(0===n)o=M(e),-1!==o&&(a=(e[o]+e[o+3])/2);else if(1===n)o=M(t),-1!==o&&(a=function(t,e,s,r){let i=0;for(let n=e,o=e+s;n<o;n++)i+=t[6*n+2*r];return i/s}(s,r,i,o));else if(2===n){const n=T(t);let c=y*i;const b=6*r,h=6*(r+i);for(let t=0;t<3;t++){const r=e[t],d=(e[t+3]-r)/U;if(i<8){const e=[...G];e.length=i;let r=0;for(let i=b;i<h;i+=6,r++){const n=e[r];n.candidate=s[i+2*t],n.count=0;const{bounds:o,leftCacheBounds:a,rightCacheBounds:c}=n;for(let t=0;t<3;t++)c[t]=1/0,c[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0,o[t]=1/0,o[t+3]=-1/0;P(i,s,o)}e.sort(D);let d=i;for(let t=0;t<d;t++){const s=e[t];for(;t+1<d&&e[t+1].candidate===s.candidate;)e.splice(t+1,1),d--}for(let r=b;r<h;r+=6){const i=s[r+2*t];for(let t=0;t<d;t++){const n=e[t];i>=n.candidate?P(r,s,n.rightCacheBounds):(P(r,s,n.leftCacheBounds),n.count++)}}for(let s=0;s<d;s++){const r=e[s],b=r.count,h=i-r.count,d=r.leftCacheBounds,l=r.rightCacheBounds;let f=0;0!==b&&(f=T(d)/n);let u=0;0!==h&&(u=T(l)/n);const _=1+y*(f*b+u*h);_<c&&(o=t,c=_,a=r.candidate)}}else{for(let t=0;t<U;t++){const e=G[t];e.count=0,e.candidate=r+d+t*d;const s=e.bounds;for(let t=0;t<3;t++)s[t]=1/0,s[t+3]=-1/0}for(let e=b;e<h;e+=6){let i=~~((s[e+2*t]-r)/d);i>=U&&(i=31);const n=G[i];n.count++,P(e,s,n.bounds)}const e=G[31];C(e.bounds,e.rightCacheBounds);for(let t=30;t>=0;t--){const e=G[t],s=G[t+1];O(e.bounds,s.rightCacheBounds,e.rightCacheBounds)}let l=0;for(let e=0;e<31;e++){const s=G[e],r=s.count,b=s.bounds,h=G[e+1].rightCacheBounds;0!==r&&(0===l?C(b,L):O(b,L,L)),l+=r;let d=0,f=0;0!==l&&(d=T(L)/n);const u=i-l;0!==u&&(f=T(h)/n);const _=1+y*(d*l+f*u);_<c&&(o=t,c=_,a=s.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${n} used.`);return{axis:o,pos:a}}(t.boundingData,b,u,e,c,a);if(-1===p.axis)return g(e+c),t.offset=e,t.count=c,t;const m=_(h,r,u,e,c,p);if(m===e||m===e+c)g(e+c),t.offset=e,t.count=c;else{t.splitAxis=p.axis;const s=new z,r=e,i=m-e;t.left=s,s.boundingData=new Float32Array(6),S(u,r,i,s.boundingData,f),w(s,r,i,f,l+1);const n=new z,o=m,a=c-i;t.right=n,n.boundingData=new Float32Array(6),S(u,o,a,n.boundingData,f),w(n,o,a,f,l+1)}return t}}function K(t,e){const s=t.geometry;e.indirect&&(t._indirectBuffer=function(t,e){const s=(t.index?t.index.count:t.attributes.position.count)/3,r=s>65536,i=r?4:2,n=e?new SharedArrayBuffer(s*i):new ArrayBuffer(s*i),o=r?new Uint32Array(n):new Uint16Array(n);for(let t=0,e=o.length;t<e;t++)o[t]=t;return o}(s,e.useSharedArrayBuffer),function(t){if(0===t.groups.length)return!1;const e=x(t),s=F(t).sort(((t,e)=>t.offset-e.offset)),r=s[s.length-1];r.count=Math.min(e-r.offset,r.count);let i=0;return s.forEach((({count:t})=>i+=t)),e!==i}(s)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),t._indirectBuffer||A(s,e);const r=R(t,e);let i,n,o;const a=[],c=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let t=0;t<r.length;t++){const e=r[t];const s=new c(32*b(e));i=new Float32Array(s),n=new Uint32Array(s),o=new Uint16Array(s),h(0,e),a.push(s)}return void(t._roots=a);function b(t){return t.count?1:1+b(t.left)+b(t.right)}function h(t,e){const s=t/4,r=t/2,a=!!e.count,c=e.boundingData;for(let t=0;t<6;t++)i[s+t]=c[t];if(a){const i=e.offset,a=e.count;return n[s+6]=i,o[r+14]=a,o[r+15]=w,t+32}{const r=e.left,i=e.right,o=e.splitAxis;let a;if(a=h(t+32,r),a/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return n[s+6]=a/4,a=h(a,i),n[s+7]=o,a}}}class j{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,r=-1/0;for(let i=0,n=t.length;i<n;i++){const n=t[i][e];s=n<s?n:s,r=n>r?n:r}this.min=s,this.max=r}setFromPoints(t,e){let s=1/0,r=-1/0;for(let i=0,n=e.length;i<n;i++){const n=e[i],o=t.dot(n);s=o<s?o:s,r=o>r?o:r}this.min=s,this.max=r}isSeparated(t){return this.min>t.max||t.min>this.max}}j.prototype.setFromBox=function(){const t=new i;return function(e,s){const r=s.min,i=s.max;let n=1/0,o=-1/0;for(let s=0;s<=1;s++)for(let a=0;a<=1;a++)for(let c=0;c<=1;c++){t.x=r.x*s+i.x*(1-s),t.y=r.y*a+i.y*(1-a),t.z=r.z*c+i.z*(1-c);const b=e.dot(t);n=Math.min(b,n),o=Math.max(b,o)}this.min=n,this.max=o}}();const q=function(){const t=new i,e=new i,s=new i;return function(r,i,n){const o=r.start,a=t,c=i.start,b=e;s.subVectors(o,c),t.subVectors(r.end,r.start),e.subVectors(i.end,i.start);const h=s.dot(b),d=b.dot(a),l=b.dot(b),f=s.dot(a),u=a.dot(a)*l-d*d;let _,p;_=0!==u?(h*d-f*l)/u:0,p=(h+_*d)/l,n.x=_,n.y=p}}(),k=function(){const t=new n,e=new i,s=new i;return function(r,i,n,o){q(r,i,t);let a=t.x,c=t.y;if(a>=0&&a<=1&&c>=0&&c<=1)return r.at(a,n),void i.at(c,o);if(a>=0&&a<=1)return c<0?i.at(0,o):i.at(1,o),void r.closestPointToPoint(o,!0,n);if(c>=0&&c<=1)return a<0?r.at(0,n):r.at(1,n),void i.closestPointToPoint(n,!0,o);{let t,b;t=a<0?r.start:r.end,b=c<0?i.start:i.end;const h=e,d=s;return r.closestPointToPoint(b,!0,e),i.closestPointToPoint(t,!0,s),h.distanceToSquared(b)<=d.distanceToSquared(t)?(n.copy(h),void o.copy(b)):(n.copy(t),void o.copy(d))}}}(),H=function(){const t=new i,e=new i,s=new o,r=new a;return function(i,n){const{radius:o,center:a}=i,{a:c,b:b,c:h}=n;r.start=c,r.end=b;if(r.closestPointToPoint(a,!0,t).distanceTo(a)<=o)return!0;r.start=c,r.end=h;if(r.closestPointToPoint(a,!0,t).distanceTo(a)<=o)return!0;r.start=b,r.end=h;if(r.closestPointToPoint(a,!0,t).distanceTo(a)<=o)return!0;const d=n.getPlane(s);if(Math.abs(d.distanceToPoint(a))<=o){const t=d.projectPoint(a,e);if(n.containsPoint(t))return!0}return!1}}();function X(t){return Math.abs(t)<1e-15}class $ extends c{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new i)),this.satBounds=new Array(4).fill().map((()=>new j)),this.points=[this.a,this.b,this.c],this.sphere=new b,this.plane=new o,this.needsUpdate=!0}intersectsSphere(t){return H(t,this)}update(){const t=this.a,e=this.b,s=this.c,r=this.points,i=this.satAxes,n=this.satBounds,o=i[0],a=n[0];this.getNormal(o),a.setFromPoints(o,r);const c=i[1],b=n[1];c.subVectors(t,e),b.setFromPoints(c,r);const h=i[2],d=n[2];h.subVectors(e,s),d.setFromPoints(h,r);const l=i[3],f=n[3];l.subVectors(s,t),f.setFromPoints(l,r),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(o,t),this.needsUpdate=!1}}$.prototype.closestPointToSegment=function(){const t=new i,e=new i,s=new a;return function(r,i=null,n=null){const{start:o,end:a}=r,c=this.points;let b,h=1/0;for(let o=0;o<3;o++){const a=(o+1)%3;s.start.copy(c[o]),s.end.copy(c[a]),k(s,r,t,e),b=t.distanceToSquared(e),b<h&&(h=b,i&&i.copy(t),n&&n.copy(e))}return this.closestPointToPoint(o,t),b=o.distanceToSquared(t),b<h&&(h=b,i&&i.copy(t),n&&n.copy(o)),this.closestPointToPoint(a,t),b=a.distanceToSquared(t),b<h&&(h=b,i&&i.copy(t),n&&n.copy(a)),Math.sqrt(h)}}(),$.prototype.intersectsTriangle=function(){const t=new $,e=new Array(3),s=new Array(3),r=new j,n=new j,o=new i,c=new i,b=new i,h=new i,d=new i,l=new a,f=new a,u=new a,_=new i;function p(t,e,s){const r=t.points;let i=0,n=-1;for(let t=0;t<3;t++){const{start:o,end:a}=l;o.copy(r[t]),a.copy(r[(t+1)%3]),l.delta(c);const b=X(e.distanceToPoint(o));if(X(e.normal.dot(c))&&b){s.copy(l),i=2;break}const h=e.intersectLine(l,_);if(!h&&b&&_.copy(o),(h||b)&&!X(_.distanceTo(a))){if(i<=1){(1===i?s.start:s.end).copy(_),b&&(n=i)}else if(i>=2){(1===n?s.start:s.end).copy(_),i=2;break}if(i++,2===i&&-1===n)break}}return i}return function(i,a=null,c=!1){this.needsUpdate&&this.update(),i.isExtendedTriangle?i.needsUpdate&&i.update():(t.copy(i),t.update(),i=t);const l=this.plane,_=i.plane;if(Math.abs(l.normal.dot(_.normal))>1-1e-10){const t=this.satBounds,b=this.satAxes;s[0]=i.a,s[1]=i.b,s[2]=i.c;for(let e=0;e<4;e++){const i=t[e],n=b[e];if(r.setFromPoints(n,s),i.isSeparated(r))return!1}const h=i.satBounds,d=i.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let t=0;t<4;t++){const s=h[t],i=d[t];if(r.setFromPoints(i,e),s.isSeparated(r))return!1}for(let t=0;t<4;t++){const i=b[t];for(let t=0;t<4;t++){const a=d[t];if(o.crossVectors(i,a),r.setFromPoints(o,e),n.setFromPoints(o,s),r.isSeparated(n))return!1}}return a&&(c||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),a.start.set(0,0,0),a.end.set(0,0,0)),!0}{const t=p(this,_,f);if(1===t&&i.containsPoint(f.end))return a&&(a.start.copy(f.end),a.end.copy(f.end)),!0;if(2!==t)return!1;const e=p(i,l,u);if(1===e&&this.containsPoint(u.end))return a&&(a.start.copy(u.end),a.end.copy(u.end)),!0;if(2!==e)return!1;if(f.delta(b),u.delta(h),b.dot(h)<0){let t=u.start;u.start=u.end,u.end=t}const s=f.start.dot(b),r=f.end.dot(b),n=u.start.dot(b),o=u.end.dot(b);return(s===o||n===r||r<n!==s<o)&&(a&&(d.subVectors(f.start,u.start),d.dot(b)>0?a.start.copy(f.start):a.start.copy(u.start),d.subVectors(f.end,u.end),d.dot(b)<0?a.end.copy(f.end):a.end.copy(u.end)),!0)}}}(),$.prototype.distanceToPoint=function(){const t=new i;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),$.prototype.distanceToTriangle=function(){const t=new i,e=new i,s=["a","b","c"],r=new a,n=new a;return function(i,o=null,a=null){const c=o||a?r:null;if(this.intersectsTriangle(i,c))return(o||a)&&(o&&c.getCenter(o),a&&c.getCenter(a)),0;let b=1/0;for(let e=0;e<3;e++){let r;const n=s[e],c=i[n];this.closestPointToPoint(c,t),r=c.distanceToSquared(t),r<b&&(b=r,o&&o.copy(t),a&&a.copy(c));const h=this[n];i.closestPointToPoint(h,t),r=h.distanceToSquared(t),r<b&&(b=r,o&&o.copy(h),a&&a.copy(t))}for(let c=0;c<3;c++){const h=s[c],d=s[(c+1)%3];r.set(this[h],this[d]);for(let c=0;c<3;c++){const h=s[c],d=s[(c+1)%3];n.set(i[h],i[d]),k(r,n,t,e);const l=t.distanceToSquared(e);l<b&&(b=l,o&&o.copy(t),a&&a.copy(e))}}return Math.sqrt(b)}}();class Y{constructor(t,e,s){this.isOrientedBox=!0,this.min=new i,this.max=new i,this.matrix=new h,this.invMatrix=new h,this.points=new Array(8).fill().map((()=>new i)),this.satAxes=new Array(3).fill().map((()=>new i)),this.satBounds=new Array(3).fill().map((()=>new j)),this.alignedSatBounds=new Array(3).fill().map((()=>new j)),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),s&&this.matrix.copy(s)}set(t,e,s){this.min.copy(t),this.max.copy(e),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}Y.prototype.update=function(){return function(){const t=this.matrix,e=this.min,s=this.max,r=this.points;for(let i=0;i<=1;i++)for(let n=0;n<=1;n++)for(let o=0;o<=1;o++){const a=r[1*i|2*n|4*o];a.x=i?s.x:e.x,a.y=n?s.y:e.y,a.z=o?s.z:e.z,a.applyMatrix4(t)}const i=this.satBounds,n=this.satAxes,o=r[0];for(let t=0;t<3;t++){const e=n[t],s=i[t],a=r[1<<t];e.subVectors(o,a),s.setFromPoints(e,r)}const a=this.alignedSatBounds;a[0].setFromPointsField(r,"x"),a[1].setFromPointsField(r,"y"),a[2].setFromPointsField(r,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}(),Y.prototype.intersectsBox=function(){const t=new j;return function(e){this.needsUpdate&&this.update();const s=e.min,r=e.max,i=this.satBounds,n=this.satAxes,o=this.alignedSatBounds;if(t.min=s.x,t.max=r.x,o[0].isSeparated(t))return!1;if(t.min=s.y,t.max=r.y,o[1].isSeparated(t))return!1;if(t.min=s.z,t.max=r.z,o[2].isSeparated(t))return!1;for(let s=0;s<3;s++){const r=n[s],o=i[s];if(t.setFromBox(r,e),o.isSeparated(t))return!1}return!0}}(),Y.prototype.intersectsTriangle=function(){const t=new $,e=new Array(3),s=new j,r=new j,n=new i;return function(i){this.needsUpdate&&this.update(),i.isExtendedTriangle?i.needsUpdate&&i.update():(t.copy(i),t.update(),i=t);const o=this.satBounds,a=this.satAxes;e[0]=i.a,e[1]=i.b,e[2]=i.c;for(let t=0;t<3;t++){const r=o[t],i=a[t];if(s.setFromPoints(i,e),r.isSeparated(s))return!1}const c=i.satBounds,b=i.satAxes,h=this.points;for(let t=0;t<3;t++){const e=c[t],r=b[t];if(s.setFromPoints(r,h),e.isSeparated(s))return!1}for(let t=0;t<3;t++){const i=a[t];for(let t=0;t<4;t++){const o=b[t];if(n.crossVectors(i,o),s.setFromPoints(n,e),r.setFromPoints(n,h),s.isSeparated(r))return!1}}return!0}}(),Y.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}(),Y.prototype.distanceToPoint=function(){const t=new i;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),Y.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map((()=>new a)),s=new Array(12).fill().map((()=>new a)),r=new i,n=new i;return function(i,o=0,a=null,c=null){if(this.needsUpdate&&this.update(),this.intersectsBox(i))return(a||c)&&(i.getCenter(n),this.closestPointToPoint(n,r),i.closestPointToPoint(r,n),a&&a.copy(r),c&&c.copy(n)),0;const b=o*o,h=i.min,d=i.max,l=this.points;let f=1/0;for(let t=0;t<8;t++){const e=l[t];n.copy(e).clamp(h,d);const s=e.distanceToSquared(n);if(s<f&&(f=s,a&&a.copy(e),c&&c.copy(n),s<b))return Math.sqrt(s)}let u=0;for(let r=0;r<3;r++)for(let i=0;i<=1;i++)for(let n=0;n<=1;n++){const o=(r+1)%3,a=(r+2)%3,c=1<<r|i<<o|n<<a,b=l[i<<o|n<<a],f=l[c];e[u].set(b,f);const _=t[r],p=t[o],m=t[a],g=s[u],y=g.start,w=g.end;y[_]=h[_],y[p]=i?h[p]:d[p],y[m]=n?h[m]:d[p],w[_]=d[_],w[p]=i?h[p]:d[p],w[m]=n?h[m]:d[p],u++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let s=0;s<=1;s++){n.x=t?d.x:h.x,n.y=e?d.y:h.y,n.z=s?d.z:h.z,this.closestPointToPoint(n,r);const i=n.distanceToSquared(r);if(i<f&&(f=i,a&&a.copy(r),c&&c.copy(n),i<b))return Math.sqrt(i)}for(let t=0;t<12;t++){const i=e[t];for(let t=0;t<12;t++){const e=s[t];k(i,e,r,n);const o=r.distanceToSquared(n);if(o<f&&(f=o,a&&a.copy(r),c&&c.copy(n),o<b))return Math.sqrt(o)}}return Math.sqrt(f)}}();class Z{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class J extends Z{constructor(){super((()=>new $))}}const W=new J;function Q(t,e){return 65535===e[t+15]}function tt(t,e){return e[t+6]}function et(t,e){return e[t+14]}function st(t){return t+8}function rt(t,e){return e[t+6]}function it(t,e){return e[t+7]}const nt=new class{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=s=>{e&&t.push(e),e=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,0!==t.length&&this.setBuffer(t.pop())}}};let ot,at;const ct=[],bt=new Z((()=>new d));function ht(t,e,s,r,i,n){ot=bt.getPrimitive(),at=bt.getPrimitive(),ct.push(ot,at),nt.setBuffer(t._roots[e]);const o=dt(0,t.geometry,s,r,i,n);nt.clearBuffer(),bt.releasePrimitive(ot),bt.releasePrimitive(at),ct.pop(),ct.pop();const a=ct.length;return a>0&&(at=ct[a-1],ot=ct[a-2]),o}function dt(t,e,s,r,i=null,n=0,o=0){const{float32Array:a,uint16Array:c,uint32Array:b}=nt;let h=2*t;if(Q(h,c)){const e=tt(t,b),s=et(h,c);return B(t,a,ot),r(e,s,!1,o,n+t,ot)}{let h=function(t){const{uint16Array:e,uint32Array:s}=nt;let r=2*t;for(;!Q(r,e);)r=2*(t=st(t));return tt(t,s)},d=function(t){const{uint16Array:e,uint32Array:s}=nt;let r=2*t;for(;!Q(r,e);)r=2*(t=rt(t,s));return tt(t,s)+et(r,e)};const l=st(t),f=rt(t,b);let u,_,p,m,g=l,y=f;if(i&&(p=ot,m=at,B(g,a,p),B(y,a,m),u=i(p),_=i(m),_<u)){g=f,y=l;const t=u;u=_,_=t,p=m}p||(p=ot,B(g,a,p));const w=s(p,Q(2*g,c),u,o+1,n+g);let I;if(2===w){const t=h(g);I=r(t,d(g)-t,!0,o+1,n+g,p)}else I=w&&dt(g,e,s,r,i,n,o+1);if(I)return!0;m=at,B(y,a,m);const v=s(m,Q(2*y,c),_,o+1,n+y);let x;if(2===v){const t=h(y);x=r(t,d(y)-t,!0,o+1,n+y,m)}else x=v&&dt(y,e,s,r,i,n,o+1);return!!x}}const lt=new i,ft=new i;const ut=new i,_t=new i,pt=new i,mt=new n,gt=new n,yt=new n,wt=new i,It=new i,vt=new i,xt=new i;function At(t,e,s,r,o,a,b,h,d){ut.fromBufferAttribute(e,a),_t.fromBufferAttribute(e,b),pt.fromBufferAttribute(e,h);const u=function(t,e,s,r,i,n){let o;return o=n===l?t.intersectTriangle(r,s,e,!0,i):t.intersectTriangle(e,s,r,n!==f,i),null===o?null:{distance:t.origin.distanceTo(i),point:i.clone()}}(t,ut,_t,pt,xt,d);if(u){r&&(mt.fromBufferAttribute(r,a),gt.fromBufferAttribute(r,b),yt.fromBufferAttribute(r,h),u.uv=c.getInterpolation(xt,ut,_t,pt,mt,gt,yt,new n)),o&&(mt.fromBufferAttribute(o,a),gt.fromBufferAttribute(o,b),yt.fromBufferAttribute(o,h),u.uv1=c.getInterpolation(xt,ut,_t,pt,mt,gt,yt,new n)),s&&(wt.fromBufferAttribute(s,a),It.fromBufferAttribute(s,b),vt.fromBufferAttribute(s,h),u.normal=c.getInterpolation(xt,ut,_t,pt,wt,It,vt,new i),u.normal.dot(t.direction)>0&&u.normal.multiplyScalar(-1));const e={a:a,b:b,c:h,normal:new i,materialIndex:0};c.getNormal(ut,_t,pt,e.normal),u.face=e,u.faceIndex=a}return u}function Vt(t,e,s,r,i){const n=3*r;let o=n+0,a=n+1,c=n+2;const b=t.index;t.index&&(o=b.getX(o),a=b.getX(a),c=b.getX(c));const{position:h,normal:d,uv:l,uv1:f}=t.attributes,u=At(s,h,d,l,f,o,a,c,e);return u?(u.faceIndex=r,i&&i.push(u),u):null}function Ft(t,e,s,r){const i=t.a,n=t.b,o=t.c;let a=e,c=e+1,b=e+2;s&&(a=s.getX(a),c=s.getX(c),b=s.getX(b)),i.x=r.getX(a),i.y=r.getY(a),i.z=r.getZ(a),n.x=r.getX(c),n.y=r.getY(c),n.z=r.getZ(c),o.x=r.getX(b),o.y=r.getY(b),o.z=r.getZ(b)}function Bt(t,e,s,r,i,n,o){const{geometry:a}=s,{index:c}=a,b=a.attributes.position;for(let s=t,a=e+t;s<a;s++){let t;if(t=s,Ft(o,3*t,c,b),o.needsUpdate=!0,r(o,t,i,n))return!0}return!1}function Mt(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const s=t.geometry,r=s.index?s.index.array:null,i=s.attributes.position;let n,o,a,c,b=0;const h=t._roots;for(let t=0,e=h.length;t<e;t++)n=h[t],o=new Uint32Array(n),a=new Uint16Array(n),c=new Float32Array(n),d(0,b),b+=n.byteLength;function d(t,s,n=!1){const b=2*t;if(a[b+15]===w){const e=o[t+6];let s=1/0,n=1/0,h=1/0,d=-1/0,l=-1/0,f=-1/0;for(let t=3*e,o=3*(e+a[b+14]);t<o;t++){let e=r[t];const o=i.getX(e),a=i.getY(e),c=i.getZ(e);o<s&&(s=o),o>d&&(d=o),a<n&&(n=a),a>l&&(l=a),c<h&&(h=c),c>f&&(f=c)}return(c[t+0]!==s||c[t+1]!==n||c[t+2]!==h||c[t+3]!==d||c[t+4]!==l||c[t+5]!==f)&&(c[t+0]=s,c[t+1]=n,c[t+2]=h,c[t+3]=d,c[t+4]=l,c[t+5]=f,!0)}{const r=t+8,i=o[t+6],a=r+s,b=i+s;let h=n,l=!1,f=!1;e?h||(l=e.has(a),f=e.has(b),h=!l&&!f):(l=!0,f=!0);const u=h||f;let _=!1;(h||l)&&(_=d(r,s,h));let p=!1;u&&(p=d(i,s,h));const m=_||p;if(m)for(let e=0;e<3;e++){const s=r+e,n=i+e,o=c[s],a=c[s+3],b=c[n],h=c[n+3];c[t+e]=o<b?o:b,c[t+e+3]=a>h?a:h}return m}}}const Ct=new d;function Ot(t,e,s,r){return B(t,e,Ct),s.intersectBox(Ct,r)}function Pt(t,e,s,r,i,n,o){const{geometry:a}=s,{index:c}=a,b=a.attributes.position;for(let a=t,h=e+t;a<h;a++){let t;if(t=s.resolveTriangleIndex(a),Ft(o,3*t,c,b),o.needsUpdate=!0,r(o,t,i,n))return!0}return!1}const Tt=new i;function St(t,e,s,r,i){nt.setBuffer(t._roots[e]),Ut(0,t,s,r,i),nt.clearBuffer()}function Ut(t,e,s,r,i){const{float32Array:n,uint16Array:o,uint32Array:a}=nt,c=2*t;if(Q(c,o)){!function(t,e,s,r,i,n){const{geometry:o,_indirectBuffer:a}=t;for(let t=r,a=r+i;t<a;t++)Vt(o,e,s,t,n)}(e,s,r,tt(t,a),et(c,o),i)}else{const o=st(t);Ot(o,n,r,Tt)&&Ut(o,e,s,r,i);const c=rt(t,a);Ot(c,n,r,Tt)&&Ut(c,e,s,r,i)}}const Dt=new i,Gt=["x","y","z"];function Lt(t,e,s,r){nt.setBuffer(t._roots[e]);const i=zt(0,t,s,r);return nt.clearBuffer(),i}function zt(t,e,s,r){const{float32Array:i,uint16Array:n,uint32Array:o}=nt;let a=2*t;if(Q(a,n)){return function(t,e,s,r,i){const{geometry:n,_indirectBuffer:o}=t;let a=1/0,c=null;for(let t=r,o=r+i;t<o;t++){let r;r=Vt(n,e,s,t),r&&r.distance<a&&(c=r,a=r.distance)}return c}(e,s,r,tt(t,o),et(a,n))}{const n=it(t,o),a=Gt[n],c=r.direction[a]>=0;let b,h;c?(b=st(t),h=rt(t,o)):(b=rt(t,o),h=st(t));const d=Ot(b,i,r,Dt)?zt(b,e,s,r):null;if(d){const t=d.point[a];if(c?t<=i[h+n]:t>=i[h+n+3])return d}const l=Ot(h,i,r,Dt)?zt(h,e,s,r):null;return d&&l?d.distance<=l.distance?d:l:d||l||null}}const Et=new d,Nt=new $,Rt=new $,Kt=new h,jt=new Y,qt=new Y;function kt(t,e,s,r){nt.setBuffer(t._roots[e]);const i=Ht(0,t,s,r);return nt.clearBuffer(),i}function Ht(t,e,s,r,i=null){const{float32Array:n,uint16Array:o,uint32Array:a}=nt;let c=2*t;null===i&&(s.boundingBox||s.computeBoundingBox(),jt.set(s.boundingBox.min,s.boundingBox.max,r),i=jt);if(!Q(c,o)){const o=t+8,c=a[t+6];B(o,n,Et);if(i.intersectsBox(Et)&&Ht(o,e,s,r,i))return!0;B(c,n,Et);return!!(i.intersectsBox(Et)&&Ht(c,e,s,r,i))}{const i=e.geometry,b=i.index,h=i.attributes.position,d=s.index,l=s.attributes.position,f=tt(t,a),u=et(c,o);if(Kt.copy(r).invert(),s.boundsTree){B(t,n,qt),qt.matrix.copy(Kt),qt.needsUpdate=!0;return s.boundsTree.shapecast({intersectsBounds:t=>qt.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let e=3*f,s=3*(u+f);e<s;e+=3)if(Ft(Rt,e,b,h),Rt.needsUpdate=!0,t.intersectsTriangle(Rt))return!0;return!1}})}for(let t=3*f,e=3*(u+f);t<e;t+=3){Ft(Nt,t,b,h),Nt.a.applyMatrix4(Kt),Nt.b.applyMatrix4(Kt),Nt.c.applyMatrix4(Kt),Nt.needsUpdate=!0;for(let t=0,e=d.count;t<e;t+=3)if(Ft(Rt,t,d,l),Rt.needsUpdate=!0,Nt.intersectsTriangle(Rt))return!0}}}const Xt=new h,$t=new Y,Yt=new Y,Zt=new i,Jt=new i,Wt=new i,Qt=new i;function te(t,e,s,r={},i={},n=0,o=1/0){e.boundingBox||e.computeBoundingBox(),$t.set(e.boundingBox.min,e.boundingBox.max,s),$t.needsUpdate=!0;const a=t.geometry,c=a.attributes.position,b=a.index,h=e.attributes.position,d=e.index,l=W.getPrimitive(),f=W.getPrimitive();let u=Zt,_=Jt,p=null,m=null;i&&(p=Wt,m=Qt);let g=1/0,y=null,w=null;return Xt.copy(s).invert(),Yt.matrix.copy(Xt),t.shapecast({boundsTraverseOrder:t=>$t.distanceToBox(t),intersectsBounds:(t,e,s)=>s<g&&s<o&&(e&&(Yt.min.copy(t.min),Yt.max.copy(t.max),Yt.needsUpdate=!0),!0),intersectsRange:(t,r)=>{if(e.boundsTree){return e.boundsTree.shapecast({boundsTraverseOrder:t=>Yt.distanceToBox(t),intersectsBounds:(t,e,s)=>s<g&&s<o,intersectsRange:(e,i)=>{for(let o=e,a=e+i;o<a;o++){Ft(f,3*o,d,h),f.a.applyMatrix4(s),f.b.applyMatrix4(s),f.c.applyMatrix4(s),f.needsUpdate=!0;for(let e=t,s=t+r;e<s;e++){Ft(l,3*e,b,c),l.needsUpdate=!0;const t=l.distanceToTriangle(f,u,p);if(t<g&&(_.copy(u),m&&m.copy(p),g=t,y=e,w=o),t<n)return!0}}}})}for(let i=0,o=x(e);i<o;i++){Ft(f,3*i,d,h),f.a.applyMatrix4(s),f.b.applyMatrix4(s),f.c.applyMatrix4(s),f.needsUpdate=!0;for(let e=t,s=t+r;e<s;e++){Ft(l,3*e,b,c),l.needsUpdate=!0;const t=l.distanceToTriangle(f,u,p);if(t<g&&(_.copy(u),m&&m.copy(p),g=t,y=e,w=i),t<n)return!0}}}}),W.releasePrimitive(l),W.releasePrimitive(f),g===1/0?null:(r.point?r.point.copy(_):r.point=_.clone(),r.distance=g,r.faceIndex=y,i&&(i.point?i.point.copy(m):i.point=m.clone(),i.point.applyMatrix4(Xt),_.applyMatrix4(Xt),i.distance=_.sub(i.point).length(),i.faceIndex=w),r)}function ee(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const s=t.geometry,r=s.index?s.index.array:null,i=s.attributes.position;let n,o,a,c,b=0;const h=t._roots;for(let t=0,e=h.length;t<e;t++)n=h[t],o=new Uint32Array(n),a=new Uint16Array(n),c=new Float32Array(n),d(0,b),b+=n.byteLength;function d(s,n,b=!1){const h=2*s;if(a[h+15]===w){const e=o[s+6];let n=1/0,b=1/0,d=1/0,l=-1/0,f=-1/0,u=-1/0;for(let s=e,o=e+a[h+14];s<o;s++){const e=3*t.resolveTriangleIndex(s);for(let t=0;t<3;t++){let s=e+t;s=r?r[s]:s;const o=i.getX(s),a=i.getY(s),c=i.getZ(s);o<n&&(n=o),o>l&&(l=o),a<b&&(b=a),a>f&&(f=a),c<d&&(d=c),c>u&&(u=c)}}return(c[s+0]!==n||c[s+1]!==b||c[s+2]!==d||c[s+3]!==l||c[s+4]!==f||c[s+5]!==u)&&(c[s+0]=n,c[s+1]=b,c[s+2]=d,c[s+3]=l,c[s+4]=f,c[s+5]=u,!0)}{const t=s+8,r=o[s+6],i=t+n,a=r+n;let h=b,l=!1,f=!1;e?h||(l=e.has(i),f=e.has(a),h=!l&&!f):(l=!0,f=!0);const u=h||f;let _=!1;(h||l)&&(_=d(t,n,h));let p=!1;u&&(p=d(r,n,h));const m=_||p;if(m)for(let e=0;e<3;e++){const i=t+e,n=r+e,o=c[i],a=c[i+3],b=c[n],h=c[n+3];c[s+e]=o<b?o:b,c[s+e+3]=a>h?a:h}return m}}}const se=new i;function re(t,e,s,r,i){nt.setBuffer(t._roots[e]),ie(0,t,s,r,i),nt.clearBuffer()}function ie(t,e,s,r,i){const{float32Array:n,uint16Array:o,uint32Array:a}=nt,c=2*t;if(Q(c,o)){!function(t,e,s,r,i,n){const{geometry:o,_indirectBuffer:a}=t;for(let t=r,c=r+i;t<c;t++)Vt(o,e,s,a?a[t]:t,n)}(e,s,r,tt(t,a),et(c,o),i)}else{const o=st(t);Ot(o,n,r,se)&&ie(o,e,s,r,i);const c=rt(t,a);Ot(c,n,r,se)&&ie(c,e,s,r,i)}}const ne=new i,oe=["x","y","z"];function ae(t,e,s,r){nt.setBuffer(t._roots[e]);const i=ce(0,t,s,r);return nt.clearBuffer(),i}function ce(t,e,s,r){const{float32Array:i,uint16Array:n,uint32Array:o}=nt;let a=2*t;if(Q(a,n)){return function(t,e,s,r,i){const{geometry:n,_indirectBuffer:o}=t;let a=1/0,c=null;for(let t=r,b=r+i;t<b;t++){let r;r=Vt(n,e,s,o?o[t]:t),r&&r.distance<a&&(c=r,a=r.distance)}return c}(e,s,r,tt(t,o),et(a,n))}{const n=it(t,o),a=oe[n],c=r.direction[a]>=0;let b,h;c?(b=st(t),h=rt(t,o)):(b=rt(t,o),h=st(t));const d=Ot(b,i,r,ne)?ce(b,e,s,r):null;if(d){const t=d.point[a];if(c?t<=i[h+n]:t>=i[h+n+3])return d}const l=Ot(h,i,r,ne)?ce(h,e,s,r):null;return d&&l?d.distance<=l.distance?d:l:d||l||null}}const be=new d,he=new $,de=new $,le=new h,fe=new Y,ue=new Y;function _e(t,e,s,r){nt.setBuffer(t._roots[e]);const i=pe(0,t,s,r);return nt.clearBuffer(),i}function pe(t,e,s,r,i=null){const{float32Array:n,uint16Array:o,uint32Array:a}=nt;let c=2*t;null===i&&(s.boundingBox||s.computeBoundingBox(),fe.set(s.boundingBox.min,s.boundingBox.max,r),i=fe);if(!Q(c,o)){const o=t+8,c=a[t+6];B(o,n,be);if(i.intersectsBox(be)&&pe(o,e,s,r,i))return!0;B(c,n,be);return!!(i.intersectsBox(be)&&pe(c,e,s,r,i))}{const i=e.geometry,b=i.index,h=i.attributes.position,d=s.index,l=s.attributes.position,f=tt(t,a),u=et(c,o);if(le.copy(r).invert(),s.boundsTree){B(t,n,ue),ue.matrix.copy(le),ue.needsUpdate=!0;return s.boundsTree.shapecast({intersectsBounds:t=>ue.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let s=f,r=u+f;s<r;s++)if(Ft(de,3*e.resolveTriangleIndex(s),b,h),de.needsUpdate=!0,t.intersectsTriangle(de))return!0;return!1}})}for(let t=f,s=u+f;t<s;t++){const s=e.resolveTriangleIndex(t);Ft(he,3*s,b,h),he.a.applyMatrix4(le),he.b.applyMatrix4(le),he.c.applyMatrix4(le),he.needsUpdate=!0;for(let t=0,e=d.count;t<e;t+=3)if(Ft(de,t,d,l),de.needsUpdate=!0,he.intersectsTriangle(de))return!0}}}const me=new h,ge=new Y,ye=new Y,we=new i,Ie=new i,ve=new i,xe=new i;function Ae(t,e,s,r={},i={},n=0,o=1/0){e.boundingBox||e.computeBoundingBox(),ge.set(e.boundingBox.min,e.boundingBox.max,s),ge.needsUpdate=!0;const a=t.geometry,c=a.attributes.position,b=a.index,h=e.attributes.position,d=e.index,l=W.getPrimitive(),f=W.getPrimitive();let u=we,_=Ie,p=null,m=null;i&&(p=ve,m=xe);let g=1/0,y=null,w=null;return me.copy(s).invert(),ye.matrix.copy(me),t.shapecast({boundsTraverseOrder:t=>ge.distanceToBox(t),intersectsBounds:(t,e,s)=>s<g&&s<o&&(e&&(ye.min.copy(t.min),ye.max.copy(t.max),ye.needsUpdate=!0),!0),intersectsRange:(r,i)=>{if(e.boundsTree){const a=e.boundsTree;return a.shapecast({boundsTraverseOrder:t=>ye.distanceToBox(t),intersectsBounds:(t,e,s)=>s<g&&s<o,intersectsRange:(e,o)=>{for(let I=e,v=e+o;I<v;I++){const e=a.resolveTriangleIndex(I);Ft(f,3*e,d,h),f.a.applyMatrix4(s),f.b.applyMatrix4(s),f.c.applyMatrix4(s),f.needsUpdate=!0;for(let e=r,s=r+i;e<s;e++){const s=t.resolveTriangleIndex(e);Ft(l,3*s,b,c),l.needsUpdate=!0;const r=l.distanceToTriangle(f,u,p);if(r<g&&(_.copy(u),m&&m.copy(p),g=r,y=e,w=I),r<n)return!0}}}})}for(let o=0,a=x(e);o<a;o++){Ft(f,3*o,d,h),f.a.applyMatrix4(s),f.b.applyMatrix4(s),f.c.applyMatrix4(s),f.needsUpdate=!0;for(let e=r,s=r+i;e<s;e++){const s=t.resolveTriangleIndex(e);Ft(l,3*s,b,c),l.needsUpdate=!0;const r=l.distanceToTriangle(f,u,p);if(r<g&&(_.copy(u),m&&m.copy(p),g=r,y=e,w=o),r<n)return!0}}}}),W.releasePrimitive(l),W.releasePrimitive(f),g===1/0?null:(r.point?r.point.copy(_):r.point=_.clone(),r.distance=g,r.faceIndex=y,i&&(i.point?i.point.copy(m):i.point=m.clone(),i.point.applyMatrix4(me),_.applyMatrix4(me),i.distance=_.sub(i.point).length(),i.faceIndex=w),r)}const Ve=new nt.constructor,Fe=new nt.constructor,Be=new Z((()=>new d)),Me=new d,Ce=new d,Oe=new d,Pe=new d;let Te=!1;function Se(t,e,s,r,i,n=0,o=0,a=0,c=0,b=null,h=!1){let d,l;h?(d=Fe,l=Ve):(d=Ve,l=Fe);const f=d.float32Array,u=d.uint32Array,_=d.uint16Array,p=l.float32Array,m=l.uint32Array,g=l.uint16Array,y=2*e,w=Q(2*t,_),I=Q(y,g);let v=!1;if(I&&w)v=h?i(tt(e,m),et(2*e,g),tt(t,u),et(2*t,_),c,o+e,a,n+t):i(tt(t,u),et(2*t,_),tt(e,m),et(2*e,g),a,n+t,c,o+e);else if(I){const b=Be.getPrimitive();B(e,p,b),b.applyMatrix4(s);const d=st(t),l=rt(t,u);B(d,f,Me),B(l,f,Ce);const _=b.intersectsBox(Me),m=b.intersectsBox(Ce);v=_&&Se(e,d,r,s,i,o,n,c,a+1,b,!h)||m&&Se(e,l,r,s,i,o,n,c,a+1,b,!h),Be.releasePrimitive(b)}else{const d=st(e),l=rt(e,m);B(d,p,Oe),B(l,p,Pe);const _=b.intersectsBox(Oe),g=b.intersectsBox(Pe);if(_&&g)v=Se(t,d,s,r,i,n,o,a,c+1,b,h)||Se(t,l,s,r,i,n,o,a,c+1,b,h);else if(_)if(w)v=Se(t,d,s,r,i,n,o,a,c+1,b,h);else{const e=Be.getPrimitive();e.copy(Oe).applyMatrix4(s);const b=st(t),l=rt(t,u);B(b,f,Me),B(l,f,Ce);const _=e.intersectsBox(Me),p=e.intersectsBox(Ce);v=_&&Se(d,b,r,s,i,o,n,c,a+1,e,!h)||p&&Se(d,l,r,s,i,o,n,c,a+1,e,!h),Be.releasePrimitive(e)}else if(g)if(w)v=Se(t,l,s,r,i,n,o,a,c+1,b,h);else{const e=Be.getPrimitive();e.copy(Pe).applyMatrix4(s);const b=st(t),d=rt(t,u);B(b,f,Me),B(d,f,Ce);const _=e.intersectsBox(Me),p=e.intersectsBox(Ce);v=_&&Se(l,b,r,s,i,o,n,c,a+1,e,!h)||p&&Se(l,d,r,s,i,o,n,c,a+1,e,!h),Be.releasePrimitive(e)}}return v}const Ue=new Y,De=new d;class Ge{static serialize(t,e={}){e={cloneBuffers:!0,...e};const s=t.geometry,r=t._roots,i=t._indirectBuffer,n=s.getIndex();let o;return o=e.cloneBuffers?{roots:r.map((t=>t.slice())),index:n.array.slice(),indirectBuffer:i?i.slice():null}:{roots:r,index:n.array,indirectBuffer:i},o}static deserialize(t,e,s={}){s={setIndex:!0,indirect:Boolean(t.indirectBuffer),...s};const{index:i,roots:n,indirectBuffer:o}=t,a=new Ge(e,{...s,[v]:!0});if(a._roots=n,a._indirectBuffer=o||null,s.setIndex){const s=e.getIndex();if(null===s){const s=new r(t.index,1,!1);e.setIndex(s)}else s.array!==i&&(s.array.set(i),s.needsUpdate=!0)}return a}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if((e=Object.assign({strategy:0,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,[v]:!1},e)).useSharedArrayBuffer&&"undefined"==typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[v]||(K(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new d)));const{_indirectBuffer:s}=this;this.resolveTriangleIndex=e.indirect?t=>s[t]:t=>t}refit(t=null){return(this.indirect?ee:Mt)(this,t)}traverse(t,e=0){const s=this._roots[e],r=new Uint32Array(s),i=new Uint16Array(s);!function e(n,o=0){const a=2*n,c=i[a+15]===w;if(c){const e=r[n+6],b=i[a+14];t(o,c,new Float32Array(s,4*n,6),e,b)}else{const i=n+8,a=r[n+6],b=r[n+7];t(o,c,new Float32Array(s,4*n,6),b)||(e(i,o+1),e(a,o+1))}}(0)}raycast(t,e=u){const s=this._roots,r=this.geometry,i=[],n=e.isMaterial,o=Array.isArray(e),a=r.groups,c=n?e.side:e,b=this.indirect?re:St;for(let r=0,n=s.length;r<n;r++){const s=o?e[a[r].materialIndex].side:c,n=i.length;if(b(this,r,s,t,i),o){const t=a[r].materialIndex;for(let e=n,s=i.length;e<s;e++)i[e].face.materialIndex=t}}return i}raycastFirst(t,e=u){const s=this._roots,r=this.geometry,i=e.isMaterial,n=Array.isArray(e);let o=null;const a=r.groups,c=i?e.side:e,b=this.indirect?ae:Lt;for(let r=0,i=s.length;r<i;r++){const s=b(this,r,n?e[a[r].materialIndex].side:c,t);null!=s&&(null==o||s.distance<o.distance)&&(o=s,n&&(s.face.materialIndex=a[r].materialIndex))}return o}intersectsGeometry(t,e){let s=!1;const r=this._roots,i=this.indirect?_e:kt;for(let n=0,o=r.length;n<o&&(s=i(this,n,t,e),!s);n++);return s}shapecast(t){const e=W.getPrimitive(),s=this.indirect?Pt:Bt;let{boundsTraverseOrder:r,intersectsBounds:i,intersectsRange:n,intersectsTriangle:o}=t;if(n&&o){const t=n;n=(r,i,n,a,c)=>!!t(r,i,n,a,c)||s(r,i,this,o,n,a,e)}else n||(n=o?(t,r,i,n)=>s(t,r,this,o,i,n,e):(t,e,s)=>s);let a=!1,c=0;const b=this._roots;for(let t=0,e=b.length;t<e;t++){const e=b[t];if(a=ht(this,t,i,n,r,c),a)break;c+=e.byteLength}return W.releasePrimitive(e),a}bvhcast(t,e,s){let{intersectsRanges:r,intersectsTriangles:i}=s;const n=W.getPrimitive(),o=this.geometry.index,a=this.geometry.attributes.position,c=this.indirect?t=>{const e=this.resolveTriangleIndex(t);Ft(n,3*e,o,a)}:t=>{Ft(n,3*t,o,a)},b=W.getPrimitive(),d=t.geometry.index,l=t.geometry.attributes.position,f=t.indirect?e=>{const s=t.resolveTriangleIndex(e);Ft(b,3*s,d,l)}:t=>{Ft(b,3*t,d,l)};if(i){const t=(t,s,r,o,a,h,d,l)=>{for(let u=r,_=r+o;u<_;u++){f(u),b.a.applyMatrix4(e),b.b.applyMatrix4(e),b.c.applyMatrix4(e),b.needsUpdate=!0;for(let e=t,r=t+s;e<r;e++)if(c(e),n.needsUpdate=!0,i(n,b,e,u,a,h,d,l))return!0}return!1};if(r){const e=r;r=function(s,r,i,n,o,a,c,b){return!!e(s,r,i,n,o,a,c,b)||t(s,r,i,n,o,a,c,b)}}else r=t}return function(t,e,s,r){if(Te)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Te=!0;const i=t._roots,n=e._roots;let o,a=0,c=0;const b=(new h).copy(s).invert();for(let t=0,e=i.length;t<e;t++){Ve.setBuffer(i[t]),c=0;const e=Be.getPrimitive();B(0,Ve.float32Array,e),e.applyMatrix4(b);for(let i=0,h=n.length;i<h&&(Fe.setBuffer(n[t]),o=Se(0,0,s,b,r,a,c,0,0,e),Fe.clearBuffer(),c+=n[i].length,!o);i++);if(Be.releasePrimitive(e),Ve.clearBuffer(),a+=i[t].length,o)break}return Te=!1,o}(this,t,e,r)}intersectsBox(t,e){return Ue.set(t.min,t.max,e),Ue.needsUpdate=!0,this.shapecast({intersectsBounds:t=>Ue.intersectsBox(t),intersectsTriangle:t=>Ue.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},r={},i=0,n=1/0){return(this.indirect?Ae:te)(this,t,e,s,r,i,n)}closestPointToPoint(t,e={},s=0,r=1/0){return function(t,e,s={},r=0,i=1/0){const n=r*r,o=i*i;let a=1/0,c=null;if(t.shapecast({boundsTraverseOrder:t=>(lt.copy(e).clamp(t.min,t.max),lt.distanceToSquared(e)),intersectsBounds:(t,e,s)=>s<a&&s<o,intersectsTriangle:(t,s)=>{t.closestPointToPoint(e,lt);const r=e.distanceToSquared(lt);return r<a&&(ft.copy(lt),a=r,c=s),r<n}}),a===1/0)return null;const b=Math.sqrt(a);return s.point?s.point.copy(ft):s.point=ft.clone(),s.distance=b,s.faceIndex=c,s}(this,t,e,s,r)}getBoundingBox(t){t.makeEmpty();return this._roots.forEach((e=>{B(0,new Float32Array(e),De),t.union(De)})),t}}function Le(t,e,s){return null===t?null:(t.point.applyMatrix4(e.matrixWorld),t.distance=t.point.distanceTo(s.ray.origin),t.object=e,t.distance<s.near||t.distance>s.far?null:t)}const ze=new p,Ee=new h,Ne=_.prototype.raycast;function Re(t,e){if(this.geometry.boundsTree){if(void 0===this.material)return;Ee.copy(this.matrixWorld).invert(),ze.copy(t.ray).applyMatrix4(Ee);const s=this.geometry.boundsTree;if(!0===t.firstHitOnly){const r=Le(s.raycastFirst(ze,this.material),this,t);r&&e.push(r)}else{const r=s.raycast(ze,this.material);for(let s=0,i=r.length;s<i;s++){const i=Le(r[s],this,t);i&&e.push(i)}}}else Ne.call(this,t,e)}function Ke(t){return this.boundsTree=new Ge(this,t),this.boundsTree}function je(){this.boundsTree=null}const qe=class t{static apply(e){t.initialized||(m.prototype.computeBoundsTree=Ke,m.prototype.disposeBoundsTree=je,_.prototype.raycast=Re,t.initialized=!0),e.boundsTree||e.computeBoundsTree()}static dispose(t){t&&t.disposeBoundsTree&&t.disposeBoundsTree()}};e(qe,"initialized",!1);let ke=qe,He=class t{constructor(t,s,r){e(this,"ids",new Set),e(this,"itemToInstances",new Map),e(this,"instanceToItem",new Map),e(this,"hiddenItems",new Set),e(this,"id"),e(this,"mesh"),e(this,"capacity",0),e(this,"capacityOffset",10),e(this,"group"),e(this,"_originalColors",new Map),e(this,"_settingVisibility",!1),this.mesh=new g(t,s,r,this),this.id=this.mesh.uuid,this.capacity=r,this.mesh.count=0,this.mesh.geometry.index.count&&ke.apply(this.mesh.geometry)}get uniqueVertices(){const t=[],e=this.mesh.geometry.getAttribute("position");if(!e)return t;const r=new Set;for(let i=0;i<e.count;i++){const n=e.getX(i),o=e.getY(i),a=e.getZ(i),c=`${n},${o},${a}`;r.has(c)||(r.add(c),t.push(new s.Vector3(n,o,a)))}return t}dispose(t=!0){if(this.clear(),this.group=void 0,this._originalColors.clear(),this.mesh){if(t){for(const t of this.mesh.material)t.dispose();this.mesh.material=[],ke.dispose(this.mesh.geometry),this.mesh.geometry&&this.mesh.geometry.dispose(),this.mesh.geometry=null}this.mesh.removeFromParent(),this.mesh.userData={},this.mesh.dispose(),this.mesh.fragment=null,this.mesh=null}}get(t){const e=this.getInstancesIDs(t);if(!e)throw new Error("Item not found!");const r=[],i=[];for(const t of e){const e=new s.Matrix4;if(this.mesh.getMatrixAt(t,e),r.push(e),this.mesh.instanceColor){const e=new s.Color;this.mesh.getColorAt(t,e),i.push(e)}}return{id:t,transforms:r,colors:i.length?i:void 0}}getItemID(t){return this.instanceToItem.get(t)||null}getInstancesIDs(t){return this.itemToInstances.get(t)||null}update(){this.mesh.instanceColor&&(this.mesh.instanceColor.needsUpdate=!0),this.mesh.instanceMatrix.needsUpdate=!0}add(t){var e;let r=0;for(const e of t)r+=e.transforms.length;const i=this.mesh.count+r;if(i>this.capacity){const t=i+this.capacityOffset,r=new g(this.mesh.geometry,this.mesh.material,t,this);r.count=this.mesh.count,this.capacity=t;const n=this.mesh;null==(e=n.parent)||e.add(r),n.removeFromParent(),this.mesh=r;const o=new s.Matrix4;for(let t=0;t<n.instanceMatrix.count;t++)n.getMatrixAt(t,o),r.setMatrixAt(t,o);if(n.instanceColor){const t=new s.Color;for(let e=0;e<n.instanceColor.count;e++)n.getColorAt(e,t),r.setColorAt(e,t)}n.dispose()}for(let e=0;e<t.length;e++){const{transforms:s,colors:r,id:i}=t[e];this.itemToInstances.has(i)||this.itemToInstances.set(i,new Set);const n=this.itemToInstances.get(i);this.ids.add(i);for(let t=0;t<s.length;t++){const e=s[t],o=this.mesh.count;if(this.mesh.setMatrixAt(o,e),r){const e=r[t];this.mesh.setColorAt(o,e)}n.add(o),this.instanceToItem.set(o,i),this.mesh.count++}}this.update()}remove(t){if(0!==this.mesh.count){for(const e of t){const t=this.itemToInstances.get(e);if(void 0===t)throw new Error("Instances not found!");for(const e of t){if(0===this.mesh.count)throw new Error("Error with mesh count!");this.putLast(e),this.instanceToItem.delete(e),this.mesh.count--}this.itemToInstances.delete(e),this.ids.delete(e)}this.update()}}clear(){this.hiddenItems.clear(),this.ids.clear(),this.instanceToItem.clear(),this.itemToInstances.clear(),this.mesh.count=0}setVisibility(t,e=this.ids){if(!this._settingVisibility){if(this._settingVisibility=!0,t)for(const t of e){if(!this.ids.has(t))continue;if(!this.hiddenItems.has(t))continue;const e=this.itemToInstances.get(t);if(!e)throw new Error("Instances not found!");for(const t of new Set(e))this.mesh.count++,this.putLast(t);this.hiddenItems.delete(t)}else for(const t of e){if(!this.ids.has(t))continue;if(this.hiddenItems.has(t))continue;const e=this.itemToInstances.get(t);if(!e)throw new Error("Instances not found!");for(const t of new Set(e))this.putLast(t),this.mesh.count--;this.hiddenItems.add(t)}this.update(),this._settingVisibility=!1}}setColor(t,e=this.ids,r=!1){if(!this.mesh.instanceColor)throw new Error("This fragment doesn't have color per instance!");for(const i of e){if(!this.ids.has(i))continue;const e=this.itemToInstances.get(i);if(!e)throw new Error("Instances not found!");const n=this._originalColors.has(i);n||this._originalColors.set(i,new Map);const o=this._originalColors.get(i);for(const i of new Set(e)){if(!n){const t=new s.Color;this.mesh.getColorAt(i,t),o.set(i,t)}this.mesh.setColorAt(i,t),r&&o.set(i,t)}}this.mesh.instanceColor.needsUpdate=!0}resetColor(t=this.ids){if(!this.mesh.instanceColor)throw new Error("This fragment doesn't have color per instance!");for(const e of t){if(!this.ids.has(e))continue;const t=this.itemToInstances.get(e);if(!t)throw new Error("Instances not found!");const s=this._originalColors.get(e);if(s)for(const e of new Set(t)){const t=s.get(e);if(!t)throw new Error("Original color not found!");this.mesh.setColorAt(e,t)}}this.mesh.instanceColor.needsUpdate=!0}applyTransform(t,e){const r=new s.Matrix4;for(const s of t){const t=this.getInstancesIDs(s);if(null!==t)for(const s of t)this.mesh.getMatrixAt(s,r),r.premultiply(e),this.mesh.setMatrixAt(s,r)}this.update()}exportData(){return{...this.mesh.exportData(),ids:Array.from(this.ids),id:this.id}}clone(e=this.ids){const r=new t(this.mesh.geometry,this.mesh.material,this.capacity),i=[];for(const t of e){const e=this.getInstancesIDs(t);if(null===e)continue;const r=[],n=[];for(const t of e){const e=new s.Matrix4,i=new s.Color;this.mesh.getMatrixAt(t,e),this.mesh.getColorAt(t,i),r.push(e),n.push(i)}i.push({id:t,transforms:r,colors:n})}return r.add(i),r}putLast(t){if(0===this.mesh.count)return;const e=this.instanceToItem.get(t),r=this.mesh.count-1;if(r===t)return;const i=this.instanceToItem.get(r);if(void 0===e||void 0===i)throw new Error("Keys not found");if(e!==i){const s=this.itemToInstances.get(e),n=this.itemToInstances.get(i);if(!s||!n)throw new Error("Instances not found");if(!s.has(t)||!n.has(r))throw new Error("Malformed fragment structure");s.delete(t),n.delete(r),s.add(r),n.add(t),this.instanceToItem.set(t,i),this.instanceToItem.set(r,e)}const n=new s.Matrix4,o=new s.Matrix4;if(this.mesh.getMatrixAt(t,n),this.mesh.getMatrixAt(r,o),this.mesh.setMatrixAt(t,o),this.mesh.setMatrixAt(r,n),null!==this.mesh.instanceColor){const n=new s.Color,o=new s.Color;this.mesh.getColorAt(t,n),this.mesh.getColorAt(r,o),this.mesh.setColorAt(t,o),this.mesh.setColorAt(r,n);const a=this._originalColors.get(e);if(a){const e=a.get(t);e&&(a.delete(t),a.set(r,e))}const c=this._originalColors.get(i);if(c){const e=c.get(r);e&&(c.delete(r),c.set(t,e))}}}};const Xe=new Int32Array(2),$e=new Float32Array(Xe.buffer),Ye=new Float64Array(Xe.buffer),Ze=1===new Uint16Array(new Uint8Array([1,0]).buffer)[0];var Je,We;(We=Je||(Je={}))[We.UTF8_BYTES=1]="UTF8_BYTES",We[We.UTF16_STRING=2]="UTF16_STRING";class Qe{constructor(t){this.bytes_=t,this.position_=0,this.text_decoder_=new TextDecoder}static allocate(t){return new Qe(new Uint8Array(t))}clear(){this.position_=0}bytes(){return this.bytes_}position(){return this.position_}setPosition(t){this.position_=t}capacity(){return this.bytes_.length}readInt8(t){return this.readUint8(t)<<24>>24}readUint8(t){return this.bytes_[t]}readInt16(t){return this.readUint16(t)<<16>>16}readUint16(t){return this.bytes_[t]|this.bytes_[t+1]<<8}readInt32(t){return this.bytes_[t]|this.bytes_[t+1]<<8|this.bytes_[t+2]<<16|this.bytes_[t+3]<<24}readUint32(t){return this.readInt32(t)>>>0}readInt64(t){return BigInt.asIntN(64,BigInt(this.readUint32(t))+(BigInt(this.readUint32(t+4))<<BigInt(32)))}readUint64(t){return BigInt.asUintN(64,BigInt(this.readUint32(t))+(BigInt(this.readUint32(t+4))<<BigInt(32)))}readFloat32(t){return Xe[0]=this.readInt32(t),$e[0]}readFloat64(t){return Xe[Ze?0:1]=this.readInt32(t),Xe[Ze?1:0]=this.readInt32(t+4),Ye[0]}writeInt8(t,e){this.bytes_[t]=e}writeUint8(t,e){this.bytes_[t]=e}writeInt16(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8}writeUint16(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8}writeInt32(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8,this.bytes_[t+2]=e>>16,this.bytes_[t+3]=e>>24}writeUint32(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8,this.bytes_[t+2]=e>>16,this.bytes_[t+3]=e>>24}writeInt64(t,e){this.writeInt32(t,Number(BigInt.asIntN(32,e))),this.writeInt32(t+4,Number(BigInt.asIntN(32,e>>BigInt(32))))}writeUint64(t,e){this.writeUint32(t,Number(BigInt.asUintN(32,e))),this.writeUint32(t+4,Number(BigInt.asUintN(32,e>>BigInt(32))))}writeFloat32(t,e){$e[0]=e,this.writeInt32(t,Xe[0])}writeFloat64(t,e){Ye[0]=e,this.writeInt32(t,Xe[Ze?0:1]),this.writeInt32(t+4,Xe[Ze?1:0])}getBufferIdentifier(){if(this.bytes_.length<this.position_+4+4)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");let t="";for(let e=0;e<4;e++)t+=String.fromCharCode(this.readInt8(this.position_+4+e));return t}__offset(t,e){const s=t-this.readInt32(t);return e<this.readInt16(s)?this.readInt16(s+e):0}__union(t,e){return t.bb_pos=e+this.readInt32(e),t.bb=this,t}__string(t,e){t+=this.readInt32(t);const s=this.readInt32(t);t+=4;const r=this.bytes_.subarray(t,t+s);return e===Je.UTF8_BYTES?r:this.text_decoder_.decode(r)}__union_with_string(t,e){return"string"==typeof t?this.__string(e):this.__union(t,e)}__indirect(t){return t+this.readInt32(t)}__vector(t){return t+this.readInt32(t)+4}__vector_len(t){return this.readInt32(t+this.readInt32(t))}__has_identifier(t){if(4!=t.length)throw new Error("FlatBuffers: file identifier must be length 4");for(let e=0;e<4;e++)if(t.charCodeAt(e)!=this.readInt8(this.position()+4+e))return!1;return!0}createScalarList(t,e){const s=[];for(let r=0;r<e;++r){const e=t(r);null!==e&&s.push(e)}return s}createObjList(t,e){const s=[];for(let r=0;r<e;++r){const e=t(r);null!==e&&s.push(e.unpack())}return s}}class ts{constructor(t){let e;this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1,this.string_maps=null,this.text_encoder=new TextEncoder,e=t||1024,this.bb=Qe.allocate(e),this.space=e}clear(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1,this.string_maps=null}forceDefaults(t){this.force_defaults=t}dataBuffer(){return this.bb}asUint8Array(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())}prep(t,e){t>this.minalign&&(this.minalign=t);const s=1+~(this.bb.capacity()-this.space+e)&t-1;for(;this.space<s+t+e;){const t=this.bb.capacity();this.bb=ts.growByteBuffer(this.bb),this.space+=this.bb.capacity()-t}this.pad(s)}pad(t){for(let e=0;e<t;e++)this.bb.writeInt8(--this.space,0)}writeInt8(t){this.bb.writeInt8(this.space-=1,t)}writeInt16(t){this.bb.writeInt16(this.space-=2,t)}writeInt32(t){this.bb.writeInt32(this.space-=4,t)}writeInt64(t){this.bb.writeInt64(this.space-=8,t)}writeFloat32(t){this.bb.writeFloat32(this.space-=4,t)}writeFloat64(t){this.bb.writeFloat64(this.space-=8,t)}addInt8(t){this.prep(1,0),this.writeInt8(t)}addInt16(t){this.prep(2,0),this.writeInt16(t)}addInt32(t){this.prep(4,0),this.writeInt32(t)}addInt64(t){this.prep(8,0),this.writeInt64(t)}addFloat32(t){this.prep(4,0),this.writeFloat32(t)}addFloat64(t){this.prep(8,0),this.writeFloat64(t)}addFieldInt8(t,e,s){(this.force_defaults||e!=s)&&(this.addInt8(e),this.slot(t))}addFieldInt16(t,e,s){(this.force_defaults||e!=s)&&(this.addInt16(e),this.slot(t))}addFieldInt32(t,e,s){(this.force_defaults||e!=s)&&(this.addInt32(e),this.slot(t))}addFieldInt64(t,e,s){(this.force_defaults||e!==s)&&(this.addInt64(e),this.slot(t))}addFieldFloat32(t,e,s){(this.force_defaults||e!=s)&&(this.addFloat32(e),this.slot(t))}addFieldFloat64(t,e,s){(this.force_defaults||e!=s)&&(this.addFloat64(e),this.slot(t))}addFieldOffset(t,e,s){(this.force_defaults||e!=s)&&(this.addOffset(e),this.slot(t))}addFieldStruct(t,e,s){e!=s&&(this.nested(e),this.slot(t))}nested(t){if(t!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")}notNested(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")}slot(t){null!==this.vtable&&(this.vtable[t]=this.offset())}offset(){return this.bb.capacity()-this.space}static growByteBuffer(t){const e=t.capacity();if(3221225472&e)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");const s=e<<1,r=Qe.allocate(s);return r.setPosition(s-e),r.bytes().set(t.bytes(),s-e),r}addOffset(t){this.prep(4,0),this.writeInt32(this.offset()-t+4)}startObject(t){this.notNested(),null==this.vtable&&(this.vtable=[]),this.vtable_in_use=t;for(let e=0;e<t;e++)this.vtable[e]=0;this.isNested=!0,this.object_start=this.offset()}endObject(){if(null==this.vtable||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);const t=this.offset();let e=this.vtable_in_use-1;for(;e>=0&&0==this.vtable[e];e--);const s=e+1;for(;e>=0;e--)this.addInt16(0!=this.vtable[e]?t-this.vtable[e]:0);this.addInt16(t-this.object_start);const r=2*(s+2);this.addInt16(r);let i=0;const n=this.space;t:for(e=0;e<this.vtables.length;e++){const t=this.bb.capacity()-this.vtables[e];if(r==this.bb.readInt16(t)){for(let e=2;e<r;e+=2)if(this.bb.readInt16(n+e)!=this.bb.readInt16(t+e))continue t;i=this.vtables[e];break}}return i?(this.space=this.bb.capacity()-t,this.bb.writeInt32(this.space,i-t)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-t,this.offset()-t)),this.isNested=!1,t}finish(t,e,s){const r=s?4:0;if(e){const t=e;if(this.prep(this.minalign,8+r),4!=t.length)throw new Error("FlatBuffers: file identifier must be length 4");for(let e=3;e>=0;e--)this.writeInt8(t.charCodeAt(e))}this.prep(this.minalign,4+r),this.addOffset(t),r&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)}finishSizePrefixed(t,e){this.finish(t,e,!0)}requiredField(t,e){const s=this.bb.capacity()-t,r=s-this.bb.readInt32(s);if(!(e<this.bb.readInt16(r)&&0!=this.bb.readInt16(r+e)))throw new Error("FlatBuffers: field "+e+" must be set")}startVector(t,e,s){this.notNested(),this.vector_num_elems=e,this.prep(4,t*e),this.prep(s,t*e)}endVector(){return this.writeInt32(this.vector_num_elems),this.offset()}createSharedString(t){if(!t)return 0;if(this.string_maps||(this.string_maps=new Map),this.string_maps.has(t))return this.string_maps.get(t);const e=this.createString(t);return this.string_maps.set(t,e),e}createString(t){if(null==t)return 0;let e;e=t instanceof Uint8Array?t:this.text_encoder.encode(t),this.addInt8(0),this.startVector(1,e.length,1),this.bb.setPosition(this.space-=e.length);for(let t=0,s=this.space,r=this.bb.bytes();t<e.length;t++)r[s++]=e[t];return this.endVector()}createObjectOffset(t){return null===t?0:"string"==typeof t?this.createString(t):t.pack(this)}createObjectOffsetList(t){const e=[];for(let s=0;s<t.length;++s){const r=t[s];if(null===r)throw new Error("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");e.push(this.createObjectOffset(r))}return e}createStructOffsetList(t,e){return e(this,t.length),this.createObjectOffsetList(t.slice().reverse()),this.endVector()}}let es=class t{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsCivilCurve(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsCivilCurve(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}points(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}pointsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}pointsArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}data(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}static startCivilCurve(t){t.startObject(2)}static addPoints(t,e){t.addFieldOffset(0,e,0)}static createPointsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startPointsVector(t,e){t.startVector(4,e,4)}static addData(t,e){t.addFieldOffset(1,e,0)}static endCivilCurve(t){return t.endObject()}static createCivilCurve(e,s,r){return t.startCivilCurve(e),t.addPoints(e,s),t.addData(e,r),t.endCivilCurve(e)}},ss=class t{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAlignment(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsAlignment(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}vertical(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new es).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}verticalLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}horizontal(t,e){const s=this.bb.__offset(this.bb_pos,6);return s?(e||new es).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}horizontalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}absolute(t,e){const s=this.bb.__offset(this.bb_pos,8);return s?(e||new es).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}absoluteLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}initialPk(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readFloat32(this.bb_pos+t):0}static startAlignment(t){t.startObject(4)}static addVertical(t,e){t.addFieldOffset(0,e,0)}static createVerticalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startVerticalVector(t,e){t.startVector(4,e,4)}static addHorizontal(t,e){t.addFieldOffset(1,e,0)}static createHorizontalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startHorizontalVector(t,e){t.startVector(4,e,4)}static addAbsolute(t,e){t.addFieldOffset(2,e,0)}static createAbsoluteVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAbsoluteVector(t,e){t.startVector(4,e,4)}static addInitialPk(t,e){t.addFieldFloat32(3,e,0)}static endAlignment(t){return t.endObject()}static createAlignment(e,s,r,i,n){return t.startAlignment(e),t.addVertical(e,s),t.addHorizontal(e,r),t.addAbsolute(e,i),t.addInitialPk(e,n),t.endAlignment(e)}},rs=class t{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsCivilData(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsCivilData(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}alignments(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new ss).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}alignmentsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrix(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startCivilData(t){t.startObject(2)}static addAlignments(t,e){t.addFieldOffset(0,e,0)}static createAlignmentsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAlignmentsVector(t,e){t.startVector(4,e,4)}static addCoordinationMatrix(t,e){t.addFieldOffset(1,e,0)}static createCoordinationMatrixVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startCoordinationMatrixVector(t,e){t.startVector(4,e,4)}static endCivilData(t){return t.endObject()}static createCivilData(e,s,r){return t.startCivilData(e),t.addAlignments(e,s),t.addCoordinationMatrix(e,r),t.endCivilData(e)}},is=class t{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsFragment(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsFragment(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}position(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}positionLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}positionArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}normal(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}normalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}normalArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}index(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}indexLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}indexArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}groups(t){const e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}groupsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}groupsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}materials(t){const e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}materialsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}materialsArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}matrices(t){const e=this.bb.__offset(this.bb_pos,14);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}matricesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}matricesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}colors(t){const e=this.bb.__offset(this.bb_pos,16);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}colorsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}colorsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsSize(t){const e=this.bb.__offset(this.bb_pos,18);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsSizeLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsSizeArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const e=this.bb.__offset(this.bb_pos,20);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}idsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,20);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}id(t){const e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__string(this.bb_pos+e,t):null}capacity(){const t=this.bb.__offset(this.bb_pos,24);return t?this.bb.readUint32(this.bb_pos+t):0}capacityOffset(){const t=this.bb.__offset(this.bb_pos,26);return t?this.bb.readUint32(this.bb_pos+t):0}static startFragment(t){t.startObject(12)}static addPosition(t,e){t.addFieldOffset(0,e,0)}static createPositionVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startPositionVector(t,e){t.startVector(4,e,4)}static addNormal(t,e){t.addFieldOffset(1,e,0)}static createNormalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startNormalVector(t,e){t.startVector(4,e,4)}static addIndex(t,e){t.addFieldOffset(2,e,0)}static createIndexVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIndexVector(t,e){t.startVector(4,e,4)}static addGroups(t,e){t.addFieldOffset(3,e,0)}static createGroupsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startGroupsVector(t,e){t.startVector(4,e,4)}static addMaterials(t,e){t.addFieldOffset(4,e,0)}static createMaterialsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startMaterialsVector(t,e){t.startVector(4,e,4)}static addMatrices(t,e){t.addFieldOffset(5,e,0)}static createMatricesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startMatricesVector(t,e){t.startVector(4,e,4)}static addColors(t,e){t.addFieldOffset(6,e,0)}static createColorsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startColorsVector(t,e){t.startVector(4,e,4)}static addItemsSize(t,e){t.addFieldOffset(7,e,0)}static createItemsSizeVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsSizeVector(t,e){t.startVector(4,e,4)}static addIds(t,e){t.addFieldOffset(8,e,0)}static createIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIdsVector(t,e){t.startVector(4,e,4)}static addId(t,e){t.addFieldOffset(9,e,0)}static addCapacity(t,e){t.addFieldInt32(10,e,0)}static addCapacityOffset(t,e){t.addFieldInt32(11,e,0)}static endFragment(t){return t.endObject()}static createFragment(e,s,r,i,n,o,a,c,b,h,d,l,f){return t.startFragment(e),t.addPosition(e,s),t.addNormal(e,r),t.addIndex(e,i),t.addGroups(e,n),t.addMaterials(e,o),t.addMatrices(e,a),t.addColors(e,c),t.addItemsSize(e,b),t.addIds(e,h),t.addId(e,d),t.addCapacity(e,l),t.addCapacityOffset(e,f),t.endFragment(e)}},ns=class t{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsFragmentsGroup(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsFragmentsGroup(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}items(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new is).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}itemsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}civil(t){const e=this.bb.__offset(this.bb_pos,6);return e?(t||new rs).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}coordinationMatrix(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}idsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeys(t){const e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsKeysLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeysIndices(t){const e=this.bb.__offset(this.bb_pos,14);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsKeysIndicesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysIndicesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRels(t){const e=this.bb.__offset(this.bb_pos,16);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsRelsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRelsIndices(t){const e=this.bb.__offset(this.bb_pos,18);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsRelsIndicesLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsIndicesArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}fragmentKeys(t){const e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__string(this.bb_pos+e,t):null}id(t){const e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__string(this.bb_pos+e,t):null}name(t){const e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__string(this.bb_pos+e,t):null}ifcName(t){const e=this.bb.__offset(this.bb_pos,26);return e?this.bb.__string(this.bb_pos+e,t):null}ifcDescription(t){const e=this.bb.__offset(this.bb_pos,28);return e?this.bb.__string(this.bb_pos+e,t):null}ifcSchema(t){const e=this.bb.__offset(this.bb_pos,30);return e?this.bb.__string(this.bb_pos+e,t):null}maxExpressId(){const t=this.bb.__offset(this.bb_pos,32);return t?this.bb.readUint32(this.bb_pos+t):0}boundingBox(t){const e=this.bb.__offset(this.bb_pos,34);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}boundingBoxLength(){const t=this.bb.__offset(this.bb_pos,34);return t?this.bb.__vector_len(this.bb_pos+t):0}boundingBoxArray(){const t=this.bb.__offset(this.bb_pos,34);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}opaqueGeometriesIds(t){const e=this.bb.__offset(this.bb_pos,36);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*t):0}opaqueGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,36);return t?this.bb.__vector_len(this.bb_pos+t):0}opaqueGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,36);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}transparentGeometriesIds(t){const e=this.bb.__offset(this.bb_pos,38);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*t):0}transparentGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,38);return t?this.bb.__vector_len(this.bb_pos+t):0}transparentGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,38);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startFragmentsGroup(t){t.startObject(18)}static addItems(t,e){t.addFieldOffset(0,e,0)}static createItemsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startItemsVector(t,e){t.startVector(4,e,4)}static addCivil(t,e){t.addFieldOffset(1,e,0)}static addCoordinationMatrix(t,e){t.addFieldOffset(2,e,0)}static createCoordinationMatrixVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startCoordinationMatrixVector(t,e){t.startVector(4,e,4)}static addIds(t,e){t.addFieldOffset(3,e,0)}static createIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIdsVector(t,e){t.startVector(4,e,4)}static addItemsKeys(t,e){t.addFieldOffset(4,e,0)}static createItemsKeysVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsKeysVector(t,e){t.startVector(4,e,4)}static addItemsKeysIndices(t,e){t.addFieldOffset(5,e,0)}static createItemsKeysIndicesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsKeysIndicesVector(t,e){t.startVector(4,e,4)}static addItemsRels(t,e){t.addFieldOffset(6,e,0)}static createItemsRelsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsRelsVector(t,e){t.startVector(4,e,4)}static addItemsRelsIndices(t,e){t.addFieldOffset(7,e,0)}static createItemsRelsIndicesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsRelsIndicesVector(t,e){t.startVector(4,e,4)}static addFragmentKeys(t,e){t.addFieldOffset(8,e,0)}static addId(t,e){t.addFieldOffset(9,e,0)}static addName(t,e){t.addFieldOffset(10,e,0)}static addIfcName(t,e){t.addFieldOffset(11,e,0)}static addIfcDescription(t,e){t.addFieldOffset(12,e,0)}static addIfcSchema(t,e){t.addFieldOffset(13,e,0)}static addMaxExpressId(t,e){t.addFieldInt32(14,e,0)}static addBoundingBox(t,e){t.addFieldOffset(15,e,0)}static createBoundingBoxVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startBoundingBoxVector(t,e){t.startVector(4,e,4)}static addOpaqueGeometriesIds(t,e){t.addFieldOffset(16,e,0)}static createOpaqueGeometriesIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startOpaqueGeometriesIdsVector(t,e){t.startVector(4,e,4)}static addTransparentGeometriesIds(t,e){t.addFieldOffset(17,e,0)}static createTransparentGeometriesIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startTransparentGeometriesIdsVector(t,e){t.startVector(4,e,4)}static endFragmentsGroup(t){return t.endObject()}static finishFragmentsGroupBuffer(t,e){t.finish(e)}static finishSizePrefixedFragmentsGroupBuffer(t,e){t.finish(e,void 0,!0)}};class os{constructor(){e(this,"version",1),e(this,"fragmentIDSeparator","|")}import(t){const e=new Qe(t),s=ns.getRootAsFragmentsGroup(e),r=this.constructFragmentGroup(s),i=s.itemsLength();for(let t=0;t<i;t++){const e=s.items(t);if(!e)continue;const i=this.constructGeometry(e),n=this.constructMaterials(e),o=e.capacity(),a=new He(i,n,o);a.capacityOffset=e.capacityOffset(),this.setInstances(e,a),this.setID(e,a),r.items.push(a),r.add(a.mesh)}return r}export(t){const e=new ts(1024),s=[],r=ns,i=is;let n=null;if(t.civilData){const s=[],r=ss,i=rs;for(const[i,n]of t.civilData.alignments){const{absolute:t,horizontal:i,vertical:o}=n,a=this.saveCivilCurves(i,e),c=this.saveCivilCurves(o,e),b=this.saveCivilCurves(t,e),h=r.createHorizontalVector(e,a),d=r.createVerticalVector(e,c),l=r.createAbsoluteVector(e,b);r.startAlignment(e),r.addHorizontal(e,h),r.addVertical(e,d),r.addAbsolute(e,l),r.addInitialPk(e,n.initialKP);const f=r.endAlignment(e);s.push(f)}const o=i.createAlignmentsVector(e,s),a=i.createCoordinationMatrixVector(e,t.coordinationMatrix.elements);i.startCivilData(e),i.addAlignments(e,o),i.addCoordinationMatrix(e,a),n=i.endCivilData(e)}for(const r of t.items){const t=r.exportData(),n=[];for(const t of r.ids){const e=r.getInstancesIDs(t);if(!e)throw new Error("Instances not found!");n.push(e.size)}const o=i.createPositionVector(e,t.position),a=i.createNormalVector(e,t.normal),c=i.createIndexVector(e,t.index),b=i.createGroupsVector(e,t.groups),h=i.createMaterialsVector(e,t.materials),d=i.createMatricesVector(e,t.matrices),l=i.createColorsVector(e,t.colors),f=i.createIdsVector(e,t.ids),u=i.createItemsSizeVector(e,n),_=e.createString(t.id);i.startFragment(e),i.addPosition(e,o),i.addNormal(e,a),i.addIndex(e,c),i.addGroups(e,b),i.addMaterials(e,h),i.addMatrices(e,d),i.addColors(e,l),i.addIds(e,f),i.addItemsSize(e,u),i.addId(e,_),i.addCapacity(e,r.capacity),i.addCapacityOffset(e,r.capacityOffset);const p=is.endFragment(e);s.push(p)}const o=r.createItemsVector(e,s),a=r.createCoordinationMatrixVector(e,t.coordinationMatrix.elements);let c="";for(const e of t.keyFragments.values())c.length&&(c+=this.fragmentIDSeparator),c+=e;const b=e.createString(c),h=[],d=[],l=[],f=[],u=[];let _=0,p=0;for(const[e,[s,r]]of t.data){h.push(_),l.push(p),u.push(e);for(const t of s)d.push(t);for(const t of r)f.push(t);_+=s.length,p+=r.length}const m=[],g=[];for(const[e,s]of t.geometryIDs.opaque)m.push(e,s);for(const[e,s]of t.geometryIDs.transparent)g.push(e,s);const y=e.createString(t.uuid),w=e.createString(t.name),I=e.createString(t.ifcMetadata.name),v=e.createString(t.ifcMetadata.description),x=e.createString(t.ifcMetadata.schema),A=r.createItemsKeysIndicesVector(e,h),V=r.createItemsKeysVector(e,d),F=r.createItemsRelsIndicesVector(e,l),B=r.createItemsRelsVector(e,f),M=r.createIdsVector(e,u),C=r.createOpaqueGeometriesIdsVector(e,m),O=r.createTransparentGeometriesIdsVector(e,g),{min:P,max:T}=t.boundingBox,S=[P.x,P.y,P.z,T.x,T.y,T.z],U=r.createBoundingBoxVector(e,S);r.startFragmentsGroup(e),r.addId(e,y),r.addName(e,w),r.addIfcName(e,I),r.addIfcDescription(e,v),r.addIfcSchema(e,x),r.addMaxExpressId(e,t.ifcMetadata.maxExpressID),r.addItems(e,o),r.addFragmentKeys(e,b),r.addIds(e,M),r.addItemsKeysIndices(e,A),r.addItemsKeys(e,V),r.addItemsRelsIndices(e,F),r.addItemsRels(e,B),r.addCoordinationMatrix(e,a),r.addBoundingBox(e,U),r.addOpaqueGeometriesIds(e,C),r.addTransparentGeometriesIds(e,O),null!==n&&r.addCivil(e,n);const D=ns.endFragmentsGroup(e);return e.finish(D),e.asUint8Array()}setID(t,e){const s=t.id();s&&(e.id=s,e.mesh.uuid=s)}setInstances(t,e){const r=t.matricesArray(),i=t.colorsArray(),n=t.idsArray(),o=t.itemsSizeArray();if(!r||!n||!o)throw new Error("Error: Can't load empty fragment!");const a=[];let c=0;for(let t=0;t<o.length;t++){const e=n[t],b=o[t],h=[],d=[];for(let t=0;t<b;t++){const t=16*c,e=r.subarray(t,t+17),n=(new s.Matrix4).fromArray(e);if(h.push(n),i){const t=3*c,[e,r,n]=i.subarray(t,t+4),o=new s.Color(e,r,n);d.push(o)}c++}const l=d.length?d:void 0;a.push({id:e,transforms:h,colors:l})}e.add(a)}constructMaterials(t){const e=t.materialsArray(),r=[];if(!e)return r;for(let t=0;t<e.length;t+=5){const i=e[t],n=Boolean(e[t+1]),o=e[t+2],a=e[t+3],c=e[t+4],b=new s.Color(o,a,c),h=new s.MeshLambertMaterial({color:b,opacity:i,transparent:n});r.push(h)}return r}constructFragmentGroup(t){const e=new ps,r=t.civil();if(r){const t=r.coordinationMatrixArray(),i=new s.Matrix4;t&&i.fromArray(t),e.civilData={alignments:new Map,coordinationMatrix:i};const n=r.alignmentsLength();for(let t=0;t<n;t++){const i=new s.LineBasicMaterial({color:16777215}),n=new ms,o=r.alignments(t);if(!o)throw new Error("Alignment not found!");const a=o.horizontalLength();n.horizontal=this.constructCivilCurves(o,n,"horizontal",a,i);const c=o.verticalLength();n.vertical=this.constructCivilCurves(o,n,"vertical",c,i);const b=o.horizontalLength();n.absolute=this.constructCivilCurves(o,n,"absolute",b,i),n.initialKP=o.initialPk(),e.civilData.alignments.set(t,n)}}e.uuid=t.id()||e.uuid,e.name=t.name()||"",e.ifcMetadata={name:t.ifcName()||"",description:t.ifcDescription()||"",schema:t.ifcSchema()||"IFC2X3",maxExpressID:t.maxExpressId()||0};const i=(new s.Matrix4).elements,n=t.coordinationMatrixArray()||i,o=t.idsArray()||new Uint32Array,a=t.itemsKeysIndicesArray()||new Uint32Array,c=t.itemsKeysArray()||new Uint32Array,b=t.itemsRelsArray()||new Uint32Array,h=t.itemsRelsIndicesArray()||new Uint32Array,d=(t.fragmentKeys()||"").split(this.fragmentIDSeparator);this.setGroupData(e,o,a,c,0),this.setGroupData(e,o,h,b,1);const l=t.opaqueGeometriesIdsArray()||new Uint32Array,f=t.transparentGeometriesIdsArray()||new Uint32Array,u=new Map;for(let t=0;t<l.length-1;t+=2){const e=l[t],s=l[t+1];u.set(e,s)}const _=new Map;for(let t=0;t<f.length-1;t+=2){const e=f[t],s=f[t+1];_.set(e,s)}e.geometryIDs={opaque:u,transparent:_};const p=t.boundingBoxArray()||[0,0,0,0,0,0],[m,g,y,w,I,v]=p;e.boundingBox.min.set(m,g,y),e.boundingBox.max.set(w,I,v);for(let t=0;t<d.length;t++)e.keyFragments.set(t,d[t]);return 16===n.length&&e.coordinationMatrix.fromArray(n),e}setGroupData(t,e,s,r,i){for(let n=0;n<s.length;n++){const o=e[n],a=s[n],c=s[n+1]||r.length,b=[];for(let t=a;t<c;t++)b.push(r[t]);t.data.has(o)||t.data.set(o,[[],[]]);const h=t.data.get(o);h&&(h[i]=b)}}constructGeometry(t){const e=t.positionArray()||new Float32Array,r=t.normalArray()||new Float32Array,i=t.indexArray(),n=t.groupsArray();if(!i)throw new Error("Index not found!");const o=new s.BufferGeometry;if(o.setIndex(Array.from(i)),o.setAttribute("position",new s.BufferAttribute(e,3)),o.setAttribute("normal",new s.BufferAttribute(r,3)),n)for(let t=0;t<n.length;t+=3){const e=n[t],s=n[t+1],r=n[t+2];o.addGroup(e,s,r)}return o}constructCivilCurves(t,e,r,i,n){const o=[];for(let a=0;a<i;a++){const i=t[r](a);if(!i)throw new Error("Curve not found!");const c=i.pointsArray();if(null===c)throw new Error("Curve points not found!");let b={};const h=i.data();h&&(b=JSON.parse(h));const d=new s.EdgesGeometry,l=new s.BufferAttribute(c,3);d.setAttribute("position",l);const f=[];for(let t=0;t<c.length/3-1;t++)f.push(t,t+1);d.setIndex(f);const u=new ys(a,b,e,d,n);o.push(u.curve)}return o}saveCivilCurves(t,e){const s=es,r=[];for(const i of t){const t=i.mesh.geometry.attributes.position.array,n=s.createPointsVector(e,t),o=e.createString(JSON.stringify(i.data));s.startCivilCurve(e),s.addPoints(e,n),s.addData(e,o);const a=s.endCivilCurve(e);r.push(a)}return r}}let as=class t{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsCivilCurve(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsCivilCurve(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}points(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}pointsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}pointsArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}data(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}static startCivilCurve(t){t.startObject(2)}static addPoints(t,e){t.addFieldOffset(0,e,0)}static createPointsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startPointsVector(t,e){t.startVector(4,e,4)}static addData(t,e){t.addFieldOffset(1,e,0)}static endCivilCurve(t){return t.endObject()}static createCivilCurve(e,s,r){return t.startCivilCurve(e),t.addPoints(e,s),t.addData(e,r),t.endCivilCurve(e)}},cs=class t{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAlignment(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsAlignment(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}vertical(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new as).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}verticalLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}horizontal(t,e){const s=this.bb.__offset(this.bb_pos,6);return s?(e||new as).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}horizontalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}absolute(t,e){const s=this.bb.__offset(this.bb_pos,8);return s?(e||new as).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}absoluteLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}initialPk(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readFloat32(this.bb_pos+t):0}static startAlignment(t){t.startObject(4)}static addVertical(t,e){t.addFieldOffset(0,e,0)}static createVerticalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startVerticalVector(t,e){t.startVector(4,e,4)}static addHorizontal(t,e){t.addFieldOffset(1,e,0)}static createHorizontalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startHorizontalVector(t,e){t.startVector(4,e,4)}static addAbsolute(t,e){t.addFieldOffset(2,e,0)}static createAbsoluteVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAbsoluteVector(t,e){t.startVector(4,e,4)}static addInitialPk(t,e){t.addFieldFloat32(3,e,0)}static endAlignment(t){return t.endObject()}static createAlignment(e,s,r,i,n){return t.startAlignment(e),t.addVertical(e,s),t.addHorizontal(e,r),t.addAbsolute(e,i),t.addInitialPk(e,n),t.endAlignment(e)}};class bs{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsCivilData(t,e){return(e||new bs).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCivilData(t,e){return t.setPosition(t.position()+4),(e||new bs).__init(t.readInt32(t.position())+t.position(),t)}alignments(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new cs).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}alignmentsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrix(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startCivilData(t){t.startObject(2)}static addAlignments(t,e){t.addFieldOffset(0,e,0)}static createAlignmentsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAlignmentsVector(t,e){t.startVector(4,e,4)}static addCoordinationMatrix(t,e){t.addFieldOffset(1,e,0)}static createCoordinationMatrixVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startCoordinationMatrixVector(t,e){t.startVector(4,e,4)}static endCivilData(t){return t.endObject()}static createCivilData(t,e,s){return bs.startCivilData(t),bs.addAlignments(t,e),bs.addCoordinationMatrix(t,s),bs.endCivilData(t)}}class hs{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsFragment(t,e){return(e||new hs).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsFragment(t,e){return t.setPosition(t.position()+4),(e||new hs).__init(t.readInt32(t.position())+t.position(),t)}position(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}positionLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}positionArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}normal(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}normalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}normalArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}index(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}indexLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}indexArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}groups(t){const e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}groupsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}groupsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}materials(t){const e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}materialsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}materialsArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}matrices(t){const e=this.bb.__offset(this.bb_pos,14);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}matricesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}matricesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}colors(t){const e=this.bb.__offset(this.bb_pos,16);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}colorsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}colorsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsSize(t){const e=this.bb.__offset(this.bb_pos,18);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsSizeLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsSizeArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const e=this.bb.__offset(this.bb_pos,20);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}idsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,20);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}id(t){const e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__string(this.bb_pos+e,t):null}capacity(){const t=this.bb.__offset(this.bb_pos,24);return t?this.bb.readUint32(this.bb_pos+t):0}capacityOffset(){const t=this.bb.__offset(this.bb_pos,26);return t?this.bb.readUint32(this.bb_pos+t):0}static startFragment(t){t.startObject(12)}static addPosition(t,e){t.addFieldOffset(0,e,0)}static createPositionVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startPositionVector(t,e){t.startVector(4,e,4)}static addNormal(t,e){t.addFieldOffset(1,e,0)}static createNormalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startNormalVector(t,e){t.startVector(4,e,4)}static addIndex(t,e){t.addFieldOffset(2,e,0)}static createIndexVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIndexVector(t,e){t.startVector(4,e,4)}static addGroups(t,e){t.addFieldOffset(3,e,0)}static createGroupsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startGroupsVector(t,e){t.startVector(4,e,4)}static addMaterials(t,e){t.addFieldOffset(4,e,0)}static createMaterialsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startMaterialsVector(t,e){t.startVector(4,e,4)}static addMatrices(t,e){t.addFieldOffset(5,e,0)}static createMatricesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startMatricesVector(t,e){t.startVector(4,e,4)}static addColors(t,e){t.addFieldOffset(6,e,0)}static createColorsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startColorsVector(t,e){t.startVector(4,e,4)}static addItemsSize(t,e){t.addFieldOffset(7,e,0)}static createItemsSizeVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsSizeVector(t,e){t.startVector(4,e,4)}static addIds(t,e){t.addFieldOffset(8,e,0)}static createIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIdsVector(t,e){t.startVector(4,e,4)}static addId(t,e){t.addFieldOffset(9,e,0)}static addCapacity(t,e){t.addFieldInt32(10,e,0)}static addCapacityOffset(t,e){t.addFieldInt32(11,e,0)}static endFragment(t){return t.endObject()}static createFragment(t,e,s,r,i,n,o,a,c,b,h,d,l){return hs.startFragment(t),hs.addPosition(t,e),hs.addNormal(t,s),hs.addIndex(t,r),hs.addGroups(t,i),hs.addMaterials(t,n),hs.addMatrices(t,o),hs.addColors(t,a),hs.addItemsSize(t,c),hs.addIds(t,b),hs.addId(t,h),hs.addCapacity(t,d),hs.addCapacityOffset(t,l),hs.endFragment(t)}}let ds=class t{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsFragmentsGroup(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsFragmentsGroup(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}items(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new hs).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}itemsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}civil(t){const e=this.bb.__offset(this.bb_pos,6);return e?(t||new bs).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}coordinationMatrix(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}idsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeys(t){const e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsKeysLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeysIndices(t){const e=this.bb.__offset(this.bb_pos,14);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsKeysIndicesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysIndicesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRels(t){const e=this.bb.__offset(this.bb_pos,16);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsRelsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRelsIndices(t){const e=this.bb.__offset(this.bb_pos,18);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsRelsIndicesLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsIndicesArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}fragmentKeys(t){const e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__string(this.bb_pos+e,t):null}globalIds(t){const e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__string(this.bb_pos+e,t):null}id(t){const e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__string(this.bb_pos+e,t):null}name(t){const e=this.bb.__offset(this.bb_pos,26);return e?this.bb.__string(this.bb_pos+e,t):null}ifcName(t){const e=this.bb.__offset(this.bb_pos,28);return e?this.bb.__string(this.bb_pos+e,t):null}ifcDescription(t){const e=this.bb.__offset(this.bb_pos,30);return e?this.bb.__string(this.bb_pos+e,t):null}ifcSchema(t){const e=this.bb.__offset(this.bb_pos,32);return e?this.bb.__string(this.bb_pos+e,t):null}maxExpressId(){const t=this.bb.__offset(this.bb_pos,34);return t?this.bb.readUint32(this.bb_pos+t):0}boundingBox(t){const e=this.bb.__offset(this.bb_pos,36);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}boundingBoxLength(){const t=this.bb.__offset(this.bb_pos,36);return t?this.bb.__vector_len(this.bb_pos+t):0}boundingBoxArray(){const t=this.bb.__offset(this.bb_pos,36);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}opaqueGeometriesIds(t){const e=this.bb.__offset(this.bb_pos,38);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*t):0}opaqueGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,38);return t?this.bb.__vector_len(this.bb_pos+t):0}opaqueGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,38);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}transparentGeometriesIds(t){const e=this.bb.__offset(this.bb_pos,40);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*t):0}transparentGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,40);return t?this.bb.__vector_len(this.bb_pos+t):0}transparentGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,40);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startFragmentsGroup(t){t.startObject(19)}static addItems(t,e){t.addFieldOffset(0,e,0)}static createItemsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startItemsVector(t,e){t.startVector(4,e,4)}static addCivil(t,e){t.addFieldOffset(1,e,0)}static addCoordinationMatrix(t,e){t.addFieldOffset(2,e,0)}static createCoordinationMatrixVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startCoordinationMatrixVector(t,e){t.startVector(4,e,4)}static addIds(t,e){t.addFieldOffset(3,e,0)}static createIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIdsVector(t,e){t.startVector(4,e,4)}static addItemsKeys(t,e){t.addFieldOffset(4,e,0)}static createItemsKeysVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsKeysVector(t,e){t.startVector(4,e,4)}static addItemsKeysIndices(t,e){t.addFieldOffset(5,e,0)}static createItemsKeysIndicesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsKeysIndicesVector(t,e){t.startVector(4,e,4)}static addItemsRels(t,e){t.addFieldOffset(6,e,0)}static createItemsRelsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsRelsVector(t,e){t.startVector(4,e,4)}static addItemsRelsIndices(t,e){t.addFieldOffset(7,e,0)}static createItemsRelsIndicesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsRelsIndicesVector(t,e){t.startVector(4,e,4)}static addFragmentKeys(t,e){t.addFieldOffset(8,e,0)}static addGlobalIds(t,e){t.addFieldOffset(9,e,0)}static addId(t,e){t.addFieldOffset(10,e,0)}static addName(t,e){t.addFieldOffset(11,e,0)}static addIfcName(t,e){t.addFieldOffset(12,e,0)}static addIfcDescription(t,e){t.addFieldOffset(13,e,0)}static addIfcSchema(t,e){t.addFieldOffset(14,e,0)}static addMaxExpressId(t,e){t.addFieldInt32(15,e,0)}static addBoundingBox(t,e){t.addFieldOffset(16,e,0)}static createBoundingBoxVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startBoundingBoxVector(t,e){t.startVector(4,e,4)}static addOpaqueGeometriesIds(t,e){t.addFieldOffset(17,e,0)}static createOpaqueGeometriesIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startOpaqueGeometriesIdsVector(t,e){t.startVector(4,e,4)}static addTransparentGeometriesIds(t,e){t.addFieldOffset(18,e,0)}static createTransparentGeometriesIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startTransparentGeometriesIdsVector(t,e){t.startVector(4,e,4)}static endFragmentsGroup(t){return t.endObject()}static finishFragmentsGroupBuffer(t,e){t.finish(e)}static finishSizePrefixedFragmentsGroupBuffer(t,e){t.finish(e,void 0,!0)}};class ls{constructor(){e(this,"version",2),e(this,"separator","|")}import(t){const e=new Qe(t),s=ds.getRootAsFragmentsGroup(e),r=this.constructFragmentGroup(s),i=s.itemsLength();for(let t=0;t<i;t++){const e=s.items(t);if(!e)continue;const i=this.constructGeometry(e),n=this.constructMaterials(e),o=e.capacity(),a=new He(i,n,o);a.capacityOffset=e.capacityOffset(),this.setInstances(e,a),this.setID(e,a),r.items.push(a),r.add(a.mesh)}return r}export(t){const e=new ts(1024),s=[],r=ds,i=hs;let n=null;if(t.civilData){const s=[],r=cs,i=bs;for(const[i,n]of t.civilData.alignments){const{absolute:t,horizontal:i,vertical:o}=n,a=this.saveCivilCurves(i,e),c=this.saveCivilCurves(o,e),b=this.saveCivilCurves(t,e),h=r.createHorizontalVector(e,a),d=r.createVerticalVector(e,c),l=r.createAbsoluteVector(e,b);r.startAlignment(e),r.addHorizontal(e,h),r.addVertical(e,d),r.addAbsolute(e,l),r.addInitialPk(e,n.initialKP);const f=r.endAlignment(e);s.push(f)}const o=i.createAlignmentsVector(e,s),a=i.createCoordinationMatrixVector(e,t.coordinationMatrix.elements);i.startCivilData(e),i.addAlignments(e,o),i.addCoordinationMatrix(e,a),n=i.endCivilData(e)}for(const r of t.items){const t=r.exportData(),n=[];for(const t of r.ids){const e=r.getInstancesIDs(t);if(!e)throw new Error("Instances not found!");n.push(e.size)}const o=i.createPositionVector(e,t.position),a=i.createNormalVector(e,t.normal),c=i.createIndexVector(e,t.index),b=i.createGroupsVector(e,t.groups),h=i.createMaterialsVector(e,t.materials),d=i.createMatricesVector(e,t.matrices),l=i.createColorsVector(e,t.colors),f=i.createIdsVector(e,t.ids),u=i.createItemsSizeVector(e,n),_=e.createString(t.id);i.startFragment(e),i.addPosition(e,o),i.addNormal(e,a),i.addIndex(e,c),i.addGroups(e,b),i.addMaterials(e,h),i.addMatrices(e,d),i.addColors(e,l),i.addIds(e,f),i.addItemsSize(e,u),i.addId(e,_),i.addCapacity(e,r.capacity),i.addCapacityOffset(e,r.capacityOffset);const p=hs.endFragment(e);s.push(p)}const o=r.createItemsVector(e,s),a=r.createCoordinationMatrixVector(e,t.coordinationMatrix.elements);let c="";for(const e of t.keyFragments.values())c.length&&(c+=this.separator),c+=e;let b="";for(const[e]of t.globalToExpressIDs)b.length&&(b+=this.separator),b+=e;const h=e.createString(c),d=e.createString(b),l=[],f=[],u=[],_=[],p=[];let m=0,g=0;for(const[e,[s,r]]of t.data){l.push(m),u.push(g),p.push(e);for(const t of s)f.push(t);for(const t of r)_.push(t);m+=s.length,g+=r.length}const y=[],w=[];for(const[e,s]of t.geometryIDs.opaque)y.push(e,s);for(const[e,s]of t.geometryIDs.transparent)w.push(e,s);const I=e.createString(t.uuid),v=e.createString(t.name),x=e.createString(t.ifcMetadata.name),A=e.createString(t.ifcMetadata.description),V=e.createString(t.ifcMetadata.schema),F=r.createItemsKeysIndicesVector(e,l),B=r.createItemsKeysVector(e,f),M=r.createItemsRelsIndicesVector(e,u),C=r.createItemsRelsVector(e,_),O=r.createIdsVector(e,p),P=r.createOpaqueGeometriesIdsVector(e,y),T=r.createTransparentGeometriesIdsVector(e,w),{min:S,max:U}=t.boundingBox,D=[S.x,S.y,S.z,U.x,U.y,U.z],G=r.createBoundingBoxVector(e,D);r.startFragmentsGroup(e),r.addId(e,I),r.addName(e,v),r.addIfcName(e,x),r.addIfcDescription(e,A),r.addIfcSchema(e,V),r.addMaxExpressId(e,t.ifcMetadata.maxExpressID),r.addItems(e,o),r.addFragmentKeys(e,h),r.addGlobalIds(e,d),r.addIds(e,O),r.addItemsKeysIndices(e,F),r.addItemsKeys(e,B),r.addItemsRelsIndices(e,M),r.addItemsRels(e,C),r.addCoordinationMatrix(e,a),r.addBoundingBox(e,G),r.addOpaqueGeometriesIds(e,P),r.addTransparentGeometriesIds(e,T),null!==n&&r.addCivil(e,n);const L=ds.endFragmentsGroup(e);return e.finish(L),e.asUint8Array()}setID(t,e){const s=t.id();s&&(e.id=s,e.mesh.uuid=s)}setInstances(t,e){const r=t.matricesArray(),i=t.colorsArray(),n=t.idsArray(),o=t.itemsSizeArray();if(!r||!n||!o)throw new Error("Error: Can't load empty fragment!");const a=[];let c=0;for(let t=0;t<o.length;t++){const e=n[t],b=o[t],h=[],d=[];for(let t=0;t<b;t++){const t=16*c,e=r.subarray(t,t+17),n=(new s.Matrix4).fromArray(e);if(h.push(n),i){const t=3*c,[e,r,n]=i.subarray(t,t+4),o=new s.Color(e,r,n);d.push(o)}c++}const l=d.length?d:void 0;a.push({id:e,transforms:h,colors:l})}e.add(a)}constructMaterials(t){const e=t.materialsArray(),r=[];if(!e)return r;for(let t=0;t<e.length;t+=5){const i=e[t],n=Boolean(e[t+1]),o=e[t+2],a=e[t+3],c=e[t+4],b=new s.Color(o,a,c),h=new s.MeshLambertMaterial({color:b,opacity:i,transparent:n});r.push(h)}return r}constructFragmentGroup(t){const e=new ps,r=t.civil();if(r){const t=r.coordinationMatrixArray(),i=new s.Matrix4;t&&i.fromArray(t),e.civilData={alignments:new Map,coordinationMatrix:i};const n=r.alignmentsLength();for(let t=0;t<n;t++){const i=new s.LineBasicMaterial({color:16777215}),n=new ms,o=r.alignments(t);if(!o)throw new Error("Alignment not found!");const a=o.horizontalLength();n.horizontal=this.constructCivilCurves(o,n,"horizontal",a,i);const c=o.verticalLength();n.vertical=this.constructCivilCurves(o,n,"vertical",c,i);const b=o.horizontalLength();n.absolute=this.constructCivilCurves(o,n,"absolute",b,i),n.initialKP=o.initialPk(),e.civilData.alignments.set(t,n)}}e.uuid=t.id()||e.uuid,e.name=t.name()||"",e.ifcMetadata={name:t.ifcName()||"",description:t.ifcDescription()||"",schema:t.ifcSchema()||"IFC2X3",maxExpressID:t.maxExpressId()||0};const i=(new s.Matrix4).elements,n=t.coordinationMatrixArray()||i,o=t.idsArray()||new Uint32Array,a=t.itemsKeysIndicesArray()||new Uint32Array,c=t.itemsKeysArray()||new Uint32Array,b=t.itemsRelsArray()||new Uint32Array,h=t.itemsRelsIndicesArray()||new Uint32Array,d=(t.fragmentKeys()||"").split(this.separator),l=(t.globalIds()||"").split(this.separator);this.setGroupData(e,o,a,c,0),this.setGroupData(e,o,h,b,1);const f=t.opaqueGeometriesIdsArray()||new Uint32Array,u=t.transparentGeometriesIdsArray()||new Uint32Array,_=new Map;for(let t=0;t<f.length-1;t+=2){const e=f[t],s=f[t+1];_.set(e,s)}const p=new Map;for(let t=0;t<u.length-1;t+=2){const e=u[t],s=u[t+1];p.set(e,s)}e.geometryIDs={opaque:_,transparent:p};const m=t.boundingBoxArray()||[0,0,0,0,0,0],[g,y,w,I,v,x]=m;e.boundingBox.min.set(g,y,w),e.boundingBox.max.set(I,v,x);for(let t=0;t<d.length;t++)e.keyFragments.set(t,d[t]);16===n.length&&e.coordinationMatrix.fromArray(n);for(let t=0;t<o.length;t++)e.globalToExpressIDs.set(l[t],o[t]);return e}setGroupData(t,e,s,r,i){for(let n=0;n<s.length;n++){const o=e[n],a=s[n],c=s[n+1],b=void 0===c?r.length:c,h=[];for(let t=a;t<b;t++)h.push(r[t]);t.data.has(o)||t.data.set(o,[[],[]]);const d=t.data.get(o);d&&(d[i]=h)}}constructGeometry(t){const e=t.positionArray()||new Float32Array,r=t.normalArray()||new Float32Array,i=t.indexArray(),n=t.groupsArray();if(!i)throw new Error("Index not found!");const o=new s.BufferGeometry;if(o.setIndex(Array.from(i)),o.setAttribute("position",new s.BufferAttribute(e,3)),o.setAttribute("normal",new s.BufferAttribute(r,3)),n)for(let t=0;t<n.length;t+=3){const e=n[t],s=n[t+1],r=n[t+2];o.addGroup(e,s,r)}return o}constructCivilCurves(t,e,r,i,n){const o=[];for(let a=0;a<i;a++){const i=t[r](a);if(!i)throw new Error("Curve not found!");const c=i.pointsArray();if(null===c)throw new Error("Curve points not found!");let b={};const h=i.data();h&&(b=JSON.parse(h));const d=new s.EdgesGeometry,l=new s.BufferAttribute(c,3);d.setAttribute("position",l);const f=[];for(let t=0;t<c.length/3-1;t++)f.push(t,t+1);d.setIndex(f);const u=new ys(a,b,e,d,n);o.push(u.curve)}return o}saveCivilCurves(t,e){const s=as,r=[];for(const i of t){const t=i.mesh.geometry.attributes.position.array,n=s.createPointsVector(e,t),o=e.createString(JSON.stringify(i.data));s.startCivilCurve(e),s.addPoints(e,n),s.addData(e,o);const a=s.endCivilCurve(e);r.push(a)}return r}}class fs{constructor(){e(this,"parsers",[new ls,new os]),e(this,"version","auto")}import(t){const e=this.parsers.length;if("auto"===this.version){for(let s=0;s<this.parsers.length;s++){const r=this.parsers[s].import(t);if(0!==Object.keys(r).length){if(0!==s){const t=this.parsers.length-s;this.warnVersion(t,e)}return r}}throw new Error("No valid parser found for this file")}this.checkCurrentVersionValid(this.version);const s=this.parsers.length-this.version,r=this.parsers[s].import(t);if(0===Object.keys(r).length)throw new Error(`The given version ${this.version} doesn't match to the given file. Try using "auto" in the version property to handle versions automatically.`);return r}export(t){if("auto"===this.version){return this.parsers[0].export(t)}this.checkCurrentVersionValid(this.version);const e=this.parsers.length-this.version;return this.parsers[e].export(t)}checkCurrentVersionValid(t){if("auto"===this.version)return;this.version!==t&&this.warnVersion(this.version,t);if(!Number.isInteger(this.version))throw new Error("Invalid version. Non-automatic versions must an integer.");if(this.version<1||this.version>t)throw new Error(`Invalid version. Versions range from 1 to ${t}.`)}warnVersion(t,e){console.warn(`This fragment file version is ${t}. The latest version is ${e}. To avoid issues, please consider updating your fragments. You can do so by regenerating your fragments from the original IFC file.`)}}class us{constructor(t){e(this,"baseDirectory"),e(this,"maxDeadTime",6e4),e(this,"mode","buffer"),e(this,"_memoryCleanTime",1e4),e(this,"_intervalID",null),e(this,"_isCleaningMemory",!1),e(this,"cleanMemory",(async()=>{if(this._isCleaningMemory)return;this._isCleaningMemory=!0;const t=await this.getDir(this.baseDirectory),e=new Set,s=(new Date).getTime();for await(const r of t.values()){const t=localStorage.getItem(r.name)||"0";s-parseInt(t,10)>this.maxDeadTime&&(e.add(r.name),localStorage.removeItem(r.name))}for(const s of e)t.removeEntry(s);this._isCleaningMemory=!1})),this.baseDirectory=t,this.setupMemoryCleanup()}get memoryCleanTime(){return this._memoryCleanTime}set memoryCleanTime(t){this._memoryCleanTime=t,this.dispose(),this.setupMemoryCleanup()}isCached(t){const e=this.encodeName(t);return null!==localStorage.getItem(e)}async get(t){const e=this.encodeName(t),s=await this.getDir(this.baseDirectory);try{const t=await s.getFileHandle(e),r=await t.getFile();return this.updateLastAccessTime(e),r}catch(t){return null}}async add(t,e){const s=this.encodeName(t),r=await this.getDir(this.baseDirectory),i=await r.getFileHandle(s,{create:!0}),n=await i.createWritable();await n.write(e),await n.close(),this.updateLastAccessTime(s)}async clear(){const t=await this.getDir(this.baseDirectory);for await(const[e]of t.entries())await t.removeEntry(e)}dispose(){null!==this._intervalID&&window.clearInterval(this._intervalID)}setupMemoryCleanup(){this._intervalID=window.setInterval(this.cleanMemory,this.memoryCleanTime)}async getDir(t){return(await navigator.storage.getDirectory()).getDirectoryHandle(t,{create:!0})}encodeName(t){return t.replace(/[\\/:*?"<>|]/g,"")}updateLastAccessTime(t){const e=(new Date).getTime().toString();localStorage.setItem(t,e)}}const _s=class t extends s.Group{constructor(){super(...arguments),e(this,"items",[]),e(this,"boundingBox",new s.Box3),e(this,"coordinationMatrix",new s.Matrix4),e(this,"keyFragments",new Map),e(this,"globalToExpressIDs",new Map),e(this,"data",new Map),e(this,"geometryIDs",{opaque:new Map,transparent:new Map}),e(this,"ifcMetadata",{name:"",description:"",schema:"IFC2X3",maxExpressID:0}),e(this,"civilData"),e(this,"streamSettings",{baseFileName:"",ids:new Map,types:new Map}),e(this,"isStreamed",!1),e(this,"_properties")}get hasProperties(){const t=void 0!==this._properties,e=0!==this.streamSettings.ids.size;return t||e}getFragmentMap(t=this.data.keys()){const e={};for(const s of t){const t=this.data.get(s);if(t)for(const r of t[0]){const t=this.keyFragments.get(r);void 0!==t&&(e[t]||(e[t]=new Set),e[t].add(s))}}return e}getItemVertices(t){const e=[],r=this.getFragmentMap([t]);for(const i in r){const r=this.items.find((t=>t.id===i));if(!r)continue;const n=r.getInstancesIDs(t);if(n)for(const t of n){const i=new s.Matrix4;r.mesh.getMatrixAt(t,i);for(const t of r.uniqueVertices){const s=t.clone().applyMatrix4(i);e.push(s)}}}return e}static setPropertiesDB(e){e?t.propertiesDB||(t.propertiesDB=new us("that-open-company-streaming-properties")):e||t.propertiesDB&&t.propertiesDB.dispose()}dispose(t=!0){for(const e of this.items)e.dispose(t);if(this.coordinationMatrix=new s.Matrix4,this.keyFragments.clear(),this.data.clear(),this._properties={},this.removeFromParent(),this.items=[],this.civilData){const{alignments:t}=this.civilData;for(const[e,s]of t)this.disposeAlignment(s.vertical),this.disposeAlignment(s.horizontal),this.disposeAlignment(s.absolute)}this.civilData=void 0}setLocalProperties(t){this._properties=t}getLocalProperties(){return this._properties}getAllPropertiesIDs(){return this._properties?Object.keys(this._properties).map((t=>parseInt(t,10))):Array.from(this.streamSettings.ids.keys())}getAllPropertiesTypes(){if(this._properties){const t=new Set;for(const e in this._properties){const s=this._properties[e];void 0!==s.type&&t.add(s.type)}return Array.from(t)}return Array.from(this.streamSettings.types.keys())}async getProperties(t){if(this._properties)return this._properties[t]||null;const e=this.getPropsURL(t),s=await this.getPropertiesData(e);return s?s[t]:null}async setProperties(t,e){if(!this._properties)throw new Error("Writing streamed properties not supported yet!");null!==e?this._properties[t]=e:delete this._properties[t]}async getAllPropertiesOfType(t){if(this._properties){const e={};let s=!1;for(const r in this._properties){const i=this._properties[r];i.type===t&&(e[i.expressID]=i,s=!0)}return s?e:null}const{types:e}=this.streamSettings,s=e.get(t);if(void 0===s)return null;const r={};for(const t of s){const e=this.constructFileName(t),s=await this.getPropertiesData(e);for(const t in s)r[parseInt(t,10)]=s[t]}return r}clone(t){throw new Error("Use FragmentsGroup.cloneGroup instead!")}cloneGroup(e){const s=new t;s.coordinationMatrix=this.coordinationMatrix,s.position.copy(this.position),s.rotation.copy(this.rotation),s.scale.copy(this.scale),s.updateMatrix(),s.ifcMetadata={...this.ifcMetadata},e||(e=this.getFragmentMap(this.data.keys()));const r=new Set,i=new Map;for(const t of this.items){if(!e[t.id])continue;const n=e[t.id],o=t.clone(n);i.set(t.id,o.id),s.items.push(o),s.add(o.mesh);for(const t of n)r.add(t)}for(const t of r){const e=this.data.get(t);e&&s.data.set(t,e)}for(const[t,e]of this.keyFragments)if(i.has(e)){const r=i.get(e);if(void 0===r)throw new Error("Malformed fragment ID map during clone!");s.keyFragments.set(t,r)}for(const[t,e]of this.globalToExpressIDs)r.has(e)&&s.globalToExpressIDs.set(t,e);return this.civilData&&(s.civilData={coordinationMatrix:this.coordinationMatrix,alignments:new Map}),s}getPropsURL(t){const{ids:e}=this.streamSettings,s=e.get(t);if(void 0===s)throw new Error("ID not found");return this.constructFileName(s)}async getPropertiesData(e){var s;let r;if((null==(s=this.streamSettings.baseUrl)?void 0:s.length)&&(console.warn("streamSettings.baseUrl is deprecated. Use FragmentsGroup.url instead."),t.url=this.streamSettings.baseUrl),t.useCache){let s=null;if(t.propertiesDB&&(s=await t.propertiesDB.get(e)),s)r=await s.text();else{const s=await t.fetch(e);if(r=await s.text(),t.propertiesDB){const s=(new TextEncoder).encode(r);await t.propertiesDB.add(e,s)}}}else{const s=await t.fetch(e);r=await s.text()}return JSON.parse(r)}constructFileName(e){if(t.constructFileName)return t.constructFileName(e);const{baseFileName:s}=this.streamSettings;return`${s}-${e}`}disposeAlignment(t){for(const e of t)if(e.mesh.geometry.dispose(),Array.isArray(e.mesh.material))for(const t of e.mesh.material)t.dispose();else e.mesh.material.dispose();t.length=0}};e(_s,"fetch",(async t=>fetch(`${_s.url}${t}`))),e(_s,"constructFileName",null),e(_s,"url",""),e(_s,"useCache",!0),e(_s,"propertiesDB",null);let ps=_s;class ms{constructor(){e(this,"vertical",[]),e(this,"horizontal",[]),e(this,"absolute",[]),e(this,"initialKP",0)}getLength(t){let e=0;for(const s of this[t])e+=s.getLength();return e}getPointAt(t,e){const s=this.getCurveAt(t,e);return s.curve.getPointAt(s.percentage)}getPercentageAt(t,e,s=.01){const r=this[e];let i=0;for(const n of r){const r=n.getPercentageAt(t,s),o=n.getLength();if(null!==r){return(i+r*o)/this.getLength(e)}i+=o}return null}getCurveAt(t,e){t<0?t=0:t>1&&(t=1);const s=this[e],r=this.getLength(e)*t;let i=0;for(const t of s){const e=t.getLength();if(i+e>=r){return{curve:t,percentage:(r-i)/e}}i+=e}throw new Error("Could not compute point!")}}class gs{constructor(t,s,r,i){e(this,"index"),e(this,"mesh"),e(this,"data"),e(this,"alignment"),this.index=t,this.mesh=s,this.data=r,this.alignment=i}get _index(){return this.mesh.geometry.index}get _pos(){return this.mesh.geometry.attributes.position.array}getLength(){let t=0;for(let e=0;e<this._index.array.length-1;e+=2){const{startPoint:s,endPoint:r}=this.getSegment(e);t+=s.distanceTo(r)}return t}getPointAt(t){const{startPoint:e,endPoint:s,distanceToStart:r}=this.getSegmentAt(t),i=s.clone();return i.sub(e),i.normalize(),i.multiplyScalar(r),i.add(e),i}getSegmentAt(t){t<0?t=0:t>1&&(t=1);const e=this.getLength()*t;let s=0;for(let t=0;t<this._index.array.length-1;t+=2){const{startPoint:r,endPoint:i}=this.getSegment(t),n=r.distanceTo(i);if(s+n>=e){return{distanceToStart:e-s,index:t,startPoint:r,endPoint:i}}s+=n}throw new Error("Could not compute point")}getPercentageAt(t,e=.01){let s=0;for(let r=0;r<this._index.array.length-1;r+=2){const{startPoint:i,endPoint:n}=this.getSegment(r),o=i.distanceTo(n),a=t.distanceTo(i);if(a+t.distanceTo(n)-o<=e){return(s+a)/this.getLength()}s+=o}return null}getSegment(t){const e=3*this._index.array[t],r=3*this._index.array[t+1];return{startPoint:new s.Vector3(this._pos[e],this._pos[e+1],this._pos[e+2]),endPoint:new s.Vector3(this._pos[r],this._pos[r+1],this._pos[r+2])}}}class ys extends s.LineSegments{constructor(t,s,r,i,n){super(i,n),e(this,"curve"),this.curve=new gs(t,this,s,r)}}class ws{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsStreamedGeometry(t,e){return(e||new ws).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsStreamedGeometry(t,e){return t.setPosition(t.position()+4),(e||new ws).__init(t.readInt32(t.position())+t.position(),t)}geometryId(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb_pos+t):0}position(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}positionLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}positionArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}normal(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}normalLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}normalArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}index(t){const e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}indexLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}indexArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startStreamedGeometry(t){t.startObject(4)}static addGeometryId(t,e){t.addFieldInt32(0,e,0)}static addPosition(t,e){t.addFieldOffset(1,e,0)}static createPositionVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startPositionVector(t,e){t.startVector(4,e,4)}static addNormal(t,e){t.addFieldOffset(2,e,0)}static createNormalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startNormalVector(t,e){t.startVector(4,e,4)}static addIndex(t,e){t.addFieldOffset(3,e,0)}static createIndexVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIndexVector(t,e){t.startVector(4,e,4)}static endStreamedGeometry(t){return t.endObject()}static createStreamedGeometry(t,e,s,r,i){return ws.startStreamedGeometry(t),ws.addGeometryId(t,e),ws.addPosition(t,s),ws.addNormal(t,r),ws.addIndex(t,i),ws.endStreamedGeometry(t)}}class Is{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsStreamedGeometries(t,e){return(e||new Is).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsStreamedGeometries(t,e){return t.setPosition(t.position()+4),(e||new Is).__init(t.readInt32(t.position())+t.position(),t)}geometries(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new ws).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}geometriesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startStreamedGeometries(t){t.startObject(1)}static addGeometries(t,e){t.addFieldOffset(0,e,0)}static createGeometriesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startGeometriesVector(t,e){t.startVector(4,e,4)}static endStreamedGeometries(t){return t.endObject()}static finishStreamedGeometriesBuffer(t,e){t.finish(e)}static finishSizePrefixedStreamedGeometriesBuffer(t,e){t.finish(e,void 0,!0)}static createStreamedGeometries(t,e){return Is.startStreamedGeometries(t),Is.addGeometries(t,e),Is.endStreamedGeometries(t)}}class vs{import(t){const e=new Qe(t),s=Is.getRootAsStreamedGeometries(e),r=new Map,i=s.geometriesLength();for(let t=0;t<i;t++){const e=s.geometries(t);if(!e)continue;const i=e.geometryId();if(null===i)throw new Error("Error finding ID!");const n=e.positionArray(),o=e.normalArray(),a=e.indexArray();n&&o&&a&&r.set(i,{position:n,normal:o,index:a})}return r}export(t){const e=new ts(1024),s=[],r=Is,i=ws;for(const[r,{index:n,position:o,normal:a}]of t){const t=i.createIndexVector(e,n),c=i.createPositionVector(e,o),b=i.createNormalVector(e,a);i.startStreamedGeometry(e),i.addGeometryId(e,r),i.addIndex(e,t),i.addPosition(e,c),i.addNormal(e,b);const h=i.endStreamedGeometry(e);s.push(h)}const n=r.createGeometriesVector(e,s);r.startStreamedGeometries(e),r.addGeometries(e,n);const o=r.endStreamedGeometries(e);return e.finish(o),e.asUint8Array()}}class xs{static combine(t){if(0===t.length)return{};if(1===t.length)return t[0];const e={};for(const s of t)for(const t in s){e[t]||(e[t]=new Set);for(const r of s[t])e[t].add(r)}return e}static intersect(t){if(0===t.length)return{};if(1===t.length)return t[0];const e=new Map;let s=0;for(const r of t){s++;for(const t in r){e.has(t)||e.set(t,{count:0,ids:new Map});const s=e.get(t);s.count++;for(const e of r[t]){const t=s.ids.get(e)||0;s.ids.set(e,t+1)}}}const r={};for(const[t,{count:i,ids:n}]of e)if(i===s)for(const[e,i]of n)i===s&&(r[t]||(r[t]=new Set),r[t].add(e));return r}static copy(t){const e={};for(const s in t)e[s]=new Set(t[s]);return e}static export(t){const e={};for(const s in t)e[s]=Array.from(t[s]);return e}static import(t){const e={};for(const s in t)e[s]=new Set(t[s]);return e}}export{ms as Alignment,gs as CivilCurve,ys as CurveMesh,He as Fragment,g as FragmentMesh,xs as FragmentUtils,ps as FragmentsGroup,fs as Serializer,vs as StreamSerializer,us as StreamerFileDb};
