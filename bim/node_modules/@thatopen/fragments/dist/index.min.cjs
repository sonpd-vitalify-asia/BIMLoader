"use strict";var t=Object.defineProperty,e=(e,s,r)=>(((e,s,r)=>{s in e?t(e,s,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[s]=r})(e,"symbol"!=typeof s?s+"":s,r),r);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const s=require("three");function r(t){const e=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(t)for(const s in t)if("default"!==s){const r=Object.getOwnPropertyDescriptor(t,s);Object.defineProperty(e,s,r.get?r:{enumerable:!0,get:()=>t[s]})}return e.default=t,Object.freeze(e)}const i=r(s);class n extends i.InstancedMesh{constructor(t,s,r,i){if(super(t,s,r),e(this,"fragment"),e(this,"material"),e(this,"geometry"),Array.isArray(s)||(s=[s]),this.material=s,!t.index)throw new Error("The geometry for fragments must be indexed!");this.geometry=t,this.fragment=i;const n=t.index.count;t.groups.length||t.groups.push({start:0,count:n,materialIndex:0})}exportData(){const t=this.geometry.attributes.position.array,e=this.geometry.attributes.normal.array,s=Array.from(this.geometry.index.array),r=[];for(const t of this.geometry.groups){const e=t.materialIndex||0,{start:s,count:i}=t;r.push(s,i,e)}const n=[];if(Array.isArray(this.material))for(const t of this.material){const e=t.opacity,s=t.transparent?1:0,r=new i.Color(t.color).toArray();n.push(e,s,...r)}const o=Array.from(this.instanceMatrix.array);let a;return a=null!==this.instanceColor?Array.from(this.instanceColor.array):[],{position:t,normal:e,index:s,groups:r,materials:n,matrices:o,colors:a}}clone(t){throw new Error("Fragment meshes can't be cloned directly. Use mesh.fragment.clone instead!")}}const o=1.25,a=65535,c=Math.pow(2,-24),b=Symbol("SKIP_GENERATION");function h(t){return function(t){return t.index?t.index.count:t.attributes.position.count}(t)/3}function d(t,e){if(!t.index){const r=t.attributes.position.count,i=function(t,e=ArrayBuffer){return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}(r,e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);t.setIndex(new s.BufferAttribute(i,1));for(let t=0;t<r;t++)i[t]=t}}function l(t){const e=h(t),s=t.drawRange,r=s.start/3,i=(s.start+s.count)/3,n=Math.max(0,r),o=Math.min(e,i)-n;return[{offset:Math.floor(n),count:Math.floor(o)}]}function f(t){if(!t.groups||!t.groups.length)return l(t);const e=[],s=new Set,r=t.drawRange,i=r.start/3,n=(r.start+r.count)/3;for(const e of t.groups){const t=e.start/3,r=(e.start+e.count)/3;s.add(Math.max(i,t)),s.add(Math.min(n,r))}const o=Array.from(s.values()).sort(((t,e)=>t-e));for(let t=0;t<o.length-1;t++){const s=o[t],r=o[t+1];e.push({offset:Math.floor(s),count:Math.floor(r-s)})}return e}function u(t,e,s){return s.min.x=e[t],s.min.y=e[t+1],s.min.z=e[t+2],s.max.x=e[t+3],s.max.y=e[t+4],s.max.z=e[t+5],s}function _(t){let e=-1,s=-1/0;for(let r=0;r<3;r++){const i=t[r+3]-t[r];i>s&&(s=i,e=r)}return e}function p(t,e){e.set(t)}function m(t,e,s){let r,i;for(let n=0;n<3;n++){const o=n+3;r=t[n],i=e[n],s[n]=r<i?r:i,r=t[o],i=e[o],s[o]=r>i?r:i}}function g(t,e,s){for(let r=0;r<3;r++){const i=e[t+2*r],n=e[t+2*r+1],o=i-n,a=i+n;o<s[r]&&(s[r]=o),a>s[r+3]&&(s[r+3]=a)}}function y(t){const e=t[3]-t[0],s=t[4]-t[1],r=t[5]-t[2];return 2*(e*s+s*r+r*e)}function w(t,e,s,r,i=null){let n=1/0,o=1/0,a=1/0,c=-1/0,b=-1/0,h=-1/0,d=1/0,l=1/0,f=1/0,u=-1/0,_=-1/0,p=-1/0;const m=null!==i;for(let r=6*e,i=6*(e+s);r<i;r+=6){const e=t[r+0],s=t[r+1],i=e-s,g=e+s;i<n&&(n=i),g>c&&(c=g),m&&e<d&&(d=e),m&&e>u&&(u=e);const y=t[r+2],w=t[r+3],x=y-w,v=y+w;x<o&&(o=x),v>b&&(b=v),m&&y<l&&(l=y),m&&y>_&&(_=y);const I=t[r+4],A=t[r+5],V=I-A,F=I+A;V<a&&(a=V),F>h&&(h=F),m&&I<f&&(f=I),m&&I>p&&(p=I)}r[0]=n,r[1]=o,r[2]=a,r[3]=c,r[4]=b,r[5]=h,m&&(i[0]=d,i[1]=l,i[2]=f,i[3]=u,i[4]=_,i[5]=p)}const x=32,v=(t,e)=>t.candidate-e.candidate,I=new Array(x).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),A=new Float32Array(6);class V{constructor(){}}function F(t,e,s,r,i,n){let o=r,a=r+i-1;const c=n.pos,b=2*n.axis;for(;;){for(;o<=a&&s[6*o+b]<c;)o++;for(;o<=a&&s[6*a+b]>=c;)a--;if(!(o<a))return o;for(let t=0;t<3;t++){let s=e[3*o+t];e[3*o+t]=e[3*a+t],e[3*a+t]=s}for(let t=0;t<6;t++){let e=s[6*o+t];s[6*o+t]=s[6*a+t],s[6*a+t]=e}o++,a--}}function B(t,e,s,r,i,n){let o=r,a=r+i-1;const c=n.pos,b=2*n.axis;for(;;){for(;o<=a&&s[6*o+b]<c;)o++;for(;o<=a&&s[6*a+b]>=c;)a--;if(!(o<a))return o;{let e=t[o];t[o]=t[a],t[a]=e;for(let t=0;t<6;t++){let e=s[6*o+t];s[6*o+t]=s[6*a+t],s[6*a+t]=e}o++,a--}}}function M(t,e){const s=t.geometry,r=s.index?s.index.array:null,i=e.maxDepth,n=e.verbose,a=e.maxLeafTris,b=e.strategy,d=e.onProgress,u=h(s),M=t._indirectBuffer;let C=!1;const O=new Float32Array(6),P=new Float32Array(6),T=function(t,e){var s;(s=e)[0]=s[1]=s[2]=1/0,s[3]=s[4]=s[5]=-1/0;const r=t.attributes.position,i=t.index?t.index.array:null,n=h(t),o=new Float32Array(6*n),a=r.normalized,b=r.array,d=r.offset||0;let l=3;r.isInterleavedBufferAttribute&&(l=r.data.stride);const f=["getX","getY","getZ"];for(let t=0;t<n;t++){const s=3*t,n=6*t;let h=s+0,u=s+1,_=s+2;i&&(h=i[h],u=i[u],_=i[_]),a||(h=h*l+d,u=u*l+d,_=_*l+d);for(let t=0;t<3;t++){let s,i,d;a?(s=r[f[t]](h),i=r[f[t]](u),d=r[f[t]](_)):(s=b[h+t],i=b[u+t],d=b[_+t]);let l=s;i<l&&(l=i),d<l&&(l=d);let p=s;i>p&&(p=i),d>p&&(p=d);const m=(p-l)/2,g=2*t;o[n+g+0]=l+m,o[n+g+1]=m+(Math.abs(l)+m)*c,l<e[t]&&(e[t]=l),p>e[t+3]&&(e[t+3]=p)}}return o}(s,O),S=e.indirect?B:F,U=[],D=e.indirect?l(s):f(s);if(1===D.length){const t=D[0],e=new V;e.boundingData=O,function(t,e,s,r){let i=1/0,n=1/0,o=1/0,a=-1/0,c=-1/0,b=-1/0;for(let r=6*e,h=6*(e+s);r<h;r+=6){const e=t[r+0];e<i&&(i=e),e>a&&(a=e);const s=t[r+2];s<n&&(n=s),s>c&&(c=s);const h=t[r+4];h<o&&(o=h),h>b&&(b=h)}r[0]=i,r[1]=n,r[2]=o,r[3]=a,r[4]=c,r[5]=b}(T,t.offset,t.count,P),L(e,t.offset,t.count,P),U.push(e)}else for(let t of D){const e=new V;e.boundingData=new Float32Array(6),w(T,t.offset,t.count,e.boundingData,P),L(e,t.offset,t.count,P),U.push(e)}return U;function G(t){d&&d(t/u)}function L(t,e,c,h=null,d=0){if(!C&&d>=i&&(C=!0,n&&(console.warn(`MeshBVH: Max depth of ${i} reached when generating BVH. Consider increasing maxDepth.`),console.warn(s))),c<=a||d>=i)return G(e+c),t.offset=e,t.count=c,t;const l=function(t,e,s,r,i,n){let a=-1,c=0;if(0===n)a=_(e),-1!==a&&(c=(e[a]+e[a+3])/2);else if(1===n)a=_(t),-1!==a&&(c=function(t,e,s,r){let i=0;for(let n=e,o=e+s;n<o;n++)i+=t[6*n+2*r];return i/s}(s,r,i,a));else if(2===n){const n=y(t);let b=o*i;const h=6*r,d=6*(r+i);for(let t=0;t<3;t++){const r=e[t],l=(e[t+3]-r)/x;if(i<8){const e=[...I];e.length=i;let r=0;for(let i=h;i<d;i+=6,r++){const n=e[r];n.candidate=s[i+2*t],n.count=0;const{bounds:o,leftCacheBounds:a,rightCacheBounds:c}=n;for(let t=0;t<3;t++)c[t]=1/0,c[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0,o[t]=1/0,o[t+3]=-1/0;g(i,s,o)}e.sort(v);let l=i;for(let t=0;t<l;t++){const s=e[t];for(;t+1<l&&e[t+1].candidate===s.candidate;)e.splice(t+1,1),l--}for(let r=h;r<d;r+=6){const i=s[r+2*t];for(let t=0;t<l;t++){const n=e[t];i>=n.candidate?g(r,s,n.rightCacheBounds):(g(r,s,n.leftCacheBounds),n.count++)}}for(let s=0;s<l;s++){const r=e[s],h=r.count,d=i-r.count,l=r.leftCacheBounds,f=r.rightCacheBounds;let u=0;0!==h&&(u=y(l)/n);let _=0;0!==d&&(_=y(f)/n);const p=1+o*(u*h+_*d);p<b&&(a=t,b=p,c=r.candidate)}}else{for(let t=0;t<x;t++){const e=I[t];e.count=0,e.candidate=r+l+t*l;const s=e.bounds;for(let t=0;t<3;t++)s[t]=1/0,s[t+3]=-1/0}for(let e=h;e<d;e+=6){let i=~~((s[e+2*t]-r)/l);i>=x&&(i=31);const n=I[i];n.count++,g(e,s,n.bounds)}const e=I[31];p(e.bounds,e.rightCacheBounds);for(let t=30;t>=0;t--){const e=I[t],s=I[t+1];m(e.bounds,s.rightCacheBounds,e.rightCacheBounds)}let f=0;for(let e=0;e<31;e++){const s=I[e],r=s.count,h=s.bounds,d=I[e+1].rightCacheBounds;0!==r&&(0===f?p(h,A):m(h,A,A)),f+=r;let l=0,u=0;0!==f&&(l=y(A)/n);const _=i-f;0!==_&&(u=y(d)/n);const g=1+o*(l*f+u*_);g<b&&(a=t,b=g,c=s.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${n} used.`);return{axis:a,pos:c}}(t.boundingData,h,T,e,c,b);if(-1===l.axis)return G(e+c),t.offset=e,t.count=c,t;const f=S(M,r,T,e,c,l);if(f===e||f===e+c)G(e+c),t.offset=e,t.count=c;else{t.splitAxis=l.axis;const s=new V,r=e,i=f-e;t.left=s,s.boundingData=new Float32Array(6),w(T,r,i,s.boundingData,P),L(s,r,i,P,d+1);const n=new V,o=f,a=c-i;t.right=n,n.boundingData=new Float32Array(6),w(T,o,a,n.boundingData,P),L(n,o,a,P,d+1)}return t}}function C(t,e){const s=t.geometry;e.indirect&&(t._indirectBuffer=function(t,e){const s=(t.index?t.index.count:t.attributes.position.count)/3,r=s>65536,i=r?4:2,n=e?new SharedArrayBuffer(s*i):new ArrayBuffer(s*i),o=r?new Uint32Array(n):new Uint16Array(n);for(let t=0,e=o.length;t<e;t++)o[t]=t;return o}(s,e.useSharedArrayBuffer),function(t){if(0===t.groups.length)return!1;const e=h(t),s=f(t).sort(((t,e)=>t.offset-e.offset)),r=s[s.length-1];r.count=Math.min(e-r.offset,r.count);let i=0;return s.forEach((({count:t})=>i+=t)),e!==i}(s)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),t._indirectBuffer||d(s,e);const r=M(t,e);let i,n,o;const c=[],b=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let t=0;t<r.length;t++){const e=r[t];const s=new b(32*l(e));i=new Float32Array(s),n=new Uint32Array(s),o=new Uint16Array(s),u(0,e),c.push(s)}return void(t._roots=c);function l(t){return t.count?1:1+l(t.left)+l(t.right)}function u(t,e){const s=t/4,r=t/2,c=!!e.count,b=e.boundingData;for(let t=0;t<6;t++)i[s+t]=b[t];if(c){const i=e.offset,c=e.count;return n[s+6]=i,o[r+14]=c,o[r+15]=a,t+32}{const r=e.left,i=e.right,o=e.splitAxis;let a;if(a=u(t+32,r),a/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return n[s+6]=a/4,a=u(a,i),n[s+7]=o,a}}}class O{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,r=-1/0;for(let i=0,n=t.length;i<n;i++){const n=t[i][e];s=n<s?n:s,r=n>r?n:r}this.min=s,this.max=r}setFromPoints(t,e){let s=1/0,r=-1/0;for(let i=0,n=e.length;i<n;i++){const n=e[i],o=t.dot(n);s=o<s?o:s,r=o>r?o:r}this.min=s,this.max=r}isSeparated(t){return this.min>t.max||t.min>this.max}}O.prototype.setFromBox=function(){const t=new s.Vector3;return function(e,s){const r=s.min,i=s.max;let n=1/0,o=-1/0;for(let s=0;s<=1;s++)for(let a=0;a<=1;a++)for(let c=0;c<=1;c++){t.x=r.x*s+i.x*(1-s),t.y=r.y*a+i.y*(1-a),t.z=r.z*c+i.z*(1-c);const b=e.dot(t);n=Math.min(b,n),o=Math.max(b,o)}this.min=n,this.max=o}}();const P=function(){const t=new s.Vector3,e=new s.Vector3,r=new s.Vector3;return function(s,i,n){const o=s.start,a=t,c=i.start,b=e;r.subVectors(o,c),t.subVectors(s.end,s.start),e.subVectors(i.end,i.start);const h=r.dot(b),d=b.dot(a),l=b.dot(b),f=r.dot(a),u=a.dot(a)*l-d*d;let _,p;_=0!==u?(h*d-f*l)/u:0,p=(h+_*d)/l,n.x=_,n.y=p}}(),T=function(){const t=new s.Vector2,e=new s.Vector3,r=new s.Vector3;return function(s,i,n,o){P(s,i,t);let a=t.x,c=t.y;if(a>=0&&a<=1&&c>=0&&c<=1)return s.at(a,n),void i.at(c,o);if(a>=0&&a<=1)return c<0?i.at(0,o):i.at(1,o),void s.closestPointToPoint(o,!0,n);if(c>=0&&c<=1)return a<0?s.at(0,n):s.at(1,n),void i.closestPointToPoint(n,!0,o);{let t,b;t=a<0?s.start:s.end,b=c<0?i.start:i.end;const h=e,d=r;return s.closestPointToPoint(b,!0,e),i.closestPointToPoint(t,!0,r),h.distanceToSquared(b)<=d.distanceToSquared(t)?(n.copy(h),void o.copy(b)):(n.copy(t),void o.copy(d))}}}(),S=function(){const t=new s.Vector3,e=new s.Vector3,r=new s.Plane,i=new s.Line3;return function(s,n){const{radius:o,center:a}=s,{a:c,b:b,c:h}=n;i.start=c,i.end=b;if(i.closestPointToPoint(a,!0,t).distanceTo(a)<=o)return!0;i.start=c,i.end=h;if(i.closestPointToPoint(a,!0,t).distanceTo(a)<=o)return!0;i.start=b,i.end=h;if(i.closestPointToPoint(a,!0,t).distanceTo(a)<=o)return!0;const d=n.getPlane(r);if(Math.abs(d.distanceToPoint(a))<=o){const t=d.projectPoint(a,e);if(n.containsPoint(t))return!0}return!1}}();function U(t){return Math.abs(t)<1e-15}class D extends s.Triangle{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new s.Vector3)),this.satBounds=new Array(4).fill().map((()=>new O)),this.points=[this.a,this.b,this.c],this.sphere=new s.Sphere,this.plane=new s.Plane,this.needsUpdate=!0}intersectsSphere(t){return S(t,this)}update(){const t=this.a,e=this.b,s=this.c,r=this.points,i=this.satAxes,n=this.satBounds,o=i[0],a=n[0];this.getNormal(o),a.setFromPoints(o,r);const c=i[1],b=n[1];c.subVectors(t,e),b.setFromPoints(c,r);const h=i[2],d=n[2];h.subVectors(e,s),d.setFromPoints(h,r);const l=i[3],f=n[3];l.subVectors(s,t),f.setFromPoints(l,r),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(o,t),this.needsUpdate=!1}}D.prototype.closestPointToSegment=function(){const t=new s.Vector3,e=new s.Vector3,r=new s.Line3;return function(s,i=null,n=null){const{start:o,end:a}=s,c=this.points;let b,h=1/0;for(let o=0;o<3;o++){const a=(o+1)%3;r.start.copy(c[o]),r.end.copy(c[a]),T(r,s,t,e),b=t.distanceToSquared(e),b<h&&(h=b,i&&i.copy(t),n&&n.copy(e))}return this.closestPointToPoint(o,t),b=o.distanceToSquared(t),b<h&&(h=b,i&&i.copy(t),n&&n.copy(o)),this.closestPointToPoint(a,t),b=a.distanceToSquared(t),b<h&&(h=b,i&&i.copy(t),n&&n.copy(a)),Math.sqrt(h)}}(),D.prototype.intersectsTriangle=function(){const t=new D,e=new Array(3),r=new Array(3),i=new O,n=new O,o=new s.Vector3,a=new s.Vector3,c=new s.Vector3,b=new s.Vector3,h=new s.Vector3,d=new s.Line3,l=new s.Line3,f=new s.Line3,u=new s.Vector3;function _(t,e,s){const r=t.points;let i=0,n=-1;for(let t=0;t<3;t++){const{start:o,end:c}=d;o.copy(r[t]),c.copy(r[(t+1)%3]),d.delta(a);const b=U(e.distanceToPoint(o));if(U(e.normal.dot(a))&&b){s.copy(d),i=2;break}const h=e.intersectLine(d,u);if(!h&&b&&u.copy(o),(h||b)&&!U(u.distanceTo(c))){if(i<=1){(1===i?s.start:s.end).copy(u),b&&(n=i)}else if(i>=2){(1===n?s.start:s.end).copy(u),i=2;break}if(i++,2===i&&-1===n)break}}return i}return function(s,a=null,d=!1){this.needsUpdate&&this.update(),s.isExtendedTriangle?s.needsUpdate&&s.update():(t.copy(s),t.update(),s=t);const u=this.plane,p=s.plane;if(Math.abs(u.normal.dot(p.normal))>1-1e-10){const t=this.satBounds,c=this.satAxes;r[0]=s.a,r[1]=s.b,r[2]=s.c;for(let e=0;e<4;e++){const s=t[e],n=c[e];if(i.setFromPoints(n,r),s.isSeparated(i))return!1}const b=s.satBounds,h=s.satAxes;e[0]=this.a,e[1]=this.b,e[2]=this.c;for(let t=0;t<4;t++){const s=b[t],r=h[t];if(i.setFromPoints(r,e),s.isSeparated(i))return!1}for(let t=0;t<4;t++){const s=c[t];for(let t=0;t<4;t++){const a=h[t];if(o.crossVectors(s,a),i.setFromPoints(o,e),n.setFromPoints(o,r),i.isSeparated(n))return!1}}return a&&(d||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),a.start.set(0,0,0),a.end.set(0,0,0)),!0}{const t=_(this,p,l);if(1===t&&s.containsPoint(l.end))return a&&(a.start.copy(l.end),a.end.copy(l.end)),!0;if(2!==t)return!1;const e=_(s,u,f);if(1===e&&this.containsPoint(f.end))return a&&(a.start.copy(f.end),a.end.copy(f.end)),!0;if(2!==e)return!1;if(l.delta(c),f.delta(b),c.dot(b)<0){let t=f.start;f.start=f.end,f.end=t}const r=l.start.dot(c),i=l.end.dot(c),n=f.start.dot(c),o=f.end.dot(c);return(r===o||n===i||i<n!==r<o)&&(a&&(h.subVectors(l.start,f.start),h.dot(c)>0?a.start.copy(l.start):a.start.copy(f.start),h.subVectors(l.end,f.end),h.dot(c)<0?a.end.copy(l.end):a.end.copy(f.end)),!0)}}}(),D.prototype.distanceToPoint=function(){const t=new s.Vector3;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),D.prototype.distanceToTriangle=function(){const t=new s.Vector3,e=new s.Vector3,r=["a","b","c"],i=new s.Line3,n=new s.Line3;return function(s,o=null,a=null){const c=o||a?i:null;if(this.intersectsTriangle(s,c))return(o||a)&&(o&&c.getCenter(o),a&&c.getCenter(a)),0;let b=1/0;for(let e=0;e<3;e++){let i;const n=r[e],c=s[n];this.closestPointToPoint(c,t),i=c.distanceToSquared(t),i<b&&(b=i,o&&o.copy(t),a&&a.copy(c));const h=this[n];s.closestPointToPoint(h,t),i=h.distanceToSquared(t),i<b&&(b=i,o&&o.copy(h),a&&a.copy(t))}for(let c=0;c<3;c++){const h=r[c],d=r[(c+1)%3];i.set(this[h],this[d]);for(let c=0;c<3;c++){const h=r[c],d=r[(c+1)%3];n.set(s[h],s[d]),T(i,n,t,e);const l=t.distanceToSquared(e);l<b&&(b=l,o&&o.copy(t),a&&a.copy(e))}}return Math.sqrt(b)}}();class G{constructor(t,e,r){this.isOrientedBox=!0,this.min=new s.Vector3,this.max=new s.Vector3,this.matrix=new s.Matrix4,this.invMatrix=new s.Matrix4,this.points=new Array(8).fill().map((()=>new s.Vector3)),this.satAxes=new Array(3).fill().map((()=>new s.Vector3)),this.satBounds=new Array(3).fill().map((()=>new O)),this.alignedSatBounds=new Array(3).fill().map((()=>new O)),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),r&&this.matrix.copy(r)}set(t,e,s){this.min.copy(t),this.max.copy(e),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}G.prototype.update=function(){return function(){const t=this.matrix,e=this.min,s=this.max,r=this.points;for(let i=0;i<=1;i++)for(let n=0;n<=1;n++)for(let o=0;o<=1;o++){const a=r[1*i|2*n|4*o];a.x=i?s.x:e.x,a.y=n?s.y:e.y,a.z=o?s.z:e.z,a.applyMatrix4(t)}const i=this.satBounds,n=this.satAxes,o=r[0];for(let t=0;t<3;t++){const e=n[t],s=i[t],a=r[1<<t];e.subVectors(o,a),s.setFromPoints(e,r)}const a=this.alignedSatBounds;a[0].setFromPointsField(r,"x"),a[1].setFromPointsField(r,"y"),a[2].setFromPointsField(r,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}(),G.prototype.intersectsBox=function(){const t=new O;return function(e){this.needsUpdate&&this.update();const s=e.min,r=e.max,i=this.satBounds,n=this.satAxes,o=this.alignedSatBounds;if(t.min=s.x,t.max=r.x,o[0].isSeparated(t))return!1;if(t.min=s.y,t.max=r.y,o[1].isSeparated(t))return!1;if(t.min=s.z,t.max=r.z,o[2].isSeparated(t))return!1;for(let s=0;s<3;s++){const r=n[s],o=i[s];if(t.setFromBox(r,e),o.isSeparated(t))return!1}return!0}}(),G.prototype.intersectsTriangle=function(){const t=new D,e=new Array(3),r=new O,i=new O,n=new s.Vector3;return function(s){this.needsUpdate&&this.update(),s.isExtendedTriangle?s.needsUpdate&&s.update():(t.copy(s),t.update(),s=t);const o=this.satBounds,a=this.satAxes;e[0]=s.a,e[1]=s.b,e[2]=s.c;for(let t=0;t<3;t++){const s=o[t],i=a[t];if(r.setFromPoints(i,e),s.isSeparated(r))return!1}const c=s.satBounds,b=s.satAxes,h=this.points;for(let t=0;t<3;t++){const e=c[t],s=b[t];if(r.setFromPoints(s,h),e.isSeparated(r))return!1}for(let t=0;t<3;t++){const s=a[t];for(let t=0;t<4;t++){const o=b[t];if(n.crossVectors(s,o),r.setFromPoints(n,e),i.setFromPoints(n,h),r.isSeparated(i))return!1}}return!0}}(),G.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}(),G.prototype.distanceToPoint=function(){const t=new s.Vector3;return function(e){return this.closestPointToPoint(e,t),e.distanceTo(t)}}(),G.prototype.distanceToBox=function(){const t=["x","y","z"],e=new Array(12).fill().map((()=>new s.Line3)),r=new Array(12).fill().map((()=>new s.Line3)),i=new s.Vector3,n=new s.Vector3;return function(s,o=0,a=null,c=null){if(this.needsUpdate&&this.update(),this.intersectsBox(s))return(a||c)&&(s.getCenter(n),this.closestPointToPoint(n,i),s.closestPointToPoint(i,n),a&&a.copy(i),c&&c.copy(n)),0;const b=o*o,h=s.min,d=s.max,l=this.points;let f=1/0;for(let t=0;t<8;t++){const e=l[t];n.copy(e).clamp(h,d);const s=e.distanceToSquared(n);if(s<f&&(f=s,a&&a.copy(e),c&&c.copy(n),s<b))return Math.sqrt(s)}let u=0;for(let s=0;s<3;s++)for(let i=0;i<=1;i++)for(let n=0;n<=1;n++){const o=(s+1)%3,a=(s+2)%3,c=1<<s|i<<o|n<<a,b=l[i<<o|n<<a],f=l[c];e[u].set(b,f);const _=t[s],p=t[o],m=t[a],g=r[u],y=g.start,w=g.end;y[_]=h[_],y[p]=i?h[p]:d[p],y[m]=n?h[m]:d[p],w[_]=d[_],w[p]=i?h[p]:d[p],w[m]=n?h[m]:d[p],u++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let s=0;s<=1;s++){n.x=t?d.x:h.x,n.y=e?d.y:h.y,n.z=s?d.z:h.z,this.closestPointToPoint(n,i);const r=n.distanceToSquared(i);if(r<f&&(f=r,a&&a.copy(i),c&&c.copy(n),r<b))return Math.sqrt(r)}for(let t=0;t<12;t++){const s=e[t];for(let t=0;t<12;t++){const e=r[t];T(s,e,i,n);const o=i.distanceToSquared(n);if(o<f&&(f=o,a&&a.copy(i),c&&c.copy(n),o<b))return Math.sqrt(o)}}return Math.sqrt(f)}}();class L{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class z extends L{constructor(){super((()=>new D))}}const E=new z;function N(t,e){return 65535===e[t+15]}function R(t,e){return e[t+6]}function j(t,e){return e[t+14]}function K(t){return t+8}function q(t,e){return e[t+6]}function k(t,e){return e[t+7]}const H=new class{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=s=>{e&&t.push(e),e=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,0!==t.length&&this.setBuffer(t.pop())}}};let X,$;const Y=[],Z=new L((()=>new s.Box3));function J(t,e,s,r,i,n){X=Z.getPrimitive(),$=Z.getPrimitive(),Y.push(X,$),H.setBuffer(t._roots[e]);const o=W(0,t.geometry,s,r,i,n);H.clearBuffer(),Z.releasePrimitive(X),Z.releasePrimitive($),Y.pop(),Y.pop();const a=Y.length;return a>0&&($=Y[a-1],X=Y[a-2]),o}function W(t,e,s,r,i=null,n=0,o=0){const{float32Array:a,uint16Array:c,uint32Array:b}=H;let h=2*t;if(N(h,c)){const e=R(t,b),s=j(h,c);return u(t,a,X),r(e,s,!1,o,n+t,X)}{let h=function(t){const{uint16Array:e,uint32Array:s}=H;let r=2*t;for(;!N(r,e);)r=2*(t=K(t));return R(t,s)},d=function(t){const{uint16Array:e,uint32Array:s}=H;let r=2*t;for(;!N(r,e);)r=2*(t=q(t,s));return R(t,s)+j(r,e)};const l=K(t),f=q(t,b);let _,p,m,g,y=l,w=f;if(i&&(m=X,g=$,u(y,a,m),u(w,a,g),_=i(m),p=i(g),p<_)){y=f,w=l;const t=_;_=p,p=t,m=g}m||(m=X,u(y,a,m));const x=s(m,N(2*y,c),_,o+1,n+y);let v;if(2===x){const t=h(y);v=r(t,d(y)-t,!0,o+1,n+y,m)}else v=x&&W(y,e,s,r,i,n,o+1);if(v)return!0;g=$,u(w,a,g);const I=s(g,N(2*w,c),p,o+1,n+w);let A;if(2===I){const t=h(w);A=r(t,d(w)-t,!0,o+1,n+w,g)}else A=I&&W(w,e,s,r,i,n,o+1);return!!A}}const Q=new s.Vector3,tt=new s.Vector3;const et=new s.Vector3,st=new s.Vector3,rt=new s.Vector3,it=new s.Vector2,nt=new s.Vector2,ot=new s.Vector2,at=new s.Vector3,ct=new s.Vector3,bt=new s.Vector3,ht=new s.Vector3;function dt(t,e,r,i,n,o,a,c,b){et.fromBufferAttribute(e,o),st.fromBufferAttribute(e,a),rt.fromBufferAttribute(e,c);const h=function(t,e,r,i,n,o){let a;return a=o===s.BackSide?t.intersectTriangle(i,r,e,!0,n):t.intersectTriangle(e,r,i,o!==s.DoubleSide,n),null===a?null:{distance:t.origin.distanceTo(n),point:n.clone()}}(t,et,st,rt,ht,b);if(h){i&&(it.fromBufferAttribute(i,o),nt.fromBufferAttribute(i,a),ot.fromBufferAttribute(i,c),h.uv=s.Triangle.getInterpolation(ht,et,st,rt,it,nt,ot,new s.Vector2)),n&&(it.fromBufferAttribute(n,o),nt.fromBufferAttribute(n,a),ot.fromBufferAttribute(n,c),h.uv1=s.Triangle.getInterpolation(ht,et,st,rt,it,nt,ot,new s.Vector2)),r&&(at.fromBufferAttribute(r,o),ct.fromBufferAttribute(r,a),bt.fromBufferAttribute(r,c),h.normal=s.Triangle.getInterpolation(ht,et,st,rt,at,ct,bt,new s.Vector3),h.normal.dot(t.direction)>0&&h.normal.multiplyScalar(-1));const e={a:o,b:a,c:c,normal:new s.Vector3,materialIndex:0};s.Triangle.getNormal(et,st,rt,e.normal),h.face=e,h.faceIndex=o}return h}function lt(t,e,s,r,i){const n=3*r;let o=n+0,a=n+1,c=n+2;const b=t.index;t.index&&(o=b.getX(o),a=b.getX(a),c=b.getX(c));const{position:h,normal:d,uv:l,uv1:f}=t.attributes,u=dt(s,h,d,l,f,o,a,c,e);return u?(u.faceIndex=r,i&&i.push(u),u):null}function ft(t,e,s,r){const i=t.a,n=t.b,o=t.c;let a=e,c=e+1,b=e+2;s&&(a=s.getX(a),c=s.getX(c),b=s.getX(b)),i.x=r.getX(a),i.y=r.getY(a),i.z=r.getZ(a),n.x=r.getX(c),n.y=r.getY(c),n.z=r.getZ(c),o.x=r.getX(b),o.y=r.getY(b),o.z=r.getZ(b)}function ut(t,e,s,r,i,n,o){const{geometry:a}=s,{index:c}=a,b=a.attributes.position;for(let s=t,a=e+t;s<a;s++){let t;if(t=s,ft(o,3*t,c,b),o.needsUpdate=!0,r(o,t,i,n))return!0}return!1}function _t(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const s=t.geometry,r=s.index?s.index.array:null,i=s.attributes.position;let n,o,c,b,h=0;const d=t._roots;for(let t=0,e=d.length;t<e;t++)n=d[t],o=new Uint32Array(n),c=new Uint16Array(n),b=new Float32Array(n),l(0,h),h+=n.byteLength;function l(t,s,n=!1){const h=2*t;if(c[h+15]===a){const e=o[t+6];let s=1/0,n=1/0,a=1/0,d=-1/0,l=-1/0,f=-1/0;for(let t=3*e,o=3*(e+c[h+14]);t<o;t++){let e=r[t];const o=i.getX(e),c=i.getY(e),b=i.getZ(e);o<s&&(s=o),o>d&&(d=o),c<n&&(n=c),c>l&&(l=c),b<a&&(a=b),b>f&&(f=b)}return(b[t+0]!==s||b[t+1]!==n||b[t+2]!==a||b[t+3]!==d||b[t+4]!==l||b[t+5]!==f)&&(b[t+0]=s,b[t+1]=n,b[t+2]=a,b[t+3]=d,b[t+4]=l,b[t+5]=f,!0)}{const r=t+8,i=o[t+6],a=r+s,c=i+s;let h=n,d=!1,f=!1;e?h||(d=e.has(a),f=e.has(c),h=!d&&!f):(d=!0,f=!0);const u=h||f;let _=!1;(h||d)&&(_=l(r,s,h));let p=!1;u&&(p=l(i,s,h));const m=_||p;if(m)for(let e=0;e<3;e++){const s=r+e,n=i+e,o=b[s],a=b[s+3],c=b[n],h=b[n+3];b[t+e]=o<c?o:c,b[t+e+3]=a>h?a:h}return m}}}const pt=new s.Box3;function mt(t,e,s,r){return u(t,e,pt),s.intersectBox(pt,r)}function gt(t,e,s,r,i,n,o){const{geometry:a}=s,{index:c}=a,b=a.attributes.position;for(let a=t,h=e+t;a<h;a++){let t;if(t=s.resolveTriangleIndex(a),ft(o,3*t,c,b),o.needsUpdate=!0,r(o,t,i,n))return!0}return!1}const yt=new s.Vector3;function wt(t,e,s,r,i){H.setBuffer(t._roots[e]),xt(0,t,s,r,i),H.clearBuffer()}function xt(t,e,s,r,i){const{float32Array:n,uint16Array:o,uint32Array:a}=H,c=2*t;if(N(c,o)){!function(t,e,s,r,i,n){const{geometry:o,_indirectBuffer:a}=t;for(let t=r,a=r+i;t<a;t++)lt(o,e,s,t,n)}(e,s,r,R(t,a),j(c,o),i)}else{const o=K(t);mt(o,n,r,yt)&&xt(o,e,s,r,i);const c=q(t,a);mt(c,n,r,yt)&&xt(c,e,s,r,i)}}const vt=new s.Vector3,It=["x","y","z"];function At(t,e,s,r){H.setBuffer(t._roots[e]);const i=Vt(0,t,s,r);return H.clearBuffer(),i}function Vt(t,e,s,r){const{float32Array:i,uint16Array:n,uint32Array:o}=H;let a=2*t;if(N(a,n)){return function(t,e,s,r,i){const{geometry:n,_indirectBuffer:o}=t;let a=1/0,c=null;for(let t=r,o=r+i;t<o;t++){let r;r=lt(n,e,s,t),r&&r.distance<a&&(c=r,a=r.distance)}return c}(e,s,r,R(t,o),j(a,n))}{const n=k(t,o),a=It[n],c=r.direction[a]>=0;let b,h;c?(b=K(t),h=q(t,o)):(b=q(t,o),h=K(t));const d=mt(b,i,r,vt)?Vt(b,e,s,r):null;if(d){const t=d.point[a];if(c?t<=i[h+n]:t>=i[h+n+3])return d}const l=mt(h,i,r,vt)?Vt(h,e,s,r):null;return d&&l?d.distance<=l.distance?d:l:d||l||null}}const Ft=new s.Box3,Bt=new D,Mt=new D,Ct=new s.Matrix4,Ot=new G,Pt=new G;function Tt(t,e,s,r){H.setBuffer(t._roots[e]);const i=St(0,t,s,r);return H.clearBuffer(),i}function St(t,e,s,r,i=null){const{float32Array:n,uint16Array:o,uint32Array:a}=H;let c=2*t;null===i&&(s.boundingBox||s.computeBoundingBox(),Ot.set(s.boundingBox.min,s.boundingBox.max,r),i=Ot);if(!N(c,o)){const o=t+8,c=a[t+6];u(o,n,Ft);if(i.intersectsBox(Ft)&&St(o,e,s,r,i))return!0;u(c,n,Ft);return!!(i.intersectsBox(Ft)&&St(c,e,s,r,i))}{const i=e.geometry,b=i.index,h=i.attributes.position,d=s.index,l=s.attributes.position,f=R(t,a),_=j(c,o);if(Ct.copy(r).invert(),s.boundsTree){u(t,n,Pt),Pt.matrix.copy(Ct),Pt.needsUpdate=!0;return s.boundsTree.shapecast({intersectsBounds:t=>Pt.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let e=3*f,s=3*(_+f);e<s;e+=3)if(ft(Mt,e,b,h),Mt.needsUpdate=!0,t.intersectsTriangle(Mt))return!0;return!1}})}for(let t=3*f,e=3*(_+f);t<e;t+=3){ft(Bt,t,b,h),Bt.a.applyMatrix4(Ct),Bt.b.applyMatrix4(Ct),Bt.c.applyMatrix4(Ct),Bt.needsUpdate=!0;for(let t=0,e=d.count;t<e;t+=3)if(ft(Mt,t,d,l),Mt.needsUpdate=!0,Bt.intersectsTriangle(Mt))return!0}}}const Ut=new s.Matrix4,Dt=new G,Gt=new G,Lt=new s.Vector3,zt=new s.Vector3,Et=new s.Vector3,Nt=new s.Vector3;function Rt(t,e,s,r={},i={},n=0,o=1/0){e.boundingBox||e.computeBoundingBox(),Dt.set(e.boundingBox.min,e.boundingBox.max,s),Dt.needsUpdate=!0;const a=t.geometry,c=a.attributes.position,b=a.index,d=e.attributes.position,l=e.index,f=E.getPrimitive(),u=E.getPrimitive();let _=Lt,p=zt,m=null,g=null;i&&(m=Et,g=Nt);let y=1/0,w=null,x=null;return Ut.copy(s).invert(),Gt.matrix.copy(Ut),t.shapecast({boundsTraverseOrder:t=>Dt.distanceToBox(t),intersectsBounds:(t,e,s)=>s<y&&s<o&&(e&&(Gt.min.copy(t.min),Gt.max.copy(t.max),Gt.needsUpdate=!0),!0),intersectsRange:(t,r)=>{if(e.boundsTree){return e.boundsTree.shapecast({boundsTraverseOrder:t=>Gt.distanceToBox(t),intersectsBounds:(t,e,s)=>s<y&&s<o,intersectsRange:(e,i)=>{for(let o=e,a=e+i;o<a;o++){ft(u,3*o,l,d),u.a.applyMatrix4(s),u.b.applyMatrix4(s),u.c.applyMatrix4(s),u.needsUpdate=!0;for(let e=t,s=t+r;e<s;e++){ft(f,3*e,b,c),f.needsUpdate=!0;const t=f.distanceToTriangle(u,_,m);if(t<y&&(p.copy(_),g&&g.copy(m),y=t,w=e,x=o),t<n)return!0}}}})}for(let i=0,o=h(e);i<o;i++){ft(u,3*i,l,d),u.a.applyMatrix4(s),u.b.applyMatrix4(s),u.c.applyMatrix4(s),u.needsUpdate=!0;for(let e=t,s=t+r;e<s;e++){ft(f,3*e,b,c),f.needsUpdate=!0;const t=f.distanceToTriangle(u,_,m);if(t<y&&(p.copy(_),g&&g.copy(m),y=t,w=e,x=i),t<n)return!0}}}}),E.releasePrimitive(f),E.releasePrimitive(u),y===1/0?null:(r.point?r.point.copy(p):r.point=p.clone(),r.distance=y,r.faceIndex=w,i&&(i.point?i.point.copy(g):i.point=g.clone(),i.point.applyMatrix4(Ut),p.applyMatrix4(Ut),i.distance=p.sub(i.point).length(),i.faceIndex=x),r)}function jt(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const s=t.geometry,r=s.index?s.index.array:null,i=s.attributes.position;let n,o,c,b,h=0;const d=t._roots;for(let t=0,e=d.length;t<e;t++)n=d[t],o=new Uint32Array(n),c=new Uint16Array(n),b=new Float32Array(n),l(0,h),h+=n.byteLength;function l(s,n,h=!1){const d=2*s;if(c[d+15]===a){const e=o[s+6];let n=1/0,a=1/0,h=1/0,l=-1/0,f=-1/0,u=-1/0;for(let s=e,o=e+c[d+14];s<o;s++){const e=3*t.resolveTriangleIndex(s);for(let t=0;t<3;t++){let s=e+t;s=r?r[s]:s;const o=i.getX(s),c=i.getY(s),b=i.getZ(s);o<n&&(n=o),o>l&&(l=o),c<a&&(a=c),c>f&&(f=c),b<h&&(h=b),b>u&&(u=b)}}return(b[s+0]!==n||b[s+1]!==a||b[s+2]!==h||b[s+3]!==l||b[s+4]!==f||b[s+5]!==u)&&(b[s+0]=n,b[s+1]=a,b[s+2]=h,b[s+3]=l,b[s+4]=f,b[s+5]=u,!0)}{const t=s+8,r=o[s+6],i=t+n,a=r+n;let c=h,d=!1,f=!1;e?c||(d=e.has(i),f=e.has(a),c=!d&&!f):(d=!0,f=!0);const u=c||f;let _=!1;(c||d)&&(_=l(t,n,c));let p=!1;u&&(p=l(r,n,c));const m=_||p;if(m)for(let e=0;e<3;e++){const i=t+e,n=r+e,o=b[i],a=b[i+3],c=b[n],h=b[n+3];b[s+e]=o<c?o:c,b[s+e+3]=a>h?a:h}return m}}}const Kt=new s.Vector3;function qt(t,e,s,r,i){H.setBuffer(t._roots[e]),kt(0,t,s,r,i),H.clearBuffer()}function kt(t,e,s,r,i){const{float32Array:n,uint16Array:o,uint32Array:a}=H,c=2*t;if(N(c,o)){!function(t,e,s,r,i,n){const{geometry:o,_indirectBuffer:a}=t;for(let t=r,c=r+i;t<c;t++)lt(o,e,s,a?a[t]:t,n)}(e,s,r,R(t,a),j(c,o),i)}else{const o=K(t);mt(o,n,r,Kt)&&kt(o,e,s,r,i);const c=q(t,a);mt(c,n,r,Kt)&&kt(c,e,s,r,i)}}const Ht=new s.Vector3,Xt=["x","y","z"];function $t(t,e,s,r){H.setBuffer(t._roots[e]);const i=Yt(0,t,s,r);return H.clearBuffer(),i}function Yt(t,e,s,r){const{float32Array:i,uint16Array:n,uint32Array:o}=H;let a=2*t;if(N(a,n)){return function(t,e,s,r,i){const{geometry:n,_indirectBuffer:o}=t;let a=1/0,c=null;for(let t=r,b=r+i;t<b;t++){let r;r=lt(n,e,s,o?o[t]:t),r&&r.distance<a&&(c=r,a=r.distance)}return c}(e,s,r,R(t,o),j(a,n))}{const n=k(t,o),a=Xt[n],c=r.direction[a]>=0;let b,h;c?(b=K(t),h=q(t,o)):(b=q(t,o),h=K(t));const d=mt(b,i,r,Ht)?Yt(b,e,s,r):null;if(d){const t=d.point[a];if(c?t<=i[h+n]:t>=i[h+n+3])return d}const l=mt(h,i,r,Ht)?Yt(h,e,s,r):null;return d&&l?d.distance<=l.distance?d:l:d||l||null}}const Zt=new s.Box3,Jt=new D,Wt=new D,Qt=new s.Matrix4,te=new G,ee=new G;function se(t,e,s,r){H.setBuffer(t._roots[e]);const i=re(0,t,s,r);return H.clearBuffer(),i}function re(t,e,s,r,i=null){const{float32Array:n,uint16Array:o,uint32Array:a}=H;let c=2*t;null===i&&(s.boundingBox||s.computeBoundingBox(),te.set(s.boundingBox.min,s.boundingBox.max,r),i=te);if(!N(c,o)){const o=t+8,c=a[t+6];u(o,n,Zt);if(i.intersectsBox(Zt)&&re(o,e,s,r,i))return!0;u(c,n,Zt);return!!(i.intersectsBox(Zt)&&re(c,e,s,r,i))}{const i=e.geometry,b=i.index,h=i.attributes.position,d=s.index,l=s.attributes.position,f=R(t,a),_=j(c,o);if(Qt.copy(r).invert(),s.boundsTree){u(t,n,ee),ee.matrix.copy(Qt),ee.needsUpdate=!0;return s.boundsTree.shapecast({intersectsBounds:t=>ee.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let s=f,r=_+f;s<r;s++)if(ft(Wt,3*e.resolveTriangleIndex(s),b,h),Wt.needsUpdate=!0,t.intersectsTriangle(Wt))return!0;return!1}})}for(let t=f,s=_+f;t<s;t++){const s=e.resolveTriangleIndex(t);ft(Jt,3*s,b,h),Jt.a.applyMatrix4(Qt),Jt.b.applyMatrix4(Qt),Jt.c.applyMatrix4(Qt),Jt.needsUpdate=!0;for(let t=0,e=d.count;t<e;t+=3)if(ft(Wt,t,d,l),Wt.needsUpdate=!0,Jt.intersectsTriangle(Wt))return!0}}}const ie=new s.Matrix4,ne=new G,oe=new G,ae=new s.Vector3,ce=new s.Vector3,be=new s.Vector3,he=new s.Vector3;function de(t,e,s,r={},i={},n=0,o=1/0){e.boundingBox||e.computeBoundingBox(),ne.set(e.boundingBox.min,e.boundingBox.max,s),ne.needsUpdate=!0;const a=t.geometry,c=a.attributes.position,b=a.index,d=e.attributes.position,l=e.index,f=E.getPrimitive(),u=E.getPrimitive();let _=ae,p=ce,m=null,g=null;i&&(m=be,g=he);let y=1/0,w=null,x=null;return ie.copy(s).invert(),oe.matrix.copy(ie),t.shapecast({boundsTraverseOrder:t=>ne.distanceToBox(t),intersectsBounds:(t,e,s)=>s<y&&s<o&&(e&&(oe.min.copy(t.min),oe.max.copy(t.max),oe.needsUpdate=!0),!0),intersectsRange:(r,i)=>{if(e.boundsTree){const a=e.boundsTree;return a.shapecast({boundsTraverseOrder:t=>oe.distanceToBox(t),intersectsBounds:(t,e,s)=>s<y&&s<o,intersectsRange:(e,o)=>{for(let h=e,v=e+o;h<v;h++){const e=a.resolveTriangleIndex(h);ft(u,3*e,l,d),u.a.applyMatrix4(s),u.b.applyMatrix4(s),u.c.applyMatrix4(s),u.needsUpdate=!0;for(let e=r,s=r+i;e<s;e++){const s=t.resolveTriangleIndex(e);ft(f,3*s,b,c),f.needsUpdate=!0;const r=f.distanceToTriangle(u,_,m);if(r<y&&(p.copy(_),g&&g.copy(m),y=r,w=e,x=h),r<n)return!0}}}})}for(let o=0,a=h(e);o<a;o++){ft(u,3*o,l,d),u.a.applyMatrix4(s),u.b.applyMatrix4(s),u.c.applyMatrix4(s),u.needsUpdate=!0;for(let e=r,s=r+i;e<s;e++){const s=t.resolveTriangleIndex(e);ft(f,3*s,b,c),f.needsUpdate=!0;const r=f.distanceToTriangle(u,_,m);if(r<y&&(p.copy(_),g&&g.copy(m),y=r,w=e,x=o),r<n)return!0}}}}),E.releasePrimitive(f),E.releasePrimitive(u),y===1/0?null:(r.point?r.point.copy(p):r.point=p.clone(),r.distance=y,r.faceIndex=w,i&&(i.point?i.point.copy(g):i.point=g.clone(),i.point.applyMatrix4(ie),p.applyMatrix4(ie),i.distance=p.sub(i.point).length(),i.faceIndex=x),r)}const le=new H.constructor,fe=new H.constructor,ue=new L((()=>new s.Box3)),_e=new s.Box3,pe=new s.Box3,me=new s.Box3,ge=new s.Box3;let ye=!1;function we(t,e,s,r,i,n=0,o=0,a=0,c=0,b=null,h=!1){let d,l;h?(d=fe,l=le):(d=le,l=fe);const f=d.float32Array,_=d.uint32Array,p=d.uint16Array,m=l.float32Array,g=l.uint32Array,y=l.uint16Array,w=2*e,x=N(2*t,p),v=N(w,y);let I=!1;if(v&&x)I=h?i(R(e,g),j(2*e,y),R(t,_),j(2*t,p),c,o+e,a,n+t):i(R(t,_),j(2*t,p),R(e,g),j(2*e,y),a,n+t,c,o+e);else if(v){const b=ue.getPrimitive();u(e,m,b),b.applyMatrix4(s);const d=K(t),l=q(t,_);u(d,f,_e),u(l,f,pe);const p=b.intersectsBox(_e),g=b.intersectsBox(pe);I=p&&we(e,d,r,s,i,o,n,c,a+1,b,!h)||g&&we(e,l,r,s,i,o,n,c,a+1,b,!h),ue.releasePrimitive(b)}else{const d=K(e),l=q(e,g);u(d,m,me),u(l,m,ge);const p=b.intersectsBox(me),y=b.intersectsBox(ge);if(p&&y)I=we(t,d,s,r,i,n,o,a,c+1,b,h)||we(t,l,s,r,i,n,o,a,c+1,b,h);else if(p)if(x)I=we(t,d,s,r,i,n,o,a,c+1,b,h);else{const e=ue.getPrimitive();e.copy(me).applyMatrix4(s);const b=K(t),l=q(t,_);u(b,f,_e),u(l,f,pe);const p=e.intersectsBox(_e),m=e.intersectsBox(pe);I=p&&we(d,b,r,s,i,o,n,c,a+1,e,!h)||m&&we(d,l,r,s,i,o,n,c,a+1,e,!h),ue.releasePrimitive(e)}else if(y)if(x)I=we(t,l,s,r,i,n,o,a,c+1,b,h);else{const e=ue.getPrimitive();e.copy(ge).applyMatrix4(s);const b=K(t),d=q(t,_);u(b,f,_e),u(d,f,pe);const p=e.intersectsBox(_e),m=e.intersectsBox(pe);I=p&&we(l,b,r,s,i,o,n,c,a+1,e,!h)||m&&we(l,d,r,s,i,o,n,c,a+1,e,!h),ue.releasePrimitive(e)}}return I}const xe=new G,ve=new s.Box3;class Ie{static serialize(t,e={}){e={cloneBuffers:!0,...e};const s=t.geometry,r=t._roots,i=t._indirectBuffer,n=s.getIndex();let o;return o=e.cloneBuffers?{roots:r.map((t=>t.slice())),index:n.array.slice(),indirectBuffer:i?i.slice():null}:{roots:r,index:n.array,indirectBuffer:i},o}static deserialize(t,e,r={}){r={setIndex:!0,indirect:Boolean(t.indirectBuffer),...r};const{index:i,roots:n,indirectBuffer:o}=t,a=new Ie(e,{...r,[b]:!0});if(a._roots=n,a._indirectBuffer=o||null,r.setIndex){const r=e.getIndex();if(null===r){const r=new s.BufferAttribute(t.index,1,!1);e.setIndex(r)}else r.array!==i&&(r.array.set(i),r.needsUpdate=!0)}return a}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if((e=Object.assign({strategy:0,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,[b]:!1},e)).useSharedArrayBuffer&&"undefined"==typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[b]||(C(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new s.Box3)));const{_indirectBuffer:r}=this;this.resolveTriangleIndex=e.indirect?t=>r[t]:t=>t}refit(t=null){return(this.indirect?jt:_t)(this,t)}traverse(t,e=0){const s=this._roots[e],r=new Uint32Array(s),i=new Uint16Array(s);!function e(n,o=0){const c=2*n,b=i[c+15]===a;if(b){const e=r[n+6],a=i[c+14];t(o,b,new Float32Array(s,4*n,6),e,a)}else{const i=n+8,a=r[n+6],c=r[n+7];t(o,b,new Float32Array(s,4*n,6),c)||(e(i,o+1),e(a,o+1))}}(0)}raycast(t,e=s.FrontSide){const r=this._roots,i=this.geometry,n=[],o=e.isMaterial,a=Array.isArray(e),c=i.groups,b=o?e.side:e,h=this.indirect?qt:wt;for(let s=0,i=r.length;s<i;s++){const r=a?e[c[s].materialIndex].side:b,i=n.length;if(h(this,s,r,t,n),a){const t=c[s].materialIndex;for(let e=i,s=n.length;e<s;e++)n[e].face.materialIndex=t}}return n}raycastFirst(t,e=s.FrontSide){const r=this._roots,i=this.geometry,n=e.isMaterial,o=Array.isArray(e);let a=null;const c=i.groups,b=n?e.side:e,h=this.indirect?$t:At;for(let s=0,i=r.length;s<i;s++){const r=h(this,s,o?e[c[s].materialIndex].side:b,t);null!=r&&(null==a||r.distance<a.distance)&&(a=r,o&&(r.face.materialIndex=c[s].materialIndex))}return a}intersectsGeometry(t,e){let s=!1;const r=this._roots,i=this.indirect?se:Tt;for(let n=0,o=r.length;n<o&&(s=i(this,n,t,e),!s);n++);return s}shapecast(t){const e=E.getPrimitive(),s=this.indirect?gt:ut;let{boundsTraverseOrder:r,intersectsBounds:i,intersectsRange:n,intersectsTriangle:o}=t;if(n&&o){const t=n;n=(r,i,n,a,c)=>!!t(r,i,n,a,c)||s(r,i,this,o,n,a,e)}else n||(n=o?(t,r,i,n)=>s(t,r,this,o,i,n,e):(t,e,s)=>s);let a=!1,c=0;const b=this._roots;for(let t=0,e=b.length;t<e;t++){const e=b[t];if(a=J(this,t,i,n,r,c),a)break;c+=e.byteLength}return E.releasePrimitive(e),a}bvhcast(t,e,r){let{intersectsRanges:i,intersectsTriangles:n}=r;const o=E.getPrimitive(),a=this.geometry.index,c=this.geometry.attributes.position,b=this.indirect?t=>{const e=this.resolveTriangleIndex(t);ft(o,3*e,a,c)}:t=>{ft(o,3*t,a,c)},h=E.getPrimitive(),d=t.geometry.index,l=t.geometry.attributes.position,f=t.indirect?e=>{const s=t.resolveTriangleIndex(e);ft(h,3*s,d,l)}:t=>{ft(h,3*t,d,l)};if(n){const t=(t,s,r,i,a,c,d,l)=>{for(let u=r,_=r+i;u<_;u++){f(u),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let e=t,r=t+s;e<r;e++)if(b(e),o.needsUpdate=!0,n(o,h,e,u,a,c,d,l))return!0}return!1};if(i){const e=i;i=function(s,r,i,n,o,a,c,b){return!!e(s,r,i,n,o,a,c,b)||t(s,r,i,n,o,a,c,b)}}else i=t}return function(t,e,r,i){if(ye)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");ye=!0;const n=t._roots,o=e._roots;let a,c=0,b=0;const h=(new s.Matrix4).copy(r).invert();for(let t=0,e=n.length;t<e;t++){le.setBuffer(n[t]),b=0;const e=ue.getPrimitive();u(0,le.float32Array,e),e.applyMatrix4(h);for(let s=0,n=o.length;s<n&&(fe.setBuffer(o[t]),a=we(0,0,r,h,i,c,b,0,0,e),fe.clearBuffer(),b+=o[s].length,!a);s++);if(ue.releasePrimitive(e),le.clearBuffer(),c+=n[t].length,a)break}return ye=!1,a}(this,t,e,i)}intersectsBox(t,e){return xe.set(t.min,t.max,e),xe.needsUpdate=!0,this.shapecast({intersectsBounds:t=>xe.intersectsBox(t),intersectsTriangle:t=>xe.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},r={},i=0,n=1/0){return(this.indirect?de:Rt)(this,t,e,s,r,i,n)}closestPointToPoint(t,e={},s=0,r=1/0){return function(t,e,s={},r=0,i=1/0){const n=r*r,o=i*i;let a=1/0,c=null;if(t.shapecast({boundsTraverseOrder:t=>(Q.copy(e).clamp(t.min,t.max),Q.distanceToSquared(e)),intersectsBounds:(t,e,s)=>s<a&&s<o,intersectsTriangle:(t,s)=>{t.closestPointToPoint(e,Q);const r=e.distanceToSquared(Q);return r<a&&(tt.copy(Q),a=r,c=s),r<n}}),a===1/0)return null;const b=Math.sqrt(a);return s.point?s.point.copy(tt):s.point=tt.clone(),s.distance=b,s.faceIndex=c,s}(this,t,e,s,r)}getBoundingBox(t){t.makeEmpty();return this._roots.forEach((e=>{u(0,new Float32Array(e),ve),t.union(ve)})),t}}function Ae(t,e,s){return null===t?null:(t.point.applyMatrix4(e.matrixWorld),t.distance=t.point.distanceTo(s.ray.origin),t.object=e,t.distance<s.near||t.distance>s.far?null:t)}const Ve=new s.Ray,Fe=new s.Matrix4,Be=s.Mesh.prototype.raycast;function Me(t,e){if(this.geometry.boundsTree){if(void 0===this.material)return;Fe.copy(this.matrixWorld).invert(),Ve.copy(t.ray).applyMatrix4(Fe);const s=this.geometry.boundsTree;if(!0===t.firstHitOnly){const r=Ae(s.raycastFirst(Ve,this.material),this,t);r&&e.push(r)}else{const r=s.raycast(Ve,this.material);for(let s=0,i=r.length;s<i;s++){const i=Ae(r[s],this,t);i&&e.push(i)}}}else Be.call(this,t,e)}function Ce(t){return this.boundsTree=new Ie(this,t),this.boundsTree}function Oe(){this.boundsTree=null}const Pe=class t{static apply(e){t.initialized||(s.BufferGeometry.prototype.computeBoundsTree=Ce,s.BufferGeometry.prototype.disposeBoundsTree=Oe,s.Mesh.prototype.raycast=Me,t.initialized=!0),e.boundsTree||e.computeBoundsTree()}static dispose(t){t&&t.disposeBoundsTree&&t.disposeBoundsTree()}};e(Pe,"initialized",!1);let Te=Pe,Se=class t{constructor(t,s,r){e(this,"ids",new Set),e(this,"itemToInstances",new Map),e(this,"instanceToItem",new Map),e(this,"hiddenItems",new Set),e(this,"id"),e(this,"mesh"),e(this,"capacity",0),e(this,"capacityOffset",10),e(this,"group"),e(this,"_originalColors",new Map),e(this,"_settingVisibility",!1),this.mesh=new n(t,s,r,this),this.id=this.mesh.uuid,this.capacity=r,this.mesh.count=0,this.mesh.geometry.index.count&&Te.apply(this.mesh.geometry)}get uniqueVertices(){const t=[],e=this.mesh.geometry.getAttribute("position");if(!e)return t;const s=new Set;for(let r=0;r<e.count;r++){const n=e.getX(r),o=e.getY(r),a=e.getZ(r),c=`${n},${o},${a}`;s.has(c)||(s.add(c),t.push(new i.Vector3(n,o,a)))}return t}dispose(t=!0){if(this.clear(),this.group=void 0,this._originalColors.clear(),this.mesh){if(t){for(const t of this.mesh.material)t.dispose();this.mesh.material=[],Te.dispose(this.mesh.geometry),this.mesh.geometry&&this.mesh.geometry.dispose(),this.mesh.geometry=null}this.mesh.removeFromParent(),this.mesh.userData={},this.mesh.dispose(),this.mesh.fragment=null,this.mesh=null}}get(t){const e=this.getInstancesIDs(t);if(!e)throw new Error("Item not found!");const s=[],r=[];for(const t of e){const e=new i.Matrix4;if(this.mesh.getMatrixAt(t,e),s.push(e),this.mesh.instanceColor){const e=new i.Color;this.mesh.getColorAt(t,e),r.push(e)}}return{id:t,transforms:s,colors:r.length?r:void 0}}getItemID(t){return this.instanceToItem.get(t)||null}getInstancesIDs(t){return this.itemToInstances.get(t)||null}update(){this.mesh.instanceColor&&(this.mesh.instanceColor.needsUpdate=!0),this.mesh.instanceMatrix.needsUpdate=!0}add(t){var e;let s=0;for(const e of t)s+=e.transforms.length;const r=this.mesh.count+s;if(r>this.capacity){const t=r+this.capacityOffset,s=new n(this.mesh.geometry,this.mesh.material,t,this);s.count=this.mesh.count,this.capacity=t;const o=this.mesh;null==(e=o.parent)||e.add(s),o.removeFromParent(),this.mesh=s;const a=new i.Matrix4;for(let t=0;t<o.instanceMatrix.count;t++)o.getMatrixAt(t,a),s.setMatrixAt(t,a);if(o.instanceColor){const t=new i.Color;for(let e=0;e<o.instanceColor.count;e++)o.getColorAt(e,t),s.setColorAt(e,t)}o.dispose()}for(let e=0;e<t.length;e++){const{transforms:s,colors:r,id:i}=t[e];this.itemToInstances.has(i)||this.itemToInstances.set(i,new Set);const n=this.itemToInstances.get(i);this.ids.add(i);for(let t=0;t<s.length;t++){const e=s[t],o=this.mesh.count;if(this.mesh.setMatrixAt(o,e),r){const e=r[t];this.mesh.setColorAt(o,e)}n.add(o),this.instanceToItem.set(o,i),this.mesh.count++}}this.update()}remove(t){if(0!==this.mesh.count){for(const e of t){const t=this.itemToInstances.get(e);if(void 0===t)throw new Error("Instances not found!");for(const e of t){if(0===this.mesh.count)throw new Error("Error with mesh count!");this.putLast(e),this.instanceToItem.delete(e),this.mesh.count--}this.itemToInstances.delete(e),this.ids.delete(e)}this.update()}}clear(){this.hiddenItems.clear(),this.ids.clear(),this.instanceToItem.clear(),this.itemToInstances.clear(),this.mesh.count=0}setVisibility(t,e=this.ids){if(!this._settingVisibility){if(this._settingVisibility=!0,t)for(const t of e){if(!this.ids.has(t))continue;if(!this.hiddenItems.has(t))continue;const e=this.itemToInstances.get(t);if(!e)throw new Error("Instances not found!");for(const t of new Set(e))this.mesh.count++,this.putLast(t);this.hiddenItems.delete(t)}else for(const t of e){if(!this.ids.has(t))continue;if(this.hiddenItems.has(t))continue;const e=this.itemToInstances.get(t);if(!e)throw new Error("Instances not found!");for(const t of new Set(e))this.putLast(t),this.mesh.count--;this.hiddenItems.add(t)}this.update(),this._settingVisibility=!1}}setColor(t,e=this.ids,s=!1){if(!this.mesh.instanceColor)throw new Error("This fragment doesn't have color per instance!");for(const r of e){if(!this.ids.has(r))continue;const e=this.itemToInstances.get(r);if(!e)throw new Error("Instances not found!");const n=this._originalColors.has(r);n||this._originalColors.set(r,new Map);const o=this._originalColors.get(r);for(const r of new Set(e)){if(!n){const t=new i.Color;this.mesh.getColorAt(r,t),o.set(r,t)}this.mesh.setColorAt(r,t),s&&o.set(r,t)}}this.mesh.instanceColor.needsUpdate=!0}resetColor(t=this.ids){if(!this.mesh.instanceColor)throw new Error("This fragment doesn't have color per instance!");for(const e of t){if(!this.ids.has(e))continue;const t=this.itemToInstances.get(e);if(!t)throw new Error("Instances not found!");const s=this._originalColors.get(e);if(s)for(const e of new Set(t)){const t=s.get(e);if(!t)throw new Error("Original color not found!");this.mesh.setColorAt(e,t)}}this.mesh.instanceColor.needsUpdate=!0}applyTransform(t,e){const s=new i.Matrix4;for(const r of t){const t=this.getInstancesIDs(r);if(null!==t)for(const r of t)this.mesh.getMatrixAt(r,s),s.premultiply(e),this.mesh.setMatrixAt(r,s)}this.update()}exportData(){return{...this.mesh.exportData(),ids:Array.from(this.ids),id:this.id}}clone(e=this.ids){const s=new t(this.mesh.geometry,this.mesh.material,this.capacity),r=[];for(const t of e){const e=this.getInstancesIDs(t);if(null===e)continue;const s=[],n=[];for(const t of e){const e=new i.Matrix4,r=new i.Color;this.mesh.getMatrixAt(t,e),this.mesh.getColorAt(t,r),s.push(e),n.push(r)}r.push({id:t,transforms:s,colors:n})}return s.add(r),s}putLast(t){if(0===this.mesh.count)return;const e=this.instanceToItem.get(t),s=this.mesh.count-1;if(s===t)return;const r=this.instanceToItem.get(s);if(void 0===e||void 0===r)throw new Error("Keys not found");if(e!==r){const i=this.itemToInstances.get(e),n=this.itemToInstances.get(r);if(!i||!n)throw new Error("Instances not found");if(!i.has(t)||!n.has(s))throw new Error("Malformed fragment structure");i.delete(t),n.delete(s),i.add(s),n.add(t),this.instanceToItem.set(t,r),this.instanceToItem.set(s,e)}const n=new i.Matrix4,o=new i.Matrix4;if(this.mesh.getMatrixAt(t,n),this.mesh.getMatrixAt(s,o),this.mesh.setMatrixAt(t,o),this.mesh.setMatrixAt(s,n),null!==this.mesh.instanceColor){const n=new i.Color,o=new i.Color;this.mesh.getColorAt(t,n),this.mesh.getColorAt(s,o),this.mesh.setColorAt(t,o),this.mesh.setColorAt(s,n);const a=this._originalColors.get(e);if(a){const e=a.get(t);e&&(a.delete(t),a.set(s,e))}const c=this._originalColors.get(r);if(c){const e=c.get(s);e&&(c.delete(s),c.set(t,e))}}}};const Ue=new Int32Array(2),De=new Float32Array(Ue.buffer),Ge=new Float64Array(Ue.buffer),Le=1===new Uint16Array(new Uint8Array([1,0]).buffer)[0];var ze,Ee;(Ee=ze||(ze={}))[Ee.UTF8_BYTES=1]="UTF8_BYTES",Ee[Ee.UTF16_STRING=2]="UTF16_STRING";class Ne{constructor(t){this.bytes_=t,this.position_=0,this.text_decoder_=new TextDecoder}static allocate(t){return new Ne(new Uint8Array(t))}clear(){this.position_=0}bytes(){return this.bytes_}position(){return this.position_}setPosition(t){this.position_=t}capacity(){return this.bytes_.length}readInt8(t){return this.readUint8(t)<<24>>24}readUint8(t){return this.bytes_[t]}readInt16(t){return this.readUint16(t)<<16>>16}readUint16(t){return this.bytes_[t]|this.bytes_[t+1]<<8}readInt32(t){return this.bytes_[t]|this.bytes_[t+1]<<8|this.bytes_[t+2]<<16|this.bytes_[t+3]<<24}readUint32(t){return this.readInt32(t)>>>0}readInt64(t){return BigInt.asIntN(64,BigInt(this.readUint32(t))+(BigInt(this.readUint32(t+4))<<BigInt(32)))}readUint64(t){return BigInt.asUintN(64,BigInt(this.readUint32(t))+(BigInt(this.readUint32(t+4))<<BigInt(32)))}readFloat32(t){return Ue[0]=this.readInt32(t),De[0]}readFloat64(t){return Ue[Le?0:1]=this.readInt32(t),Ue[Le?1:0]=this.readInt32(t+4),Ge[0]}writeInt8(t,e){this.bytes_[t]=e}writeUint8(t,e){this.bytes_[t]=e}writeInt16(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8}writeUint16(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8}writeInt32(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8,this.bytes_[t+2]=e>>16,this.bytes_[t+3]=e>>24}writeUint32(t,e){this.bytes_[t]=e,this.bytes_[t+1]=e>>8,this.bytes_[t+2]=e>>16,this.bytes_[t+3]=e>>24}writeInt64(t,e){this.writeInt32(t,Number(BigInt.asIntN(32,e))),this.writeInt32(t+4,Number(BigInt.asIntN(32,e>>BigInt(32))))}writeUint64(t,e){this.writeUint32(t,Number(BigInt.asUintN(32,e))),this.writeUint32(t+4,Number(BigInt.asUintN(32,e>>BigInt(32))))}writeFloat32(t,e){De[0]=e,this.writeInt32(t,Ue[0])}writeFloat64(t,e){Ge[0]=e,this.writeInt32(t,Ue[Le?0:1]),this.writeInt32(t+4,Ue[Le?1:0])}getBufferIdentifier(){if(this.bytes_.length<this.position_+4+4)throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");let t="";for(let e=0;e<4;e++)t+=String.fromCharCode(this.readInt8(this.position_+4+e));return t}__offset(t,e){const s=t-this.readInt32(t);return e<this.readInt16(s)?this.readInt16(s+e):0}__union(t,e){return t.bb_pos=e+this.readInt32(e),t.bb=this,t}__string(t,e){t+=this.readInt32(t);const s=this.readInt32(t);t+=4;const r=this.bytes_.subarray(t,t+s);return e===ze.UTF8_BYTES?r:this.text_decoder_.decode(r)}__union_with_string(t,e){return"string"==typeof t?this.__string(e):this.__union(t,e)}__indirect(t){return t+this.readInt32(t)}__vector(t){return t+this.readInt32(t)+4}__vector_len(t){return this.readInt32(t+this.readInt32(t))}__has_identifier(t){if(4!=t.length)throw new Error("FlatBuffers: file identifier must be length 4");for(let e=0;e<4;e++)if(t.charCodeAt(e)!=this.readInt8(this.position()+4+e))return!1;return!0}createScalarList(t,e){const s=[];for(let r=0;r<e;++r){const e=t(r);null!==e&&s.push(e)}return s}createObjList(t,e){const s=[];for(let r=0;r<e;++r){const e=t(r);null!==e&&s.push(e.unpack())}return s}}class Re{constructor(t){let e;this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1,this.string_maps=null,this.text_encoder=new TextEncoder,e=t||1024,this.bb=Ne.allocate(e),this.space=e}clear(){this.bb.clear(),this.space=this.bb.capacity(),this.minalign=1,this.vtable=null,this.vtable_in_use=0,this.isNested=!1,this.object_start=0,this.vtables=[],this.vector_num_elems=0,this.force_defaults=!1,this.string_maps=null}forceDefaults(t){this.force_defaults=t}dataBuffer(){return this.bb}asUint8Array(){return this.bb.bytes().subarray(this.bb.position(),this.bb.position()+this.offset())}prep(t,e){t>this.minalign&&(this.minalign=t);const s=1+~(this.bb.capacity()-this.space+e)&t-1;for(;this.space<s+t+e;){const t=this.bb.capacity();this.bb=Re.growByteBuffer(this.bb),this.space+=this.bb.capacity()-t}this.pad(s)}pad(t){for(let e=0;e<t;e++)this.bb.writeInt8(--this.space,0)}writeInt8(t){this.bb.writeInt8(this.space-=1,t)}writeInt16(t){this.bb.writeInt16(this.space-=2,t)}writeInt32(t){this.bb.writeInt32(this.space-=4,t)}writeInt64(t){this.bb.writeInt64(this.space-=8,t)}writeFloat32(t){this.bb.writeFloat32(this.space-=4,t)}writeFloat64(t){this.bb.writeFloat64(this.space-=8,t)}addInt8(t){this.prep(1,0),this.writeInt8(t)}addInt16(t){this.prep(2,0),this.writeInt16(t)}addInt32(t){this.prep(4,0),this.writeInt32(t)}addInt64(t){this.prep(8,0),this.writeInt64(t)}addFloat32(t){this.prep(4,0),this.writeFloat32(t)}addFloat64(t){this.prep(8,0),this.writeFloat64(t)}addFieldInt8(t,e,s){(this.force_defaults||e!=s)&&(this.addInt8(e),this.slot(t))}addFieldInt16(t,e,s){(this.force_defaults||e!=s)&&(this.addInt16(e),this.slot(t))}addFieldInt32(t,e,s){(this.force_defaults||e!=s)&&(this.addInt32(e),this.slot(t))}addFieldInt64(t,e,s){(this.force_defaults||e!==s)&&(this.addInt64(e),this.slot(t))}addFieldFloat32(t,e,s){(this.force_defaults||e!=s)&&(this.addFloat32(e),this.slot(t))}addFieldFloat64(t,e,s){(this.force_defaults||e!=s)&&(this.addFloat64(e),this.slot(t))}addFieldOffset(t,e,s){(this.force_defaults||e!=s)&&(this.addOffset(e),this.slot(t))}addFieldStruct(t,e,s){e!=s&&(this.nested(e),this.slot(t))}nested(t){if(t!=this.offset())throw new Error("FlatBuffers: struct must be serialized inline.")}notNested(){if(this.isNested)throw new Error("FlatBuffers: object serialization must not be nested.")}slot(t){null!==this.vtable&&(this.vtable[t]=this.offset())}offset(){return this.bb.capacity()-this.space}static growByteBuffer(t){const e=t.capacity();if(3221225472&e)throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");const s=e<<1,r=Ne.allocate(s);return r.setPosition(s-e),r.bytes().set(t.bytes(),s-e),r}addOffset(t){this.prep(4,0),this.writeInt32(this.offset()-t+4)}startObject(t){this.notNested(),null==this.vtable&&(this.vtable=[]),this.vtable_in_use=t;for(let e=0;e<t;e++)this.vtable[e]=0;this.isNested=!0,this.object_start=this.offset()}endObject(){if(null==this.vtable||!this.isNested)throw new Error("FlatBuffers: endObject called without startObject");this.addInt32(0);const t=this.offset();let e=this.vtable_in_use-1;for(;e>=0&&0==this.vtable[e];e--);const s=e+1;for(;e>=0;e--)this.addInt16(0!=this.vtable[e]?t-this.vtable[e]:0);this.addInt16(t-this.object_start);const r=2*(s+2);this.addInt16(r);let i=0;const n=this.space;t:for(e=0;e<this.vtables.length;e++){const t=this.bb.capacity()-this.vtables[e];if(r==this.bb.readInt16(t)){for(let e=2;e<r;e+=2)if(this.bb.readInt16(n+e)!=this.bb.readInt16(t+e))continue t;i=this.vtables[e];break}}return i?(this.space=this.bb.capacity()-t,this.bb.writeInt32(this.space,i-t)):(this.vtables.push(this.offset()),this.bb.writeInt32(this.bb.capacity()-t,this.offset()-t)),this.isNested=!1,t}finish(t,e,s){const r=s?4:0;if(e){const t=e;if(this.prep(this.minalign,8+r),4!=t.length)throw new Error("FlatBuffers: file identifier must be length 4");for(let e=3;e>=0;e--)this.writeInt8(t.charCodeAt(e))}this.prep(this.minalign,4+r),this.addOffset(t),r&&this.addInt32(this.bb.capacity()-this.space),this.bb.setPosition(this.space)}finishSizePrefixed(t,e){this.finish(t,e,!0)}requiredField(t,e){const s=this.bb.capacity()-t,r=s-this.bb.readInt32(s);if(!(e<this.bb.readInt16(r)&&0!=this.bb.readInt16(r+e)))throw new Error("FlatBuffers: field "+e+" must be set")}startVector(t,e,s){this.notNested(),this.vector_num_elems=e,this.prep(4,t*e),this.prep(s,t*e)}endVector(){return this.writeInt32(this.vector_num_elems),this.offset()}createSharedString(t){if(!t)return 0;if(this.string_maps||(this.string_maps=new Map),this.string_maps.has(t))return this.string_maps.get(t);const e=this.createString(t);return this.string_maps.set(t,e),e}createString(t){if(null==t)return 0;let e;e=t instanceof Uint8Array?t:this.text_encoder.encode(t),this.addInt8(0),this.startVector(1,e.length,1),this.bb.setPosition(this.space-=e.length);for(let t=0,s=this.space,r=this.bb.bytes();t<e.length;t++)r[s++]=e[t];return this.endVector()}createObjectOffset(t){return null===t?0:"string"==typeof t?this.createString(t):t.pack(this)}createObjectOffsetList(t){const e=[];for(let s=0;s<t.length;++s){const r=t[s];if(null===r)throw new Error("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");e.push(this.createObjectOffset(r))}return e}createStructOffsetList(t,e){return e(this,t.length),this.createObjectOffsetList(t.slice().reverse()),this.endVector()}}let je=class t{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsCivilCurve(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsCivilCurve(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}points(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}pointsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}pointsArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}data(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}static startCivilCurve(t){t.startObject(2)}static addPoints(t,e){t.addFieldOffset(0,e,0)}static createPointsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startPointsVector(t,e){t.startVector(4,e,4)}static addData(t,e){t.addFieldOffset(1,e,0)}static endCivilCurve(t){return t.endObject()}static createCivilCurve(e,s,r){return t.startCivilCurve(e),t.addPoints(e,s),t.addData(e,r),t.endCivilCurve(e)}},Ke=class t{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAlignment(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsAlignment(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}vertical(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new je).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}verticalLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}horizontal(t,e){const s=this.bb.__offset(this.bb_pos,6);return s?(e||new je).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}horizontalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}absolute(t,e){const s=this.bb.__offset(this.bb_pos,8);return s?(e||new je).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}absoluteLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}initialPk(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readFloat32(this.bb_pos+t):0}static startAlignment(t){t.startObject(4)}static addVertical(t,e){t.addFieldOffset(0,e,0)}static createVerticalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startVerticalVector(t,e){t.startVector(4,e,4)}static addHorizontal(t,e){t.addFieldOffset(1,e,0)}static createHorizontalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startHorizontalVector(t,e){t.startVector(4,e,4)}static addAbsolute(t,e){t.addFieldOffset(2,e,0)}static createAbsoluteVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAbsoluteVector(t,e){t.startVector(4,e,4)}static addInitialPk(t,e){t.addFieldFloat32(3,e,0)}static endAlignment(t){return t.endObject()}static createAlignment(e,s,r,i,n){return t.startAlignment(e),t.addVertical(e,s),t.addHorizontal(e,r),t.addAbsolute(e,i),t.addInitialPk(e,n),t.endAlignment(e)}},qe=class t{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsCivilData(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsCivilData(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}alignments(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new Ke).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}alignmentsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrix(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startCivilData(t){t.startObject(2)}static addAlignments(t,e){t.addFieldOffset(0,e,0)}static createAlignmentsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAlignmentsVector(t,e){t.startVector(4,e,4)}static addCoordinationMatrix(t,e){t.addFieldOffset(1,e,0)}static createCoordinationMatrixVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startCoordinationMatrixVector(t,e){t.startVector(4,e,4)}static endCivilData(t){return t.endObject()}static createCivilData(e,s,r){return t.startCivilData(e),t.addAlignments(e,s),t.addCoordinationMatrix(e,r),t.endCivilData(e)}},ke=class t{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsFragment(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsFragment(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}position(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}positionLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}positionArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}normal(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}normalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}normalArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}index(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}indexLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}indexArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}groups(t){const e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}groupsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}groupsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}materials(t){const e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}materialsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}materialsArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}matrices(t){const e=this.bb.__offset(this.bb_pos,14);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}matricesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}matricesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}colors(t){const e=this.bb.__offset(this.bb_pos,16);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}colorsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}colorsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsSize(t){const e=this.bb.__offset(this.bb_pos,18);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsSizeLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsSizeArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const e=this.bb.__offset(this.bb_pos,20);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}idsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,20);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}id(t){const e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__string(this.bb_pos+e,t):null}capacity(){const t=this.bb.__offset(this.bb_pos,24);return t?this.bb.readUint32(this.bb_pos+t):0}capacityOffset(){const t=this.bb.__offset(this.bb_pos,26);return t?this.bb.readUint32(this.bb_pos+t):0}static startFragment(t){t.startObject(12)}static addPosition(t,e){t.addFieldOffset(0,e,0)}static createPositionVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startPositionVector(t,e){t.startVector(4,e,4)}static addNormal(t,e){t.addFieldOffset(1,e,0)}static createNormalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startNormalVector(t,e){t.startVector(4,e,4)}static addIndex(t,e){t.addFieldOffset(2,e,0)}static createIndexVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIndexVector(t,e){t.startVector(4,e,4)}static addGroups(t,e){t.addFieldOffset(3,e,0)}static createGroupsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startGroupsVector(t,e){t.startVector(4,e,4)}static addMaterials(t,e){t.addFieldOffset(4,e,0)}static createMaterialsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startMaterialsVector(t,e){t.startVector(4,e,4)}static addMatrices(t,e){t.addFieldOffset(5,e,0)}static createMatricesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startMatricesVector(t,e){t.startVector(4,e,4)}static addColors(t,e){t.addFieldOffset(6,e,0)}static createColorsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startColorsVector(t,e){t.startVector(4,e,4)}static addItemsSize(t,e){t.addFieldOffset(7,e,0)}static createItemsSizeVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsSizeVector(t,e){t.startVector(4,e,4)}static addIds(t,e){t.addFieldOffset(8,e,0)}static createIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIdsVector(t,e){t.startVector(4,e,4)}static addId(t,e){t.addFieldOffset(9,e,0)}static addCapacity(t,e){t.addFieldInt32(10,e,0)}static addCapacityOffset(t,e){t.addFieldInt32(11,e,0)}static endFragment(t){return t.endObject()}static createFragment(e,s,r,i,n,o,a,c,b,h,d,l,f){return t.startFragment(e),t.addPosition(e,s),t.addNormal(e,r),t.addIndex(e,i),t.addGroups(e,n),t.addMaterials(e,o),t.addMatrices(e,a),t.addColors(e,c),t.addItemsSize(e,b),t.addIds(e,h),t.addId(e,d),t.addCapacity(e,l),t.addCapacityOffset(e,f),t.endFragment(e)}},He=class t{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsFragmentsGroup(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsFragmentsGroup(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}items(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new ke).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}itemsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}civil(t){const e=this.bb.__offset(this.bb_pos,6);return e?(t||new qe).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}coordinationMatrix(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}idsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeys(t){const e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsKeysLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeysIndices(t){const e=this.bb.__offset(this.bb_pos,14);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsKeysIndicesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysIndicesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRels(t){const e=this.bb.__offset(this.bb_pos,16);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsRelsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRelsIndices(t){const e=this.bb.__offset(this.bb_pos,18);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsRelsIndicesLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsIndicesArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}fragmentKeys(t){const e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__string(this.bb_pos+e,t):null}id(t){const e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__string(this.bb_pos+e,t):null}name(t){const e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__string(this.bb_pos+e,t):null}ifcName(t){const e=this.bb.__offset(this.bb_pos,26);return e?this.bb.__string(this.bb_pos+e,t):null}ifcDescription(t){const e=this.bb.__offset(this.bb_pos,28);return e?this.bb.__string(this.bb_pos+e,t):null}ifcSchema(t){const e=this.bb.__offset(this.bb_pos,30);return e?this.bb.__string(this.bb_pos+e,t):null}maxExpressId(){const t=this.bb.__offset(this.bb_pos,32);return t?this.bb.readUint32(this.bb_pos+t):0}boundingBox(t){const e=this.bb.__offset(this.bb_pos,34);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}boundingBoxLength(){const t=this.bb.__offset(this.bb_pos,34);return t?this.bb.__vector_len(this.bb_pos+t):0}boundingBoxArray(){const t=this.bb.__offset(this.bb_pos,34);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}opaqueGeometriesIds(t){const e=this.bb.__offset(this.bb_pos,36);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*t):0}opaqueGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,36);return t?this.bb.__vector_len(this.bb_pos+t):0}opaqueGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,36);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}transparentGeometriesIds(t){const e=this.bb.__offset(this.bb_pos,38);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*t):0}transparentGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,38);return t?this.bb.__vector_len(this.bb_pos+t):0}transparentGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,38);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startFragmentsGroup(t){t.startObject(18)}static addItems(t,e){t.addFieldOffset(0,e,0)}static createItemsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startItemsVector(t,e){t.startVector(4,e,4)}static addCivil(t,e){t.addFieldOffset(1,e,0)}static addCoordinationMatrix(t,e){t.addFieldOffset(2,e,0)}static createCoordinationMatrixVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startCoordinationMatrixVector(t,e){t.startVector(4,e,4)}static addIds(t,e){t.addFieldOffset(3,e,0)}static createIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIdsVector(t,e){t.startVector(4,e,4)}static addItemsKeys(t,e){t.addFieldOffset(4,e,0)}static createItemsKeysVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsKeysVector(t,e){t.startVector(4,e,4)}static addItemsKeysIndices(t,e){t.addFieldOffset(5,e,0)}static createItemsKeysIndicesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsKeysIndicesVector(t,e){t.startVector(4,e,4)}static addItemsRels(t,e){t.addFieldOffset(6,e,0)}static createItemsRelsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsRelsVector(t,e){t.startVector(4,e,4)}static addItemsRelsIndices(t,e){t.addFieldOffset(7,e,0)}static createItemsRelsIndicesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsRelsIndicesVector(t,e){t.startVector(4,e,4)}static addFragmentKeys(t,e){t.addFieldOffset(8,e,0)}static addId(t,e){t.addFieldOffset(9,e,0)}static addName(t,e){t.addFieldOffset(10,e,0)}static addIfcName(t,e){t.addFieldOffset(11,e,0)}static addIfcDescription(t,e){t.addFieldOffset(12,e,0)}static addIfcSchema(t,e){t.addFieldOffset(13,e,0)}static addMaxExpressId(t,e){t.addFieldInt32(14,e,0)}static addBoundingBox(t,e){t.addFieldOffset(15,e,0)}static createBoundingBoxVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startBoundingBoxVector(t,e){t.startVector(4,e,4)}static addOpaqueGeometriesIds(t,e){t.addFieldOffset(16,e,0)}static createOpaqueGeometriesIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startOpaqueGeometriesIdsVector(t,e){t.startVector(4,e,4)}static addTransparentGeometriesIds(t,e){t.addFieldOffset(17,e,0)}static createTransparentGeometriesIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startTransparentGeometriesIdsVector(t,e){t.startVector(4,e,4)}static endFragmentsGroup(t){return t.endObject()}static finishFragmentsGroupBuffer(t,e){t.finish(e)}static finishSizePrefixedFragmentsGroupBuffer(t,e){t.finish(e,void 0,!0)}};class Xe{constructor(){e(this,"version",1),e(this,"fragmentIDSeparator","|")}import(t){const e=new Ne(t),s=He.getRootAsFragmentsGroup(e),r=this.constructFragmentGroup(s),i=s.itemsLength();for(let t=0;t<i;t++){const e=s.items(t);if(!e)continue;const i=this.constructGeometry(e),n=this.constructMaterials(e),o=e.capacity(),a=new Se(i,n,o);a.capacityOffset=e.capacityOffset(),this.setInstances(e,a),this.setID(e,a),r.items.push(a),r.add(a.mesh)}return r}export(t){const e=new Re(1024),s=[],r=He,i=ke;let n=null;if(t.civilData){const s=[],r=Ke,i=qe;for(const[i,n]of t.civilData.alignments){const{absolute:t,horizontal:i,vertical:o}=n,a=this.saveCivilCurves(i,e),c=this.saveCivilCurves(o,e),b=this.saveCivilCurves(t,e),h=r.createHorizontalVector(e,a),d=r.createVerticalVector(e,c),l=r.createAbsoluteVector(e,b);r.startAlignment(e),r.addHorizontal(e,h),r.addVertical(e,d),r.addAbsolute(e,l),r.addInitialPk(e,n.initialKP);const f=r.endAlignment(e);s.push(f)}const o=i.createAlignmentsVector(e,s),a=i.createCoordinationMatrixVector(e,t.coordinationMatrix.elements);i.startCivilData(e),i.addAlignments(e,o),i.addCoordinationMatrix(e,a),n=i.endCivilData(e)}for(const r of t.items){const t=r.exportData(),n=[];for(const t of r.ids){const e=r.getInstancesIDs(t);if(!e)throw new Error("Instances not found!");n.push(e.size)}const o=i.createPositionVector(e,t.position),a=i.createNormalVector(e,t.normal),c=i.createIndexVector(e,t.index),b=i.createGroupsVector(e,t.groups),h=i.createMaterialsVector(e,t.materials),d=i.createMatricesVector(e,t.matrices),l=i.createColorsVector(e,t.colors),f=i.createIdsVector(e,t.ids),u=i.createItemsSizeVector(e,n),_=e.createString(t.id);i.startFragment(e),i.addPosition(e,o),i.addNormal(e,a),i.addIndex(e,c),i.addGroups(e,b),i.addMaterials(e,h),i.addMatrices(e,d),i.addColors(e,l),i.addIds(e,f),i.addItemsSize(e,u),i.addId(e,_),i.addCapacity(e,r.capacity),i.addCapacityOffset(e,r.capacityOffset);const p=ke.endFragment(e);s.push(p)}const o=r.createItemsVector(e,s),a=r.createCoordinationMatrixVector(e,t.coordinationMatrix.elements);let c="";for(const e of t.keyFragments.values())c.length&&(c+=this.fragmentIDSeparator),c+=e;const b=e.createString(c),h=[],d=[],l=[],f=[],u=[];let _=0,p=0;for(const[e,[s,r]]of t.data){h.push(_),l.push(p),u.push(e);for(const t of s)d.push(t);for(const t of r)f.push(t);_+=s.length,p+=r.length}const m=[],g=[];for(const[e,s]of t.geometryIDs.opaque)m.push(e,s);for(const[e,s]of t.geometryIDs.transparent)g.push(e,s);const y=e.createString(t.uuid),w=e.createString(t.name),x=e.createString(t.ifcMetadata.name),v=e.createString(t.ifcMetadata.description),I=e.createString(t.ifcMetadata.schema),A=r.createItemsKeysIndicesVector(e,h),V=r.createItemsKeysVector(e,d),F=r.createItemsRelsIndicesVector(e,l),B=r.createItemsRelsVector(e,f),M=r.createIdsVector(e,u),C=r.createOpaqueGeometriesIdsVector(e,m),O=r.createTransparentGeometriesIdsVector(e,g),{min:P,max:T}=t.boundingBox,S=[P.x,P.y,P.z,T.x,T.y,T.z],U=r.createBoundingBoxVector(e,S);r.startFragmentsGroup(e),r.addId(e,y),r.addName(e,w),r.addIfcName(e,x),r.addIfcDescription(e,v),r.addIfcSchema(e,I),r.addMaxExpressId(e,t.ifcMetadata.maxExpressID),r.addItems(e,o),r.addFragmentKeys(e,b),r.addIds(e,M),r.addItemsKeysIndices(e,A),r.addItemsKeys(e,V),r.addItemsRelsIndices(e,F),r.addItemsRels(e,B),r.addCoordinationMatrix(e,a),r.addBoundingBox(e,U),r.addOpaqueGeometriesIds(e,C),r.addTransparentGeometriesIds(e,O),null!==n&&r.addCivil(e,n);const D=He.endFragmentsGroup(e);return e.finish(D),e.asUint8Array()}setID(t,e){const s=t.id();s&&(e.id=s,e.mesh.uuid=s)}setInstances(t,e){const s=t.matricesArray(),r=t.colorsArray(),n=t.idsArray(),o=t.itemsSizeArray();if(!s||!n||!o)throw new Error("Error: Can't load empty fragment!");const a=[];let c=0;for(let t=0;t<o.length;t++){const e=n[t],b=o[t],h=[],d=[];for(let t=0;t<b;t++){const t=16*c,e=s.subarray(t,t+17),n=(new i.Matrix4).fromArray(e);if(h.push(n),r){const t=3*c,[e,s,n]=r.subarray(t,t+4),o=new i.Color(e,s,n);d.push(o)}c++}const l=d.length?d:void 0;a.push({id:e,transforms:h,colors:l})}e.add(a)}constructMaterials(t){const e=t.materialsArray(),s=[];if(!e)return s;for(let t=0;t<e.length;t+=5){const r=e[t],n=Boolean(e[t+1]),o=e[t+2],a=e[t+3],c=e[t+4],b=new i.Color(o,a,c),h=new i.MeshLambertMaterial({color:b,opacity:r,transparent:n});s.push(h)}return s}constructFragmentGroup(t){const e=new ss,s=t.civil();if(s){const t=s.coordinationMatrixArray(),r=new i.Matrix4;t&&r.fromArray(t),e.civilData={alignments:new Map,coordinationMatrix:r};const n=s.alignmentsLength();for(let t=0;t<n;t++){const r=new i.LineBasicMaterial({color:16777215}),n=new rs,o=s.alignments(t);if(!o)throw new Error("Alignment not found!");const a=o.horizontalLength();n.horizontal=this.constructCivilCurves(o,n,"horizontal",a,r);const c=o.verticalLength();n.vertical=this.constructCivilCurves(o,n,"vertical",c,r);const b=o.horizontalLength();n.absolute=this.constructCivilCurves(o,n,"absolute",b,r),n.initialKP=o.initialPk(),e.civilData.alignments.set(t,n)}}e.uuid=t.id()||e.uuid,e.name=t.name()||"",e.ifcMetadata={name:t.ifcName()||"",description:t.ifcDescription()||"",schema:t.ifcSchema()||"IFC2X3",maxExpressID:t.maxExpressId()||0};const r=(new i.Matrix4).elements,n=t.coordinationMatrixArray()||r,o=t.idsArray()||new Uint32Array,a=t.itemsKeysIndicesArray()||new Uint32Array,c=t.itemsKeysArray()||new Uint32Array,b=t.itemsRelsArray()||new Uint32Array,h=t.itemsRelsIndicesArray()||new Uint32Array,d=(t.fragmentKeys()||"").split(this.fragmentIDSeparator);this.setGroupData(e,o,a,c,0),this.setGroupData(e,o,h,b,1);const l=t.opaqueGeometriesIdsArray()||new Uint32Array,f=t.transparentGeometriesIdsArray()||new Uint32Array,u=new Map;for(let t=0;t<l.length-1;t+=2){const e=l[t],s=l[t+1];u.set(e,s)}const _=new Map;for(let t=0;t<f.length-1;t+=2){const e=f[t],s=f[t+1];_.set(e,s)}e.geometryIDs={opaque:u,transparent:_};const p=t.boundingBoxArray()||[0,0,0,0,0,0],[m,g,y,w,x,v]=p;e.boundingBox.min.set(m,g,y),e.boundingBox.max.set(w,x,v);for(let t=0;t<d.length;t++)e.keyFragments.set(t,d[t]);return 16===n.length&&e.coordinationMatrix.fromArray(n),e}setGroupData(t,e,s,r,i){for(let n=0;n<s.length;n++){const o=e[n],a=s[n],c=s[n+1]||r.length,b=[];for(let t=a;t<c;t++)b.push(r[t]);t.data.has(o)||t.data.set(o,[[],[]]);const h=t.data.get(o);h&&(h[i]=b)}}constructGeometry(t){const e=t.positionArray()||new Float32Array,s=t.normalArray()||new Float32Array,r=t.indexArray(),n=t.groupsArray();if(!r)throw new Error("Index not found!");const o=new i.BufferGeometry;if(o.setIndex(Array.from(r)),o.setAttribute("position",new i.BufferAttribute(e,3)),o.setAttribute("normal",new i.BufferAttribute(s,3)),n)for(let t=0;t<n.length;t+=3){const e=n[t],s=n[t+1],r=n[t+2];o.addGroup(e,s,r)}return o}constructCivilCurves(t,e,s,r,n){const o=[];for(let a=0;a<r;a++){const r=t[s](a);if(!r)throw new Error("Curve not found!");const c=r.pointsArray();if(null===c)throw new Error("Curve points not found!");let b={};const h=r.data();h&&(b=JSON.parse(h));const d=new i.EdgesGeometry,l=new i.BufferAttribute(c,3);d.setAttribute("position",l);const f=[];for(let t=0;t<c.length/3-1;t++)f.push(t,t+1);d.setIndex(f);const u=new ns(a,b,e,d,n);o.push(u.curve)}return o}saveCivilCurves(t,e){const s=je,r=[];for(const i of t){const t=i.mesh.geometry.attributes.position.array,n=s.createPointsVector(e,t),o=e.createString(JSON.stringify(i.data));s.startCivilCurve(e),s.addPoints(e,n),s.addData(e,o);const a=s.endCivilCurve(e);r.push(a)}return r}}let $e=class t{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsCivilCurve(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsCivilCurve(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}points(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}pointsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}pointsArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}data(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.__string(this.bb_pos+e,t):null}static startCivilCurve(t){t.startObject(2)}static addPoints(t,e){t.addFieldOffset(0,e,0)}static createPointsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startPointsVector(t,e){t.startVector(4,e,4)}static addData(t,e){t.addFieldOffset(1,e,0)}static endCivilCurve(t){return t.endObject()}static createCivilCurve(e,s,r){return t.startCivilCurve(e),t.addPoints(e,s),t.addData(e,r),t.endCivilCurve(e)}},Ye=class t{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsAlignment(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsAlignment(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}vertical(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new $e).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}verticalLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}horizontal(t,e){const s=this.bb.__offset(this.bb_pos,6);return s?(e||new $e).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}horizontalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}absolute(t,e){const s=this.bb.__offset(this.bb_pos,8);return s?(e||new $e).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}absoluteLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}initialPk(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.readFloat32(this.bb_pos+t):0}static startAlignment(t){t.startObject(4)}static addVertical(t,e){t.addFieldOffset(0,e,0)}static createVerticalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startVerticalVector(t,e){t.startVector(4,e,4)}static addHorizontal(t,e){t.addFieldOffset(1,e,0)}static createHorizontalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startHorizontalVector(t,e){t.startVector(4,e,4)}static addAbsolute(t,e){t.addFieldOffset(2,e,0)}static createAbsoluteVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAbsoluteVector(t,e){t.startVector(4,e,4)}static addInitialPk(t,e){t.addFieldFloat32(3,e,0)}static endAlignment(t){return t.endObject()}static createAlignment(e,s,r,i,n){return t.startAlignment(e),t.addVertical(e,s),t.addHorizontal(e,r),t.addAbsolute(e,i),t.addInitialPk(e,n),t.endAlignment(e)}};class Ze{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsCivilData(t,e){return(e||new Ze).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsCivilData(t,e){return t.setPosition(t.position()+4),(e||new Ze).__init(t.readInt32(t.position())+t.position(),t)}alignments(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new Ye).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}alignmentsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrix(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startCivilData(t){t.startObject(2)}static addAlignments(t,e){t.addFieldOffset(0,e,0)}static createAlignmentsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startAlignmentsVector(t,e){t.startVector(4,e,4)}static addCoordinationMatrix(t,e){t.addFieldOffset(1,e,0)}static createCoordinationMatrixVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startCoordinationMatrixVector(t,e){t.startVector(4,e,4)}static endCivilData(t){return t.endObject()}static createCivilData(t,e,s){return Ze.startCivilData(t),Ze.addAlignments(t,e),Ze.addCoordinationMatrix(t,s),Ze.endCivilData(t)}}class Je{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsFragment(t,e){return(e||new Je).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsFragment(t,e){return t.setPosition(t.position()+4),(e||new Je).__init(t.readInt32(t.position())+t.position(),t)}position(t){const e=this.bb.__offset(this.bb_pos,4);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}positionLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}positionArray(){const t=this.bb.__offset(this.bb_pos,4);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}normal(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}normalLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}normalArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}index(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}indexLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}indexArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}groups(t){const e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}groupsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}groupsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}materials(t){const e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}materialsLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}materialsArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}matrices(t){const e=this.bb.__offset(this.bb_pos,14);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}matricesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}matricesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}colors(t){const e=this.bb.__offset(this.bb_pos,16);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}colorsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}colorsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsSize(t){const e=this.bb.__offset(this.bb_pos,18);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsSizeLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsSizeArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const e=this.bb.__offset(this.bb_pos,20);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}idsLength(){const t=this.bb.__offset(this.bb_pos,20);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,20);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}id(t){const e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__string(this.bb_pos+e,t):null}capacity(){const t=this.bb.__offset(this.bb_pos,24);return t?this.bb.readUint32(this.bb_pos+t):0}capacityOffset(){const t=this.bb.__offset(this.bb_pos,26);return t?this.bb.readUint32(this.bb_pos+t):0}static startFragment(t){t.startObject(12)}static addPosition(t,e){t.addFieldOffset(0,e,0)}static createPositionVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startPositionVector(t,e){t.startVector(4,e,4)}static addNormal(t,e){t.addFieldOffset(1,e,0)}static createNormalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startNormalVector(t,e){t.startVector(4,e,4)}static addIndex(t,e){t.addFieldOffset(2,e,0)}static createIndexVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIndexVector(t,e){t.startVector(4,e,4)}static addGroups(t,e){t.addFieldOffset(3,e,0)}static createGroupsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startGroupsVector(t,e){t.startVector(4,e,4)}static addMaterials(t,e){t.addFieldOffset(4,e,0)}static createMaterialsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startMaterialsVector(t,e){t.startVector(4,e,4)}static addMatrices(t,e){t.addFieldOffset(5,e,0)}static createMatricesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startMatricesVector(t,e){t.startVector(4,e,4)}static addColors(t,e){t.addFieldOffset(6,e,0)}static createColorsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startColorsVector(t,e){t.startVector(4,e,4)}static addItemsSize(t,e){t.addFieldOffset(7,e,0)}static createItemsSizeVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsSizeVector(t,e){t.startVector(4,e,4)}static addIds(t,e){t.addFieldOffset(8,e,0)}static createIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIdsVector(t,e){t.startVector(4,e,4)}static addId(t,e){t.addFieldOffset(9,e,0)}static addCapacity(t,e){t.addFieldInt32(10,e,0)}static addCapacityOffset(t,e){t.addFieldInt32(11,e,0)}static endFragment(t){return t.endObject()}static createFragment(t,e,s,r,i,n,o,a,c,b,h,d,l){return Je.startFragment(t),Je.addPosition(t,e),Je.addNormal(t,s),Je.addIndex(t,r),Je.addGroups(t,i),Je.addMaterials(t,n),Je.addMatrices(t,o),Je.addColors(t,a),Je.addItemsSize(t,c),Je.addIds(t,b),Je.addId(t,h),Je.addCapacity(t,d),Je.addCapacityOffset(t,l),Je.endFragment(t)}}let We=class t{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsFragmentsGroup(e,s){return(s||new t).__init(e.readInt32(e.position())+e.position(),e)}static getSizePrefixedRootAsFragmentsGroup(e,s){return e.setPosition(e.position()+4),(s||new t).__init(e.readInt32(e.position())+e.position(),e)}items(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new Je).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}itemsLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}civil(t){const e=this.bb.__offset(this.bb_pos,6);return e?(t||new Ze).__init(this.bb.__indirect(this.bb_pos+e),this.bb):null}coordinationMatrix(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}coordinationMatrixLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}coordinationMatrixArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}ids(t){const e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}idsLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}idsArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeys(t){const e=this.bb.__offset(this.bb_pos,12);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsKeysLength(){const t=this.bb.__offset(this.bb_pos,12);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysArray(){const t=this.bb.__offset(this.bb_pos,12);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsKeysIndices(t){const e=this.bb.__offset(this.bb_pos,14);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsKeysIndicesLength(){const t=this.bb.__offset(this.bb_pos,14);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsKeysIndicesArray(){const t=this.bb.__offset(this.bb_pos,14);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRels(t){const e=this.bb.__offset(this.bb_pos,16);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsRelsLength(){const t=this.bb.__offset(this.bb_pos,16);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsArray(){const t=this.bb.__offset(this.bb_pos,16);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}itemsRelsIndices(t){const e=this.bb.__offset(this.bb_pos,18);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}itemsRelsIndicesLength(){const t=this.bb.__offset(this.bb_pos,18);return t?this.bb.__vector_len(this.bb_pos+t):0}itemsRelsIndicesArray(){const t=this.bb.__offset(this.bb_pos,18);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}fragmentKeys(t){const e=this.bb.__offset(this.bb_pos,20);return e?this.bb.__string(this.bb_pos+e,t):null}globalIds(t){const e=this.bb.__offset(this.bb_pos,22);return e?this.bb.__string(this.bb_pos+e,t):null}id(t){const e=this.bb.__offset(this.bb_pos,24);return e?this.bb.__string(this.bb_pos+e,t):null}name(t){const e=this.bb.__offset(this.bb_pos,26);return e?this.bb.__string(this.bb_pos+e,t):null}ifcName(t){const e=this.bb.__offset(this.bb_pos,28);return e?this.bb.__string(this.bb_pos+e,t):null}ifcDescription(t){const e=this.bb.__offset(this.bb_pos,30);return e?this.bb.__string(this.bb_pos+e,t):null}ifcSchema(t){const e=this.bb.__offset(this.bb_pos,32);return e?this.bb.__string(this.bb_pos+e,t):null}maxExpressId(){const t=this.bb.__offset(this.bb_pos,34);return t?this.bb.readUint32(this.bb_pos+t):0}boundingBox(t){const e=this.bb.__offset(this.bb_pos,36);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}boundingBoxLength(){const t=this.bb.__offset(this.bb_pos,36);return t?this.bb.__vector_len(this.bb_pos+t):0}boundingBoxArray(){const t=this.bb.__offset(this.bb_pos,36);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}opaqueGeometriesIds(t){const e=this.bb.__offset(this.bb_pos,38);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*t):0}opaqueGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,38);return t?this.bb.__vector_len(this.bb_pos+t):0}opaqueGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,38);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}transparentGeometriesIds(t){const e=this.bb.__offset(this.bb_pos,40);return e?this.bb.readInt32(this.bb.__vector(this.bb_pos+e)+4*t):0}transparentGeometriesIdsLength(){const t=this.bb.__offset(this.bb_pos,40);return t?this.bb.__vector_len(this.bb_pos+t):0}transparentGeometriesIdsArray(){const t=this.bb.__offset(this.bb_pos,40);return t?new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startFragmentsGroup(t){t.startObject(19)}static addItems(t,e){t.addFieldOffset(0,e,0)}static createItemsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startItemsVector(t,e){t.startVector(4,e,4)}static addCivil(t,e){t.addFieldOffset(1,e,0)}static addCoordinationMatrix(t,e){t.addFieldOffset(2,e,0)}static createCoordinationMatrixVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startCoordinationMatrixVector(t,e){t.startVector(4,e,4)}static addIds(t,e){t.addFieldOffset(3,e,0)}static createIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIdsVector(t,e){t.startVector(4,e,4)}static addItemsKeys(t,e){t.addFieldOffset(4,e,0)}static createItemsKeysVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsKeysVector(t,e){t.startVector(4,e,4)}static addItemsKeysIndices(t,e){t.addFieldOffset(5,e,0)}static createItemsKeysIndicesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsKeysIndicesVector(t,e){t.startVector(4,e,4)}static addItemsRels(t,e){t.addFieldOffset(6,e,0)}static createItemsRelsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsRelsVector(t,e){t.startVector(4,e,4)}static addItemsRelsIndices(t,e){t.addFieldOffset(7,e,0)}static createItemsRelsIndicesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startItemsRelsIndicesVector(t,e){t.startVector(4,e,4)}static addFragmentKeys(t,e){t.addFieldOffset(8,e,0)}static addGlobalIds(t,e){t.addFieldOffset(9,e,0)}static addId(t,e){t.addFieldOffset(10,e,0)}static addName(t,e){t.addFieldOffset(11,e,0)}static addIfcName(t,e){t.addFieldOffset(12,e,0)}static addIfcDescription(t,e){t.addFieldOffset(13,e,0)}static addIfcSchema(t,e){t.addFieldOffset(14,e,0)}static addMaxExpressId(t,e){t.addFieldInt32(15,e,0)}static addBoundingBox(t,e){t.addFieldOffset(16,e,0)}static createBoundingBoxVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startBoundingBoxVector(t,e){t.startVector(4,e,4)}static addOpaqueGeometriesIds(t,e){t.addFieldOffset(17,e,0)}static createOpaqueGeometriesIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startOpaqueGeometriesIdsVector(t,e){t.startVector(4,e,4)}static addTransparentGeometriesIds(t,e){t.addFieldOffset(18,e,0)}static createTransparentGeometriesIdsVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startTransparentGeometriesIdsVector(t,e){t.startVector(4,e,4)}static endFragmentsGroup(t){return t.endObject()}static finishFragmentsGroupBuffer(t,e){t.finish(e)}static finishSizePrefixedFragmentsGroupBuffer(t,e){t.finish(e,void 0,!0)}};class Qe{constructor(){e(this,"version",2),e(this,"separator","|")}import(t){const e=new Ne(t),s=We.getRootAsFragmentsGroup(e),r=this.constructFragmentGroup(s),i=s.itemsLength();for(let t=0;t<i;t++){const e=s.items(t);if(!e)continue;const i=this.constructGeometry(e),n=this.constructMaterials(e),o=e.capacity(),a=new Se(i,n,o);a.capacityOffset=e.capacityOffset(),this.setInstances(e,a),this.setID(e,a),r.items.push(a),r.add(a.mesh)}return r}export(t){const e=new Re(1024),s=[],r=We,i=Je;let n=null;if(t.civilData){const s=[],r=Ye,i=Ze;for(const[i,n]of t.civilData.alignments){const{absolute:t,horizontal:i,vertical:o}=n,a=this.saveCivilCurves(i,e),c=this.saveCivilCurves(o,e),b=this.saveCivilCurves(t,e),h=r.createHorizontalVector(e,a),d=r.createVerticalVector(e,c),l=r.createAbsoluteVector(e,b);r.startAlignment(e),r.addHorizontal(e,h),r.addVertical(e,d),r.addAbsolute(e,l),r.addInitialPk(e,n.initialKP);const f=r.endAlignment(e);s.push(f)}const o=i.createAlignmentsVector(e,s),a=i.createCoordinationMatrixVector(e,t.coordinationMatrix.elements);i.startCivilData(e),i.addAlignments(e,o),i.addCoordinationMatrix(e,a),n=i.endCivilData(e)}for(const r of t.items){const t=r.exportData(),n=[];for(const t of r.ids){const e=r.getInstancesIDs(t);if(!e)throw new Error("Instances not found!");n.push(e.size)}const o=i.createPositionVector(e,t.position),a=i.createNormalVector(e,t.normal),c=i.createIndexVector(e,t.index),b=i.createGroupsVector(e,t.groups),h=i.createMaterialsVector(e,t.materials),d=i.createMatricesVector(e,t.matrices),l=i.createColorsVector(e,t.colors),f=i.createIdsVector(e,t.ids),u=i.createItemsSizeVector(e,n),_=e.createString(t.id);i.startFragment(e),i.addPosition(e,o),i.addNormal(e,a),i.addIndex(e,c),i.addGroups(e,b),i.addMaterials(e,h),i.addMatrices(e,d),i.addColors(e,l),i.addIds(e,f),i.addItemsSize(e,u),i.addId(e,_),i.addCapacity(e,r.capacity),i.addCapacityOffset(e,r.capacityOffset);const p=Je.endFragment(e);s.push(p)}const o=r.createItemsVector(e,s),a=r.createCoordinationMatrixVector(e,t.coordinationMatrix.elements);let c="";for(const e of t.keyFragments.values())c.length&&(c+=this.separator),c+=e;let b="";for(const[e]of t.globalToExpressIDs)b.length&&(b+=this.separator),b+=e;const h=e.createString(c),d=e.createString(b),l=[],f=[],u=[],_=[],p=[];let m=0,g=0;for(const[e,[s,r]]of t.data){l.push(m),u.push(g),p.push(e);for(const t of s)f.push(t);for(const t of r)_.push(t);m+=s.length,g+=r.length}const y=[],w=[];for(const[e,s]of t.geometryIDs.opaque)y.push(e,s);for(const[e,s]of t.geometryIDs.transparent)w.push(e,s);const x=e.createString(t.uuid),v=e.createString(t.name),I=e.createString(t.ifcMetadata.name),A=e.createString(t.ifcMetadata.description),V=e.createString(t.ifcMetadata.schema),F=r.createItemsKeysIndicesVector(e,l),B=r.createItemsKeysVector(e,f),M=r.createItemsRelsIndicesVector(e,u),C=r.createItemsRelsVector(e,_),O=r.createIdsVector(e,p),P=r.createOpaqueGeometriesIdsVector(e,y),T=r.createTransparentGeometriesIdsVector(e,w),{min:S,max:U}=t.boundingBox,D=[S.x,S.y,S.z,U.x,U.y,U.z],G=r.createBoundingBoxVector(e,D);r.startFragmentsGroup(e),r.addId(e,x),r.addName(e,v),r.addIfcName(e,I),r.addIfcDescription(e,A),r.addIfcSchema(e,V),r.addMaxExpressId(e,t.ifcMetadata.maxExpressID),r.addItems(e,o),r.addFragmentKeys(e,h),r.addGlobalIds(e,d),r.addIds(e,O),r.addItemsKeysIndices(e,F),r.addItemsKeys(e,B),r.addItemsRelsIndices(e,M),r.addItemsRels(e,C),r.addCoordinationMatrix(e,a),r.addBoundingBox(e,G),r.addOpaqueGeometriesIds(e,P),r.addTransparentGeometriesIds(e,T),null!==n&&r.addCivil(e,n);const L=We.endFragmentsGroup(e);return e.finish(L),e.asUint8Array()}setID(t,e){const s=t.id();s&&(e.id=s,e.mesh.uuid=s)}setInstances(t,e){const s=t.matricesArray(),r=t.colorsArray(),n=t.idsArray(),o=t.itemsSizeArray();if(!s||!n||!o)throw new Error("Error: Can't load empty fragment!");const a=[];let c=0;for(let t=0;t<o.length;t++){const e=n[t],b=o[t],h=[],d=[];for(let t=0;t<b;t++){const t=16*c,e=s.subarray(t,t+17),n=(new i.Matrix4).fromArray(e);if(h.push(n),r){const t=3*c,[e,s,n]=r.subarray(t,t+4),o=new i.Color(e,s,n);d.push(o)}c++}const l=d.length?d:void 0;a.push({id:e,transforms:h,colors:l})}e.add(a)}constructMaterials(t){const e=t.materialsArray(),s=[];if(!e)return s;for(let t=0;t<e.length;t+=5){const r=e[t],n=Boolean(e[t+1]),o=e[t+2],a=e[t+3],c=e[t+4],b=new i.Color(o,a,c),h=new i.MeshLambertMaterial({color:b,opacity:r,transparent:n});s.push(h)}return s}constructFragmentGroup(t){const e=new ss,s=t.civil();if(s){const t=s.coordinationMatrixArray(),r=new i.Matrix4;t&&r.fromArray(t),e.civilData={alignments:new Map,coordinationMatrix:r};const n=s.alignmentsLength();for(let t=0;t<n;t++){const r=new i.LineBasicMaterial({color:16777215}),n=new rs,o=s.alignments(t);if(!o)throw new Error("Alignment not found!");const a=o.horizontalLength();n.horizontal=this.constructCivilCurves(o,n,"horizontal",a,r);const c=o.verticalLength();n.vertical=this.constructCivilCurves(o,n,"vertical",c,r);const b=o.horizontalLength();n.absolute=this.constructCivilCurves(o,n,"absolute",b,r),n.initialKP=o.initialPk(),e.civilData.alignments.set(t,n)}}e.uuid=t.id()||e.uuid,e.name=t.name()||"",e.ifcMetadata={name:t.ifcName()||"",description:t.ifcDescription()||"",schema:t.ifcSchema()||"IFC2X3",maxExpressID:t.maxExpressId()||0};const r=(new i.Matrix4).elements,n=t.coordinationMatrixArray()||r,o=t.idsArray()||new Uint32Array,a=t.itemsKeysIndicesArray()||new Uint32Array,c=t.itemsKeysArray()||new Uint32Array,b=t.itemsRelsArray()||new Uint32Array,h=t.itemsRelsIndicesArray()||new Uint32Array,d=(t.fragmentKeys()||"").split(this.separator),l=(t.globalIds()||"").split(this.separator);this.setGroupData(e,o,a,c,0),this.setGroupData(e,o,h,b,1);const f=t.opaqueGeometriesIdsArray()||new Uint32Array,u=t.transparentGeometriesIdsArray()||new Uint32Array,_=new Map;for(let t=0;t<f.length-1;t+=2){const e=f[t],s=f[t+1];_.set(e,s)}const p=new Map;for(let t=0;t<u.length-1;t+=2){const e=u[t],s=u[t+1];p.set(e,s)}e.geometryIDs={opaque:_,transparent:p};const m=t.boundingBoxArray()||[0,0,0,0,0,0],[g,y,w,x,v,I]=m;e.boundingBox.min.set(g,y,w),e.boundingBox.max.set(x,v,I);for(let t=0;t<d.length;t++)e.keyFragments.set(t,d[t]);16===n.length&&e.coordinationMatrix.fromArray(n);for(let t=0;t<o.length;t++)e.globalToExpressIDs.set(l[t],o[t]);return e}setGroupData(t,e,s,r,i){for(let n=0;n<s.length;n++){const o=e[n],a=s[n],c=s[n+1],b=void 0===c?r.length:c,h=[];for(let t=a;t<b;t++)h.push(r[t]);t.data.has(o)||t.data.set(o,[[],[]]);const d=t.data.get(o);d&&(d[i]=h)}}constructGeometry(t){const e=t.positionArray()||new Float32Array,s=t.normalArray()||new Float32Array,r=t.indexArray(),n=t.groupsArray();if(!r)throw new Error("Index not found!");const o=new i.BufferGeometry;if(o.setIndex(Array.from(r)),o.setAttribute("position",new i.BufferAttribute(e,3)),o.setAttribute("normal",new i.BufferAttribute(s,3)),n)for(let t=0;t<n.length;t+=3){const e=n[t],s=n[t+1],r=n[t+2];o.addGroup(e,s,r)}return o}constructCivilCurves(t,e,s,r,n){const o=[];for(let a=0;a<r;a++){const r=t[s](a);if(!r)throw new Error("Curve not found!");const c=r.pointsArray();if(null===c)throw new Error("Curve points not found!");let b={};const h=r.data();h&&(b=JSON.parse(h));const d=new i.EdgesGeometry,l=new i.BufferAttribute(c,3);d.setAttribute("position",l);const f=[];for(let t=0;t<c.length/3-1;t++)f.push(t,t+1);d.setIndex(f);const u=new ns(a,b,e,d,n);o.push(u.curve)}return o}saveCivilCurves(t,e){const s=$e,r=[];for(const i of t){const t=i.mesh.geometry.attributes.position.array,n=s.createPointsVector(e,t),o=e.createString(JSON.stringify(i.data));s.startCivilCurve(e),s.addPoints(e,n),s.addData(e,o);const a=s.endCivilCurve(e);r.push(a)}return r}}class ts{constructor(t){e(this,"baseDirectory"),e(this,"maxDeadTime",6e4),e(this,"mode","buffer"),e(this,"_memoryCleanTime",1e4),e(this,"_intervalID",null),e(this,"_isCleaningMemory",!1),e(this,"cleanMemory",(async()=>{if(this._isCleaningMemory)return;this._isCleaningMemory=!0;const t=await this.getDir(this.baseDirectory),e=new Set,s=(new Date).getTime();for await(const r of t.values()){const t=localStorage.getItem(r.name)||"0";s-parseInt(t,10)>this.maxDeadTime&&(e.add(r.name),localStorage.removeItem(r.name))}for(const s of e)t.removeEntry(s);this._isCleaningMemory=!1})),this.baseDirectory=t,this.setupMemoryCleanup()}get memoryCleanTime(){return this._memoryCleanTime}set memoryCleanTime(t){this._memoryCleanTime=t,this.dispose(),this.setupMemoryCleanup()}isCached(t){const e=this.encodeName(t);return null!==localStorage.getItem(e)}async get(t){const e=this.encodeName(t),s=await this.getDir(this.baseDirectory);try{const t=await s.getFileHandle(e),r=await t.getFile();return this.updateLastAccessTime(e),r}catch(t){return null}}async add(t,e){const s=this.encodeName(t),r=await this.getDir(this.baseDirectory),i=await r.getFileHandle(s,{create:!0}),n=await i.createWritable();await n.write(e),await n.close(),this.updateLastAccessTime(s)}async clear(){const t=await this.getDir(this.baseDirectory);for await(const[e]of t.entries())await t.removeEntry(e)}dispose(){null!==this._intervalID&&window.clearInterval(this._intervalID)}setupMemoryCleanup(){this._intervalID=window.setInterval(this.cleanMemory,this.memoryCleanTime)}async getDir(t){return(await navigator.storage.getDirectory()).getDirectoryHandle(t,{create:!0})}encodeName(t){return t.replace(/[\\/:*?"<>|]/g,"")}updateLastAccessTime(t){const e=(new Date).getTime().toString();localStorage.setItem(t,e)}}const es=class t extends i.Group{constructor(){super(...arguments),e(this,"items",[]),e(this,"boundingBox",new i.Box3),e(this,"coordinationMatrix",new i.Matrix4),e(this,"keyFragments",new Map),e(this,"globalToExpressIDs",new Map),e(this,"data",new Map),e(this,"geometryIDs",{opaque:new Map,transparent:new Map}),e(this,"ifcMetadata",{name:"",description:"",schema:"IFC2X3",maxExpressID:0}),e(this,"civilData"),e(this,"streamSettings",{baseFileName:"",ids:new Map,types:new Map}),e(this,"isStreamed",!1),e(this,"_properties")}get hasProperties(){const t=void 0!==this._properties,e=0!==this.streamSettings.ids.size;return t||e}getFragmentMap(t=this.data.keys()){const e={};for(const s of t){const t=this.data.get(s);if(t)for(const r of t[0]){const t=this.keyFragments.get(r);void 0!==t&&(e[t]||(e[t]=new Set),e[t].add(s))}}return e}getItemVertices(t){const e=[],s=this.getFragmentMap([t]);for(const r in s){const s=this.items.find((t=>t.id===r));if(!s)continue;const n=s.getInstancesIDs(t);if(n)for(const t of n){const r=new i.Matrix4;s.mesh.getMatrixAt(t,r);for(const t of s.uniqueVertices){const s=t.clone().applyMatrix4(r);e.push(s)}}}return e}static setPropertiesDB(e){e?t.propertiesDB||(t.propertiesDB=new ts("that-open-company-streaming-properties")):e||t.propertiesDB&&t.propertiesDB.dispose()}dispose(t=!0){for(const e of this.items)e.dispose(t);if(this.coordinationMatrix=new i.Matrix4,this.keyFragments.clear(),this.data.clear(),this._properties={},this.removeFromParent(),this.items=[],this.civilData){const{alignments:t}=this.civilData;for(const[e,s]of t)this.disposeAlignment(s.vertical),this.disposeAlignment(s.horizontal),this.disposeAlignment(s.absolute)}this.civilData=void 0}setLocalProperties(t){this._properties=t}getLocalProperties(){return this._properties}getAllPropertiesIDs(){return this._properties?Object.keys(this._properties).map((t=>parseInt(t,10))):Array.from(this.streamSettings.ids.keys())}getAllPropertiesTypes(){if(this._properties){const t=new Set;for(const e in this._properties){const s=this._properties[e];void 0!==s.type&&t.add(s.type)}return Array.from(t)}return Array.from(this.streamSettings.types.keys())}async getProperties(t){if(this._properties)return this._properties[t]||null;const e=this.getPropsURL(t),s=await this.getPropertiesData(e);return s?s[t]:null}async setProperties(t,e){if(!this._properties)throw new Error("Writing streamed properties not supported yet!");null!==e?this._properties[t]=e:delete this._properties[t]}async getAllPropertiesOfType(t){if(this._properties){const e={};let s=!1;for(const r in this._properties){const i=this._properties[r];i.type===t&&(e[i.expressID]=i,s=!0)}return s?e:null}const{types:e}=this.streamSettings,s=e.get(t);if(void 0===s)return null;const r={};for(const t of s){const e=this.constructFileName(t),s=await this.getPropertiesData(e);for(const t in s)r[parseInt(t,10)]=s[t]}return r}clone(t){throw new Error("Use FragmentsGroup.cloneGroup instead!")}cloneGroup(e){const s=new t;s.coordinationMatrix=this.coordinationMatrix,s.position.copy(this.position),s.rotation.copy(this.rotation),s.scale.copy(this.scale),s.updateMatrix(),s.ifcMetadata={...this.ifcMetadata},e||(e=this.getFragmentMap(this.data.keys()));const r=new Set,i=new Map;for(const t of this.items){if(!e[t.id])continue;const n=e[t.id],o=t.clone(n);i.set(t.id,o.id),s.items.push(o),s.add(o.mesh);for(const t of n)r.add(t)}for(const t of r){const e=this.data.get(t);e&&s.data.set(t,e)}for(const[t,e]of this.keyFragments)if(i.has(e)){const r=i.get(e);if(void 0===r)throw new Error("Malformed fragment ID map during clone!");s.keyFragments.set(t,r)}for(const[t,e]of this.globalToExpressIDs)r.has(e)&&s.globalToExpressIDs.set(t,e);return this.civilData&&(s.civilData={coordinationMatrix:this.coordinationMatrix,alignments:new Map}),s}getPropsURL(t){const{ids:e}=this.streamSettings,s=e.get(t);if(void 0===s)throw new Error("ID not found");return this.constructFileName(s)}async getPropertiesData(e){var s;let r;if((null==(s=this.streamSettings.baseUrl)?void 0:s.length)&&(console.warn("streamSettings.baseUrl is deprecated. Use FragmentsGroup.url instead."),t.url=this.streamSettings.baseUrl),t.useCache){let s=null;if(t.propertiesDB&&(s=await t.propertiesDB.get(e)),s)r=await s.text();else{const s=await t.fetch(e);if(r=await s.text(),t.propertiesDB){const s=(new TextEncoder).encode(r);await t.propertiesDB.add(e,s)}}}else{const s=await t.fetch(e);r=await s.text()}return JSON.parse(r)}constructFileName(e){if(t.constructFileName)return t.constructFileName(e);const{baseFileName:s}=this.streamSettings;return`${s}-${e}`}disposeAlignment(t){for(const e of t)if(e.mesh.geometry.dispose(),Array.isArray(e.mesh.material))for(const t of e.mesh.material)t.dispose();else e.mesh.material.dispose();t.length=0}};e(es,"fetch",(async t=>fetch(`${es.url}${t}`))),e(es,"constructFileName",null),e(es,"url",""),e(es,"useCache",!0),e(es,"propertiesDB",null);let ss=es;class rs{constructor(){e(this,"vertical",[]),e(this,"horizontal",[]),e(this,"absolute",[]),e(this,"initialKP",0)}getLength(t){let e=0;for(const s of this[t])e+=s.getLength();return e}getPointAt(t,e){const s=this.getCurveAt(t,e);return s.curve.getPointAt(s.percentage)}getPercentageAt(t,e,s=.01){const r=this[e];let i=0;for(const n of r){const r=n.getPercentageAt(t,s),o=n.getLength();if(null!==r){return(i+r*o)/this.getLength(e)}i+=o}return null}getCurveAt(t,e){t<0?t=0:t>1&&(t=1);const s=this[e],r=this.getLength(e)*t;let i=0;for(const t of s){const e=t.getLength();if(i+e>=r){return{curve:t,percentage:(r-i)/e}}i+=e}throw new Error("Could not compute point!")}}class is{constructor(t,s,r,i){e(this,"index"),e(this,"mesh"),e(this,"data"),e(this,"alignment"),this.index=t,this.mesh=s,this.data=r,this.alignment=i}get _index(){return this.mesh.geometry.index}get _pos(){return this.mesh.geometry.attributes.position.array}getLength(){let t=0;for(let e=0;e<this._index.array.length-1;e+=2){const{startPoint:s,endPoint:r}=this.getSegment(e);t+=s.distanceTo(r)}return t}getPointAt(t){const{startPoint:e,endPoint:s,distanceToStart:r}=this.getSegmentAt(t),i=s.clone();return i.sub(e),i.normalize(),i.multiplyScalar(r),i.add(e),i}getSegmentAt(t){t<0?t=0:t>1&&(t=1);const e=this.getLength()*t;let s=0;for(let t=0;t<this._index.array.length-1;t+=2){const{startPoint:r,endPoint:i}=this.getSegment(t),n=r.distanceTo(i);if(s+n>=e){return{distanceToStart:e-s,index:t,startPoint:r,endPoint:i}}s+=n}throw new Error("Could not compute point")}getPercentageAt(t,e=.01){let s=0;for(let r=0;r<this._index.array.length-1;r+=2){const{startPoint:i,endPoint:n}=this.getSegment(r),o=i.distanceTo(n),a=t.distanceTo(i);if(a+t.distanceTo(n)-o<=e){return(s+a)/this.getLength()}s+=o}return null}getSegment(t){const e=3*this._index.array[t],s=3*this._index.array[t+1];return{startPoint:new i.Vector3(this._pos[e],this._pos[e+1],this._pos[e+2]),endPoint:new i.Vector3(this._pos[s],this._pos[s+1],this._pos[s+2])}}}class ns extends i.LineSegments{constructor(t,s,r,i,n){super(i,n),e(this,"curve"),this.curve=new is(t,this,s,r)}}class os{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsStreamedGeometry(t,e){return(e||new os).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsStreamedGeometry(t,e){return t.setPosition(t.position()+4),(e||new os).__init(t.readInt32(t.position())+t.position(),t)}geometryId(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.readUint32(this.bb_pos+t):0}position(t){const e=this.bb.__offset(this.bb_pos,6);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}positionLength(){const t=this.bb.__offset(this.bb_pos,6);return t?this.bb.__vector_len(this.bb_pos+t):0}positionArray(){const t=this.bb.__offset(this.bb_pos,6);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}normal(t){const e=this.bb.__offset(this.bb_pos,8);return e?this.bb.readFloat32(this.bb.__vector(this.bb_pos+e)+4*t):0}normalLength(){const t=this.bb.__offset(this.bb_pos,8);return t?this.bb.__vector_len(this.bb_pos+t):0}normalArray(){const t=this.bb.__offset(this.bb_pos,8);return t?new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}index(t){const e=this.bb.__offset(this.bb_pos,10);return e?this.bb.readUint32(this.bb.__vector(this.bb_pos+e)+4*t):0}indexLength(){const t=this.bb.__offset(this.bb_pos,10);return t?this.bb.__vector_len(this.bb_pos+t):0}indexArray(){const t=this.bb.__offset(this.bb_pos,10);return t?new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset+this.bb.__vector(this.bb_pos+t),this.bb.__vector_len(this.bb_pos+t)):null}static startStreamedGeometry(t){t.startObject(4)}static addGeometryId(t,e){t.addFieldInt32(0,e,0)}static addPosition(t,e){t.addFieldOffset(1,e,0)}static createPositionVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startPositionVector(t,e){t.startVector(4,e,4)}static addNormal(t,e){t.addFieldOffset(2,e,0)}static createNormalVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addFloat32(e[s]);return t.endVector()}static startNormalVector(t,e){t.startVector(4,e,4)}static addIndex(t,e){t.addFieldOffset(3,e,0)}static createIndexVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addInt32(e[s]);return t.endVector()}static startIndexVector(t,e){t.startVector(4,e,4)}static endStreamedGeometry(t){return t.endObject()}static createStreamedGeometry(t,e,s,r,i){return os.startStreamedGeometry(t),os.addGeometryId(t,e),os.addPosition(t,s),os.addNormal(t,r),os.addIndex(t,i),os.endStreamedGeometry(t)}}class as{constructor(){e(this,"bb",null),e(this,"bb_pos",0)}__init(t,e){return this.bb_pos=t,this.bb=e,this}static getRootAsStreamedGeometries(t,e){return(e||new as).__init(t.readInt32(t.position())+t.position(),t)}static getSizePrefixedRootAsStreamedGeometries(t,e){return t.setPosition(t.position()+4),(e||new as).__init(t.readInt32(t.position())+t.position(),t)}geometries(t,e){const s=this.bb.__offset(this.bb_pos,4);return s?(e||new os).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos+s)+4*t),this.bb):null}geometriesLength(){const t=this.bb.__offset(this.bb_pos,4);return t?this.bb.__vector_len(this.bb_pos+t):0}static startStreamedGeometries(t){t.startObject(1)}static addGeometries(t,e){t.addFieldOffset(0,e,0)}static createGeometriesVector(t,e){t.startVector(4,e.length,4);for(let s=e.length-1;s>=0;s--)t.addOffset(e[s]);return t.endVector()}static startGeometriesVector(t,e){t.startVector(4,e,4)}static endStreamedGeometries(t){return t.endObject()}static finishStreamedGeometriesBuffer(t,e){t.finish(e)}static finishSizePrefixedStreamedGeometriesBuffer(t,e){t.finish(e,void 0,!0)}static createStreamedGeometries(t,e){return as.startStreamedGeometries(t),as.addGeometries(t,e),as.endStreamedGeometries(t)}}exports.Alignment=rs,exports.CivilCurve=is,exports.CurveMesh=ns,exports.Fragment=Se,exports.FragmentMesh=n,exports.FragmentUtils=class{static combine(t){if(0===t.length)return{};if(1===t.length)return t[0];const e={};for(const s of t)for(const t in s){e[t]||(e[t]=new Set);for(const r of s[t])e[t].add(r)}return e}static intersect(t){if(0===t.length)return{};if(1===t.length)return t[0];const e=new Map;let s=0;for(const r of t){s++;for(const t in r){e.has(t)||e.set(t,{count:0,ids:new Map});const s=e.get(t);s.count++;for(const e of r[t]){const t=s.ids.get(e)||0;s.ids.set(e,t+1)}}}const r={};for(const[t,{count:i,ids:n}]of e)if(i===s)for(const[e,i]of n)i===s&&(r[t]||(r[t]=new Set),r[t].add(e));return r}static copy(t){const e={};for(const s in t)e[s]=new Set(t[s]);return e}static export(t){const e={};for(const s in t)e[s]=Array.from(t[s]);return e}static import(t){const e={};for(const s in t)e[s]=new Set(t[s]);return e}},exports.FragmentsGroup=ss,exports.Serializer=class{constructor(){e(this,"parsers",[new Qe,new Xe]),e(this,"version","auto")}import(t){const e=this.parsers.length;if("auto"===this.version){for(let s=0;s<this.parsers.length;s++){const r=this.parsers[s].import(t);if(0!==Object.keys(r).length){if(0!==s){const t=this.parsers.length-s;this.warnVersion(t,e)}return r}}throw new Error("No valid parser found for this file")}this.checkCurrentVersionValid(this.version);const s=this.parsers.length-this.version,r=this.parsers[s].import(t);if(0===Object.keys(r).length)throw new Error(`The given version ${this.version} doesn't match to the given file. Try using "auto" in the version property to handle versions automatically.`);return r}export(t){if("auto"===this.version){return this.parsers[0].export(t)}this.checkCurrentVersionValid(this.version);const e=this.parsers.length-this.version;return this.parsers[e].export(t)}checkCurrentVersionValid(t){if("auto"===this.version)return;this.version!==t&&this.warnVersion(this.version,t);if(!Number.isInteger(this.version))throw new Error("Invalid version. Non-automatic versions must an integer.");if(this.version<1||this.version>t)throw new Error(`Invalid version. Versions range from 1 to ${t}.`)}warnVersion(t,e){console.warn(`This fragment file version is ${t}. The latest version is ${e}. To avoid issues, please consider updating your fragments. You can do so by regenerating your fragments from the original IFC file.`)}},exports.StreamSerializer=class{import(t){const e=new Ne(t),s=as.getRootAsStreamedGeometries(e),r=new Map,i=s.geometriesLength();for(let t=0;t<i;t++){const e=s.geometries(t);if(!e)continue;const i=e.geometryId();if(null===i)throw new Error("Error finding ID!");const n=e.positionArray(),o=e.normalArray(),a=e.indexArray();n&&o&&a&&r.set(i,{position:n,normal:o,index:a})}return r}export(t){const e=new Re(1024),s=[],r=as,i=os;for(const[r,{index:n,position:o,normal:a}]of t){const t=i.createIndexVector(e,n),c=i.createPositionVector(e,o),b=i.createNormalVector(e,a);i.startStreamedGeometry(e),i.addGeometryId(e,r),i.addIndex(e,t),i.addPosition(e,c),i.addNormal(e,b);const h=i.endStreamedGeometry(e);s.push(h)}const n=r.createGeometriesVector(e,s);r.startStreamedGeometries(e),r.addGeometries(e,n);const o=r.endStreamedGeometries(e);return e.finish(o),e.asUint8Array()}},exports.StreamerFileDb=ts;
