import {
  FILE_DESCRIPTION,
  FILE_NAME,
  Handle,
  IFC4,
  IFCBRIDGE,
  IFCBUILDING,
  IFCBUILDINGSTOREY,
  IFCCLASSIFICATION,
  IFCCLASSIFICATIONREFERENCE,
  IFCCOMPLEXPROPERTY,
  IFCELEMENTQUANTITY,
  IFCFACILITY,
  IFCFACILITYPART,
  IFCOPENINGELEMENT,
  IFCOWNERHISTORY,
  IFCPHYSICALCOMPLEXQUANTITY,
  IFCPROJECT,
  IFCPROPERTYENUMERATEDVALUE,
  IFCPROPERTYLISTVALUE,
  IFCPROPERTYSET,
  IFCRELAGGREGATES,
  IFCRELASSIGNSTOCONTROL,
  IFCRELASSIGNSTOGROUP,
  IFCRELASSIGNSTOPRODUCT,
  IFCRELASSOCIATESCLASSIFICATION,
  IFCRELASSOCIATESDOCUMENT,
  IFCRELASSOCIATESMATERIAL,
  IFCRELCONNECTSELEMENTS,
  IFCRELCONTAINEDINSPATIALSTRUCTURE,
  IFCRELDECLARES,
  IFCRELDEFINESBYPROPERTIES,
  IFCRELDEFINESBYTEMPLATE,
  IFCRELDEFINESBYTYPE,
  IFCRELFLOWCONTROLELEMENTS,
  IFCRELNESTS,
  IFCROAD,
  IFCSITE,
  IFCSPACE,
  IFCUNITASSIGNMENT,
  IfcAPI2,
  LogLevel,
  Schemas,
  web_ifc_api_exports
} from "./chunk-N4Q74TYM.js";
import {
  AmbientLight,
  BackSide,
  Box3,
  BoxGeometry,
  BufferAttribute,
  BufferGeometry,
  Clock,
  Color,
  ColorManagement,
  CylinderGeometry,
  DepthFormat,
  DepthTexture,
  DirectionalLight,
  DoubleSide,
  EdgesGeometry,
  Euler,
  Float32BufferAttribute,
  FrontSide,
  Group,
  InstancedMesh,
  Line,
  Line3,
  LineBasicMaterial,
  LineSegments,
  MOUSE,
  MathUtils,
  Matrix3,
  Matrix4,
  Mesh,
  MeshBasicMaterial,
  MeshDepthMaterial,
  MeshLambertMaterial,
  NearestFilter,
  Object3D,
  OctahedronGeometry,
  OrthographicCamera,
  PerspectiveCamera,
  Plane,
  PlaneGeometry,
  Quaternion,
  Ray,
  Raycaster,
  Scene,
  ShaderMaterial,
  Sphere,
  SphereGeometry,
  Spherical,
  TorusGeometry,
  Triangle,
  UnsignedShortType,
  Vector2,
  Vector3,
  Vector4,
  WebGLRenderTarget,
  WebGLRenderer
} from "./chunk-QNYFAHYS.js";
import "./chunk-PZ5AY32C.js";

// node_modules/@thatopen/fragments/dist/index.mjs
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var FragmentMesh = class extends InstancedMesh {
  /**
   * Constructs a new FragmentMesh.
   *
   * @param geometry - The geometry for the mesh. Must be indexed.
   * @param material - The material(s) for the mesh. If a single material is provided, it will be wrapped in an array.
   * @param count - The number of instances to create.
   * @param fragment - The fragment associated with this mesh.
   */
  constructor(geometry, material, count, fragment) {
    super(geometry, material, count);
    __publicField(this, "fragment");
    __publicField(this, "material");
    __publicField(this, "geometry");
    if (!Array.isArray(material)) {
      material = [material];
    }
    this.material = material;
    if (!geometry.index) {
      throw new Error("The geometry for fragments must be indexed!");
    }
    this.geometry = geometry;
    this.fragment = fragment;
    const size = geometry.index.count;
    if (!geometry.groups.length) {
      geometry.groups.push({
        start: 0,
        count: size,
        materialIndex: 0
      });
    }
  }
  /**
   * Exports the data of the fragment mesh to a serializable format.
   *
   * @returns An object containing the position, normal, index, groups, materials, matrices, and colors of the fragment mesh.
   */
  exportData() {
    const position = this.geometry.attributes.position.array;
    const normal = this.geometry.attributes.normal.array;
    const index = Array.from(this.geometry.index.array);
    const groups = [];
    for (const group of this.geometry.groups) {
      const index2 = group.materialIndex || 0;
      const { start, count } = group;
      groups.push(start, count, index2);
    }
    const materials = [];
    if (Array.isArray(this.material)) {
      for (const material of this.material) {
        const opacity = material.opacity;
        const transparent = material.transparent ? 1 : 0;
        const color = new Color(material.color).toArray();
        materials.push(opacity, transparent, ...color);
      }
    }
    const matrices = Array.from(this.instanceMatrix.array);
    let colors;
    if (this.instanceColor !== null) {
      colors = Array.from(this.instanceColor.array);
    } else {
      colors = [];
    }
    return {
      position,
      normal,
      index,
      groups,
      materials,
      matrices,
      colors
    };
  }
  clone(_recursive) {
    throw new Error(
      "Fragment meshes can't be cloned directly. Use mesh.fragment.clone instead!"
    );
  }
};
var CENTER = 0;
var AVERAGE = 1;
var SAH = 2;
var CONTAINED = 2;
var TRIANGLE_INTERSECT_COST = 1.25;
var TRAVERSAL_COST = 1;
var BYTES_PER_NODE = 6 * 4 + 4 + 4;
var IS_LEAFNODE_FLAG = 65535;
var FLOAT32_EPSILON = Math.pow(2, -24);
var SKIP_GENERATION = Symbol("SKIP_GENERATION");
function getVertexCount(geo) {
  return geo.index ? geo.index.count : geo.attributes.position.count;
}
function getTriCount(geo) {
  return getVertexCount(geo) / 3;
}
function getIndexArray(vertexCount, BufferConstructor = ArrayBuffer) {
  if (vertexCount > 65535) {
    return new Uint32Array(new BufferConstructor(4 * vertexCount));
  } else {
    return new Uint16Array(new BufferConstructor(2 * vertexCount));
  }
}
function ensureIndex(geo, options) {
  if (!geo.index) {
    const vertexCount = geo.attributes.position.count;
    const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
    const index = getIndexArray(vertexCount, BufferConstructor);
    geo.setIndex(new BufferAttribute(index, 1));
    for (let i = 0; i < vertexCount; i++) {
      index[i] = i;
    }
  }
}
function getFullGeometryRange(geo) {
  const triCount = getTriCount(geo);
  const drawRange = geo.drawRange;
  const start = drawRange.start / 3;
  const end = (drawRange.start + drawRange.count) / 3;
  const offset = Math.max(0, start);
  const count = Math.min(triCount, end) - offset;
  return [{
    offset: Math.floor(offset),
    count: Math.floor(count)
  }];
}
function getRootIndexRanges(geo) {
  if (!geo.groups || !geo.groups.length) {
    return getFullGeometryRange(geo);
  }
  const ranges = [];
  const rangeBoundaries = /* @__PURE__ */ new Set();
  const drawRange = geo.drawRange;
  const drawRangeStart = drawRange.start / 3;
  const drawRangeEnd = (drawRange.start + drawRange.count) / 3;
  for (const group of geo.groups) {
    const groupStart = group.start / 3;
    const groupEnd = (group.start + group.count) / 3;
    rangeBoundaries.add(Math.max(drawRangeStart, groupStart));
    rangeBoundaries.add(Math.min(drawRangeEnd, groupEnd));
  }
  const sortedBoundaries = Array.from(rangeBoundaries.values()).sort((a, b) => a - b);
  for (let i = 0; i < sortedBoundaries.length - 1; i++) {
    const start = sortedBoundaries[i];
    const end = sortedBoundaries[i + 1];
    ranges.push({
      offset: Math.floor(start),
      count: Math.floor(end - start)
    });
  }
  return ranges;
}
function hasGroupGaps(geometry) {
  if (geometry.groups.length === 0) {
    return false;
  }
  const vertexCount = getTriCount(geometry);
  const groups = getRootIndexRanges(geometry).sort((a, b) => a.offset - b.offset);
  const finalGroup = groups[groups.length - 1];
  finalGroup.count = Math.min(vertexCount - finalGroup.offset, finalGroup.count);
  let total = 0;
  groups.forEach(({ count }) => total += count);
  return vertexCount !== total;
}
function arrayToBox(nodeIndex32, array, target) {
  target.min.x = array[nodeIndex32];
  target.min.y = array[nodeIndex32 + 1];
  target.min.z = array[nodeIndex32 + 2];
  target.max.x = array[nodeIndex32 + 3];
  target.max.y = array[nodeIndex32 + 4];
  target.max.z = array[nodeIndex32 + 5];
  return target;
}
function makeEmptyBounds(target) {
  target[0] = target[1] = target[2] = Infinity;
  target[3] = target[4] = target[5] = -Infinity;
}
function getLongestEdgeIndex(bounds) {
  let splitDimIdx = -1;
  let splitDist = -Infinity;
  for (let i = 0; i < 3; i++) {
    const dist = bounds[i + 3] - bounds[i];
    if (dist > splitDist) {
      splitDist = dist;
      splitDimIdx = i;
    }
  }
  return splitDimIdx;
}
function copyBounds(source, target) {
  target.set(source);
}
function unionBounds(a, b, target) {
  let aVal, bVal;
  for (let d = 0; d < 3; d++) {
    const d3 = d + 3;
    aVal = a[d];
    bVal = b[d];
    target[d] = aVal < bVal ? aVal : bVal;
    aVal = a[d3];
    bVal = b[d3];
    target[d3] = aVal > bVal ? aVal : bVal;
  }
}
function expandByTriangleBounds(startIndex, triangleBounds, bounds) {
  for (let d = 0; d < 3; d++) {
    const tCenter = triangleBounds[startIndex + 2 * d];
    const tHalf = triangleBounds[startIndex + 2 * d + 1];
    const tMin = tCenter - tHalf;
    const tMax = tCenter + tHalf;
    if (tMin < bounds[d]) {
      bounds[d] = tMin;
    }
    if (tMax > bounds[d + 3]) {
      bounds[d + 3] = tMax;
    }
  }
}
function computeSurfaceArea(bounds) {
  const d0 = bounds[3] - bounds[0];
  const d1 = bounds[4] - bounds[1];
  const d2 = bounds[5] - bounds[2];
  return 2 * (d0 * d1 + d1 * d2 + d2 * d0);
}
function getBounds(triangleBounds, offset, count, target, centroidTarget = null) {
  let minx = Infinity;
  let miny = Infinity;
  let minz = Infinity;
  let maxx = -Infinity;
  let maxy = -Infinity;
  let maxz = -Infinity;
  let cminx = Infinity;
  let cminy = Infinity;
  let cminz = Infinity;
  let cmaxx = -Infinity;
  let cmaxy = -Infinity;
  let cmaxz = -Infinity;
  const includeCentroid = centroidTarget !== null;
  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {
    const cx = triangleBounds[i + 0];
    const hx = triangleBounds[i + 1];
    const lx = cx - hx;
    const rx = cx + hx;
    if (lx < minx)
      minx = lx;
    if (rx > maxx)
      maxx = rx;
    if (includeCentroid && cx < cminx)
      cminx = cx;
    if (includeCentroid && cx > cmaxx)
      cmaxx = cx;
    const cy = triangleBounds[i + 2];
    const hy = triangleBounds[i + 3];
    const ly = cy - hy;
    const ry = cy + hy;
    if (ly < miny)
      miny = ly;
    if (ry > maxy)
      maxy = ry;
    if (includeCentroid && cy < cminy)
      cminy = cy;
    if (includeCentroid && cy > cmaxy)
      cmaxy = cy;
    const cz = triangleBounds[i + 4];
    const hz = triangleBounds[i + 5];
    const lz = cz - hz;
    const rz = cz + hz;
    if (lz < minz)
      minz = lz;
    if (rz > maxz)
      maxz = rz;
    if (includeCentroid && cz < cminz)
      cminz = cz;
    if (includeCentroid && cz > cmaxz)
      cmaxz = cz;
  }
  target[0] = minx;
  target[1] = miny;
  target[2] = minz;
  target[3] = maxx;
  target[4] = maxy;
  target[5] = maxz;
  if (includeCentroid) {
    centroidTarget[0] = cminx;
    centroidTarget[1] = cminy;
    centroidTarget[2] = cminz;
    centroidTarget[3] = cmaxx;
    centroidTarget[4] = cmaxy;
    centroidTarget[5] = cmaxz;
  }
}
function getCentroidBounds(triangleBounds, offset, count, centroidTarget) {
  let cminx = Infinity;
  let cminy = Infinity;
  let cminz = Infinity;
  let cmaxx = -Infinity;
  let cmaxy = -Infinity;
  let cmaxz = -Infinity;
  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {
    const cx = triangleBounds[i + 0];
    if (cx < cminx)
      cminx = cx;
    if (cx > cmaxx)
      cmaxx = cx;
    const cy = triangleBounds[i + 2];
    if (cy < cminy)
      cminy = cy;
    if (cy > cmaxy)
      cmaxy = cy;
    const cz = triangleBounds[i + 4];
    if (cz < cminz)
      cminz = cz;
    if (cz > cmaxz)
      cmaxz = cz;
  }
  centroidTarget[0] = cminx;
  centroidTarget[1] = cminy;
  centroidTarget[2] = cminz;
  centroidTarget[3] = cmaxx;
  centroidTarget[4] = cmaxy;
  centroidTarget[5] = cmaxz;
}
function computeTriangleBounds(geo, fullBounds) {
  makeEmptyBounds(fullBounds);
  const posAttr = geo.attributes.position;
  const index = geo.index ? geo.index.array : null;
  const triCount = getTriCount(geo);
  const triangleBounds = new Float32Array(triCount * 6);
  const normalized = posAttr.normalized;
  const posArr = posAttr.array;
  const bufferOffset = posAttr.offset || 0;
  let stride = 3;
  if (posAttr.isInterleavedBufferAttribute) {
    stride = posAttr.data.stride;
  }
  const getters = ["getX", "getY", "getZ"];
  for (let tri = 0; tri < triCount; tri++) {
    const tri3 = tri * 3;
    const tri6 = tri * 6;
    let ai = tri3 + 0;
    let bi = tri3 + 1;
    let ci = tri3 + 2;
    if (index) {
      ai = index[ai];
      bi = index[bi];
      ci = index[ci];
    }
    if (!normalized) {
      ai = ai * stride + bufferOffset;
      bi = bi * stride + bufferOffset;
      ci = ci * stride + bufferOffset;
    }
    for (let el = 0; el < 3; el++) {
      let a, b, c;
      if (normalized) {
        a = posAttr[getters[el]](ai);
        b = posAttr[getters[el]](bi);
        c = posAttr[getters[el]](ci);
      } else {
        a = posArr[ai + el];
        b = posArr[bi + el];
        c = posArr[ci + el];
      }
      let min = a;
      if (b < min)
        min = b;
      if (c < min)
        min = c;
      let max = a;
      if (b > max)
        max = b;
      if (c > max)
        max = c;
      const halfExtents = (max - min) / 2;
      const el2 = el * 2;
      triangleBounds[tri6 + el2 + 0] = min + halfExtents;
      triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * FLOAT32_EPSILON;
      if (min < fullBounds[el])
        fullBounds[el] = min;
      if (max > fullBounds[el + 3])
        fullBounds[el + 3] = max;
    }
  }
  return triangleBounds;
}
var BIN_COUNT = 32;
var binsSort = (a, b) => a.candidate - b.candidate;
var sahBins = new Array(BIN_COUNT).fill().map(() => {
  return {
    count: 0,
    bounds: new Float32Array(6),
    rightCacheBounds: new Float32Array(6),
    leftCacheBounds: new Float32Array(6),
    candidate: 0
  };
});
var leftBounds = new Float32Array(6);
function getOptimalSplit(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {
  let axis = -1;
  let pos = 0;
  if (strategy === CENTER) {
    axis = getLongestEdgeIndex(centroidBoundingData);
    if (axis !== -1) {
      pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;
    }
  } else if (strategy === AVERAGE) {
    axis = getLongestEdgeIndex(nodeBoundingData);
    if (axis !== -1) {
      pos = getAverage(triangleBounds, offset, count, axis);
    }
  } else if (strategy === SAH) {
    const rootSurfaceArea = computeSurfaceArea(nodeBoundingData);
    let bestCost = TRIANGLE_INTERSECT_COST * count;
    const cStart = offset * 6;
    const cEnd = (offset + count) * 6;
    for (let a = 0; a < 3; a++) {
      const axisLeft = centroidBoundingData[a];
      const axisRight = centroidBoundingData[a + 3];
      const axisLength = axisRight - axisLeft;
      const binWidth = axisLength / BIN_COUNT;
      if (count < BIN_COUNT / 4) {
        const truncatedBins = [...sahBins];
        truncatedBins.length = count;
        let b = 0;
        for (let c = cStart; c < cEnd; c += 6, b++) {
          const bin = truncatedBins[b];
          bin.candidate = triangleBounds[c + 2 * a];
          bin.count = 0;
          const {
            bounds,
            leftCacheBounds,
            rightCacheBounds
          } = bin;
          for (let d = 0; d < 3; d++) {
            rightCacheBounds[d] = Infinity;
            rightCacheBounds[d + 3] = -Infinity;
            leftCacheBounds[d] = Infinity;
            leftCacheBounds[d + 3] = -Infinity;
            bounds[d] = Infinity;
            bounds[d + 3] = -Infinity;
          }
          expandByTriangleBounds(c, triangleBounds, bounds);
        }
        truncatedBins.sort(binsSort);
        let splitCount = count;
        for (let bi = 0; bi < splitCount; bi++) {
          const bin = truncatedBins[bi];
          while (bi + 1 < splitCount && truncatedBins[bi + 1].candidate === bin.candidate) {
            truncatedBins.splice(bi + 1, 1);
            splitCount--;
          }
        }
        for (let c = cStart; c < cEnd; c += 6) {
          const center = triangleBounds[c + 2 * a];
          for (let bi = 0; bi < splitCount; bi++) {
            const bin = truncatedBins[bi];
            if (center >= bin.candidate) {
              expandByTriangleBounds(c, triangleBounds, bin.rightCacheBounds);
            } else {
              expandByTriangleBounds(c, triangleBounds, bin.leftCacheBounds);
              bin.count++;
            }
          }
        }
        for (let bi = 0; bi < splitCount; bi++) {
          const bin = truncatedBins[bi];
          const leftCount = bin.count;
          const rightCount = count - bin.count;
          const leftBounds22 = bin.leftCacheBounds;
          const rightBounds = bin.rightCacheBounds;
          let leftProb = 0;
          if (leftCount !== 0) {
            leftProb = computeSurfaceArea(leftBounds22) / rootSurfaceArea;
          }
          let rightProb = 0;
          if (rightCount !== 0) {
            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;
          }
          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);
          if (cost < bestCost) {
            axis = a;
            bestCost = cost;
            pos = bin.candidate;
          }
        }
      } else {
        for (let i = 0; i < BIN_COUNT; i++) {
          const bin = sahBins[i];
          bin.count = 0;
          bin.candidate = axisLeft + binWidth + i * binWidth;
          const bounds = bin.bounds;
          for (let d = 0; d < 3; d++) {
            bounds[d] = Infinity;
            bounds[d + 3] = -Infinity;
          }
        }
        for (let c = cStart; c < cEnd; c += 6) {
          const triCenter = triangleBounds[c + 2 * a];
          const relativeCenter = triCenter - axisLeft;
          let binIndex = ~~(relativeCenter / binWidth);
          if (binIndex >= BIN_COUNT)
            binIndex = BIN_COUNT - 1;
          const bin = sahBins[binIndex];
          bin.count++;
          expandByTriangleBounds(c, triangleBounds, bin.bounds);
        }
        const lastBin = sahBins[BIN_COUNT - 1];
        copyBounds(lastBin.bounds, lastBin.rightCacheBounds);
        for (let i = BIN_COUNT - 2; i >= 0; i--) {
          const bin = sahBins[i];
          const nextBin = sahBins[i + 1];
          unionBounds(bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds);
        }
        let leftCount = 0;
        for (let i = 0; i < BIN_COUNT - 1; i++) {
          const bin = sahBins[i];
          const binCount = bin.count;
          const bounds = bin.bounds;
          const nextBin = sahBins[i + 1];
          const rightBounds = nextBin.rightCacheBounds;
          if (binCount !== 0) {
            if (leftCount === 0) {
              copyBounds(bounds, leftBounds);
            } else {
              unionBounds(bounds, leftBounds, leftBounds);
            }
          }
          leftCount += binCount;
          let leftProb = 0;
          let rightProb = 0;
          if (leftCount !== 0) {
            leftProb = computeSurfaceArea(leftBounds) / rootSurfaceArea;
          }
          const rightCount = count - leftCount;
          if (rightCount !== 0) {
            rightProb = computeSurfaceArea(rightBounds) / rootSurfaceArea;
          }
          const cost = TRAVERSAL_COST + TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);
          if (cost < bestCost) {
            axis = a;
            bestCost = cost;
            pos = bin.candidate;
          }
        }
      }
    }
  } else {
    console.warn(`MeshBVH: Invalid build strategy value ${strategy} used.`);
  }
  return { axis, pos };
}
function getAverage(triangleBounds, offset, count, axis) {
  let avg = 0;
  for (let i = offset, end = offset + count; i < end; i++) {
    avg += triangleBounds[i * 6 + axis * 2];
  }
  return avg / count;
}
var MeshBVHNode = class {
  constructor() {
  }
};
function partition(indirectBuffer, index, triangleBounds, offset, count, split) {
  let left = offset;
  let right = offset + count - 1;
  const pos = split.pos;
  const axisOffset = split.axis * 2;
  while (true) {
    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {
      left++;
    }
    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {
      right--;
    }
    if (left < right) {
      for (let i = 0; i < 3; i++) {
        let t0 = index[left * 3 + i];
        index[left * 3 + i] = index[right * 3 + i];
        index[right * 3 + i] = t0;
      }
      for (let i = 0; i < 6; i++) {
        let tb = triangleBounds[left * 6 + i];
        triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];
        triangleBounds[right * 6 + i] = tb;
      }
      left++;
      right--;
    } else {
      return left;
    }
  }
}
function partition_indirect(indirectBuffer, index, triangleBounds, offset, count, split) {
  let left = offset;
  let right = offset + count - 1;
  const pos = split.pos;
  const axisOffset = split.axis * 2;
  while (true) {
    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {
      left++;
    }
    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {
      right--;
    }
    if (left < right) {
      let t = indirectBuffer[left];
      indirectBuffer[left] = indirectBuffer[right];
      indirectBuffer[right] = t;
      for (let i = 0; i < 6; i++) {
        let tb = triangleBounds[left * 6 + i];
        triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];
        triangleBounds[right * 6 + i] = tb;
      }
      left++;
      right--;
    } else {
      return left;
    }
  }
}
function generateIndirectBuffer(geometry, useSharedArrayBuffer) {
  const triCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;
  const useUint32 = triCount > 2 ** 16;
  const byteCount = useUint32 ? 4 : 2;
  const buffer = useSharedArrayBuffer ? new SharedArrayBuffer(triCount * byteCount) : new ArrayBuffer(triCount * byteCount);
  const indirectBuffer = useUint32 ? new Uint32Array(buffer) : new Uint16Array(buffer);
  for (let i = 0, l = indirectBuffer.length; i < l; i++) {
    indirectBuffer[i] = i;
  }
  return indirectBuffer;
}
function buildTree(bvh, options) {
  const geometry = bvh.geometry;
  const indexArray = geometry.index ? geometry.index.array : null;
  const maxDepth = options.maxDepth;
  const verbose = options.verbose;
  const maxLeafTris = options.maxLeafTris;
  const strategy = options.strategy;
  const onProgress = options.onProgress;
  const totalTriangles = getTriCount(geometry);
  const indirectBuffer = bvh._indirectBuffer;
  let reachedMaxDepth = false;
  const fullBounds = new Float32Array(6);
  const cacheCentroidBoundingData = new Float32Array(6);
  const triangleBounds = computeTriangleBounds(geometry, fullBounds);
  const partionFunc = options.indirect ? partition_indirect : partition;
  const roots = [];
  const ranges = options.indirect ? getFullGeometryRange(geometry) : getRootIndexRanges(geometry);
  if (ranges.length === 1) {
    const range = ranges[0];
    const root = new MeshBVHNode();
    root.boundingData = fullBounds;
    getCentroidBounds(triangleBounds, range.offset, range.count, cacheCentroidBoundingData);
    splitNode(root, range.offset, range.count, cacheCentroidBoundingData);
    roots.push(root);
  } else {
    for (let range of ranges) {
      const root = new MeshBVHNode();
      root.boundingData = new Float32Array(6);
      getBounds(triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData);
      splitNode(root, range.offset, range.count, cacheCentroidBoundingData);
      roots.push(root);
    }
  }
  return roots;
  function triggerProgress(trianglesProcessed) {
    if (onProgress) {
      onProgress(trianglesProcessed / totalTriangles);
    }
  }
  function splitNode(node, offset, count, centroidBoundingData = null, depth = 0) {
    if (!reachedMaxDepth && depth >= maxDepth) {
      reachedMaxDepth = true;
      if (verbose) {
        console.warn(`MeshBVH: Max depth of ${maxDepth} reached when generating BVH. Consider increasing maxDepth.`);
        console.warn(geometry);
      }
    }
    if (count <= maxLeafTris || depth >= maxDepth) {
      triggerProgress(offset + count);
      node.offset = offset;
      node.count = count;
      return node;
    }
    const split = getOptimalSplit(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);
    if (split.axis === -1) {
      triggerProgress(offset + count);
      node.offset = offset;
      node.count = count;
      return node;
    }
    const splitOffset = partionFunc(indirectBuffer, indexArray, triangleBounds, offset, count, split);
    if (splitOffset === offset || splitOffset === offset + count) {
      triggerProgress(offset + count);
      node.offset = offset;
      node.count = count;
    } else {
      node.splitAxis = split.axis;
      const left = new MeshBVHNode();
      const lstart = offset;
      const lcount = splitOffset - offset;
      node.left = left;
      left.boundingData = new Float32Array(6);
      getBounds(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);
      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);
      const right = new MeshBVHNode();
      const rstart = splitOffset;
      const rcount = count - lcount;
      node.right = right;
      right.boundingData = new Float32Array(6);
      getBounds(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);
      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);
    }
    return node;
  }
}
function buildPackedTree(bvh, options) {
  const geometry = bvh.geometry;
  if (options.indirect) {
    bvh._indirectBuffer = generateIndirectBuffer(geometry, options.useSharedArrayBuffer);
    if (hasGroupGaps(geometry) && !options.verbose) {
      console.warn(
        'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
      );
    }
  }
  if (!bvh._indirectBuffer) {
    ensureIndex(geometry, options);
  }
  const roots = buildTree(bvh, options);
  let float32Array;
  let uint32Array;
  let uint16Array;
  const packedRoots = [];
  const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
  for (let i = 0; i < roots.length; i++) {
    const root = roots[i];
    let nodeCount = countNodes(root);
    const buffer = new BufferConstructor(BYTES_PER_NODE * nodeCount);
    float32Array = new Float32Array(buffer);
    uint32Array = new Uint32Array(buffer);
    uint16Array = new Uint16Array(buffer);
    populateBuffer(0, root);
    packedRoots.push(buffer);
  }
  bvh._roots = packedRoots;
  return;
  function countNodes(node) {
    if (node.count) {
      return 1;
    } else {
      return 1 + countNodes(node.left) + countNodes(node.right);
    }
  }
  function populateBuffer(byteOffset, node) {
    const stride4Offset = byteOffset / 4;
    const stride2Offset = byteOffset / 2;
    const isLeaf = !!node.count;
    const boundingData = node.boundingData;
    for (let i = 0; i < 6; i++) {
      float32Array[stride4Offset + i] = boundingData[i];
    }
    if (isLeaf) {
      const offset = node.offset;
      const count = node.count;
      uint32Array[stride4Offset + 6] = offset;
      uint16Array[stride2Offset + 14] = count;
      uint16Array[stride2Offset + 15] = IS_LEAFNODE_FLAG;
      return byteOffset + BYTES_PER_NODE;
    } else {
      const left = node.left;
      const right = node.right;
      const splitAxis = node.splitAxis;
      let nextUnusedPointer;
      nextUnusedPointer = populateBuffer(byteOffset + BYTES_PER_NODE, left);
      if (nextUnusedPointer / 4 > Math.pow(2, 32)) {
        throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
      }
      uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;
      nextUnusedPointer = populateBuffer(nextUnusedPointer, right);
      uint32Array[stride4Offset + 7] = splitAxis;
      return nextUnusedPointer;
    }
  }
}
var SeparatingAxisBounds = class {
  constructor() {
    this.min = Infinity;
    this.max = -Infinity;
  }
  setFromPointsField(points, field) {
    let min = Infinity;
    let max = -Infinity;
    for (let i = 0, l = points.length; i < l; i++) {
      const p = points[i];
      const val2 = p[field];
      min = val2 < min ? val2 : min;
      max = val2 > max ? val2 : max;
    }
    this.min = min;
    this.max = max;
  }
  setFromPoints(axis, points) {
    let min = Infinity;
    let max = -Infinity;
    for (let i = 0, l = points.length; i < l; i++) {
      const p = points[i];
      const val2 = axis.dot(p);
      min = val2 < min ? val2 : min;
      max = val2 > max ? val2 : max;
    }
    this.min = min;
    this.max = max;
  }
  isSeparated(other) {
    return this.min > other.max || other.min > this.max;
  }
};
SeparatingAxisBounds.prototype.setFromBox = function() {
  const p = new Vector3();
  return function setFromBox(axis, box) {
    const boxMin = box.min;
    const boxMax = box.max;
    let min = Infinity;
    let max = -Infinity;
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          p.x = boxMin.x * x + boxMax.x * (1 - x);
          p.y = boxMin.y * y + boxMax.y * (1 - y);
          p.z = boxMin.z * z + boxMax.z * (1 - z);
          const val2 = axis.dot(p);
          min = Math.min(val2, min);
          max = Math.max(val2, max);
        }
      }
    }
    this.min = min;
    this.max = max;
  };
}();
var closestPointLineToLine = function() {
  const dir1 = new Vector3();
  const dir2 = new Vector3();
  const v02 = new Vector3();
  return function closestPointLineToLine22(l1, l2, result) {
    const v0 = l1.start;
    const v10 = dir1;
    const v2 = l2.start;
    const v32 = dir2;
    v02.subVectors(v0, v2);
    dir1.subVectors(l1.end, l1.start);
    dir2.subVectors(l2.end, l2.start);
    const d0232 = v02.dot(v32);
    const d3210 = v32.dot(v10);
    const d3232 = v32.dot(v32);
    const d0210 = v02.dot(v10);
    const d1010 = v10.dot(v10);
    const denom = d1010 * d3232 - d3210 * d3210;
    let d, d2;
    if (denom !== 0) {
      d = (d0232 * d3210 - d0210 * d3232) / denom;
    } else {
      d = 0;
    }
    d2 = (d0232 + d * d3210) / d3232;
    result.x = d;
    result.y = d2;
  };
}();
var closestPointsSegmentToSegment = function() {
  const paramResult = new Vector2();
  const temp122 = new Vector3();
  const temp222 = new Vector3();
  return function closestPointsSegmentToSegment22(l1, l2, target1, target2) {
    closestPointLineToLine(l1, l2, paramResult);
    let d = paramResult.x;
    let d2 = paramResult.y;
    if (d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1) {
      l1.at(d, target1);
      l2.at(d2, target2);
      return;
    } else if (d >= 0 && d <= 1) {
      if (d2 < 0) {
        l2.at(0, target2);
      } else {
        l2.at(1, target2);
      }
      l1.closestPointToPoint(target2, true, target1);
      return;
    } else if (d2 >= 0 && d2 <= 1) {
      if (d < 0) {
        l1.at(0, target1);
      } else {
        l1.at(1, target1);
      }
      l2.closestPointToPoint(target1, true, target2);
      return;
    } else {
      let p;
      if (d < 0) {
        p = l1.start;
      } else {
        p = l1.end;
      }
      let p2;
      if (d2 < 0) {
        p2 = l2.start;
      } else {
        p2 = l2.end;
      }
      const closestPoint = temp122;
      const closestPoint2 = temp222;
      l1.closestPointToPoint(p2, true, temp122);
      l2.closestPointToPoint(p, true, temp222);
      if (closestPoint.distanceToSquared(p2) <= closestPoint2.distanceToSquared(p)) {
        target1.copy(closestPoint);
        target2.copy(p2);
        return;
      } else {
        target1.copy(p);
        target2.copy(closestPoint2);
        return;
      }
    }
  };
}();
var sphereIntersectTriangle = function() {
  const closestPointTemp = new Vector3();
  const projectedPointTemp = new Vector3();
  const planeTemp = new Plane();
  const lineTemp = new Line3();
  return function sphereIntersectTriangle22(sphere, triangle32) {
    const { radius, center } = sphere;
    const { a, b, c } = triangle32;
    lineTemp.start = a;
    lineTemp.end = b;
    const closestPoint1 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint1.distanceTo(center) <= radius)
      return true;
    lineTemp.start = a;
    lineTemp.end = c;
    const closestPoint2 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint2.distanceTo(center) <= radius)
      return true;
    lineTemp.start = b;
    lineTemp.end = c;
    const closestPoint3 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint3.distanceTo(center) <= radius)
      return true;
    const plane = triangle32.getPlane(planeTemp);
    const dp = Math.abs(plane.distanceToPoint(center));
    if (dp <= radius) {
      const pp = plane.projectPoint(center, projectedPointTemp);
      const cp = triangle32.containsPoint(pp);
      if (cp)
        return true;
    }
    return false;
  };
}();
var ZERO_EPSILON = 1e-15;
function isNearZero(value) {
  return Math.abs(value) < ZERO_EPSILON;
}
var ExtendedTriangle = class extends Triangle {
  constructor(...args) {
    super(...args);
    this.isExtendedTriangle = true;
    this.satAxes = new Array(4).fill().map(() => new Vector3());
    this.satBounds = new Array(4).fill().map(() => new SeparatingAxisBounds());
    this.points = [this.a, this.b, this.c];
    this.sphere = new Sphere();
    this.plane = new Plane();
    this.needsUpdate = true;
  }
  intersectsSphere(sphere) {
    return sphereIntersectTriangle(sphere, this);
  }
  update() {
    const a = this.a;
    const b = this.b;
    const c = this.c;
    const points = this.points;
    const satAxes = this.satAxes;
    const satBounds = this.satBounds;
    const axis0 = satAxes[0];
    const sab0 = satBounds[0];
    this.getNormal(axis0);
    sab0.setFromPoints(axis0, points);
    const axis1 = satAxes[1];
    const sab1 = satBounds[1];
    axis1.subVectors(a, b);
    sab1.setFromPoints(axis1, points);
    const axis2 = satAxes[2];
    const sab2 = satBounds[2];
    axis2.subVectors(b, c);
    sab2.setFromPoints(axis2, points);
    const axis3 = satAxes[3];
    const sab3 = satBounds[3];
    axis3.subVectors(c, a);
    sab3.setFromPoints(axis3, points);
    this.sphere.setFromPoints(this.points);
    this.plane.setFromNormalAndCoplanarPoint(axis0, a);
    this.needsUpdate = false;
  }
};
ExtendedTriangle.prototype.closestPointToSegment = function() {
  const point1 = new Vector3();
  const point2 = new Vector3();
  const edge = new Line3();
  return function distanceToSegment(segment, target1 = null, target2 = null) {
    const { start, end } = segment;
    const points = this.points;
    let distSq;
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 3; i++) {
      const nexti = (i + 1) % 3;
      edge.start.copy(points[i]);
      edge.end.copy(points[nexti]);
      closestPointsSegmentToSegment(edge, segment, point1, point2);
      distSq = point1.distanceToSquared(point2);
      if (distSq < closestDistanceSq) {
        closestDistanceSq = distSq;
        if (target1)
          target1.copy(point1);
        if (target2)
          target2.copy(point2);
      }
    }
    this.closestPointToPoint(start, point1);
    distSq = start.distanceToSquared(point1);
    if (distSq < closestDistanceSq) {
      closestDistanceSq = distSq;
      if (target1)
        target1.copy(point1);
      if (target2)
        target2.copy(start);
    }
    this.closestPointToPoint(end, point1);
    distSq = end.distanceToSquared(point1);
    if (distSq < closestDistanceSq) {
      closestDistanceSq = distSq;
      if (target1)
        target1.copy(point1);
      if (target2)
        target2.copy(end);
    }
    return Math.sqrt(closestDistanceSq);
  };
}();
ExtendedTriangle.prototype.intersectsTriangle = function() {
  const saTri2 = new ExtendedTriangle();
  const arr1 = new Array(3);
  const arr2 = new Array(3);
  const cachedSatBounds = new SeparatingAxisBounds();
  const cachedSatBounds2 = new SeparatingAxisBounds();
  const cachedAxis = new Vector3();
  const dir = new Vector3();
  const dir1 = new Vector3();
  const dir2 = new Vector3();
  const tempDir = new Vector3();
  const edge = new Line3();
  const edge1 = new Line3();
  const edge2 = new Line3();
  const tempPoint = new Vector3();
  function triIntersectPlane(tri, plane, targetEdge) {
    const points = tri.points;
    let count = 0;
    let startPointIntersection = -1;
    for (let i = 0; i < 3; i++) {
      const { start, end } = edge;
      start.copy(points[i]);
      end.copy(points[(i + 1) % 3]);
      edge.delta(dir);
      const startIntersects = isNearZero(plane.distanceToPoint(start));
      if (isNearZero(plane.normal.dot(dir)) && startIntersects) {
        targetEdge.copy(edge);
        count = 2;
        break;
      }
      const doesIntersect = plane.intersectLine(edge, tempPoint);
      if (!doesIntersect && startIntersects) {
        tempPoint.copy(start);
      }
      if ((doesIntersect || startIntersects) && !isNearZero(tempPoint.distanceTo(end))) {
        if (count <= 1) {
          const point = count === 1 ? targetEdge.start : targetEdge.end;
          point.copy(tempPoint);
          if (startIntersects) {
            startPointIntersection = count;
          }
        } else if (count >= 2) {
          const point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;
          point.copy(tempPoint);
          count = 2;
          break;
        }
        count++;
        if (count === 2 && startPointIntersection === -1) {
          break;
        }
      }
    }
    return count;
  }
  return function intersectsTriangle(other, target = null, suppressLog = false) {
    if (this.needsUpdate) {
      this.update();
    }
    if (!other.isExtendedTriangle) {
      saTri2.copy(other);
      saTri2.update();
      other = saTri2;
    } else if (other.needsUpdate) {
      other.update();
    }
    const plane1 = this.plane;
    const plane2 = other.plane;
    if (Math.abs(plane1.normal.dot(plane2.normal)) > 1 - 1e-10) {
      const satBounds1 = this.satBounds;
      const satAxes1 = this.satAxes;
      arr2[0] = other.a;
      arr2[1] = other.b;
      arr2[2] = other.c;
      for (let i = 0; i < 4; i++) {
        const sb = satBounds1[i];
        const sa = satAxes1[i];
        cachedSatBounds.setFromPoints(sa, arr2);
        if (sb.isSeparated(cachedSatBounds))
          return false;
      }
      const satBounds2 = other.satBounds;
      const satAxes2 = other.satAxes;
      arr1[0] = this.a;
      arr1[1] = this.b;
      arr1[2] = this.c;
      for (let i = 0; i < 4; i++) {
        const sb = satBounds2[i];
        const sa = satAxes2[i];
        cachedSatBounds.setFromPoints(sa, arr1);
        if (sb.isSeparated(cachedSatBounds))
          return false;
      }
      for (let i = 0; i < 4; i++) {
        const sa1 = satAxes1[i];
        for (let i2 = 0; i2 < 4; i2++) {
          const sa2 = satAxes2[i2];
          cachedAxis.crossVectors(sa1, sa2);
          cachedSatBounds.setFromPoints(cachedAxis, arr1);
          cachedSatBounds2.setFromPoints(cachedAxis, arr2);
          if (cachedSatBounds.isSeparated(cachedSatBounds2))
            return false;
        }
      }
      if (target) {
        if (!suppressLog) {
          console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.");
        }
        target.start.set(0, 0, 0);
        target.end.set(0, 0, 0);
      }
      return true;
    } else {
      const count1 = triIntersectPlane(this, plane2, edge1);
      if (count1 === 1 && other.containsPoint(edge1.end)) {
        if (target) {
          target.start.copy(edge1.end);
          target.end.copy(edge1.end);
        }
        return true;
      } else if (count1 !== 2) {
        return false;
      }
      const count2 = triIntersectPlane(other, plane1, edge2);
      if (count2 === 1 && this.containsPoint(edge2.end)) {
        if (target) {
          target.start.copy(edge2.end);
          target.end.copy(edge2.end);
        }
        return true;
      } else if (count2 !== 2) {
        return false;
      }
      edge1.delta(dir1);
      edge2.delta(dir2);
      if (dir1.dot(dir2) < 0) {
        let tmp = edge2.start;
        edge2.start = edge2.end;
        edge2.end = tmp;
      }
      const s1 = edge1.start.dot(dir1);
      const e1 = edge1.end.dot(dir1);
      const s2 = edge2.start.dot(dir1);
      const e2 = edge2.end.dot(dir1);
      const separated1 = e1 < s2;
      const separated2 = s1 < e2;
      if (s1 !== e2 && s2 !== e1 && separated1 === separated2) {
        return false;
      }
      if (target) {
        tempDir.subVectors(edge1.start, edge2.start);
        if (tempDir.dot(dir1) > 0) {
          target.start.copy(edge1.start);
        } else {
          target.start.copy(edge2.start);
        }
        tempDir.subVectors(edge1.end, edge2.end);
        if (tempDir.dot(dir1) < 0) {
          target.end.copy(edge1.end);
        } else {
          target.end.copy(edge2.end);
        }
      }
      return true;
    }
  };
}();
ExtendedTriangle.prototype.distanceToPoint = function() {
  const target = new Vector3();
  return function distanceToPoint(point) {
    this.closestPointToPoint(point, target);
    return point.distanceTo(target);
  };
}();
ExtendedTriangle.prototype.distanceToTriangle = function() {
  const point = new Vector3();
  const point2 = new Vector3();
  const cornerFields = ["a", "b", "c"];
  const line1 = new Line3();
  const line2 = new Line3();
  return function distanceToTriangle(other, target1 = null, target2 = null) {
    const lineTarget = target1 || target2 ? line1 : null;
    if (this.intersectsTriangle(other, lineTarget)) {
      if (target1 || target2) {
        if (target1)
          lineTarget.getCenter(target1);
        if (target2)
          lineTarget.getCenter(target2);
      }
      return 0;
    }
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 3; i++) {
      let dist;
      const field = cornerFields[i];
      const otherVec = other[field];
      this.closestPointToPoint(otherVec, point);
      dist = otherVec.distanceToSquared(point);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(point);
        if (target2)
          target2.copy(otherVec);
      }
      const thisVec = this[field];
      other.closestPointToPoint(thisVec, point);
      dist = thisVec.distanceToSquared(point);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(thisVec);
        if (target2)
          target2.copy(point);
      }
    }
    for (let i = 0; i < 3; i++) {
      const f11 = cornerFields[i];
      const f12 = cornerFields[(i + 1) % 3];
      line1.set(this[f11], this[f12]);
      for (let i2 = 0; i2 < 3; i2++) {
        const f21 = cornerFields[i2];
        const f22 = cornerFields[(i2 + 1) % 3];
        line2.set(other[f21], other[f22]);
        closestPointsSegmentToSegment(line1, line2, point, point2);
        const dist = point.distanceToSquared(point2);
        if (dist < closestDistanceSq) {
          closestDistanceSq = dist;
          if (target1)
            target1.copy(point);
          if (target2)
            target2.copy(point2);
        }
      }
    }
    return Math.sqrt(closestDistanceSq);
  };
}();
var OrientedBox = class {
  constructor(min, max, matrix) {
    this.isOrientedBox = true;
    this.min = new Vector3();
    this.max = new Vector3();
    this.matrix = new Matrix4();
    this.invMatrix = new Matrix4();
    this.points = new Array(8).fill().map(() => new Vector3());
    this.satAxes = new Array(3).fill().map(() => new Vector3());
    this.satBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());
    this.alignedSatBounds = new Array(3).fill().map(() => new SeparatingAxisBounds());
    this.needsUpdate = false;
    if (min)
      this.min.copy(min);
    if (max)
      this.max.copy(max);
    if (matrix)
      this.matrix.copy(matrix);
  }
  set(min, max, matrix) {
    this.min.copy(min);
    this.max.copy(max);
    this.matrix.copy(matrix);
    this.needsUpdate = true;
  }
  copy(other) {
    this.min.copy(other.min);
    this.max.copy(other.max);
    this.matrix.copy(other.matrix);
    this.needsUpdate = true;
  }
};
OrientedBox.prototype.update = /* @__PURE__ */ function() {
  return function update() {
    const matrix = this.matrix;
    const min = this.min;
    const max = this.max;
    const points = this.points;
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          const i = (1 << 0) * x | (1 << 1) * y | (1 << 2) * z;
          const v = points[i];
          v.x = x ? max.x : min.x;
          v.y = y ? max.y : min.y;
          v.z = z ? max.z : min.z;
          v.applyMatrix4(matrix);
        }
      }
    }
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    const minVec = points[0];
    for (let i = 0; i < 3; i++) {
      const axis = satAxes[i];
      const sb = satBounds[i];
      const index = 1 << i;
      const pi = points[index];
      axis.subVectors(minVec, pi);
      sb.setFromPoints(axis, points);
    }
    const alignedSatBounds = this.alignedSatBounds;
    alignedSatBounds[0].setFromPointsField(points, "x");
    alignedSatBounds[1].setFromPointsField(points, "y");
    alignedSatBounds[2].setFromPointsField(points, "z");
    this.invMatrix.copy(this.matrix).invert();
    this.needsUpdate = false;
  };
}();
OrientedBox.prototype.intersectsBox = function() {
  const aabbBounds = new SeparatingAxisBounds();
  return function intersectsBox(box) {
    if (this.needsUpdate) {
      this.update();
    }
    const min = box.min;
    const max = box.max;
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    const alignedSatBounds = this.alignedSatBounds;
    aabbBounds.min = min.x;
    aabbBounds.max = max.x;
    if (alignedSatBounds[0].isSeparated(aabbBounds))
      return false;
    aabbBounds.min = min.y;
    aabbBounds.max = max.y;
    if (alignedSatBounds[1].isSeparated(aabbBounds))
      return false;
    aabbBounds.min = min.z;
    aabbBounds.max = max.z;
    if (alignedSatBounds[2].isSeparated(aabbBounds))
      return false;
    for (let i = 0; i < 3; i++) {
      const axis = satAxes[i];
      const sb = satBounds[i];
      aabbBounds.setFromBox(axis, box);
      if (sb.isSeparated(aabbBounds))
        return false;
    }
    return true;
  };
}();
OrientedBox.prototype.intersectsTriangle = function() {
  const saTri = new ExtendedTriangle();
  const pointsArr = new Array(3);
  const cachedSatBounds = new SeparatingAxisBounds();
  const cachedSatBounds2 = new SeparatingAxisBounds();
  const cachedAxis = new Vector3();
  return function intersectsTriangle(triangle32) {
    if (this.needsUpdate) {
      this.update();
    }
    if (!triangle32.isExtendedTriangle) {
      saTri.copy(triangle32);
      saTri.update();
      triangle32 = saTri;
    } else if (triangle32.needsUpdate) {
      triangle32.update();
    }
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    pointsArr[0] = triangle32.a;
    pointsArr[1] = triangle32.b;
    pointsArr[2] = triangle32.c;
    for (let i = 0; i < 3; i++) {
      const sb = satBounds[i];
      const sa = satAxes[i];
      cachedSatBounds.setFromPoints(sa, pointsArr);
      if (sb.isSeparated(cachedSatBounds))
        return false;
    }
    const triSatBounds = triangle32.satBounds;
    const triSatAxes = triangle32.satAxes;
    const points = this.points;
    for (let i = 0; i < 3; i++) {
      const sb = triSatBounds[i];
      const sa = triSatAxes[i];
      cachedSatBounds.setFromPoints(sa, points);
      if (sb.isSeparated(cachedSatBounds))
        return false;
    }
    for (let i = 0; i < 3; i++) {
      const sa1 = satAxes[i];
      for (let i2 = 0; i2 < 4; i2++) {
        const sa2 = triSatAxes[i2];
        cachedAxis.crossVectors(sa1, sa2);
        cachedSatBounds.setFromPoints(cachedAxis, pointsArr);
        cachedSatBounds2.setFromPoints(cachedAxis, points);
        if (cachedSatBounds.isSeparated(cachedSatBounds2))
          return false;
      }
    }
    return true;
  };
}();
OrientedBox.prototype.closestPointToPoint = /* @__PURE__ */ function() {
  return function closestPointToPoint22(point, target1) {
    if (this.needsUpdate) {
      this.update();
    }
    target1.copy(point).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix);
    return target1;
  };
}();
OrientedBox.prototype.distanceToPoint = function() {
  const target = new Vector3();
  return function distanceToPoint(point) {
    this.closestPointToPoint(point, target);
    return point.distanceTo(target);
  };
}();
OrientedBox.prototype.distanceToBox = function() {
  const xyzFields = ["x", "y", "z"];
  const segments1 = new Array(12).fill().map(() => new Line3());
  const segments2 = new Array(12).fill().map(() => new Line3());
  const point1 = new Vector3();
  const point2 = new Vector3();
  return function distanceToBox(box, threshold = 0, target1 = null, target2 = null) {
    if (this.needsUpdate) {
      this.update();
    }
    if (this.intersectsBox(box)) {
      if (target1 || target2) {
        box.getCenter(point2);
        this.closestPointToPoint(point2, point1);
        box.closestPointToPoint(point1, point2);
        if (target1)
          target1.copy(point1);
        if (target2)
          target2.copy(point2);
      }
      return 0;
    }
    const threshold2 = threshold * threshold;
    const min = box.min;
    const max = box.max;
    const points = this.points;
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 8; i++) {
      const p = points[i];
      point2.copy(p).clamp(min, max);
      const dist = p.distanceToSquared(point2);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(p);
        if (target2)
          target2.copy(point2);
        if (dist < threshold2)
          return Math.sqrt(dist);
      }
    }
    let count = 0;
    for (let i = 0; i < 3; i++) {
      for (let i1 = 0; i1 <= 1; i1++) {
        for (let i2 = 0; i2 <= 1; i2++) {
          const nextIndex = (i + 1) % 3;
          const nextIndex2 = (i + 2) % 3;
          const index = i1 << nextIndex | i2 << nextIndex2;
          const index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;
          const p1 = points[index];
          const p2 = points[index2];
          const line1 = segments1[count];
          line1.set(p1, p2);
          const f1 = xyzFields[i];
          const f2 = xyzFields[nextIndex];
          const f3 = xyzFields[nextIndex2];
          const line2 = segments2[count];
          const start = line2.start;
          const end = line2.end;
          start[f1] = min[f1];
          start[f2] = i1 ? min[f2] : max[f2];
          start[f3] = i2 ? min[f3] : max[f2];
          end[f1] = max[f1];
          end[f2] = i1 ? min[f2] : max[f2];
          end[f3] = i2 ? min[f3] : max[f2];
          count++;
        }
      }
    }
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          point2.x = x ? max.x : min.x;
          point2.y = y ? max.y : min.y;
          point2.z = z ? max.z : min.z;
          this.closestPointToPoint(point2, point1);
          const dist = point2.distanceToSquared(point1);
          if (dist < closestDistanceSq) {
            closestDistanceSq = dist;
            if (target1)
              target1.copy(point1);
            if (target2)
              target2.copy(point2);
            if (dist < threshold2)
              return Math.sqrt(dist);
          }
        }
      }
    }
    for (let i = 0; i < 12; i++) {
      const l1 = segments1[i];
      for (let i2 = 0; i2 < 12; i2++) {
        const l2 = segments2[i2];
        closestPointsSegmentToSegment(l1, l2, point1, point2);
        const dist = point1.distanceToSquared(point2);
        if (dist < closestDistanceSq) {
          closestDistanceSq = dist;
          if (target1)
            target1.copy(point1);
          if (target2)
            target2.copy(point2);
          if (dist < threshold2)
            return Math.sqrt(dist);
        }
      }
    }
    return Math.sqrt(closestDistanceSq);
  };
}();
var PrimitivePool = class {
  constructor(getNewPrimitive) {
    this._getNewPrimitive = getNewPrimitive;
    this._primitives = [];
  }
  getPrimitive() {
    const primitives = this._primitives;
    if (primitives.length === 0) {
      return this._getNewPrimitive();
    } else {
      return primitives.pop();
    }
  }
  releasePrimitive(primitive) {
    this._primitives.push(primitive);
  }
};
var ExtendedTrianglePoolBase = class extends PrimitivePool {
  constructor() {
    super(() => new ExtendedTriangle());
  }
};
var ExtendedTrianglePool = new ExtendedTrianglePoolBase();
function IS_LEAF(n16, uint16Array) {
  return uint16Array[n16 + 15] === 65535;
}
function OFFSET(n32, uint32Array) {
  return uint32Array[n32 + 6];
}
function COUNT(n16, uint16Array) {
  return uint16Array[n16 + 14];
}
function LEFT_NODE(n32) {
  return n32 + 8;
}
function RIGHT_NODE(n32, uint32Array) {
  return uint32Array[n32 + 6];
}
function SPLIT_AXIS(n32, uint32Array) {
  return uint32Array[n32 + 7];
}
function BOUNDING_DATA_INDEX(n32) {
  return n32;
}
var _BufferStack = class {
  constructor() {
    this.float32Array = null;
    this.uint16Array = null;
    this.uint32Array = null;
    const stack = [];
    let prevBuffer = null;
    this.setBuffer = (buffer) => {
      if (prevBuffer) {
        stack.push(prevBuffer);
      }
      prevBuffer = buffer;
      this.float32Array = new Float32Array(buffer);
      this.uint16Array = new Uint16Array(buffer);
      this.uint32Array = new Uint32Array(buffer);
    };
    this.clearBuffer = () => {
      prevBuffer = null;
      this.float32Array = null;
      this.uint16Array = null;
      this.uint32Array = null;
      if (stack.length !== 0) {
        this.setBuffer(stack.pop());
      }
    };
  }
};
var BufferStack = new _BufferStack();
var _box1;
var _box2;
var boxStack = [];
var boxPool = new PrimitivePool(() => new Box3());
function shapecast(bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset) {
  _box1 = boxPool.getPrimitive();
  _box2 = boxPool.getPrimitive();
  boxStack.push(_box1, _box2);
  BufferStack.setBuffer(bvh._roots[root]);
  const result = shapecastTraverse(0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);
  BufferStack.clearBuffer();
  boxPool.releasePrimitive(_box1);
  boxPool.releasePrimitive(_box2);
  boxStack.pop();
  boxStack.pop();
  const length = boxStack.length;
  if (length > 0) {
    _box2 = boxStack[length - 1];
    _box1 = boxStack[length - 2];
  }
  return result;
}
function shapecastTraverse(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc = null, nodeIndexByteOffset = 0, depth = 0) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, _box1);
    return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1);
  } else {
    let getLeftOffset = function(nodeIndex322) {
      const { uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
      let nodeIndex162 = nodeIndex322 * 2;
      while (!IS_LEAF(nodeIndex162, uint16Array2)) {
        nodeIndex322 = LEFT_NODE(nodeIndex322);
        nodeIndex162 = nodeIndex322 * 2;
      }
      return OFFSET(nodeIndex322, uint32Array2);
    }, getRightEndOffset = function(nodeIndex322) {
      const { uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack;
      let nodeIndex162 = nodeIndex322 * 2;
      while (!IS_LEAF(nodeIndex162, uint16Array2)) {
        nodeIndex322 = RIGHT_NODE(nodeIndex322, uint32Array2);
        nodeIndex162 = nodeIndex322 * 2;
      }
      return OFFSET(nodeIndex322, uint32Array2) + COUNT(nodeIndex162, uint16Array2);
    };
    const left = LEFT_NODE(nodeIndex32);
    const right = RIGHT_NODE(nodeIndex32, uint32Array);
    let c1 = left;
    let c2 = right;
    let score1, score2;
    let box1, box2;
    if (nodeScoreFunc) {
      box1 = _box1;
      box2 = _box2;
      arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);
      arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);
      score1 = nodeScoreFunc(box1);
      score2 = nodeScoreFunc(box2);
      if (score2 < score1) {
        c1 = right;
        c2 = left;
        const temp52 = score1;
        score1 = score2;
        score2 = temp52;
        box1 = box2;
      }
    }
    if (!box1) {
      box1 = _box1;
      arrayToBox(BOUNDING_DATA_INDEX(c1), float32Array, box1);
    }
    const isC1Leaf = IS_LEAF(c1 * 2, uint16Array);
    const c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);
    let c1StopTraversal;
    if (c1Intersection === CONTAINED) {
      const offset = getLeftOffset(c1);
      const end = getRightEndOffset(c1);
      const count = end - offset;
      c1StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1);
    } else {
      c1StopTraversal = c1Intersection && shapecastTraverse(
        c1,
        geometry,
        intersectsBoundsFunc,
        intersectsRangeFunc,
        nodeScoreFunc,
        nodeIndexByteOffset,
        depth + 1
      );
    }
    if (c1StopTraversal)
      return true;
    box2 = _box2;
    arrayToBox(BOUNDING_DATA_INDEX(c2), float32Array, box2);
    const isC2Leaf = IS_LEAF(c2 * 2, uint16Array);
    const c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);
    let c2StopTraversal;
    if (c2Intersection === CONTAINED) {
      const offset = getLeftOffset(c2);
      const end = getRightEndOffset(c2);
      const count = end - offset;
      c2StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2);
    } else {
      c2StopTraversal = c2Intersection && shapecastTraverse(
        c2,
        geometry,
        intersectsBoundsFunc,
        intersectsRangeFunc,
        nodeScoreFunc,
        nodeIndexByteOffset,
        depth + 1
      );
    }
    if (c2StopTraversal)
      return true;
    return false;
  }
}
var temp = new Vector3();
var temp1$2 = new Vector3();
function closestPointToPoint(bvh, point, target = {}, minThreshold = 0, maxThreshold = Infinity) {
  const minThresholdSq = minThreshold * minThreshold;
  const maxThresholdSq = maxThreshold * maxThreshold;
  let closestDistanceSq = Infinity;
  let closestDistanceTriIndex = null;
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        temp.copy(point).clamp(box.min, box.max);
        return temp.distanceToSquared(point);
      },
      intersectsBounds: (box, isLeaf, score) => {
        return score < closestDistanceSq && score < maxThresholdSq;
      },
      intersectsTriangle: (tri, triIndex) => {
        tri.closestPointToPoint(point, temp);
        const distSq = point.distanceToSquared(temp);
        if (distSq < closestDistanceSq) {
          temp1$2.copy(temp);
          closestDistanceSq = distSq;
          closestDistanceTriIndex = triIndex;
        }
        if (distSq < minThresholdSq) {
          return true;
        } else {
          return false;
        }
      }
    }
  );
  if (closestDistanceSq === Infinity)
    return null;
  const closestDistance = Math.sqrt(closestDistanceSq);
  if (!target.point)
    target.point = temp1$2.clone();
  else
    target.point.copy(temp1$2);
  target.distance = closestDistance, target.faceIndex = closestDistanceTriIndex;
  return target;
}
var _vA = new Vector3();
var _vB = new Vector3();
var _vC = new Vector3();
var _uvA = new Vector2();
var _uvB = new Vector2();
var _uvC = new Vector2();
var _normalA = new Vector3();
var _normalB = new Vector3();
var _normalC = new Vector3();
var _intersectionPoint = new Vector3();
function checkIntersection(ray22, pA, pB, pC, point, side) {
  let intersect;
  if (side === BackSide) {
    intersect = ray22.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray22.intersectTriangle(pA, pB, pC, side !== DoubleSide, point);
  }
  if (intersect === null)
    return null;
  const distance = ray22.origin.distanceTo(point);
  return {
    distance,
    point: point.clone()
  };
}
function checkBufferGeometryIntersection(ray22, position, normal, uv, uv1, a, b, c, side) {
  _vA.fromBufferAttribute(position, a);
  _vB.fromBufferAttribute(position, b);
  _vC.fromBufferAttribute(position, c);
  const intersection = checkIntersection(ray22, _vA, _vB, _vC, _intersectionPoint, side);
  if (intersection) {
    if (uv) {
      _uvA.fromBufferAttribute(uv, a);
      _uvB.fromBufferAttribute(uv, b);
      _uvC.fromBufferAttribute(uv, c);
      intersection.uv = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    if (uv1) {
      _uvA.fromBufferAttribute(uv1, a);
      _uvB.fromBufferAttribute(uv1, b);
      _uvC.fromBufferAttribute(uv1, c);
      intersection.uv1 = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2());
    }
    if (normal) {
      _normalA.fromBufferAttribute(normal, a);
      _normalB.fromBufferAttribute(normal, b);
      _normalC.fromBufferAttribute(normal, c);
      intersection.normal = Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new Vector3());
      if (intersection.normal.dot(ray22.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
    }
    const face = {
      a,
      b,
      c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA, _vB, _vC, face.normal);
    intersection.face = face;
    intersection.faceIndex = a;
  }
  return intersection;
}
function intersectTri(geo, side, ray22, tri, intersections) {
  const triOffset = tri * 3;
  let a = triOffset + 0;
  let b = triOffset + 1;
  let c = triOffset + 2;
  const index = geo.index;
  if (geo.index) {
    a = index.getX(a);
    b = index.getX(b);
    c = index.getX(c);
  }
  const { position, normal, uv, uv1 } = geo.attributes;
  const intersection = checkBufferGeometryIntersection(ray22, position, normal, uv, uv1, a, b, c, side);
  if (intersection) {
    intersection.faceIndex = tri;
    if (intersections)
      intersections.push(intersection);
    return intersection;
  }
  return null;
}
function setTriangle(tri, i, index, pos) {
  const ta = tri.a;
  const tb = tri.b;
  const tc = tri.c;
  let i0 = i;
  let i1 = i + 1;
  let i2 = i + 2;
  if (index) {
    i0 = index.getX(i0);
    i1 = index.getX(i1);
    i2 = index.getX(i2);
  }
  ta.x = pos.getX(i0);
  ta.y = pos.getY(i0);
  ta.z = pos.getZ(i0);
  tb.x = pos.getX(i1);
  tb.y = pos.getY(i1);
  tb.z = pos.getZ(i1);
  tc.x = pos.getX(i2);
  tc.y = pos.getY(i2);
  tc.z = pos.getZ(i2);
}
function intersectTris(bvh, side, ray22, offset, count, intersections) {
  const { geometry, _indirectBuffer } = bvh;
  for (let i = offset, end = offset + count; i < end; i++) {
    intersectTri(geometry, side, ray22, i, intersections);
  }
}
function intersectClosestTri(bvh, side, ray22, offset, count) {
  const { geometry, _indirectBuffer } = bvh;
  let dist = Infinity;
  let res = null;
  for (let i = offset, end = offset + count; i < end; i++) {
    let intersection;
    intersection = intersectTri(geometry, side, ray22, i);
    if (intersection && intersection.distance < dist) {
      res = intersection;
      dist = intersection.distance;
    }
  }
  return res;
}
function iterateOverTriangles(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle32) {
  const { geometry } = bvh;
  const { index } = geometry;
  const pos = geometry.attributes.position;
  for (let i = offset, l = count + offset; i < l; i++) {
    let tri;
    tri = i;
    setTriangle(triangle32, tri * 3, index, pos);
    triangle32.needsUpdate = true;
    if (intersectsTriangleFunc(triangle32, tri, contained, depth)) {
      return true;
    }
  }
  return false;
}
function refit(bvh, nodeIndices = null) {
  if (nodeIndices && Array.isArray(nodeIndices)) {
    nodeIndices = new Set(nodeIndices);
  }
  const geometry = bvh.geometry;
  const indexArr = geometry.index ? geometry.index.array : null;
  const posAttr = geometry.attributes.position;
  let buffer, uint32Array, uint16Array, float32Array;
  let byteOffset = 0;
  const roots = bvh._roots;
  for (let i = 0, l = roots.length; i < l; i++) {
    buffer = roots[i];
    uint32Array = new Uint32Array(buffer);
    uint16Array = new Uint16Array(buffer);
    float32Array = new Float32Array(buffer);
    _traverse22(0, byteOffset);
    byteOffset += buffer.byteLength;
  }
  function _traverse22(node32Index, byteOffset2, force = false) {
    const node16Index = node32Index * 2;
    const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;
    if (isLeaf) {
      const offset = uint32Array[node32Index + 6];
      const count = uint16Array[node16Index + 14];
      let minx = Infinity;
      let miny = Infinity;
      let minz = Infinity;
      let maxx = -Infinity;
      let maxy = -Infinity;
      let maxz = -Infinity;
      for (let i = 3 * offset, l = 3 * (offset + count); i < l; i++) {
        let index = indexArr[i];
        const x = posAttr.getX(index);
        const y = posAttr.getY(index);
        const z = posAttr.getZ(index);
        if (x < minx)
          minx = x;
        if (x > maxx)
          maxx = x;
        if (y < miny)
          miny = y;
        if (y > maxy)
          maxy = y;
        if (z < minz)
          minz = z;
        if (z > maxz)
          maxz = z;
      }
      if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {
        float32Array[node32Index + 0] = minx;
        float32Array[node32Index + 1] = miny;
        float32Array[node32Index + 2] = minz;
        float32Array[node32Index + 3] = maxx;
        float32Array[node32Index + 4] = maxy;
        float32Array[node32Index + 5] = maxz;
        return true;
      } else {
        return false;
      }
    } else {
      const left = node32Index + 8;
      const right = uint32Array[node32Index + 6];
      const offsetLeft = left + byteOffset2;
      const offsetRight = right + byteOffset2;
      let forceChildren = force;
      let includesLeft = false;
      let includesRight = false;
      if (nodeIndices) {
        if (!forceChildren) {
          includesLeft = nodeIndices.has(offsetLeft);
          includesRight = nodeIndices.has(offsetRight);
          forceChildren = !includesLeft && !includesRight;
        }
      } else {
        includesLeft = true;
        includesRight = true;
      }
      const traverseLeft = forceChildren || includesLeft;
      const traverseRight = forceChildren || includesRight;
      let leftChange = false;
      if (traverseLeft) {
        leftChange = _traverse22(left, byteOffset2, forceChildren);
      }
      let rightChange = false;
      if (traverseRight) {
        rightChange = _traverse22(right, byteOffset2, forceChildren);
      }
      const didChange = leftChange || rightChange;
      if (didChange) {
        for (let i = 0; i < 3; i++) {
          const lefti = left + i;
          const righti = right + i;
          const minLeftValue = float32Array[lefti];
          const maxLeftValue = float32Array[lefti + 3];
          const minRightValue = float32Array[righti];
          const maxRightValue = float32Array[righti + 3];
          float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;
          float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;
        }
      }
      return didChange;
    }
  }
}
var _boundingBox = new Box3();
function intersectRay(nodeIndex32, array, ray22, target) {
  arrayToBox(nodeIndex32, array, _boundingBox);
  return ray22.intersectBox(_boundingBox, target);
}
function intersectTris_indirect(bvh, side, ray22, offset, count, intersections) {
  const { geometry, _indirectBuffer } = bvh;
  for (let i = offset, end = offset + count; i < end; i++) {
    let vi = _indirectBuffer ? _indirectBuffer[i] : i;
    intersectTri(geometry, side, ray22, vi, intersections);
  }
}
function intersectClosestTri_indirect(bvh, side, ray22, offset, count) {
  const { geometry, _indirectBuffer } = bvh;
  let dist = Infinity;
  let res = null;
  for (let i = offset, end = offset + count; i < end; i++) {
    let intersection;
    intersection = intersectTri(geometry, side, ray22, _indirectBuffer ? _indirectBuffer[i] : i);
    if (intersection && intersection.distance < dist) {
      res = intersection;
      dist = intersection.distance;
    }
  }
  return res;
}
function iterateOverTriangles_indirect(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle32) {
  const { geometry } = bvh;
  const { index } = geometry;
  const pos = geometry.attributes.position;
  for (let i = offset, l = count + offset; i < l; i++) {
    let tri;
    tri = bvh.resolveTriangleIndex(i);
    setTriangle(triangle32, tri * 3, index, pos);
    triangle32.needsUpdate = true;
    if (intersectsTriangleFunc(triangle32, tri, contained, depth)) {
      return true;
    }
  }
  return false;
}
var _boxIntersection$3 = new Vector3();
function raycast(bvh, root, side, ray22, intersects2) {
  BufferStack.setBuffer(bvh._roots[root]);
  _raycast$1(0, bvh, side, ray22, intersects2);
  BufferStack.clearBuffer();
}
function _raycast$1(nodeIndex32, bvh, side, ray22, intersects2) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  const nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    intersectTris(bvh, side, ray22, offset, count, intersects2);
  } else {
    const leftIndex = LEFT_NODE(nodeIndex32);
    if (intersectRay(leftIndex, float32Array, ray22, _boxIntersection$3)) {
      _raycast$1(leftIndex, bvh, side, ray22, intersects2);
    }
    const rightIndex = RIGHT_NODE(nodeIndex32, uint32Array);
    if (intersectRay(rightIndex, float32Array, ray22, _boxIntersection$3)) {
      _raycast$1(rightIndex, bvh, side, ray22, intersects2);
    }
  }
}
var _boxIntersection$2 = new Vector3();
var _xyzFields$1 = ["x", "y", "z"];
function raycastFirst(bvh, root, side, ray22) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _raycastFirst$1(0, bvh, side, ray22);
  BufferStack.clearBuffer();
  return result;
}
function _raycastFirst$1(nodeIndex32, bvh, side, ray22) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    return intersectClosestTri(bvh, side, ray22, offset, count);
  } else {
    const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);
    const xyzAxis = _xyzFields$1[splitAxis];
    const rayDir = ray22.direction[xyzAxis];
    const leftToRight = rayDir >= 0;
    let c1, c2;
    if (leftToRight) {
      c1 = LEFT_NODE(nodeIndex32);
      c2 = RIGHT_NODE(nodeIndex32, uint32Array);
    } else {
      c1 = RIGHT_NODE(nodeIndex32, uint32Array);
      c2 = LEFT_NODE(nodeIndex32);
    }
    const c1Intersection = intersectRay(c1, float32Array, ray22, _boxIntersection$2);
    const c1Result = c1Intersection ? _raycastFirst$1(c1, bvh, side, ray22) : null;
    if (c1Result) {
      const point = c1Result.point[xyzAxis];
      const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : (
        // min bounding data
        point >= float32Array[c2 + splitAxis + 3]
      );
      if (isOutside) {
        return c1Result;
      }
    }
    const c2Intersection = intersectRay(c2, float32Array, ray22, _boxIntersection$2);
    const c2Result = c2Intersection ? _raycastFirst$1(c2, bvh, side, ray22) : null;
    if (c1Result && c2Result) {
      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;
    } else {
      return c1Result || c2Result || null;
    }
  }
}
var boundingBox$1 = new Box3();
var triangle$1 = new ExtendedTriangle();
var triangle2$1 = new ExtendedTriangle();
var invertedMat$1 = new Matrix4();
var obb$4 = new OrientedBox();
var obb2$3 = new OrientedBox();
function intersectsGeometry(bvh, root, otherGeometry, geometryToBvh) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _intersectsGeometry$1(0, bvh, otherGeometry, geometryToBvh);
  BufferStack.clearBuffer();
  return result;
}
function _intersectsGeometry$1(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  if (cachedObb === null) {
    if (!otherGeometry.boundingBox) {
      otherGeometry.computeBoundingBox();
    }
    obb$4.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
    cachedObb = obb$4;
  }
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const thisGeometry = bvh.geometry;
    const thisIndex = thisGeometry.index;
    const thisPos = thisGeometry.attributes.position;
    const index = otherGeometry.index;
    const pos = otherGeometry.attributes.position;
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    invertedMat$1.copy(geometryToBvh).invert();
    if (otherGeometry.boundsTree) {
      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, obb2$3);
      obb2$3.matrix.copy(invertedMat$1);
      obb2$3.needsUpdate = true;
      const res = otherGeometry.boundsTree.shapecast({
        intersectsBounds: (box) => obb2$3.intersectsBox(box),
        intersectsTriangle: (tri) => {
          tri.a.applyMatrix4(geometryToBvh);
          tri.b.applyMatrix4(geometryToBvh);
          tri.c.applyMatrix4(geometryToBvh);
          tri.needsUpdate = true;
          for (let i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {
            setTriangle(triangle2$1, i, thisIndex, thisPos);
            triangle2$1.needsUpdate = true;
            if (tri.intersectsTriangle(triangle2$1)) {
              return true;
            }
          }
          return false;
        }
      });
      return res;
    } else {
      for (let i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {
        setTriangle(triangle$1, i, thisIndex, thisPos);
        triangle$1.a.applyMatrix4(invertedMat$1);
        triangle$1.b.applyMatrix4(invertedMat$1);
        triangle$1.c.applyMatrix4(invertedMat$1);
        triangle$1.needsUpdate = true;
        for (let i2 = 0, l2 = index.count; i2 < l2; i2 += 3) {
          setTriangle(triangle2$1, i2, index, pos);
          triangle2$1.needsUpdate = true;
          if (triangle$1.intersectsTriangle(triangle2$1)) {
            return true;
          }
        }
      }
    }
  } else {
    const left = nodeIndex32 + 8;
    const right = uint32Array[nodeIndex32 + 6];
    arrayToBox(BOUNDING_DATA_INDEX(left), float32Array, boundingBox$1);
    const leftIntersection = cachedObb.intersectsBox(boundingBox$1) && _intersectsGeometry$1(left, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (leftIntersection)
      return true;
    arrayToBox(BOUNDING_DATA_INDEX(right), float32Array, boundingBox$1);
    const rightIntersection = cachedObb.intersectsBox(boundingBox$1) && _intersectsGeometry$1(right, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (rightIntersection)
      return true;
    return false;
  }
}
var tempMatrix$1 = new Matrix4();
var obb$3 = new OrientedBox();
var obb2$2 = new OrientedBox();
var temp1$1 = new Vector3();
var temp2$1 = new Vector3();
var temp3$1 = new Vector3();
var temp4$1 = new Vector3();
function closestPointToGeometry(bvh, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
  if (!otherGeometry.boundingBox) {
    otherGeometry.computeBoundingBox();
  }
  obb$3.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
  obb$3.needsUpdate = true;
  const geometry = bvh.geometry;
  const pos = geometry.attributes.position;
  const index = geometry.index;
  const otherPos = otherGeometry.attributes.position;
  const otherIndex = otherGeometry.index;
  const triangle32 = ExtendedTrianglePool.getPrimitive();
  const triangle222 = ExtendedTrianglePool.getPrimitive();
  let tempTarget1 = temp1$1;
  let tempTargetDest1 = temp2$1;
  let tempTarget2 = null;
  let tempTargetDest2 = null;
  if (target2) {
    tempTarget2 = temp3$1;
    tempTargetDest2 = temp4$1;
  }
  let closestDistance = Infinity;
  let closestDistanceTriIndex = null;
  let closestDistanceOtherTriIndex = null;
  tempMatrix$1.copy(geometryToBvh).invert();
  obb2$2.matrix.copy(tempMatrix$1);
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        return obb$3.distanceToBox(box);
      },
      intersectsBounds: (box, isLeaf, score) => {
        if (score < closestDistance && score < maxThreshold) {
          if (isLeaf) {
            obb2$2.min.copy(box.min);
            obb2$2.max.copy(box.max);
            obb2$2.needsUpdate = true;
          }
          return true;
        }
        return false;
      },
      intersectsRange: (offset, count) => {
        if (otherGeometry.boundsTree) {
          const otherBvh = otherGeometry.boundsTree;
          return otherBvh.shapecast({
            boundsTraverseOrder: (box) => {
              return obb2$2.distanceToBox(box);
            },
            intersectsBounds: (box, isLeaf, score) => {
              return score < closestDistance && score < maxThreshold;
            },
            intersectsRange: (otherOffset, otherCount) => {
              for (let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++) {
                setTriangle(triangle222, 3 * i2, otherIndex, otherPos);
                triangle222.a.applyMatrix4(geometryToBvh);
                triangle222.b.applyMatrix4(geometryToBvh);
                triangle222.c.applyMatrix4(geometryToBvh);
                triangle222.needsUpdate = true;
                for (let i = offset, l = offset + count; i < l; i++) {
                  setTriangle(triangle32, 3 * i, index, pos);
                  triangle32.needsUpdate = true;
                  const dist = triangle32.distanceToTriangle(triangle222, tempTarget1, tempTarget2);
                  if (dist < closestDistance) {
                    tempTargetDest1.copy(tempTarget1);
                    if (tempTargetDest2) {
                      tempTargetDest2.copy(tempTarget2);
                    }
                    closestDistance = dist;
                    closestDistanceTriIndex = i;
                    closestDistanceOtherTriIndex = i2;
                  }
                  if (dist < minThreshold) {
                    return true;
                  }
                }
              }
            }
          });
        } else {
          const triCount = getTriCount(otherGeometry);
          for (let i2 = 0, l2 = triCount; i2 < l2; i2++) {
            setTriangle(triangle222, 3 * i2, otherIndex, otherPos);
            triangle222.a.applyMatrix4(geometryToBvh);
            triangle222.b.applyMatrix4(geometryToBvh);
            triangle222.c.applyMatrix4(geometryToBvh);
            triangle222.needsUpdate = true;
            for (let i = offset, l = offset + count; i < l; i++) {
              setTriangle(triangle32, 3 * i, index, pos);
              triangle32.needsUpdate = true;
              const dist = triangle32.distanceToTriangle(triangle222, tempTarget1, tempTarget2);
              if (dist < closestDistance) {
                tempTargetDest1.copy(tempTarget1);
                if (tempTargetDest2) {
                  tempTargetDest2.copy(tempTarget2);
                }
                closestDistance = dist;
                closestDistanceTriIndex = i;
                closestDistanceOtherTriIndex = i2;
              }
              if (dist < minThreshold) {
                return true;
              }
            }
          }
        }
      }
    }
  );
  ExtendedTrianglePool.releasePrimitive(triangle32);
  ExtendedTrianglePool.releasePrimitive(triangle222);
  if (closestDistance === Infinity) {
    return null;
  }
  if (!target1.point) {
    target1.point = tempTargetDest1.clone();
  } else {
    target1.point.copy(tempTargetDest1);
  }
  target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;
  if (target2) {
    if (!target2.point)
      target2.point = tempTargetDest2.clone();
    else
      target2.point.copy(tempTargetDest2);
    target2.point.applyMatrix4(tempMatrix$1);
    tempTargetDest1.applyMatrix4(tempMatrix$1);
    target2.distance = tempTargetDest1.sub(target2.point).length();
    target2.faceIndex = closestDistanceOtherTriIndex;
  }
  return target1;
}
function refit_indirect(bvh, nodeIndices = null) {
  if (nodeIndices && Array.isArray(nodeIndices)) {
    nodeIndices = new Set(nodeIndices);
  }
  const geometry = bvh.geometry;
  const indexArr = geometry.index ? geometry.index.array : null;
  const posAttr = geometry.attributes.position;
  let buffer, uint32Array, uint16Array, float32Array;
  let byteOffset = 0;
  const roots = bvh._roots;
  for (let i = 0, l = roots.length; i < l; i++) {
    buffer = roots[i];
    uint32Array = new Uint32Array(buffer);
    uint16Array = new Uint16Array(buffer);
    float32Array = new Float32Array(buffer);
    _traverse22(0, byteOffset);
    byteOffset += buffer.byteLength;
  }
  function _traverse22(node32Index, byteOffset2, force = false) {
    const node16Index = node32Index * 2;
    const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;
    if (isLeaf) {
      const offset = uint32Array[node32Index + 6];
      const count = uint16Array[node16Index + 14];
      let minx = Infinity;
      let miny = Infinity;
      let minz = Infinity;
      let maxx = -Infinity;
      let maxy = -Infinity;
      let maxz = -Infinity;
      for (let i = offset, l = offset + count; i < l; i++) {
        const t = 3 * bvh.resolveTriangleIndex(i);
        for (let j = 0; j < 3; j++) {
          let index = t + j;
          index = indexArr ? indexArr[index] : index;
          const x = posAttr.getX(index);
          const y = posAttr.getY(index);
          const z = posAttr.getZ(index);
          if (x < minx)
            minx = x;
          if (x > maxx)
            maxx = x;
          if (y < miny)
            miny = y;
          if (y > maxy)
            maxy = y;
          if (z < minz)
            minz = z;
          if (z > maxz)
            maxz = z;
        }
      }
      if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {
        float32Array[node32Index + 0] = minx;
        float32Array[node32Index + 1] = miny;
        float32Array[node32Index + 2] = minz;
        float32Array[node32Index + 3] = maxx;
        float32Array[node32Index + 4] = maxy;
        float32Array[node32Index + 5] = maxz;
        return true;
      } else {
        return false;
      }
    } else {
      const left = node32Index + 8;
      const right = uint32Array[node32Index + 6];
      const offsetLeft = left + byteOffset2;
      const offsetRight = right + byteOffset2;
      let forceChildren = force;
      let includesLeft = false;
      let includesRight = false;
      if (nodeIndices) {
        if (!forceChildren) {
          includesLeft = nodeIndices.has(offsetLeft);
          includesRight = nodeIndices.has(offsetRight);
          forceChildren = !includesLeft && !includesRight;
        }
      } else {
        includesLeft = true;
        includesRight = true;
      }
      const traverseLeft = forceChildren || includesLeft;
      const traverseRight = forceChildren || includesRight;
      let leftChange = false;
      if (traverseLeft) {
        leftChange = _traverse22(left, byteOffset2, forceChildren);
      }
      let rightChange = false;
      if (traverseRight) {
        rightChange = _traverse22(right, byteOffset2, forceChildren);
      }
      const didChange = leftChange || rightChange;
      if (didChange) {
        for (let i = 0; i < 3; i++) {
          const lefti = left + i;
          const righti = right + i;
          const minLeftValue = float32Array[lefti];
          const maxLeftValue = float32Array[lefti + 3];
          const minRightValue = float32Array[righti];
          const maxRightValue = float32Array[righti + 3];
          float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;
          float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;
        }
      }
      return didChange;
    }
  }
}
var _boxIntersection$1 = new Vector3();
function raycast_indirect(bvh, root, side, ray22, intersects2) {
  BufferStack.setBuffer(bvh._roots[root]);
  _raycast(0, bvh, side, ray22, intersects2);
  BufferStack.clearBuffer();
}
function _raycast(nodeIndex32, bvh, side, ray22, intersects2) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  const nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    intersectTris_indirect(bvh, side, ray22, offset, count, intersects2);
  } else {
    const leftIndex = LEFT_NODE(nodeIndex32);
    if (intersectRay(leftIndex, float32Array, ray22, _boxIntersection$1)) {
      _raycast(leftIndex, bvh, side, ray22, intersects2);
    }
    const rightIndex = RIGHT_NODE(nodeIndex32, uint32Array);
    if (intersectRay(rightIndex, float32Array, ray22, _boxIntersection$1)) {
      _raycast(rightIndex, bvh, side, ray22, intersects2);
    }
  }
}
var _boxIntersection = new Vector3();
var _xyzFields = ["x", "y", "z"];
function raycastFirst_indirect(bvh, root, side, ray22) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _raycastFirst(0, bvh, side, ray22);
  BufferStack.clearBuffer();
  return result;
}
function _raycastFirst(nodeIndex32, bvh, side, ray22) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    return intersectClosestTri_indirect(bvh, side, ray22, offset, count);
  } else {
    const splitAxis = SPLIT_AXIS(nodeIndex32, uint32Array);
    const xyzAxis = _xyzFields[splitAxis];
    const rayDir = ray22.direction[xyzAxis];
    const leftToRight = rayDir >= 0;
    let c1, c2;
    if (leftToRight) {
      c1 = LEFT_NODE(nodeIndex32);
      c2 = RIGHT_NODE(nodeIndex32, uint32Array);
    } else {
      c1 = RIGHT_NODE(nodeIndex32, uint32Array);
      c2 = LEFT_NODE(nodeIndex32);
    }
    const c1Intersection = intersectRay(c1, float32Array, ray22, _boxIntersection);
    const c1Result = c1Intersection ? _raycastFirst(c1, bvh, side, ray22) : null;
    if (c1Result) {
      const point = c1Result.point[xyzAxis];
      const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : (
        // min bounding data
        point >= float32Array[c2 + splitAxis + 3]
      );
      if (isOutside) {
        return c1Result;
      }
    }
    const c2Intersection = intersectRay(c2, float32Array, ray22, _boxIntersection);
    const c2Result = c2Intersection ? _raycastFirst(c2, bvh, side, ray22) : null;
    if (c1Result && c2Result) {
      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;
    } else {
      return c1Result || c2Result || null;
    }
  }
}
var boundingBox = new Box3();
var triangle = new ExtendedTriangle();
var triangle2 = new ExtendedTriangle();
var invertedMat = new Matrix4();
var obb$2 = new OrientedBox();
var obb2$1 = new OrientedBox();
function intersectsGeometry_indirect(bvh, root, otherGeometry, geometryToBvh) {
  BufferStack.setBuffer(bvh._roots[root]);
  const result = _intersectsGeometry(0, bvh, otherGeometry, geometryToBvh);
  BufferStack.clearBuffer();
  return result;
}
function _intersectsGeometry(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {
  const { float32Array, uint16Array, uint32Array } = BufferStack;
  let nodeIndex16 = nodeIndex32 * 2;
  if (cachedObb === null) {
    if (!otherGeometry.boundingBox) {
      otherGeometry.computeBoundingBox();
    }
    obb$2.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
    cachedObb = obb$2;
  }
  const isLeaf = IS_LEAF(nodeIndex16, uint16Array);
  if (isLeaf) {
    const thisGeometry = bvh.geometry;
    const thisIndex = thisGeometry.index;
    const thisPos = thisGeometry.attributes.position;
    const index = otherGeometry.index;
    const pos = otherGeometry.attributes.position;
    const offset = OFFSET(nodeIndex32, uint32Array);
    const count = COUNT(nodeIndex16, uint16Array);
    invertedMat.copy(geometryToBvh).invert();
    if (otherGeometry.boundsTree) {
      arrayToBox(BOUNDING_DATA_INDEX(nodeIndex32), float32Array, obb2$1);
      obb2$1.matrix.copy(invertedMat);
      obb2$1.needsUpdate = true;
      const res = otherGeometry.boundsTree.shapecast({
        intersectsBounds: (box) => obb2$1.intersectsBox(box),
        intersectsTriangle: (tri) => {
          tri.a.applyMatrix4(geometryToBvh);
          tri.b.applyMatrix4(geometryToBvh);
          tri.c.applyMatrix4(geometryToBvh);
          tri.needsUpdate = true;
          for (let i = offset, l = count + offset; i < l; i++) {
            setTriangle(triangle2, 3 * bvh.resolveTriangleIndex(i), thisIndex, thisPos);
            triangle2.needsUpdate = true;
            if (tri.intersectsTriangle(triangle2)) {
              return true;
            }
          }
          return false;
        }
      });
      return res;
    } else {
      for (let i = offset, l = count + offset; i < l; i++) {
        const ti = bvh.resolveTriangleIndex(i);
        setTriangle(triangle, 3 * ti, thisIndex, thisPos);
        triangle.a.applyMatrix4(invertedMat);
        triangle.b.applyMatrix4(invertedMat);
        triangle.c.applyMatrix4(invertedMat);
        triangle.needsUpdate = true;
        for (let i2 = 0, l2 = index.count; i2 < l2; i2 += 3) {
          setTriangle(triangle2, i2, index, pos);
          triangle2.needsUpdate = true;
          if (triangle.intersectsTriangle(triangle2)) {
            return true;
          }
        }
      }
    }
  } else {
    const left = nodeIndex32 + 8;
    const right = uint32Array[nodeIndex32 + 6];
    arrayToBox(BOUNDING_DATA_INDEX(left), float32Array, boundingBox);
    const leftIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(left, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (leftIntersection)
      return true;
    arrayToBox(BOUNDING_DATA_INDEX(right), float32Array, boundingBox);
    const rightIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(right, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (rightIntersection)
      return true;
    return false;
  }
}
var tempMatrix = new Matrix4();
var obb$1 = new OrientedBox();
var obb2 = new OrientedBox();
var temp1 = new Vector3();
var temp2 = new Vector3();
var temp3 = new Vector3();
var temp4 = new Vector3();
function closestPointToGeometry_indirect(bvh, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
  if (!otherGeometry.boundingBox) {
    otherGeometry.computeBoundingBox();
  }
  obb$1.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
  obb$1.needsUpdate = true;
  const geometry = bvh.geometry;
  const pos = geometry.attributes.position;
  const index = geometry.index;
  const otherPos = otherGeometry.attributes.position;
  const otherIndex = otherGeometry.index;
  const triangle32 = ExtendedTrianglePool.getPrimitive();
  const triangle222 = ExtendedTrianglePool.getPrimitive();
  let tempTarget1 = temp1;
  let tempTargetDest1 = temp2;
  let tempTarget2 = null;
  let tempTargetDest2 = null;
  if (target2) {
    tempTarget2 = temp3;
    tempTargetDest2 = temp4;
  }
  let closestDistance = Infinity;
  let closestDistanceTriIndex = null;
  let closestDistanceOtherTriIndex = null;
  tempMatrix.copy(geometryToBvh).invert();
  obb2.matrix.copy(tempMatrix);
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        return obb$1.distanceToBox(box);
      },
      intersectsBounds: (box, isLeaf, score) => {
        if (score < closestDistance && score < maxThreshold) {
          if (isLeaf) {
            obb2.min.copy(box.min);
            obb2.max.copy(box.max);
            obb2.needsUpdate = true;
          }
          return true;
        }
        return false;
      },
      intersectsRange: (offset, count) => {
        if (otherGeometry.boundsTree) {
          const otherBvh = otherGeometry.boundsTree;
          return otherBvh.shapecast({
            boundsTraverseOrder: (box) => {
              return obb2.distanceToBox(box);
            },
            intersectsBounds: (box, isLeaf, score) => {
              return score < closestDistance && score < maxThreshold;
            },
            intersectsRange: (otherOffset, otherCount) => {
              for (let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++) {
                const ti2 = otherBvh.resolveTriangleIndex(i2);
                setTriangle(triangle222, 3 * ti2, otherIndex, otherPos);
                triangle222.a.applyMatrix4(geometryToBvh);
                triangle222.b.applyMatrix4(geometryToBvh);
                triangle222.c.applyMatrix4(geometryToBvh);
                triangle222.needsUpdate = true;
                for (let i = offset, l = offset + count; i < l; i++) {
                  const ti = bvh.resolveTriangleIndex(i);
                  setTriangle(triangle32, 3 * ti, index, pos);
                  triangle32.needsUpdate = true;
                  const dist = triangle32.distanceToTriangle(triangle222, tempTarget1, tempTarget2);
                  if (dist < closestDistance) {
                    tempTargetDest1.copy(tempTarget1);
                    if (tempTargetDest2) {
                      tempTargetDest2.copy(tempTarget2);
                    }
                    closestDistance = dist;
                    closestDistanceTriIndex = i;
                    closestDistanceOtherTriIndex = i2;
                  }
                  if (dist < minThreshold) {
                    return true;
                  }
                }
              }
            }
          });
        } else {
          const triCount = getTriCount(otherGeometry);
          for (let i2 = 0, l2 = triCount; i2 < l2; i2++) {
            setTriangle(triangle222, 3 * i2, otherIndex, otherPos);
            triangle222.a.applyMatrix4(geometryToBvh);
            triangle222.b.applyMatrix4(geometryToBvh);
            triangle222.c.applyMatrix4(geometryToBvh);
            triangle222.needsUpdate = true;
            for (let i = offset, l = offset + count; i < l; i++) {
              const ti = bvh.resolveTriangleIndex(i);
              setTriangle(triangle32, 3 * ti, index, pos);
              triangle32.needsUpdate = true;
              const dist = triangle32.distanceToTriangle(triangle222, tempTarget1, tempTarget2);
              if (dist < closestDistance) {
                tempTargetDest1.copy(tempTarget1);
                if (tempTargetDest2) {
                  tempTargetDest2.copy(tempTarget2);
                }
                closestDistance = dist;
                closestDistanceTriIndex = i;
                closestDistanceOtherTriIndex = i2;
              }
              if (dist < minThreshold) {
                return true;
              }
            }
          }
        }
      }
    }
  );
  ExtendedTrianglePool.releasePrimitive(triangle32);
  ExtendedTrianglePool.releasePrimitive(triangle222);
  if (closestDistance === Infinity) {
    return null;
  }
  if (!target1.point) {
    target1.point = tempTargetDest1.clone();
  } else {
    target1.point.copy(tempTargetDest1);
  }
  target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;
  if (target2) {
    if (!target2.point)
      target2.point = tempTargetDest2.clone();
    else
      target2.point.copy(tempTargetDest2);
    target2.point.applyMatrix4(tempMatrix);
    tempTargetDest1.applyMatrix4(tempMatrix);
    target2.distance = tempTargetDest1.sub(target2.point).length();
    target2.faceIndex = closestDistanceOtherTriIndex;
  }
  return target1;
}
function isSharedArrayBufferSupported() {
  return typeof SharedArrayBuffer !== "undefined";
}
var _bufferStack1 = new BufferStack.constructor();
var _bufferStack2 = new BufferStack.constructor();
var _boxPool = new PrimitivePool(() => new Box3());
var _leftBox1 = new Box3();
var _rightBox1 = new Box3();
var _leftBox2 = new Box3();
var _rightBox2 = new Box3();
var _active = false;
function bvhcast(bvh, otherBvh, matrixToLocal, intersectsRanges) {
  if (_active) {
    throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  }
  _active = true;
  const roots = bvh._roots;
  const otherRoots = otherBvh._roots;
  let result;
  let offset1 = 0;
  let offset2 = 0;
  const invMat = new Matrix4().copy(matrixToLocal).invert();
  for (let i = 0, il = roots.length; i < il; i++) {
    _bufferStack1.setBuffer(roots[i]);
    offset2 = 0;
    const localBox = _boxPool.getPrimitive();
    arrayToBox(BOUNDING_DATA_INDEX(0), _bufferStack1.float32Array, localBox);
    localBox.applyMatrix4(invMat);
    for (let j = 0, jl = otherRoots.length; j < jl; j++) {
      _bufferStack2.setBuffer(otherRoots[i]);
      result = _traverse(
        0,
        0,
        matrixToLocal,
        invMat,
        intersectsRanges,
        offset1,
        offset2,
        0,
        0,
        localBox
      );
      _bufferStack2.clearBuffer();
      offset2 += otherRoots[j].length;
      if (result) {
        break;
      }
    }
    _boxPool.releasePrimitive(localBox);
    _bufferStack1.clearBuffer();
    offset1 += roots[i].length;
    if (result) {
      break;
    }
  }
  _active = false;
  return result;
}
function _traverse(node1Index32, node2Index32, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset = 0, node2IndexByteOffset = 0, depth1 = 0, depth2 = 0, currBox = null, reversed = false) {
  let bufferStack1, bufferStack2;
  if (reversed) {
    bufferStack1 = _bufferStack2;
    bufferStack2 = _bufferStack1;
  } else {
    bufferStack1 = _bufferStack1;
    bufferStack2 = _bufferStack2;
  }
  const float32Array1 = bufferStack1.float32Array, uint32Array1 = bufferStack1.uint32Array, uint16Array1 = bufferStack1.uint16Array, float32Array2 = bufferStack2.float32Array, uint32Array2 = bufferStack2.uint32Array, uint16Array2 = bufferStack2.uint16Array;
  const node1Index16 = node1Index32 * 2;
  const node2Index16 = node2Index32 * 2;
  const isLeaf1 = IS_LEAF(node1Index16, uint16Array1);
  const isLeaf2 = IS_LEAF(node2Index16, uint16Array2);
  let result = false;
  if (isLeaf2 && isLeaf1) {
    if (reversed) {
      result = intersectsRangesFunc(
        OFFSET(node2Index32, uint32Array2),
        COUNT(node2Index32 * 2, uint16Array2),
        OFFSET(node1Index32, uint32Array1),
        COUNT(node1Index32 * 2, uint16Array1),
        depth2,
        node2IndexByteOffset + node2Index32,
        depth1,
        node1IndexByteOffset + node1Index32
      );
    } else {
      result = intersectsRangesFunc(
        OFFSET(node1Index32, uint32Array1),
        COUNT(node1Index32 * 2, uint16Array1),
        OFFSET(node2Index32, uint32Array2),
        COUNT(node2Index32 * 2, uint16Array2),
        depth1,
        node1IndexByteOffset + node1Index32,
        depth2,
        node2IndexByteOffset + node2Index32
      );
    }
  } else if (isLeaf2) {
    const newBox = _boxPool.getPrimitive();
    arrayToBox(BOUNDING_DATA_INDEX(node2Index32), float32Array2, newBox);
    newBox.applyMatrix4(matrix2to1);
    const cl1 = LEFT_NODE(node1Index32);
    const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
    arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
    arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
    const intersectCl1 = newBox.intersectsBox(_leftBox1);
    const intersectCr1 = newBox.intersectsBox(_rightBox1);
    result = intersectCl1 && _traverse(
      node2Index32,
      cl1,
      matrix1to2,
      matrix2to1,
      intersectsRangesFunc,
      node2IndexByteOffset,
      node1IndexByteOffset,
      depth2,
      depth1 + 1,
      newBox,
      !reversed
    ) || intersectCr1 && _traverse(
      node2Index32,
      cr1,
      matrix1to2,
      matrix2to1,
      intersectsRangesFunc,
      node2IndexByteOffset,
      node1IndexByteOffset,
      depth2,
      depth1 + 1,
      newBox,
      !reversed
    );
    _boxPool.releasePrimitive(newBox);
  } else {
    const cl2 = LEFT_NODE(node2Index32);
    const cr2 = RIGHT_NODE(node2Index32, uint32Array2);
    arrayToBox(BOUNDING_DATA_INDEX(cl2), float32Array2, _leftBox2);
    arrayToBox(BOUNDING_DATA_INDEX(cr2), float32Array2, _rightBox2);
    const leftIntersects = currBox.intersectsBox(_leftBox2);
    const rightIntersects = currBox.intersectsBox(_rightBox2);
    if (leftIntersects && rightIntersects) {
      result = _traverse(
        node1Index32,
        cl2,
        matrix2to1,
        matrix1to2,
        intersectsRangesFunc,
        node1IndexByteOffset,
        node2IndexByteOffset,
        depth1,
        depth2 + 1,
        currBox,
        reversed
      ) || _traverse(
        node1Index32,
        cr2,
        matrix2to1,
        matrix1to2,
        intersectsRangesFunc,
        node1IndexByteOffset,
        node2IndexByteOffset,
        depth1,
        depth2 + 1,
        currBox,
        reversed
      );
    } else if (leftIntersects) {
      if (isLeaf1) {
        result = _traverse(
          node1Index32,
          cl2,
          matrix2to1,
          matrix1to2,
          intersectsRangesFunc,
          node1IndexByteOffset,
          node2IndexByteOffset,
          depth1,
          depth2 + 1,
          currBox,
          reversed
        );
      } else {
        const newBox = _boxPool.getPrimitive();
        newBox.copy(_leftBox2).applyMatrix4(matrix2to1);
        const cl1 = LEFT_NODE(node1Index32);
        const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
        arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
        arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
        const intersectCl1 = newBox.intersectsBox(_leftBox1);
        const intersectCr1 = newBox.intersectsBox(_rightBox1);
        result = intersectCl1 && _traverse(
          cl2,
          cl1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        ) || intersectCr1 && _traverse(
          cl2,
          cr1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        );
        _boxPool.releasePrimitive(newBox);
      }
    } else if (rightIntersects) {
      if (isLeaf1) {
        result = _traverse(
          node1Index32,
          cr2,
          matrix2to1,
          matrix1to2,
          intersectsRangesFunc,
          node1IndexByteOffset,
          node2IndexByteOffset,
          depth1,
          depth2 + 1,
          currBox,
          reversed
        );
      } else {
        const newBox = _boxPool.getPrimitive();
        newBox.copy(_rightBox2).applyMatrix4(matrix2to1);
        const cl1 = LEFT_NODE(node1Index32);
        const cr1 = RIGHT_NODE(node1Index32, uint32Array1);
        arrayToBox(BOUNDING_DATA_INDEX(cl1), float32Array1, _leftBox1);
        arrayToBox(BOUNDING_DATA_INDEX(cr1), float32Array1, _rightBox1);
        const intersectCl1 = newBox.intersectsBox(_leftBox1);
        const intersectCr1 = newBox.intersectsBox(_rightBox1);
        result = intersectCl1 && _traverse(
          cr2,
          cl1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        ) || intersectCr1 && _traverse(
          cr2,
          cr1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        );
        _boxPool.releasePrimitive(newBox);
      }
    }
  }
  return result;
}
var obb = new OrientedBox();
var tempBox = new Box3();
var MeshBVH = class _MeshBVH {
  static serialize(bvh, options = {}) {
    options = {
      cloneBuffers: true,
      ...options
    };
    const geometry = bvh.geometry;
    const rootData = bvh._roots;
    const indirectBuffer = bvh._indirectBuffer;
    const indexAttribute = geometry.getIndex();
    let result;
    if (options.cloneBuffers) {
      result = {
        roots: rootData.map((root) => root.slice()),
        index: indexAttribute.array.slice(),
        indirectBuffer: indirectBuffer ? indirectBuffer.slice() : null
      };
    } else {
      result = {
        roots: rootData,
        index: indexAttribute.array,
        indirectBuffer
      };
    }
    return result;
  }
  static deserialize(data, geometry, options = {}) {
    options = {
      setIndex: true,
      indirect: Boolean(data.indirectBuffer),
      ...options
    };
    const { index, roots, indirectBuffer } = data;
    const bvh = new _MeshBVH(geometry, { ...options, [SKIP_GENERATION]: true });
    bvh._roots = roots;
    bvh._indirectBuffer = indirectBuffer || null;
    if (options.setIndex) {
      const indexAttribute = geometry.getIndex();
      if (indexAttribute === null) {
        const newIndex = new BufferAttribute(data.index, 1, false);
        geometry.setIndex(newIndex);
      } else if (indexAttribute.array !== index) {
        indexAttribute.array.set(index);
        indexAttribute.needsUpdate = true;
      }
    }
    return bvh;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(geometry, options = {}) {
    if (!geometry.isBufferGeometry) {
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {
      throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    }
    options = Object.assign({
      strategy: CENTER,
      maxDepth: 40,
      maxLeafTris: 10,
      verbose: true,
      useSharedArrayBuffer: false,
      setBoundingBox: true,
      onProgress: null,
      indirect: false,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [SKIP_GENERATION]: false
    }, options);
    if (options.useSharedArrayBuffer && !isSharedArrayBufferSupported()) {
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    }
    this.geometry = geometry;
    this._roots = null;
    this._indirectBuffer = null;
    if (!options[SKIP_GENERATION]) {
      buildPackedTree(this, options);
      if (!geometry.boundingBox && options.setBoundingBox) {
        geometry.boundingBox = this.getBoundingBox(new Box3());
      }
    }
    const { _indirectBuffer } = this;
    this.resolveTriangleIndex = options.indirect ? (i) => _indirectBuffer[i] : (i) => i;
  }
  refit(nodeIndices = null) {
    const refitFunc = this.indirect ? refit_indirect : refit;
    return refitFunc(this, nodeIndices);
  }
  traverse(callback, rootIndex = 0) {
    const buffer = this._roots[rootIndex];
    const uint32Array = new Uint32Array(buffer);
    const uint16Array = new Uint16Array(buffer);
    _traverse22(0);
    function _traverse22(node32Index, depth = 0) {
      const node16Index = node32Index * 2;
      const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG;
      if (isLeaf) {
        const offset = uint32Array[node32Index + 6];
        const count = uint16Array[node16Index + 14];
        callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);
      } else {
        const left = node32Index + BYTES_PER_NODE / 4;
        const right = uint32Array[node32Index + 6];
        const splitAxis = uint32Array[node32Index + 7];
        const stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);
        if (!stopTraversal) {
          _traverse22(left, depth + 1);
          _traverse22(right, depth + 1);
        }
      }
    }
  }
  /* Core Cast Functions */
  raycast(ray22, materialOrSide = FrontSide) {
    const roots = this._roots;
    const geometry = this.geometry;
    const intersects2 = [];
    const isMaterial = materialOrSide.isMaterial;
    const isArrayMaterial = Array.isArray(materialOrSide);
    const groups = geometry.groups;
    const side = isMaterial ? materialOrSide.side : materialOrSide;
    const raycastFunc = this.indirect ? raycast_indirect : raycast;
    for (let i = 0, l = roots.length; i < l; i++) {
      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;
      const startCount = intersects2.length;
      raycastFunc(this, i, materialSide, ray22, intersects2);
      if (isArrayMaterial) {
        const materialIndex = groups[i].materialIndex;
        for (let j = startCount, jl = intersects2.length; j < jl; j++) {
          intersects2[j].face.materialIndex = materialIndex;
        }
      }
    }
    return intersects2;
  }
  raycastFirst(ray22, materialOrSide = FrontSide) {
    const roots = this._roots;
    const geometry = this.geometry;
    const isMaterial = materialOrSide.isMaterial;
    const isArrayMaterial = Array.isArray(materialOrSide);
    let closestResult = null;
    const groups = geometry.groups;
    const side = isMaterial ? materialOrSide.side : materialOrSide;
    const raycastFirstFunc = this.indirect ? raycastFirst_indirect : raycastFirst;
    for (let i = 0, l = roots.length; i < l; i++) {
      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;
      const result = raycastFirstFunc(this, i, materialSide, ray22);
      if (result != null && (closestResult == null || result.distance < closestResult.distance)) {
        closestResult = result;
        if (isArrayMaterial) {
          result.face.materialIndex = groups[i].materialIndex;
        }
      }
    }
    return closestResult;
  }
  intersectsGeometry(otherGeometry, geomToMesh) {
    let result = false;
    const roots = this._roots;
    const intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect : intersectsGeometry;
    for (let i = 0, l = roots.length; i < l; i++) {
      result = intersectsGeometryFunc(this, i, otherGeometry, geomToMesh);
      if (result) {
        break;
      }
    }
    return result;
  }
  shapecast(callbacks) {
    const triangle32 = ExtendedTrianglePool.getPrimitive();
    const iterateFunc = this.indirect ? iterateOverTriangles_indirect : iterateOverTriangles;
    let {
      boundsTraverseOrder,
      intersectsBounds,
      intersectsRange,
      intersectsTriangle
    } = callbacks;
    if (intersectsRange && intersectsTriangle) {
      const originalIntersectsRange = intersectsRange;
      intersectsRange = (offset, count, contained, depth, nodeIndex) => {
        if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {
          return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle32);
        }
        return true;
      };
    } else if (!intersectsRange) {
      if (intersectsTriangle) {
        intersectsRange = (offset, count, contained, depth) => {
          return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle32);
        };
      } else {
        intersectsRange = (offset, count, contained) => {
          return contained;
        };
      }
    }
    let result = false;
    let byteOffset = 0;
    const roots = this._roots;
    for (let i = 0, l = roots.length; i < l; i++) {
      const root = roots[i];
      result = shapecast(this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);
      if (result) {
        break;
      }
      byteOffset += root.byteLength;
    }
    ExtendedTrianglePool.releasePrimitive(triangle32);
    return result;
  }
  bvhcast(otherBvh, matrixToLocal, callbacks) {
    let {
      intersectsRanges,
      intersectsTriangles
    } = callbacks;
    const triangle1 = ExtendedTrianglePool.getPrimitive();
    const indexAttr1 = this.geometry.index;
    const positionAttr1 = this.geometry.attributes.position;
    const assignTriangle1 = this.indirect ? (i1) => {
      const ti = this.resolveTriangleIndex(i1);
      setTriangle(triangle1, ti * 3, indexAttr1, positionAttr1);
    } : (i1) => {
      setTriangle(triangle1, i1 * 3, indexAttr1, positionAttr1);
    };
    const triangle222 = ExtendedTrianglePool.getPrimitive();
    const indexAttr2 = otherBvh.geometry.index;
    const positionAttr2 = otherBvh.geometry.attributes.position;
    const assignTriangle2 = otherBvh.indirect ? (i2) => {
      const ti2 = otherBvh.resolveTriangleIndex(i2);
      setTriangle(triangle222, ti2 * 3, indexAttr2, positionAttr2);
    } : (i2) => {
      setTriangle(triangle222, i2 * 3, indexAttr2, positionAttr2);
    };
    if (intersectsTriangles) {
      const iterateOverDoubleTriangles = (offset1, count1, offset2, count2, depth1, index1, depth2, index2) => {
        for (let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++) {
          assignTriangle2(i2);
          triangle222.a.applyMatrix4(matrixToLocal);
          triangle222.b.applyMatrix4(matrixToLocal);
          triangle222.c.applyMatrix4(matrixToLocal);
          triangle222.needsUpdate = true;
          for (let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {
            assignTriangle1(i1);
            triangle1.needsUpdate = true;
            if (intersectsTriangles(triangle1, triangle222, i1, i2, depth1, index1, depth2, index2)) {
              return true;
            }
          }
        }
        return false;
      };
      if (intersectsRanges) {
        const originalIntersectsRanges = intersectsRanges;
        intersectsRanges = function(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {
          if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {
            return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);
          }
          return true;
        };
      } else {
        intersectsRanges = iterateOverDoubleTriangles;
      }
    }
    return bvhcast(this, otherBvh, matrixToLocal, intersectsRanges);
  }
  /* Derived Cast Functions */
  intersectsBox(box, boxToMesh) {
    obb.set(box.min, box.max, boxToMesh);
    obb.needsUpdate = true;
    return this.shapecast(
      {
        intersectsBounds: (box2) => obb.intersectsBox(box2),
        intersectsTriangle: (tri) => obb.intersectsTriangle(tri)
      }
    );
  }
  intersectsSphere(sphere) {
    return this.shapecast(
      {
        intersectsBounds: (box) => sphere.intersectsBox(box),
        intersectsTriangle: (tri) => tri.intersectsSphere(sphere)
      }
    );
  }
  closestPointToGeometry(otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
    const closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect : closestPointToGeometry;
    return closestPointToGeometryFunc(
      this,
      otherGeometry,
      geometryToBvh,
      target1,
      target2,
      minThreshold,
      maxThreshold
    );
  }
  closestPointToPoint(point, target = {}, minThreshold = 0, maxThreshold = Infinity) {
    return closestPointToPoint(
      this,
      point,
      target,
      minThreshold,
      maxThreshold
    );
  }
  getBoundingBox(target) {
    target.makeEmpty();
    const roots = this._roots;
    roots.forEach((buffer) => {
      arrayToBox(0, new Float32Array(buffer), tempBox);
      target.union(tempBox);
    });
    return target;
  }
};
function convertRaycastIntersect(hit, object, raycaster) {
  if (hit === null) {
    return null;
  }
  hit.point.applyMatrix4(object.matrixWorld);
  hit.distance = hit.point.distanceTo(raycaster.ray.origin);
  hit.object = object;
  if (hit.distance < raycaster.near || hit.distance > raycaster.far) {
    return null;
  } else {
    return hit;
  }
}
var ray = new Ray();
var tmpInverseMatrix = new Matrix4();
var origMeshRaycastFunc = Mesh.prototype.raycast;
function acceleratedRaycast(raycaster, intersects2) {
  if (this.geometry.boundsTree) {
    if (this.material === void 0)
      return;
    tmpInverseMatrix.copy(this.matrixWorld).invert();
    ray.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);
    const bvh = this.geometry.boundsTree;
    if (raycaster.firstHitOnly === true) {
      const hit = convertRaycastIntersect(bvh.raycastFirst(ray, this.material), this, raycaster);
      if (hit) {
        intersects2.push(hit);
      }
    } else {
      const hits = bvh.raycast(ray, this.material);
      for (let i = 0, l = hits.length; i < l; i++) {
        const hit = convertRaycastIntersect(hits[i], this, raycaster);
        if (hit) {
          intersects2.push(hit);
        }
      }
    }
  } else {
    origMeshRaycastFunc.call(this, raycaster, intersects2);
  }
}
function computeBoundsTree(options) {
  this.boundsTree = new MeshBVH(this, options);
  return this.boundsTree;
}
function disposeBoundsTree() {
  this.boundsTree = null;
}
var _BVH = class _BVH2 {
  /**
   * Applies the Bounding Volume Hierarchy (BVH) to a given BufferGeometry.
   * If the BVH is not already initialized, it adds the necessary methods to the BufferGeometry and Mesh prototypes.
   * If the geometry does not have a boundsTree, it computes one.
   *
   * @param geometry - The BufferGeometry to apply the BVH to.
   */
  static apply(geometry) {
    if (!_BVH2.initialized) {
      BufferGeometry.prototype.computeBoundsTree = computeBoundsTree;
      BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree;
      Mesh.prototype.raycast = acceleratedRaycast;
      _BVH2.initialized = true;
    }
    if (!geometry.boundsTree) {
      geometry.computeBoundsTree();
    }
  }
  /**
   * Disposes of the BVH associated with the given BufferGeometry.
   * If the geometry has a boundsTree, it disposes of it.
   *
   * @param geometry - The BufferGeometry to dispose of the BVH from.
   */
  static dispose(geometry) {
    if (geometry && geometry.disposeBoundsTree) {
      geometry.disposeBoundsTree();
    }
  }
};
__publicField(_BVH, "initialized", false);
var BVH = _BVH;
var Fragment$2 = class Fragment {
  /**
   * Constructs a new Fragment.
   * @param geometry - The geometry of the fragment.
   * @param material - The material(s) of the fragment.
   * @param count - The initial number of instances in the fragment.
   */
  constructor(geometry, material, count) {
    __publicField(this, "ids", /* @__PURE__ */ new Set());
    __publicField(this, "itemToInstances", /* @__PURE__ */ new Map());
    __publicField(this, "instanceToItem", /* @__PURE__ */ new Map());
    __publicField(this, "hiddenItems", /* @__PURE__ */ new Set());
    __publicField(this, "id");
    __publicField(this, "mesh");
    __publicField(this, "capacity", 0);
    __publicField(this, "capacityOffset", 10);
    __publicField(this, "group");
    __publicField(this, "_originalColors", /* @__PURE__ */ new Map());
    __publicField(this, "_settingVisibility", false);
    this.mesh = new FragmentMesh(geometry, material, count, this);
    this.id = this.mesh.uuid;
    this.capacity = count;
    this.mesh.count = 0;
    if (this.mesh.geometry.index.count) {
      BVH.apply(this.mesh.geometry);
    }
  }
  /**
   * A getter property that returns the unique vertices of the fragment's geometry.
   * The unique vertices are determined by comparing the vertex positions.
   *
   * @returns An array of unique vertices.
   */
  get uniqueVertices() {
    const uniqueVertices = [];
    const position = this.mesh.geometry.getAttribute(
      "position"
    );
    if (!position)
      return uniqueVertices;
    const uniqueVerticesSet = /* @__PURE__ */ new Set();
    for (let i = 0; i < position.count; i++) {
      const x = position.getX(i);
      const y = position.getY(i);
      const z = position.getZ(i);
      const vertexKey = `${x},${y},${z}`;
      if (!uniqueVerticesSet.has(vertexKey)) {
        uniqueVerticesSet.add(vertexKey);
        uniqueVertices.push(new Vector3(x, y, z));
      }
    }
    return uniqueVertices;
  }
  /**
   * Disposes of the fragment and its associated resources.
   *
   * @param disposeResources - If true, disposes geometries and materials associated with the fragment. If false, only disposes of the fragment itself.
   */
  dispose(disposeResources = true) {
    this.clear();
    this.group = void 0;
    this._originalColors.clear();
    if (this.mesh) {
      if (disposeResources) {
        for (const mat of this.mesh.material) {
          mat.dispose();
        }
        this.mesh.material = [];
        BVH.dispose(this.mesh.geometry);
        if (this.mesh.geometry) {
          this.mesh.geometry.dispose();
        }
        this.mesh.geometry = null;
      }
      this.mesh.removeFromParent();
      this.mesh.userData = {};
      this.mesh.dispose();
      this.mesh.fragment = null;
      this.mesh = null;
    }
  }
  /**
   * Retrieves the transform matrices and colors of instances associated with a given item ID.
   *
   * @param itemID - The unique identifier of the item.
   * @throws Will throw an error if the item is not found.
   * @returns An object containing the item ID, an array of transform matrices, and an optional array of colors.
   * If no colors are found, the colors array will be undefined.
   */
  get(itemID) {
    const instanceIDs = this.getInstancesIDs(itemID);
    if (!instanceIDs) {
      throw new Error("Item not found!");
    }
    const transforms = [];
    const colorsArray = [];
    for (const id of instanceIDs) {
      const matrix = new Matrix4();
      this.mesh.getMatrixAt(id, matrix);
      transforms.push(matrix);
      if (this.mesh.instanceColor) {
        const color = new Color();
        this.mesh.getColorAt(id, color);
        colorsArray.push(color);
      }
    }
    const colors = colorsArray.length ? colorsArray : void 0;
    return { id: itemID, transforms, colors };
  }
  /**
   * Retrieves the item ID associated with a given instance ID.
   *
   * @param instanceID - The unique identifier of the instance.
   * @returns The item ID associated with the instance, or null if no association exists.
   */
  getItemID(instanceID) {
    return this.instanceToItem.get(instanceID) || null;
  }
  /**
   * Retrieves the instance IDs associated with a given item ID.
   *
   * @param itemID - The unique identifier of the item.
   * @returns The set of instance IDs associated with the item, or null if no association exists.
   */
  getInstancesIDs(itemID) {
    return this.itemToInstances.get(itemID) || null;
  }
  /**
   * Updates the instance color and matrix attributes of the fragment's mesh.
   * This method should be called whenever the instance color or matrix attributes
   * need to be updated.
   */
  update() {
    if (this.mesh.instanceColor) {
      this.mesh.instanceColor.needsUpdate = true;
    }
    this.mesh.instanceMatrix.needsUpdate = true;
  }
  /**
   * Adds items to the fragment.
   *
   * @param items - An array of items to be added. Each item contains an ID, an array of transform matrices, and an optional array of colors.
   *
   * If the necessary capacity to accommodate the new items exceeds the current capacity,
   * a new mesh with a larger capacity is created, and the old mesh is disposed.
   *
   * The transform matrices and colors of the items are added to the respective attributes of the mesh.
   *
   * The instance IDs, item IDs, and associations between instance IDs and item IDs are updated accordingly.
   *
   * The instance color and matrix attributes of the mesh are updated.
   */
  add(items) {
    var _a;
    let size = 0;
    for (const item of items) {
      size += item.transforms.length;
    }
    const necessaryCapacity = this.mesh.count + size;
    if (necessaryCapacity > this.capacity) {
      const newCapacity = necessaryCapacity + this.capacityOffset;
      const newMesh = new FragmentMesh(
        this.mesh.geometry,
        this.mesh.material,
        newCapacity,
        this
      );
      newMesh.count = this.mesh.count;
      this.capacity = newCapacity;
      const oldMesh = this.mesh;
      (_a = oldMesh.parent) == null ? void 0 : _a.add(newMesh);
      oldMesh.removeFromParent();
      this.mesh = newMesh;
      const tempMatrix22 = new Matrix4();
      for (let i = 0; i < oldMesh.instanceMatrix.count; i++) {
        oldMesh.getMatrixAt(i, tempMatrix22);
        newMesh.setMatrixAt(i, tempMatrix22);
      }
      if (oldMesh.instanceColor) {
        const tempColor = new Color();
        for (let i = 0; i < oldMesh.instanceColor.count; i++) {
          oldMesh.getColorAt(i, tempColor);
          newMesh.setColorAt(i, tempColor);
        }
      }
      oldMesh.dispose();
    }
    for (let i = 0; i < items.length; i++) {
      const { transforms, colors, id } = items[i];
      if (!this.itemToInstances.has(id)) {
        this.itemToInstances.set(id, /* @__PURE__ */ new Set());
      }
      const instances = this.itemToInstances.get(id);
      this.ids.add(id);
      for (let j = 0; j < transforms.length; j++) {
        const transform = transforms[j];
        const newInstanceID = this.mesh.count;
        this.mesh.setMatrixAt(newInstanceID, transform);
        if (colors) {
          const color = colors[j];
          this.mesh.setColorAt(newInstanceID, color);
        }
        instances.add(newInstanceID);
        this.instanceToItem.set(newInstanceID, id);
        this.mesh.count++;
      }
    }
    this.update();
  }
  /**
   * Removes items from the fragment.
   *
   * @param itemsIDs - An iterable of item IDs to be removed.
   *
   * The instance IDs, item IDs, and associations between instance IDs and item IDs are updated accordingly.
   *
   * The instance color and matrix attributes of the mesh are updated.
   *
   * @throws Will throw an error if the instances are not found.
   */
  remove(itemsIDs) {
    if (this.mesh.count === 0) {
      return;
    }
    for (const itemID of itemsIDs) {
      const instancesToDelete = this.itemToInstances.get(itemID);
      if (instancesToDelete === void 0) {
        throw new Error("Instances not found!");
      }
      for (const instanceID of instancesToDelete) {
        if (this.mesh.count === 0)
          throw new Error("Error with mesh count!");
        this.putLast(instanceID);
        this.instanceToItem.delete(instanceID);
        this.mesh.count--;
      }
      this.itemToInstances.delete(itemID);
      this.ids.delete(itemID);
    }
    this.update();
  }
  /**
   * Clears the fragment by resetting the hidden items, item IDs, instance-to-item associations,
   * instance-to-item map, and the count of instances in the fragment's mesh.
   *
   * @remarks
   * This method is used to reset the fragment to its initial state.
   *
   * @example
   * ```typescript
   * fragment.clear();
   * ```
   */
  clear() {
    this.hiddenItems.clear();
    this.ids.clear();
    this.instanceToItem.clear();
    this.itemToInstances.clear();
    this.mesh.count = 0;
  }
  /**
   * Sets the visibility of items in the fragment.
   *
   * @param visible - A boolean indicating whether the items should be visible or hidden.
   * @param itemIDs - An iterable of item IDs to be affected. If not provided, all items in the fragment will be affected.
   *
   * @remarks
   * This method updates the visibility of items in the fragment based on the provided visibility flag.
   *
   *
   * @example
   * ```typescript
   * fragment.setVisibility(true, [1, 2, 3]); // Makes items with IDs 1, 2, and 3 visible.
   * fragment.setVisibility(false); // Makes all items in the fragment hidden.
   * ```
   */
  setVisibility(visible, itemIDs = this.ids) {
    if (this._settingVisibility)
      return;
    this._settingVisibility = true;
    if (visible) {
      for (const itemID of itemIDs) {
        if (!this.ids.has(itemID)) {
          continue;
        }
        if (!this.hiddenItems.has(itemID)) {
          continue;
        }
        const instances = this.itemToInstances.get(itemID);
        if (!instances)
          throw new Error("Instances not found!");
        for (const instance of new Set(instances)) {
          this.mesh.count++;
          this.putLast(instance);
        }
        this.hiddenItems.delete(itemID);
      }
    } else {
      for (const itemID of itemIDs) {
        if (!this.ids.has(itemID)) {
          continue;
        }
        if (this.hiddenItems.has(itemID)) {
          continue;
        }
        const instances = this.itemToInstances.get(itemID);
        if (!instances) {
          throw new Error("Instances not found!");
        }
        for (const instance of new Set(instances)) {
          this.putLast(instance);
          this.mesh.count--;
        }
        this.hiddenItems.add(itemID);
      }
    }
    this.update();
    this._settingVisibility = false;
  }
  /**
   * Sets the color of items in the fragment.
   *
   * @param color - The color to be set for the items.
   * @param itemIDs - An iterable of item IDs to be affected. If not provided, all items in the fragment will be affected.
   * @param override - A boolean indicating whether the original color should be overridden. If true, the original color will be replaced with the new color.
   *
   *
   * @example
   * ```typescript
   * fragment.setColor(new THREE.Color(0xff0000), [1, 2, 3], true); // Sets the color of items with IDs 1, 2, and 3 to red, overriding their original colors.
   * fragment.setColor(new THREE.Color(0x00ff00)); // Sets the color of all items in the fragment to green.
   * ```
   */
  setColor(color, itemIDs = this.ids, override = false) {
    if (!this.mesh.instanceColor) {
      throw new Error("This fragment doesn't have color per instance!");
    }
    for (const itemID of itemIDs) {
      if (!this.ids.has(itemID)) {
        continue;
      }
      const instances = this.itemToInstances.get(itemID);
      if (!instances) {
        throw new Error("Instances not found!");
      }
      const originalsExist = this._originalColors.has(itemID);
      if (!originalsExist) {
        this._originalColors.set(itemID, /* @__PURE__ */ new Map());
      }
      const originals = this._originalColors.get(itemID);
      for (const instance of new Set(instances)) {
        if (!originalsExist) {
          const originalColor = new Color();
          this.mesh.getColorAt(instance, originalColor);
          originals.set(instance, originalColor);
        }
        this.mesh.setColorAt(instance, color);
        if (override) {
          originals.set(instance, color);
        }
      }
    }
    this.mesh.instanceColor.needsUpdate = true;
  }
  /**
   * Resets the color of items in the fragment to their original colors.
   *
   * @param itemIDs - An iterable of item IDs to be affected. If not provided, all items in the fragment will be affected.
   *
   *
   * @example
   * ```typescript
   * fragment.resetColor([1, 2, 3]); // Resets the color of items with IDs 1, 2, and 3 to their original colors.
   * fragment.resetColor(); // Resets the color of all items in the fragment to their original colors.
   * ```
   */
  resetColor(itemIDs = this.ids) {
    if (!this.mesh.instanceColor) {
      throw new Error("This fragment doesn't have color per instance!");
    }
    for (const itemID of itemIDs) {
      if (!this.ids.has(itemID)) {
        continue;
      }
      const instances = this.itemToInstances.get(itemID);
      if (!instances) {
        throw new Error("Instances not found!");
      }
      const originals = this._originalColors.get(itemID);
      if (!originals) {
        continue;
      }
      for (const instance of new Set(instances)) {
        const originalColor = originals.get(instance);
        if (!originalColor) {
          throw new Error("Original color not found!");
        }
        this.mesh.setColorAt(instance, originalColor);
      }
    }
    this.mesh.instanceColor.needsUpdate = true;
  }
  /**
   * Applies a transformation matrix to instances associated with given item IDs.
   *
   * @param itemIDs - An iterable of item IDs to be affected.
   * @param transform - The transformation matrix to be applied.
   *
   * @remarks
   * This method applies the provided transformation matrix to the instances associated with the given item IDs.
   *
   * @example
   * ```typescript
   * fragment.applyTransform([1, 2, 3], new THREE.Matrix4().makeTranslation(1, 0, 0)); // Applies a translation of (1, 0, 0) to instances with IDs 1, 2, and 3.
   * ```
   */
  applyTransform(itemIDs, transform) {
    const tempMatrix22 = new Matrix4();
    for (const itemID of itemIDs) {
      const instances = this.getInstancesIDs(itemID);
      if (instances === null) {
        continue;
      }
      for (const instanceID of instances) {
        this.mesh.getMatrixAt(instanceID, tempMatrix22);
        tempMatrix22.premultiply(transform);
        this.mesh.setMatrixAt(instanceID, tempMatrix22);
      }
    }
    this.update();
  }
  /**
   * Exports the fragment's geometry and associated data.
   *
   * @returns An object containing the exported geometry, an array of IDs associated with the fragment, and the fragment's ID.
   *
   * @remarks
   * This method is used to export the fragment's geometry and associated data for further processing or storage.
   *
   * @example
   * ```typescript
   * const exportedData = fragment.exportData();
   * // Use the exportedData object for further processing or storage
   * ```
   */
  exportData() {
    const geometry = this.mesh.exportData();
    const ids = Array.from(this.ids);
    const id = this.id;
    return { ...geometry, ids, id };
  }
  /**
   * Creates a copy of the whole fragment or a part of it. It shares the geometry with the original fragment, but has its own InstancedMesh data, so it also needs to be disposed.
   *
   * @param itemIDs - An iterable of item IDs to be included in the clone.
   *
   */
  clone(itemIDs = this.ids) {
    const newFragment = new Fragment(
      this.mesh.geometry,
      this.mesh.material,
      this.capacity
    );
    const items = [];
    for (const id of itemIDs) {
      const instancesIDs = this.getInstancesIDs(id);
      if (instancesIDs === null) {
        continue;
      }
      const transforms = [];
      const colors = [];
      for (const instanceID of instancesIDs) {
        const newMatrix = new Matrix4();
        const newColor = new Color();
        this.mesh.getMatrixAt(instanceID, newMatrix);
        this.mesh.getColorAt(instanceID, newColor);
        transforms.push(newMatrix);
        colors.push(newColor);
      }
      items.push({
        id,
        transforms,
        colors
      });
    }
    newFragment.add(items);
    return newFragment;
  }
  putLast(instanceID1) {
    if (this.mesh.count === 0)
      return;
    const id1 = this.instanceToItem.get(instanceID1);
    const instanceID2 = this.mesh.count - 1;
    if (instanceID2 === instanceID1) {
      return;
    }
    const id2 = this.instanceToItem.get(instanceID2);
    if (id1 === void 0 || id2 === void 0) {
      throw new Error("Keys not found");
    }
    if (id1 !== id2) {
      const instances1 = this.itemToInstances.get(id1);
      const instances2 = this.itemToInstances.get(id2);
      if (!instances1 || !instances2) {
        throw new Error("Instances not found");
      }
      if (!instances1.has(instanceID1) || !instances2.has(instanceID2)) {
        throw new Error("Malformed fragment structure");
      }
      instances1.delete(instanceID1);
      instances2.delete(instanceID2);
      instances1.add(instanceID2);
      instances2.add(instanceID1);
      this.instanceToItem.set(instanceID1, id2);
      this.instanceToItem.set(instanceID2, id1);
    }
    const transform1 = new Matrix4();
    const transform2 = new Matrix4();
    this.mesh.getMatrixAt(instanceID1, transform1);
    this.mesh.getMatrixAt(instanceID2, transform2);
    this.mesh.setMatrixAt(instanceID1, transform2);
    this.mesh.setMatrixAt(instanceID2, transform1);
    if (this.mesh.instanceColor !== null) {
      const color1 = new Color();
      const color2 = new Color();
      this.mesh.getColorAt(instanceID1, color1);
      this.mesh.getColorAt(instanceID2, color2);
      this.mesh.setColorAt(instanceID1, color2);
      this.mesh.setColorAt(instanceID2, color1);
      const originals1 = this._originalColors.get(id1);
      if (originals1) {
        const color12 = originals1.get(instanceID1);
        if (color12) {
          originals1.delete(instanceID1);
          originals1.set(instanceID2, color12);
        }
      }
      const originals2 = this._originalColors.get(id2);
      if (originals2) {
        const color22 = originals2.get(instanceID2);
        if (color22) {
          originals2.delete(instanceID2);
          originals2.set(instanceID1, color22);
        }
      }
    }
  }
};
var SIZEOF_SHORT = 2;
var SIZEOF_INT = 4;
var FILE_IDENTIFIER_LENGTH = 4;
var SIZE_PREFIX_LENGTH = 4;
var int32 = new Int32Array(2);
var float32 = new Float32Array(int32.buffer);
var float64 = new Float64Array(int32.buffer);
var isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1;
var Encoding;
(function(Encoding2) {
  Encoding2[Encoding2["UTF8_BYTES"] = 1] = "UTF8_BYTES";
  Encoding2[Encoding2["UTF16_STRING"] = 2] = "UTF16_STRING";
})(Encoding || (Encoding = {}));
var ByteBuffer = class _ByteBuffer {
  /**
   * Create a new ByteBuffer with a given array of bytes (`Uint8Array`)
   */
  constructor(bytes_) {
    this.bytes_ = bytes_;
    this.position_ = 0;
    this.text_decoder_ = new TextDecoder();
  }
  /**
   * Create and allocate a new ByteBuffer with a given size.
   */
  static allocate(byte_size) {
    return new _ByteBuffer(new Uint8Array(byte_size));
  }
  clear() {
    this.position_ = 0;
  }
  /**
   * Get the underlying `Uint8Array`.
   */
  bytes() {
    return this.bytes_;
  }
  /**
   * Get the buffer's position.
   */
  position() {
    return this.position_;
  }
  /**
   * Set the buffer's position.
   */
  setPosition(position) {
    this.position_ = position;
  }
  /**
   * Get the buffer's capacity.
   */
  capacity() {
    return this.bytes_.length;
  }
  readInt8(offset) {
    return this.readUint8(offset) << 24 >> 24;
  }
  readUint8(offset) {
    return this.bytes_[offset];
  }
  readInt16(offset) {
    return this.readUint16(offset) << 16 >> 16;
  }
  readUint16(offset) {
    return this.bytes_[offset] | this.bytes_[offset + 1] << 8;
  }
  readInt32(offset) {
    return this.bytes_[offset] | this.bytes_[offset + 1] << 8 | this.bytes_[offset + 2] << 16 | this.bytes_[offset + 3] << 24;
  }
  readUint32(offset) {
    return this.readInt32(offset) >>> 0;
  }
  readInt64(offset) {
    return BigInt.asIntN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
  }
  readUint64(offset) {
    return BigInt.asUintN(64, BigInt(this.readUint32(offset)) + (BigInt(this.readUint32(offset + 4)) << BigInt(32)));
  }
  readFloat32(offset) {
    int32[0] = this.readInt32(offset);
    return float32[0];
  }
  readFloat64(offset) {
    int32[isLittleEndian ? 0 : 1] = this.readInt32(offset);
    int32[isLittleEndian ? 1 : 0] = this.readInt32(offset + 4);
    return float64[0];
  }
  writeInt8(offset, value) {
    this.bytes_[offset] = value;
  }
  writeUint8(offset, value) {
    this.bytes_[offset] = value;
  }
  writeInt16(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
  }
  writeUint16(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
  }
  writeInt32(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
    this.bytes_[offset + 2] = value >> 16;
    this.bytes_[offset + 3] = value >> 24;
  }
  writeUint32(offset, value) {
    this.bytes_[offset] = value;
    this.bytes_[offset + 1] = value >> 8;
    this.bytes_[offset + 2] = value >> 16;
    this.bytes_[offset + 3] = value >> 24;
  }
  writeInt64(offset, value) {
    this.writeInt32(offset, Number(BigInt.asIntN(32, value)));
    this.writeInt32(offset + 4, Number(BigInt.asIntN(32, value >> BigInt(32))));
  }
  writeUint64(offset, value) {
    this.writeUint32(offset, Number(BigInt.asUintN(32, value)));
    this.writeUint32(offset + 4, Number(BigInt.asUintN(32, value >> BigInt(32))));
  }
  writeFloat32(offset, value) {
    float32[0] = value;
    this.writeInt32(offset, int32[0]);
  }
  writeFloat64(offset, value) {
    float64[0] = value;
    this.writeInt32(offset, int32[isLittleEndian ? 0 : 1]);
    this.writeInt32(offset + 4, int32[isLittleEndian ? 1 : 0]);
  }
  /**
   * Return the file identifier.   Behavior is undefined for FlatBuffers whose
   * schema does not include a file_identifier (likely points at padding or the
   * start of a the root vtable).
   */
  getBufferIdentifier() {
    if (this.bytes_.length < this.position_ + SIZEOF_INT + FILE_IDENTIFIER_LENGTH) {
      throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
    }
    let result = "";
    for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {
      result += String.fromCharCode(this.readInt8(this.position_ + SIZEOF_INT + i));
    }
    return result;
  }
  /**
   * Look up a field in the vtable, return an offset into the object, or 0 if the
   * field is not present.
   */
  __offset(bb_pos, vtable_offset) {
    const vtable = bb_pos - this.readInt32(bb_pos);
    return vtable_offset < this.readInt16(vtable) ? this.readInt16(vtable + vtable_offset) : 0;
  }
  /**
   * Initialize any Table-derived type to point to the union at the given offset.
   */
  __union(t, offset) {
    t.bb_pos = offset + this.readInt32(offset);
    t.bb = this;
    return t;
  }
  /**
   * Create a JavaScript string from UTF-8 data stored inside the FlatBuffer.
   * This allocates a new string and converts to wide chars upon each access.
   *
   * To avoid the conversion to string, pass Encoding.UTF8_BYTES as the
   * "optionalEncoding" argument. This is useful for avoiding conversion when
   * the data will just be packaged back up in another FlatBuffer later on.
   *
   * @param offset
   * @param opt_encoding Defaults to UTF16_STRING
   */
  __string(offset, opt_encoding) {
    offset += this.readInt32(offset);
    const length = this.readInt32(offset);
    offset += SIZEOF_INT;
    const utf8bytes = this.bytes_.subarray(offset, offset + length);
    if (opt_encoding === Encoding.UTF8_BYTES)
      return utf8bytes;
    else
      return this.text_decoder_.decode(utf8bytes);
  }
  /**
   * Handle unions that can contain string as its member, if a Table-derived type then initialize it,
   * if a string then return a new one
   *
   * WARNING: strings are immutable in JS so we can't change the string that the user gave us, this
   * makes the behaviour of __union_with_string different compared to __union
   */
  __union_with_string(o, offset) {
    if (typeof o === "string") {
      return this.__string(offset);
    }
    return this.__union(o, offset);
  }
  /**
   * Retrieve the relative offset stored at "offset"
   */
  __indirect(offset) {
    return offset + this.readInt32(offset);
  }
  /**
   * Get the start of data of a vector whose offset is stored at "offset" in this object.
   */
  __vector(offset) {
    return offset + this.readInt32(offset) + SIZEOF_INT;
  }
  /**
   * Get the length of a vector whose offset is stored at "offset" in this object.
   */
  __vector_len(offset) {
    return this.readInt32(offset + this.readInt32(offset));
  }
  __has_identifier(ident) {
    if (ident.length != FILE_IDENTIFIER_LENGTH) {
      throw new Error("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
    }
    for (let i = 0; i < FILE_IDENTIFIER_LENGTH; i++) {
      if (ident.charCodeAt(i) != this.readInt8(this.position() + SIZEOF_INT + i)) {
        return false;
      }
    }
    return true;
  }
  /**
   * A helper function for generating list for obj api
   */
  createScalarList(listAccessor, listLength) {
    const ret = [];
    for (let i = 0; i < listLength; ++i) {
      const val2 = listAccessor(i);
      if (val2 !== null) {
        ret.push(val2);
      }
    }
    return ret;
  }
  /**
   * A helper function for generating list for obj api
   * @param listAccessor function that accepts an index and return data at that index
   * @param listLength listLength
   * @param res result list
   */
  createObjList(listAccessor, listLength) {
    const ret = [];
    for (let i = 0; i < listLength; ++i) {
      const val2 = listAccessor(i);
      if (val2 !== null) {
        ret.push(val2.unpack());
      }
    }
    return ret;
  }
};
var Builder = class _Builder {
  /**
   * Create a FlatBufferBuilder.
   */
  constructor(opt_initial_size) {
    this.minalign = 1;
    this.vtable = null;
    this.vtable_in_use = 0;
    this.isNested = false;
    this.object_start = 0;
    this.vtables = [];
    this.vector_num_elems = 0;
    this.force_defaults = false;
    this.string_maps = null;
    this.text_encoder = new TextEncoder();
    let initial_size;
    if (!opt_initial_size) {
      initial_size = 1024;
    } else {
      initial_size = opt_initial_size;
    }
    this.bb = ByteBuffer.allocate(initial_size);
    this.space = initial_size;
  }
  clear() {
    this.bb.clear();
    this.space = this.bb.capacity();
    this.minalign = 1;
    this.vtable = null;
    this.vtable_in_use = 0;
    this.isNested = false;
    this.object_start = 0;
    this.vtables = [];
    this.vector_num_elems = 0;
    this.force_defaults = false;
    this.string_maps = null;
  }
  /**
   * In order to save space, fields that are set to their default value
   * don't get serialized into the buffer. Forcing defaults provides a
   * way to manually disable this optimization.
   *
   * @param forceDefaults true always serializes default values
   */
  forceDefaults(forceDefaults) {
    this.force_defaults = forceDefaults;
  }
  /**
   * Get the ByteBuffer representing the FlatBuffer. Only call this after you've
   * called finish(). The actual data starts at the ByteBuffer's current position,
   * not necessarily at 0.
   */
  dataBuffer() {
    return this.bb;
  }
  /**
   * Get the bytes representing the FlatBuffer. Only call this after you've
   * called finish().
   */
  asUint8Array() {
    return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
  }
  /**
   * Prepare to write an element of `size` after `additional_bytes` have been
   * written, e.g. if you write a string, you need to align such the int length
   * field is aligned to 4 bytes, and the string data follows it directly. If all
   * you need to do is alignment, `additional_bytes` will be 0.
   *
   * @param size This is the of the new element to write
   * @param additional_bytes The padding size
   */
  prep(size, additional_bytes) {
    if (size > this.minalign) {
      this.minalign = size;
    }
    const align_size = ~(this.bb.capacity() - this.space + additional_bytes) + 1 & size - 1;
    while (this.space < align_size + size + additional_bytes) {
      const old_buf_size = this.bb.capacity();
      this.bb = _Builder.growByteBuffer(this.bb);
      this.space += this.bb.capacity() - old_buf_size;
    }
    this.pad(align_size);
  }
  pad(byte_size) {
    for (let i = 0; i < byte_size; i++) {
      this.bb.writeInt8(--this.space, 0);
    }
  }
  writeInt8(value) {
    this.bb.writeInt8(this.space -= 1, value);
  }
  writeInt16(value) {
    this.bb.writeInt16(this.space -= 2, value);
  }
  writeInt32(value) {
    this.bb.writeInt32(this.space -= 4, value);
  }
  writeInt64(value) {
    this.bb.writeInt64(this.space -= 8, value);
  }
  writeFloat32(value) {
    this.bb.writeFloat32(this.space -= 4, value);
  }
  writeFloat64(value) {
    this.bb.writeFloat64(this.space -= 8, value);
  }
  /**
   * Add an `int8` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int8` to add the buffer.
   */
  addInt8(value) {
    this.prep(1, 0);
    this.writeInt8(value);
  }
  /**
   * Add an `int16` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int16` to add the buffer.
   */
  addInt16(value) {
    this.prep(2, 0);
    this.writeInt16(value);
  }
  /**
   * Add an `int32` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int32` to add the buffer.
   */
  addInt32(value) {
    this.prep(4, 0);
    this.writeInt32(value);
  }
  /**
   * Add an `int64` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `int64` to add the buffer.
   */
  addInt64(value) {
    this.prep(8, 0);
    this.writeInt64(value);
  }
  /**
   * Add a `float32` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `float32` to add the buffer.
   */
  addFloat32(value) {
    this.prep(4, 0);
    this.writeFloat32(value);
  }
  /**
   * Add a `float64` to the buffer, properly aligned, and grows the buffer (if necessary).
   * @param value The `float64` to add the buffer.
   */
  addFloat64(value) {
    this.prep(8, 0);
    this.writeFloat64(value);
  }
  addFieldInt8(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addInt8(value);
      this.slot(voffset);
    }
  }
  addFieldInt16(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addInt16(value);
      this.slot(voffset);
    }
  }
  addFieldInt32(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addInt32(value);
      this.slot(voffset);
    }
  }
  addFieldInt64(voffset, value, defaultValue) {
    if (this.force_defaults || value !== defaultValue) {
      this.addInt64(value);
      this.slot(voffset);
    }
  }
  addFieldFloat32(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addFloat32(value);
      this.slot(voffset);
    }
  }
  addFieldFloat64(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addFloat64(value);
      this.slot(voffset);
    }
  }
  addFieldOffset(voffset, value, defaultValue) {
    if (this.force_defaults || value != defaultValue) {
      this.addOffset(value);
      this.slot(voffset);
    }
  }
  /**
   * Structs are stored inline, so nothing additional is being added. `d` is always 0.
   */
  addFieldStruct(voffset, value, defaultValue) {
    if (value != defaultValue) {
      this.nested(value);
      this.slot(voffset);
    }
  }
  /**
   * Structures are always stored inline, they need to be created right
   * where they're used.  You'll get this assertion failure if you
   * created it elsewhere.
   */
  nested(obj) {
    if (obj != this.offset()) {
      throw new Error("FlatBuffers: struct must be serialized inline.");
    }
  }
  /**
   * Should not be creating any other object, string or vector
   * while an object is being constructed
   */
  notNested() {
    if (this.isNested) {
      throw new Error("FlatBuffers: object serialization must not be nested.");
    }
  }
  /**
   * Set the current vtable at `voffset` to the current location in the buffer.
   */
  slot(voffset) {
    if (this.vtable !== null)
      this.vtable[voffset] = this.offset();
  }
  /**
   * @returns Offset relative to the end of the buffer.
   */
  offset() {
    return this.bb.capacity() - this.space;
  }
  /**
   * Doubles the size of the backing ByteBuffer and copies the old data towards
   * the end of the new buffer (since we build the buffer backwards).
   *
   * @param bb The current buffer with the existing data
   * @returns A new byte buffer with the old data copied
   * to it. The data is located at the end of the buffer.
   *
   * uint8Array.set() formally takes {Array<number>|ArrayBufferView}, so to pass
   * it a uint8Array we need to suppress the type check:
   * @suppress {checkTypes}
   */
  static growByteBuffer(bb) {
    const old_buf_size = bb.capacity();
    if (old_buf_size & 3221225472) {
      throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
    }
    const new_buf_size = old_buf_size << 1;
    const nbb = ByteBuffer.allocate(new_buf_size);
    nbb.setPosition(new_buf_size - old_buf_size);
    nbb.bytes().set(bb.bytes(), new_buf_size - old_buf_size);
    return nbb;
  }
  /**
   * Adds on offset, relative to where it will be written.
   *
   * @param offset The offset to add.
   */
  addOffset(offset) {
    this.prep(SIZEOF_INT, 0);
    this.writeInt32(this.offset() - offset + SIZEOF_INT);
  }
  /**
   * Start encoding a new object in the buffer.  Users will not usually need to
   * call this directly. The FlatBuffers compiler will generate helper methods
   * that call this method internally.
   */
  startObject(numfields) {
    this.notNested();
    if (this.vtable == null) {
      this.vtable = [];
    }
    this.vtable_in_use = numfields;
    for (let i = 0; i < numfields; i++) {
      this.vtable[i] = 0;
    }
    this.isNested = true;
    this.object_start = this.offset();
  }
  /**
   * Finish off writing the object that is under construction.
   *
   * @returns The offset to the object inside `dataBuffer`
   */
  endObject() {
    if (this.vtable == null || !this.isNested) {
      throw new Error("FlatBuffers: endObject called without startObject");
    }
    this.addInt32(0);
    const vtableloc = this.offset();
    let i = this.vtable_in_use - 1;
    for (; i >= 0 && this.vtable[i] == 0; i--) {
    }
    const trimmed_size = i + 1;
    for (; i >= 0; i--) {
      this.addInt16(this.vtable[i] != 0 ? vtableloc - this.vtable[i] : 0);
    }
    const standard_fields = 2;
    this.addInt16(vtableloc - this.object_start);
    const len = (trimmed_size + standard_fields) * SIZEOF_SHORT;
    this.addInt16(len);
    let existing_vtable = 0;
    const vt1 = this.space;
    outer_loop:
      for (i = 0; i < this.vtables.length; i++) {
        const vt2 = this.bb.capacity() - this.vtables[i];
        if (len == this.bb.readInt16(vt2)) {
          for (let j = SIZEOF_SHORT; j < len; j += SIZEOF_SHORT) {
            if (this.bb.readInt16(vt1 + j) != this.bb.readInt16(vt2 + j)) {
              continue outer_loop;
            }
          }
          existing_vtable = this.vtables[i];
          break;
        }
      }
    if (existing_vtable) {
      this.space = this.bb.capacity() - vtableloc;
      this.bb.writeInt32(this.space, existing_vtable - vtableloc);
    } else {
      this.vtables.push(this.offset());
      this.bb.writeInt32(this.bb.capacity() - vtableloc, this.offset() - vtableloc);
    }
    this.isNested = false;
    return vtableloc;
  }
  /**
   * Finalize a buffer, poiting to the given `root_table`.
   */
  finish(root_table, opt_file_identifier, opt_size_prefix) {
    const size_prefix = opt_size_prefix ? SIZE_PREFIX_LENGTH : 0;
    if (opt_file_identifier) {
      const file_identifier = opt_file_identifier;
      this.prep(this.minalign, SIZEOF_INT + FILE_IDENTIFIER_LENGTH + size_prefix);
      if (file_identifier.length != FILE_IDENTIFIER_LENGTH) {
        throw new Error("FlatBuffers: file identifier must be length " + FILE_IDENTIFIER_LENGTH);
      }
      for (let i = FILE_IDENTIFIER_LENGTH - 1; i >= 0; i--) {
        this.writeInt8(file_identifier.charCodeAt(i));
      }
    }
    this.prep(this.minalign, SIZEOF_INT + size_prefix);
    this.addOffset(root_table);
    if (size_prefix) {
      this.addInt32(this.bb.capacity() - this.space);
    }
    this.bb.setPosition(this.space);
  }
  /**
   * Finalize a size prefixed buffer, pointing to the given `root_table`.
   */
  finishSizePrefixed(root_table, opt_file_identifier) {
    this.finish(root_table, opt_file_identifier, true);
  }
  /**
   * This checks a required field has been set in a given table that has
   * just been constructed.
   */
  requiredField(table, field) {
    const table_start = this.bb.capacity() - table;
    const vtable_start = table_start - this.bb.readInt32(table_start);
    const ok = field < this.bb.readInt16(vtable_start) && this.bb.readInt16(vtable_start + field) != 0;
    if (!ok) {
      throw new Error("FlatBuffers: field " + field + " must be set");
    }
  }
  /**
   * Start a new array/vector of objects.  Users usually will not call
   * this directly. The FlatBuffers compiler will create a start/end
   * method for vector types in generated code.
   *
   * @param elem_size The size of each element in the array
   * @param num_elems The number of elements in the array
   * @param alignment The alignment of the array
   */
  startVector(elem_size, num_elems, alignment) {
    this.notNested();
    this.vector_num_elems = num_elems;
    this.prep(SIZEOF_INT, elem_size * num_elems);
    this.prep(alignment, elem_size * num_elems);
  }
  /**
   * Finish off the creation of an array and all its elements. The array must be
   * created with `startVector`.
   *
   * @returns The offset at which the newly created array
   * starts.
   */
  endVector() {
    this.writeInt32(this.vector_num_elems);
    return this.offset();
  }
  /**
   * Encode the string `s` in the buffer using UTF-8. If the string passed has
   * already been seen, we return the offset of the already written string
   *
   * @param s The string to encode
   * @return The offset in the buffer where the encoded string starts
   */
  createSharedString(s) {
    if (!s) {
      return 0;
    }
    if (!this.string_maps) {
      this.string_maps = /* @__PURE__ */ new Map();
    }
    if (this.string_maps.has(s)) {
      return this.string_maps.get(s);
    }
    const offset = this.createString(s);
    this.string_maps.set(s, offset);
    return offset;
  }
  /**
   * Encode the string `s` in the buffer using UTF-8. If a Uint8Array is passed
   * instead of a string, it is assumed to contain valid UTF-8 encoded data.
   *
   * @param s The string to encode
   * @return The offset in the buffer where the encoded string starts
   */
  createString(s) {
    if (s === null || s === void 0) {
      return 0;
    }
    let utf8;
    if (s instanceof Uint8Array) {
      utf8 = s;
    } else {
      utf8 = this.text_encoder.encode(s);
    }
    this.addInt8(0);
    this.startVector(1, utf8.length, 1);
    this.bb.setPosition(this.space -= utf8.length);
    for (let i = 0, offset = this.space, bytes = this.bb.bytes(); i < utf8.length; i++) {
      bytes[offset++] = utf8[i];
    }
    return this.endVector();
  }
  /**
   * A helper function to pack an object
   *
   * @returns offset of obj
   */
  createObjectOffset(obj) {
    if (obj === null) {
      return 0;
    }
    if (typeof obj === "string") {
      return this.createString(obj);
    } else {
      return obj.pack(this);
    }
  }
  /**
   * A helper function to pack a list of object
   *
   * @returns list of offsets of each non null object
   */
  createObjectOffsetList(list) {
    const ret = [];
    for (let i = 0; i < list.length; ++i) {
      const val2 = list[i];
      if (val2 !== null) {
        ret.push(this.createObjectOffset(val2));
      } else {
        throw new Error("FlatBuffers: Argument for createObjectOffsetList cannot contain null.");
      }
    }
    return ret;
  }
  createStructOffsetList(list, startFunc) {
    startFunc(this, list.length);
    this.createObjectOffsetList(list.slice().reverse());
    return this.endVector();
  }
};
var CivilCurve$2 = class CivilCurve {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsCivilCurve(bb, obj) {
    return (obj || new CivilCurve()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsCivilCurve(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new CivilCurve()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  points(index) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readFloat32(
      this.bb.__vector(this.bb_pos + offset) + index * 4
    ) : 0;
  }
  pointsLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  pointsArray() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? new Float32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  data(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  static startCivilCurve(builder) {
    builder.startObject(2);
  }
  static addPoints(builder, pointsOffset) {
    builder.addFieldOffset(0, pointsOffset, 0);
  }
  static createPointsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]);
    }
    return builder.endVector();
  }
  static startPointsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addData(builder, dataOffset) {
    builder.addFieldOffset(1, dataOffset, 0);
  }
  static endCivilCurve(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createCivilCurve(builder, pointsOffset, dataOffset) {
    CivilCurve.startCivilCurve(builder);
    CivilCurve.addPoints(builder, pointsOffset);
    CivilCurve.addData(builder, dataOffset);
    return CivilCurve.endCivilCurve(builder);
  }
};
var Alignment$2 = class Alignment {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsAlignment(bb, obj) {
    return (obj || new Alignment()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsAlignment(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new Alignment()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  vertical(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? (obj || new CivilCurve$2()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  verticalLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  horizontal(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? (obj || new CivilCurve$2()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  horizontalLength() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  absolute(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? (obj || new CivilCurve$2()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  absoluteLength() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  initialPk() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0;
  }
  static startAlignment(builder) {
    builder.startObject(4);
  }
  static addVertical(builder, verticalOffset) {
    builder.addFieldOffset(0, verticalOffset, 0);
  }
  static createVerticalVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startVerticalVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addHorizontal(builder, horizontalOffset) {
    builder.addFieldOffset(1, horizontalOffset, 0);
  }
  static createHorizontalVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startHorizontalVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addAbsolute(builder, absoluteOffset) {
    builder.addFieldOffset(2, absoluteOffset, 0);
  }
  static createAbsoluteVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startAbsoluteVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addInitialPk(builder, initialPk) {
    builder.addFieldFloat32(3, initialPk, 0);
  }
  static endAlignment(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createAlignment(builder, verticalOffset, horizontalOffset, absoluteOffset, initialPk) {
    Alignment.startAlignment(builder);
    Alignment.addVertical(builder, verticalOffset);
    Alignment.addHorizontal(builder, horizontalOffset);
    Alignment.addAbsolute(builder, absoluteOffset);
    Alignment.addInitialPk(builder, initialPk);
    return Alignment.endAlignment(builder);
  }
};
var CivilData$1 = class CivilData {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsCivilData(bb, obj) {
    return (obj || new CivilData()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsCivilData(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new CivilData()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  alignments(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? (obj || new Alignment$2()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  alignmentsLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  coordinationMatrix(index) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.readFloat32(
      this.bb.__vector(this.bb_pos + offset) + index * 4
    ) : 0;
  }
  coordinationMatrixLength() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  coordinationMatrixArray() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? new Float32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  static startCivilData(builder) {
    builder.startObject(2);
  }
  static addAlignments(builder, alignmentsOffset) {
    builder.addFieldOffset(0, alignmentsOffset, 0);
  }
  static createAlignmentsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startAlignmentsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addCoordinationMatrix(builder, coordinationMatrixOffset) {
    builder.addFieldOffset(1, coordinationMatrixOffset, 0);
  }
  static createCoordinationMatrixVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]);
    }
    return builder.endVector();
  }
  static startCoordinationMatrixVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endCivilData(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createCivilData(builder, alignmentsOffset, coordinationMatrixOffset) {
    CivilData.startCivilData(builder);
    CivilData.addAlignments(builder, alignmentsOffset);
    CivilData.addCoordinationMatrix(builder, coordinationMatrixOffset);
    return CivilData.endCivilData(builder);
  }
};
var Fragment$1 = class Fragment2 {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsFragment(bb, obj) {
    return (obj || new Fragment2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsFragment(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new Fragment2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  position(index) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  positionLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  positionArray() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
  }
  normal(index) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  normalLength() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  normalArray() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
  }
  index(index) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  indexLength() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  indexArray() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
  }
  groups(index) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  groupsLength() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  groupsArray() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
  }
  materials(index) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  materialsLength() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  materialsArray() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
  }
  matrices(index) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  matricesLength() {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  matricesArray() {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
  }
  colors(index) {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  colorsLength() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  colorsArray() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
  }
  itemsSize(index) {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  itemsSizeLength() {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  itemsSizeArray() {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
  }
  ids(index) {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  idsLength() {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  idsArray() {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
  }
  id(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  capacity() {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  capacityOffset() {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  static startFragment(builder) {
    builder.startObject(12);
  }
  static addPosition(builder, positionOffset) {
    builder.addFieldOffset(0, positionOffset, 0);
  }
  static createPositionVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]);
    }
    return builder.endVector();
  }
  static startPositionVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addNormal(builder, normalOffset) {
    builder.addFieldOffset(1, normalOffset, 0);
  }
  static createNormalVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]);
    }
    return builder.endVector();
  }
  static startNormalVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addIndex(builder, indexOffset) {
    builder.addFieldOffset(2, indexOffset, 0);
  }
  static createIndexVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startIndexVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addGroups(builder, groupsOffset) {
    builder.addFieldOffset(3, groupsOffset, 0);
  }
  static createGroupsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]);
    }
    return builder.endVector();
  }
  static startGroupsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addMaterials(builder, materialsOffset) {
    builder.addFieldOffset(4, materialsOffset, 0);
  }
  static createMaterialsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]);
    }
    return builder.endVector();
  }
  static startMaterialsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addMatrices(builder, matricesOffset) {
    builder.addFieldOffset(5, matricesOffset, 0);
  }
  static createMatricesVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]);
    }
    return builder.endVector();
  }
  static startMatricesVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addColors(builder, colorsOffset) {
    builder.addFieldOffset(6, colorsOffset, 0);
  }
  static createColorsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]);
    }
    return builder.endVector();
  }
  static startColorsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addItemsSize(builder, itemsSizeOffset) {
    builder.addFieldOffset(7, itemsSizeOffset, 0);
  }
  static createItemsSizeVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startItemsSizeVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addIds(builder, idsOffset) {
    builder.addFieldOffset(8, idsOffset, 0);
  }
  static createIdsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startIdsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addId(builder, idOffset) {
    builder.addFieldOffset(9, idOffset, 0);
  }
  static addCapacity(builder, capacity) {
    builder.addFieldInt32(10, capacity, 0);
  }
  static addCapacityOffset(builder, capacityOffset) {
    builder.addFieldInt32(11, capacityOffset, 0);
  }
  static endFragment(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createFragment(builder, positionOffset, normalOffset, indexOffset, groupsOffset, materialsOffset, matricesOffset, colorsOffset, itemsSizeOffset, idsOffset, idOffset, capacity, capacityOffset) {
    Fragment2.startFragment(builder);
    Fragment2.addPosition(builder, positionOffset);
    Fragment2.addNormal(builder, normalOffset);
    Fragment2.addIndex(builder, indexOffset);
    Fragment2.addGroups(builder, groupsOffset);
    Fragment2.addMaterials(builder, materialsOffset);
    Fragment2.addMatrices(builder, matricesOffset);
    Fragment2.addColors(builder, colorsOffset);
    Fragment2.addItemsSize(builder, itemsSizeOffset);
    Fragment2.addIds(builder, idsOffset);
    Fragment2.addId(builder, idOffset);
    Fragment2.addCapacity(builder, capacity);
    Fragment2.addCapacityOffset(builder, capacityOffset);
    return Fragment2.endFragment(builder);
  }
};
var FragmentsGroup$2 = class FragmentsGroup {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsFragmentsGroup(bb, obj) {
    return (obj || new FragmentsGroup()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsFragmentsGroup(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new FragmentsGroup()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  items(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? (obj || new Fragment$1()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  itemsLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  civil(obj) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? (obj || new CivilData$1()).__init(
      this.bb.__indirect(this.bb_pos + offset),
      this.bb
    ) : null;
  }
  coordinationMatrix(index) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.readFloat32(
      this.bb.__vector(this.bb_pos + offset) + index * 4
    ) : 0;
  }
  coordinationMatrixLength() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  coordinationMatrixArray() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? new Float32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  ids(index) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  idsLength() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  idsArray() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? new Uint32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  itemsKeys(index) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  itemsKeysLength() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  itemsKeysArray() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? new Uint32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  itemsKeysIndices(index) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  itemsKeysIndicesLength() {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  itemsKeysIndicesArray() {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? new Uint32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  itemsRels(index) {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  itemsRelsLength() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  itemsRelsArray() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? new Uint32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  itemsRelsIndices(index) {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  itemsRelsIndicesLength() {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  itemsRelsIndicesArray() {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? new Uint32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  fragmentKeys(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  id(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  name(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ifcName(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ifcDescription(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ifcSchema(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  maxExpressId() {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  boundingBox(index) {
    const offset = this.bb.__offset(this.bb_pos, 34);
    return offset ? this.bb.readFloat32(
      this.bb.__vector(this.bb_pos + offset) + index * 4
    ) : 0;
  }
  boundingBoxLength() {
    const offset = this.bb.__offset(this.bb_pos, 34);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  boundingBoxArray() {
    const offset = this.bb.__offset(this.bb_pos, 34);
    return offset ? new Float32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  opaqueGeometriesIds(index) {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  opaqueGeometriesIdsLength() {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  opaqueGeometriesIdsArray() {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? new Int32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  transparentGeometriesIds(index) {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  transparentGeometriesIdsLength() {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  transparentGeometriesIdsArray() {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? new Int32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  static startFragmentsGroup(builder) {
    builder.startObject(18);
  }
  static addItems(builder, itemsOffset) {
    builder.addFieldOffset(0, itemsOffset, 0);
  }
  static createItemsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startItemsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addCivil(builder, civilOffset) {
    builder.addFieldOffset(1, civilOffset, 0);
  }
  static addCoordinationMatrix(builder, coordinationMatrixOffset) {
    builder.addFieldOffset(2, coordinationMatrixOffset, 0);
  }
  static createCoordinationMatrixVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]);
    }
    return builder.endVector();
  }
  static startCoordinationMatrixVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addIds(builder, idsOffset) {
    builder.addFieldOffset(3, idsOffset, 0);
  }
  static createIdsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startIdsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addItemsKeys(builder, itemsKeysOffset) {
    builder.addFieldOffset(4, itemsKeysOffset, 0);
  }
  static createItemsKeysVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startItemsKeysVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addItemsKeysIndices(builder, itemsKeysIndicesOffset) {
    builder.addFieldOffset(5, itemsKeysIndicesOffset, 0);
  }
  static createItemsKeysIndicesVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startItemsKeysIndicesVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addItemsRels(builder, itemsRelsOffset) {
    builder.addFieldOffset(6, itemsRelsOffset, 0);
  }
  static createItemsRelsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startItemsRelsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addItemsRelsIndices(builder, itemsRelsIndicesOffset) {
    builder.addFieldOffset(7, itemsRelsIndicesOffset, 0);
  }
  static createItemsRelsIndicesVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startItemsRelsIndicesVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addFragmentKeys(builder, fragmentKeysOffset) {
    builder.addFieldOffset(8, fragmentKeysOffset, 0);
  }
  static addId(builder, idOffset) {
    builder.addFieldOffset(9, idOffset, 0);
  }
  static addName(builder, nameOffset) {
    builder.addFieldOffset(10, nameOffset, 0);
  }
  static addIfcName(builder, ifcNameOffset) {
    builder.addFieldOffset(11, ifcNameOffset, 0);
  }
  static addIfcDescription(builder, ifcDescriptionOffset) {
    builder.addFieldOffset(12, ifcDescriptionOffset, 0);
  }
  static addIfcSchema(builder, ifcSchemaOffset) {
    builder.addFieldOffset(13, ifcSchemaOffset, 0);
  }
  static addMaxExpressId(builder, maxExpressId) {
    builder.addFieldInt32(14, maxExpressId, 0);
  }
  static addBoundingBox(builder, boundingBoxOffset) {
    builder.addFieldOffset(15, boundingBoxOffset, 0);
  }
  static createBoundingBoxVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]);
    }
    return builder.endVector();
  }
  static startBoundingBoxVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addOpaqueGeometriesIds(builder, opaqueGeometriesIdsOffset) {
    builder.addFieldOffset(16, opaqueGeometriesIdsOffset, 0);
  }
  static createOpaqueGeometriesIdsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startOpaqueGeometriesIdsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addTransparentGeometriesIds(builder, transparentGeometriesIdsOffset) {
    builder.addFieldOffset(17, transparentGeometriesIdsOffset, 0);
  }
  static createTransparentGeometriesIdsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startTransparentGeometriesIdsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endFragmentsGroup(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishFragmentsGroupBuffer(builder, offset) {
    builder.finish(offset);
  }
  static finishSizePrefixedFragmentsGroupBuffer(builder, offset) {
    builder.finish(offset, void 0, true);
  }
};
var ParserV1 = class {
  constructor() {
    __publicField(this, "version", 1);
    __publicField(this, "fragmentIDSeparator", "|");
  }
  /** {@link FragmentParser.import} */
  import(bytes) {
    const buffer = new ByteBuffer(bytes);
    const fbFragmentsGroup = FragmentsGroup$2.getRootAsFragmentsGroup(buffer);
    const fragmentsGroup = this.constructFragmentGroup(fbFragmentsGroup);
    const length = fbFragmentsGroup.itemsLength();
    for (let i = 0; i < length; i++) {
      const fbFragment = fbFragmentsGroup.items(i);
      if (!fbFragment)
        continue;
      const geometry = this.constructGeometry(fbFragment);
      const materials = this.constructMaterials(fbFragment);
      const capacity = fbFragment.capacity();
      const fragment = new Fragment$2(geometry, materials, capacity);
      fragment.capacityOffset = fbFragment.capacityOffset();
      this.setInstances(fbFragment, fragment);
      this.setID(fbFragment, fragment);
      fragmentsGroup.items.push(fragment);
      fragmentsGroup.add(fragment.mesh);
    }
    return fragmentsGroup;
  }
  /**
   * Exports the FragmentsGroup to a flatbuffer binary file.
   *
   * @param group - The FragmentsGroup to be exported.
   * @returns The flatbuffer binary file as a Uint8Array.
   */
  export(group) {
    const builder = new Builder(1024);
    const items = [];
    const G = FragmentsGroup$2;
    const F = Fragment$1;
    let civilData = null;
    if (group.civilData) {
      const alignments = [];
      const A = Alignment$2;
      const C = CivilData$1;
      for (const [_id, alignment] of group.civilData.alignments) {
        const { absolute, horizontal, vertical } = alignment;
        const horCurves = this.saveCivilCurves(horizontal, builder);
        const verCurves = this.saveCivilCurves(vertical, builder);
        const absCurves = this.saveCivilCurves(absolute, builder);
        const horVector = A.createHorizontalVector(builder, horCurves);
        const verVector = A.createVerticalVector(builder, verCurves);
        const absVector = A.createAbsoluteVector(builder, absCurves);
        A.startAlignment(builder);
        A.addHorizontal(builder, horVector);
        A.addVertical(builder, verVector);
        A.addAbsolute(builder, absVector);
        A.addInitialPk(builder, alignment.initialKP);
        const exported = A.endAlignment(builder);
        alignments.push(exported);
      }
      const algVector = C.createAlignmentsVector(builder, alignments);
      const coordVector = C.createCoordinationMatrixVector(
        builder,
        group.coordinationMatrix.elements
      );
      C.startCivilData(builder);
      C.addAlignments(builder, algVector);
      C.addCoordinationMatrix(builder, coordVector);
      civilData = C.endCivilData(builder);
    }
    for (const fragment of group.items) {
      const result2 = fragment.exportData();
      const itemsSize = [];
      for (const itemID of fragment.ids) {
        const instances = fragment.getInstancesIDs(itemID);
        if (!instances) {
          throw new Error("Instances not found!");
        }
        itemsSize.push(instances.size);
      }
      const posVector = F.createPositionVector(builder, result2.position);
      const normalVector = F.createNormalVector(builder, result2.normal);
      const indexVector = F.createIndexVector(builder, result2.index);
      const groupsVector = F.createGroupsVector(builder, result2.groups);
      const matsVector = F.createMaterialsVector(builder, result2.materials);
      const matricesVector = F.createMatricesVector(builder, result2.matrices);
      const colorsVector = F.createColorsVector(builder, result2.colors);
      const idsVector2 = F.createIdsVector(builder, result2.ids);
      const itemsSizeVector = F.createItemsSizeVector(builder, itemsSize);
      const idStr = builder.createString(result2.id);
      F.startFragment(builder);
      F.addPosition(builder, posVector);
      F.addNormal(builder, normalVector);
      F.addIndex(builder, indexVector);
      F.addGroups(builder, groupsVector);
      F.addMaterials(builder, matsVector);
      F.addMatrices(builder, matricesVector);
      F.addColors(builder, colorsVector);
      F.addIds(builder, idsVector2);
      F.addItemsSize(builder, itemsSizeVector);
      F.addId(builder, idStr);
      F.addCapacity(builder, fragment.capacity);
      F.addCapacityOffset(builder, fragment.capacityOffset);
      const exported = Fragment$1.endFragment(builder);
      items.push(exported);
    }
    const itemsVector = G.createItemsVector(builder, items);
    const matrixVector = G.createCoordinationMatrixVector(
      builder,
      group.coordinationMatrix.elements
    );
    let fragmentKeys = "";
    for (const fragmentID of group.keyFragments.values()) {
      if (fragmentKeys.length) {
        fragmentKeys += this.fragmentIDSeparator;
      }
      fragmentKeys += fragmentID;
    }
    const fragmentKeysRef = builder.createString(fragmentKeys);
    const keyIndices = [];
    const itemsKeys = [];
    const relsIndices = [];
    const itemsRels = [];
    const ids = [];
    let keysCounter = 0;
    let relsCounter = 0;
    for (const [expressID, [keys, rels]] of group.data) {
      keyIndices.push(keysCounter);
      relsIndices.push(relsCounter);
      ids.push(expressID);
      for (const key of keys) {
        itemsKeys.push(key);
      }
      for (const rel of rels) {
        itemsRels.push(rel);
      }
      keysCounter += keys.length;
      relsCounter += rels.length;
    }
    const opaqueIDs = [];
    const transpIDs = [];
    for (const [geometryID, key] of group.geometryIDs.opaque) {
      opaqueIDs.push(geometryID, key);
    }
    for (const [geometryID, key] of group.geometryIDs.transparent) {
      transpIDs.push(geometryID, key);
    }
    const groupID = builder.createString(group.uuid);
    const groupName = builder.createString(group.name);
    const ifcName = builder.createString(group.ifcMetadata.name);
    const ifcDescription = builder.createString(group.ifcMetadata.description);
    const ifcSchema = builder.createString(group.ifcMetadata.schema);
    const keysIVector = G.createItemsKeysIndicesVector(builder, keyIndices);
    const keysVector = G.createItemsKeysVector(builder, itemsKeys);
    const relsIVector = G.createItemsRelsIndicesVector(builder, relsIndices);
    const relsVector = G.createItemsRelsVector(builder, itemsRels);
    const idsVector = G.createIdsVector(builder, ids);
    const oIdsVector = G.createOpaqueGeometriesIdsVector(builder, opaqueIDs);
    const tIdsVector = G.createTransparentGeometriesIdsVector(
      builder,
      transpIDs
    );
    const { min, max } = group.boundingBox;
    const bbox = [min.x, min.y, min.z, max.x, max.y, max.z];
    const bboxVector = G.createBoundingBoxVector(builder, bbox);
    G.startFragmentsGroup(builder);
    G.addId(builder, groupID);
    G.addName(builder, groupName);
    G.addIfcName(builder, ifcName);
    G.addIfcDescription(builder, ifcDescription);
    G.addIfcSchema(builder, ifcSchema);
    G.addMaxExpressId(builder, group.ifcMetadata.maxExpressID);
    G.addItems(builder, itemsVector);
    G.addFragmentKeys(builder, fragmentKeysRef);
    G.addIds(builder, idsVector);
    G.addItemsKeysIndices(builder, keysIVector);
    G.addItemsKeys(builder, keysVector);
    G.addItemsRelsIndices(builder, relsIVector);
    G.addItemsRels(builder, relsVector);
    G.addCoordinationMatrix(builder, matrixVector);
    G.addBoundingBox(builder, bboxVector);
    G.addOpaqueGeometriesIds(builder, oIdsVector);
    G.addTransparentGeometriesIds(builder, tIdsVector);
    if (civilData !== null) {
      G.addCivil(builder, civilData);
    }
    const result = FragmentsGroup$2.endFragmentsGroup(builder);
    builder.finish(result);
    return builder.asUint8Array();
  }
  setID(fbFragment, fragment) {
    const id = fbFragment.id();
    if (id) {
      fragment.id = id;
      fragment.mesh.uuid = id;
    }
  }
  setInstances(fbFragment, fragment) {
    const matricesData = fbFragment.matricesArray();
    const colorData = fbFragment.colorsArray();
    const ids = fbFragment.idsArray();
    const itemsSize = fbFragment.itemsSizeArray();
    if (!matricesData || !ids || !itemsSize) {
      throw new Error(`Error: Can't load empty fragment!`);
    }
    const items = [];
    let offset = 0;
    for (let i = 0; i < itemsSize.length; i++) {
      const id = ids[i];
      const size = itemsSize[i];
      const transforms = [];
      const colorsArray = [];
      for (let j = 0; j < size; j++) {
        const mStart = offset * 16;
        const matrixArray = matricesData.subarray(mStart, mStart + 17);
        const transform = new Matrix4().fromArray(matrixArray);
        transforms.push(transform);
        if (colorData) {
          const cStart = offset * 3;
          const [r, g, b] = colorData.subarray(cStart, cStart + 4);
          const color = new Color(r, g, b);
          colorsArray.push(color);
        }
        offset++;
      }
      const colors = colorsArray.length ? colorsArray : void 0;
      items.push({ id, transforms, colors });
    }
    fragment.add(items);
  }
  constructMaterials(fragment) {
    const materials = fragment.materialsArray();
    const matArray = [];
    if (!materials)
      return matArray;
    for (let i = 0; i < materials.length; i += 5) {
      const opacity = materials[i];
      const transparent = Boolean(materials[i + 1]);
      const red = materials[i + 2];
      const green = materials[i + 3];
      const blue = materials[i + 4];
      const color = new Color(red, green, blue);
      const material = new MeshLambertMaterial({
        color,
        opacity,
        transparent
      });
      matArray.push(material);
    }
    return matArray;
  }
  constructFragmentGroup(group) {
    const fragmentsGroup = new FragmentsGroup3();
    const civil = group.civil();
    if (civil) {
      const matArray = civil.coordinationMatrixArray();
      const coordinationMatrix = new Matrix4();
      if (matArray) {
        coordinationMatrix.fromArray(matArray);
      }
      fragmentsGroup.civilData = { alignments: /* @__PURE__ */ new Map(), coordinationMatrix };
      const aligLength = civil.alignmentsLength();
      for (let i = 0; i < aligLength; i++) {
        const lineMat = new LineBasicMaterial({ color: 16777215 });
        const alignment = new Alignment3();
        const aligData = civil.alignments(i);
        if (!aligData) {
          throw new Error("Alignment not found!");
        }
        const horLength = aligData.horizontalLength();
        alignment.horizontal = this.constructCivilCurves(
          aligData,
          alignment,
          "horizontal",
          horLength,
          lineMat
        );
        const verLength = aligData.verticalLength();
        alignment.vertical = this.constructCivilCurves(
          aligData,
          alignment,
          "vertical",
          verLength,
          lineMat
        );
        const absLength = aligData.horizontalLength();
        alignment.absolute = this.constructCivilCurves(
          aligData,
          alignment,
          "absolute",
          absLength,
          lineMat
        );
        alignment.initialKP = aligData.initialPk();
        fragmentsGroup.civilData.alignments.set(i, alignment);
      }
    }
    fragmentsGroup.uuid = group.id() || fragmentsGroup.uuid;
    fragmentsGroup.name = group.name() || "";
    fragmentsGroup.ifcMetadata = {
      name: group.ifcName() || "",
      description: group.ifcDescription() || "",
      schema: group.ifcSchema() || "IFC2X3",
      maxExpressID: group.maxExpressId() || 0
    };
    const defaultMatrix = new Matrix4().elements;
    const matrixArray = group.coordinationMatrixArray() || defaultMatrix;
    const ids = group.idsArray() || new Uint32Array();
    const keysIndices = group.itemsKeysIndicesArray() || new Uint32Array();
    const keysArray = group.itemsKeysArray() || new Uint32Array();
    const relsArray = group.itemsRelsArray() || new Uint32Array();
    const relsIndices = group.itemsRelsIndicesArray() || new Uint32Array();
    const keysIdsString = group.fragmentKeys() || "";
    const keysIdsArray = keysIdsString.split(this.fragmentIDSeparator);
    this.setGroupData(fragmentsGroup, ids, keysIndices, keysArray, 0);
    this.setGroupData(fragmentsGroup, ids, relsIndices, relsArray, 1);
    const opaqueIDs = group.opaqueGeometriesIdsArray() || new Uint32Array();
    const transpIDs = group.transparentGeometriesIdsArray() || new Uint32Array();
    const opaque = /* @__PURE__ */ new Map();
    for (let i = 0; i < opaqueIDs.length - 1; i += 2) {
      const geometryID = opaqueIDs[i];
      const key = opaqueIDs[i + 1];
      opaque.set(geometryID, key);
    }
    const transparent = /* @__PURE__ */ new Map();
    for (let i = 0; i < transpIDs.length - 1; i += 2) {
      const geometryID = transpIDs[i];
      const key = transpIDs[i + 1];
      transparent.set(geometryID, key);
    }
    fragmentsGroup.geometryIDs = { opaque, transparent };
    const bbox = group.boundingBoxArray() || [0, 0, 0, 0, 0, 0];
    const [minX, minY, minZ, maxX, maxY, maxZ] = bbox;
    fragmentsGroup.boundingBox.min.set(minX, minY, minZ);
    fragmentsGroup.boundingBox.max.set(maxX, maxY, maxZ);
    for (let i = 0; i < keysIdsArray.length; i++) {
      fragmentsGroup.keyFragments.set(i, keysIdsArray[i]);
    }
    if (matrixArray.length === 16) {
      fragmentsGroup.coordinationMatrix.fromArray(matrixArray);
    }
    return fragmentsGroup;
  }
  setGroupData(group, ids, indices, array, index) {
    for (let i = 0; i < indices.length; i++) {
      const expressID = ids[i];
      const currentIndex = indices[i];
      const nextIndex = indices[i + 1] || array.length;
      const keys = [];
      for (let j = currentIndex; j < nextIndex; j++) {
        keys.push(array[j]);
      }
      if (!group.data.has(expressID)) {
        group.data.set(expressID, [[], []]);
      }
      const data = group.data.get(expressID);
      if (!data)
        continue;
      data[index] = keys;
    }
  }
  constructGeometry(fragment) {
    const position = fragment.positionArray() || new Float32Array();
    const normal = fragment.normalArray() || new Float32Array();
    const index = fragment.indexArray();
    const groups = fragment.groupsArray();
    if (!index)
      throw new Error("Index not found!");
    const geometry = new BufferGeometry();
    geometry.setIndex(Array.from(index));
    geometry.setAttribute("position", new BufferAttribute(position, 3));
    geometry.setAttribute("normal", new BufferAttribute(normal, 3));
    if (groups) {
      for (let i = 0; i < groups.length; i += 3) {
        const start = groups[i];
        const count = groups[i + 1];
        const materialIndex = groups[i + 2];
        geometry.addGroup(start, count, materialIndex);
      }
    }
    return geometry;
  }
  constructCivilCurves(alignData, alignment, option, length, lineMat) {
    const curves = [];
    for (let i = 0; i < length; i++) {
      const found = alignData[option](i);
      if (!found) {
        throw new Error("Curve not found!");
      }
      const points = found.pointsArray();
      if (points === null) {
        throw new Error("Curve points not found!");
      }
      let data = {};
      const curveData = found.data();
      if (curveData) {
        data = JSON.parse(curveData);
      }
      const geometry = new EdgesGeometry();
      const posAttr = new BufferAttribute(points, 3);
      geometry.setAttribute("position", posAttr);
      const index = [];
      for (let i2 = 0; i2 < points.length / 3 - 1; i2++) {
        index.push(i2, i2 + 1);
      }
      geometry.setIndex(index);
      const curveMesh = new CurveMesh(i, data, alignment, geometry, lineMat);
      curves.push(curveMesh.curve);
    }
    return curves;
  }
  saveCivilCurves(curves, builder) {
    const CC = CivilCurve$2;
    const curvesRef = [];
    for (const curve of curves) {
      const attrs = curve.mesh.geometry.attributes;
      const position = attrs.position.array;
      const posVector = CC.createPointsVector(builder, position);
      const dataStr = builder.createString(JSON.stringify(curve.data));
      CC.startCivilCurve(builder);
      CC.addPoints(builder, posVector);
      CC.addData(builder, dataStr);
      const exported = CC.endCivilCurve(builder);
      curvesRef.push(exported);
    }
    return curvesRef;
  }
};
var CivilCurve$1 = class CivilCurve2 {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsCivilCurve(bb, obj) {
    return (obj || new CivilCurve2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsCivilCurve(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new CivilCurve2()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  points(index) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  pointsLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  pointsArray() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
  }
  data(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  static startCivilCurve(builder) {
    builder.startObject(2);
  }
  static addPoints(builder, pointsOffset) {
    builder.addFieldOffset(0, pointsOffset, 0);
  }
  static createPointsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]);
    }
    return builder.endVector();
  }
  static startPointsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addData(builder, dataOffset) {
    builder.addFieldOffset(1, dataOffset, 0);
  }
  static endCivilCurve(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createCivilCurve(builder, pointsOffset, dataOffset) {
    CivilCurve2.startCivilCurve(builder);
    CivilCurve2.addPoints(builder, pointsOffset);
    CivilCurve2.addData(builder, dataOffset);
    return CivilCurve2.endCivilCurve(builder);
  }
};
var Alignment$1 = class Alignment2 {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsAlignment(bb, obj) {
    return (obj || new Alignment2()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsAlignment(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new Alignment2()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  vertical(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? (obj || new CivilCurve$1()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  verticalLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  horizontal(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? (obj || new CivilCurve$1()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  horizontalLength() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  absolute(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? (obj || new CivilCurve$1()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  absoluteLength() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  initialPk() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readFloat32(this.bb_pos + offset) : 0;
  }
  static startAlignment(builder) {
    builder.startObject(4);
  }
  static addVertical(builder, verticalOffset) {
    builder.addFieldOffset(0, verticalOffset, 0);
  }
  static createVerticalVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startVerticalVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addHorizontal(builder, horizontalOffset) {
    builder.addFieldOffset(1, horizontalOffset, 0);
  }
  static createHorizontalVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startHorizontalVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addAbsolute(builder, absoluteOffset) {
    builder.addFieldOffset(2, absoluteOffset, 0);
  }
  static createAbsoluteVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startAbsoluteVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addInitialPk(builder, initialPk) {
    builder.addFieldFloat32(3, initialPk, 0);
  }
  static endAlignment(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createAlignment(builder, verticalOffset, horizontalOffset, absoluteOffset, initialPk) {
    Alignment2.startAlignment(builder);
    Alignment2.addVertical(builder, verticalOffset);
    Alignment2.addHorizontal(builder, horizontalOffset);
    Alignment2.addAbsolute(builder, absoluteOffset);
    Alignment2.addInitialPk(builder, initialPk);
    return Alignment2.endAlignment(builder);
  }
};
var CivilData2 = class _CivilData2 {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsCivilData(bb, obj) {
    return (obj || new _CivilData2()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsCivilData(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _CivilData2()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  alignments(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? (obj || new Alignment$1()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  alignmentsLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  coordinationMatrix(index) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.readFloat32(
      this.bb.__vector(this.bb_pos + offset) + index * 4
    ) : 0;
  }
  coordinationMatrixLength() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  coordinationMatrixArray() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? new Float32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  static startCivilData(builder) {
    builder.startObject(2);
  }
  static addAlignments(builder, alignmentsOffset) {
    builder.addFieldOffset(0, alignmentsOffset, 0);
  }
  static createAlignmentsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startAlignmentsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addCoordinationMatrix(builder, coordinationMatrixOffset) {
    builder.addFieldOffset(1, coordinationMatrixOffset, 0);
  }
  static createCoordinationMatrixVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]);
    }
    return builder.endVector();
  }
  static startCoordinationMatrixVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endCivilData(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createCivilData(builder, alignmentsOffset, coordinationMatrixOffset) {
    _CivilData2.startCivilData(builder);
    _CivilData2.addAlignments(builder, alignmentsOffset);
    _CivilData2.addCoordinationMatrix(builder, coordinationMatrixOffset);
    return _CivilData2.endCivilData(builder);
  }
};
var Fragment3 = class _Fragment3 {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsFragment(bb, obj) {
    return (obj || new _Fragment3()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  static getSizePrefixedRootAsFragment(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _Fragment3()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }
  position(index) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  positionLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  positionArray() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
  }
  normal(index) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  normalLength() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  normalArray() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
  }
  index(index) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  indexLength() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  indexArray() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
  }
  groups(index) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  groupsLength() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  groupsArray() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
  }
  materials(index) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  materialsLength() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  materialsArray() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
  }
  matrices(index) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  matricesLength() {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  matricesArray() {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
  }
  colors(index) {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  colorsLength() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  colorsArray() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
  }
  itemsSize(index) {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  itemsSizeLength() {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  itemsSizeArray() {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
  }
  ids(index) {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  idsLength() {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  idsArray() {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset), this.bb.__vector_len(this.bb_pos + offset)) : null;
  }
  id(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  capacity() {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  capacityOffset() {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  static startFragment(builder) {
    builder.startObject(12);
  }
  static addPosition(builder, positionOffset) {
    builder.addFieldOffset(0, positionOffset, 0);
  }
  static createPositionVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]);
    }
    return builder.endVector();
  }
  static startPositionVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addNormal(builder, normalOffset) {
    builder.addFieldOffset(1, normalOffset, 0);
  }
  static createNormalVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]);
    }
    return builder.endVector();
  }
  static startNormalVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addIndex(builder, indexOffset) {
    builder.addFieldOffset(2, indexOffset, 0);
  }
  static createIndexVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startIndexVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addGroups(builder, groupsOffset) {
    builder.addFieldOffset(3, groupsOffset, 0);
  }
  static createGroupsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]);
    }
    return builder.endVector();
  }
  static startGroupsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addMaterials(builder, materialsOffset) {
    builder.addFieldOffset(4, materialsOffset, 0);
  }
  static createMaterialsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]);
    }
    return builder.endVector();
  }
  static startMaterialsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addMatrices(builder, matricesOffset) {
    builder.addFieldOffset(5, matricesOffset, 0);
  }
  static createMatricesVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]);
    }
    return builder.endVector();
  }
  static startMatricesVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addColors(builder, colorsOffset) {
    builder.addFieldOffset(6, colorsOffset, 0);
  }
  static createColorsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]);
    }
    return builder.endVector();
  }
  static startColorsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addItemsSize(builder, itemsSizeOffset) {
    builder.addFieldOffset(7, itemsSizeOffset, 0);
  }
  static createItemsSizeVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startItemsSizeVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addIds(builder, idsOffset) {
    builder.addFieldOffset(8, idsOffset, 0);
  }
  static createIdsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startIdsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addId(builder, idOffset) {
    builder.addFieldOffset(9, idOffset, 0);
  }
  static addCapacity(builder, capacity) {
    builder.addFieldInt32(10, capacity, 0);
  }
  static addCapacityOffset(builder, capacityOffset) {
    builder.addFieldInt32(11, capacityOffset, 0);
  }
  static endFragment(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createFragment(builder, positionOffset, normalOffset, indexOffset, groupsOffset, materialsOffset, matricesOffset, colorsOffset, itemsSizeOffset, idsOffset, idOffset, capacity, capacityOffset) {
    _Fragment3.startFragment(builder);
    _Fragment3.addPosition(builder, positionOffset);
    _Fragment3.addNormal(builder, normalOffset);
    _Fragment3.addIndex(builder, indexOffset);
    _Fragment3.addGroups(builder, groupsOffset);
    _Fragment3.addMaterials(builder, materialsOffset);
    _Fragment3.addMatrices(builder, matricesOffset);
    _Fragment3.addColors(builder, colorsOffset);
    _Fragment3.addItemsSize(builder, itemsSizeOffset);
    _Fragment3.addIds(builder, idsOffset);
    _Fragment3.addId(builder, idOffset);
    _Fragment3.addCapacity(builder, capacity);
    _Fragment3.addCapacityOffset(builder, capacityOffset);
    return _Fragment3.endFragment(builder);
  }
};
var FragmentsGroup$1 = class FragmentsGroup2 {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsFragmentsGroup(bb, obj) {
    return (obj || new FragmentsGroup2()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsFragmentsGroup(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new FragmentsGroup2()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  items(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? (obj || new Fragment3()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  itemsLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  civil(obj) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? (obj || new CivilData2()).__init(
      this.bb.__indirect(this.bb_pos + offset),
      this.bb
    ) : null;
  }
  coordinationMatrix(index) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.readFloat32(
      this.bb.__vector(this.bb_pos + offset) + index * 4
    ) : 0;
  }
  coordinationMatrixLength() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  coordinationMatrixArray() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? new Float32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  ids(index) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  idsLength() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  idsArray() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? new Uint32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  itemsKeys(index) {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  itemsKeysLength() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  itemsKeysArray() {
    const offset = this.bb.__offset(this.bb_pos, 12);
    return offset ? new Uint32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  itemsKeysIndices(index) {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  itemsKeysIndicesLength() {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  itemsKeysIndicesArray() {
    const offset = this.bb.__offset(this.bb_pos, 14);
    return offset ? new Uint32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  itemsRels(index) {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  itemsRelsLength() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  itemsRelsArray() {
    const offset = this.bb.__offset(this.bb_pos, 16);
    return offset ? new Uint32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  itemsRelsIndices(index) {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  itemsRelsIndicesLength() {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  itemsRelsIndicesArray() {
    const offset = this.bb.__offset(this.bb_pos, 18);
    return offset ? new Uint32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  fragmentKeys(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 20);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  globalIds(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 22);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  id(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 24);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  name(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 26);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ifcName(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 28);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ifcDescription(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 30);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  ifcSchema(optionalEncoding) {
    const offset = this.bb.__offset(this.bb_pos, 32);
    return offset ? this.bb.__string(this.bb_pos + offset, optionalEncoding) : null;
  }
  maxExpressId() {
    const offset = this.bb.__offset(this.bb_pos, 34);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  boundingBox(index) {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? this.bb.readFloat32(
      this.bb.__vector(this.bb_pos + offset) + index * 4
    ) : 0;
  }
  boundingBoxLength() {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  boundingBoxArray() {
    const offset = this.bb.__offset(this.bb_pos, 36);
    return offset ? new Float32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  opaqueGeometriesIds(index) {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  opaqueGeometriesIdsLength() {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  opaqueGeometriesIdsArray() {
    const offset = this.bb.__offset(this.bb_pos, 38);
    return offset ? new Int32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  transparentGeometriesIds(index) {
    const offset = this.bb.__offset(this.bb_pos, 40);
    return offset ? this.bb.readInt32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  transparentGeometriesIdsLength() {
    const offset = this.bb.__offset(this.bb_pos, 40);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  transparentGeometriesIdsArray() {
    const offset = this.bb.__offset(this.bb_pos, 40);
    return offset ? new Int32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  static startFragmentsGroup(builder) {
    builder.startObject(19);
  }
  static addItems(builder, itemsOffset) {
    builder.addFieldOffset(0, itemsOffset, 0);
  }
  static createItemsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startItemsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addCivil(builder, civilOffset) {
    builder.addFieldOffset(1, civilOffset, 0);
  }
  static addCoordinationMatrix(builder, coordinationMatrixOffset) {
    builder.addFieldOffset(2, coordinationMatrixOffset, 0);
  }
  static createCoordinationMatrixVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]);
    }
    return builder.endVector();
  }
  static startCoordinationMatrixVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addIds(builder, idsOffset) {
    builder.addFieldOffset(3, idsOffset, 0);
  }
  static createIdsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startIdsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addItemsKeys(builder, itemsKeysOffset) {
    builder.addFieldOffset(4, itemsKeysOffset, 0);
  }
  static createItemsKeysVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startItemsKeysVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addItemsKeysIndices(builder, itemsKeysIndicesOffset) {
    builder.addFieldOffset(5, itemsKeysIndicesOffset, 0);
  }
  static createItemsKeysIndicesVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startItemsKeysIndicesVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addItemsRels(builder, itemsRelsOffset) {
    builder.addFieldOffset(6, itemsRelsOffset, 0);
  }
  static createItemsRelsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startItemsRelsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addItemsRelsIndices(builder, itemsRelsIndicesOffset) {
    builder.addFieldOffset(7, itemsRelsIndicesOffset, 0);
  }
  static createItemsRelsIndicesVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startItemsRelsIndicesVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addFragmentKeys(builder, fragmentKeysOffset) {
    builder.addFieldOffset(8, fragmentKeysOffset, 0);
  }
  static addGlobalIds(builder, globalIdsOffset) {
    builder.addFieldOffset(9, globalIdsOffset, 0);
  }
  static addId(builder, idOffset) {
    builder.addFieldOffset(10, idOffset, 0);
  }
  static addName(builder, nameOffset) {
    builder.addFieldOffset(11, nameOffset, 0);
  }
  static addIfcName(builder, ifcNameOffset) {
    builder.addFieldOffset(12, ifcNameOffset, 0);
  }
  static addIfcDescription(builder, ifcDescriptionOffset) {
    builder.addFieldOffset(13, ifcDescriptionOffset, 0);
  }
  static addIfcSchema(builder, ifcSchemaOffset) {
    builder.addFieldOffset(14, ifcSchemaOffset, 0);
  }
  static addMaxExpressId(builder, maxExpressId) {
    builder.addFieldInt32(15, maxExpressId, 0);
  }
  static addBoundingBox(builder, boundingBoxOffset) {
    builder.addFieldOffset(16, boundingBoxOffset, 0);
  }
  static createBoundingBoxVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]);
    }
    return builder.endVector();
  }
  static startBoundingBoxVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addOpaqueGeometriesIds(builder, opaqueGeometriesIdsOffset) {
    builder.addFieldOffset(17, opaqueGeometriesIdsOffset, 0);
  }
  static createOpaqueGeometriesIdsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startOpaqueGeometriesIdsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addTransparentGeometriesIds(builder, transparentGeometriesIdsOffset) {
    builder.addFieldOffset(18, transparentGeometriesIdsOffset, 0);
  }
  static createTransparentGeometriesIdsVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startTransparentGeometriesIdsVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endFragmentsGroup(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishFragmentsGroupBuffer(builder, offset) {
    builder.finish(offset);
  }
  static finishSizePrefixedFragmentsGroupBuffer(builder, offset) {
    builder.finish(offset, void 0, true);
  }
};
var ParserV2 = class {
  constructor() {
    __publicField(this, "version", 2);
    __publicField(this, "separator", "|");
  }
  /** {@link FragmentParser.import} */
  import(bytes) {
    const buffer = new ByteBuffer(bytes);
    const fbFragmentsGroup = FragmentsGroup$1.getRootAsFragmentsGroup(buffer);
    const fragmentsGroup = this.constructFragmentGroup(fbFragmentsGroup);
    const length = fbFragmentsGroup.itemsLength();
    for (let i = 0; i < length; i++) {
      const fbFragment = fbFragmentsGroup.items(i);
      if (!fbFragment)
        continue;
      const geometry = this.constructGeometry(fbFragment);
      const materials = this.constructMaterials(fbFragment);
      const capacity = fbFragment.capacity();
      const fragment = new Fragment$2(geometry, materials, capacity);
      fragment.capacityOffset = fbFragment.capacityOffset();
      this.setInstances(fbFragment, fragment);
      this.setID(fbFragment, fragment);
      fragmentsGroup.items.push(fragment);
      fragmentsGroup.add(fragment.mesh);
    }
    return fragmentsGroup;
  }
  /**
   * Exports the FragmentsGroup to a flatbuffer binary file.
   *
   * @param group - The FragmentsGroup to be exported.
   * @returns The flatbuffer binary file as a Uint8Array.
   */
  export(group) {
    const builder = new Builder(1024);
    const items = [];
    const G = FragmentsGroup$1;
    const F = Fragment3;
    let civilData = null;
    if (group.civilData) {
      const alignments = [];
      const A = Alignment$1;
      const C = CivilData2;
      for (const [_id, alignment] of group.civilData.alignments) {
        const { absolute, horizontal, vertical } = alignment;
        const horCurves = this.saveCivilCurves(horizontal, builder);
        const verCurves = this.saveCivilCurves(vertical, builder);
        const absCurves = this.saveCivilCurves(absolute, builder);
        const horVector = A.createHorizontalVector(builder, horCurves);
        const verVector = A.createVerticalVector(builder, verCurves);
        const absVector = A.createAbsoluteVector(builder, absCurves);
        A.startAlignment(builder);
        A.addHorizontal(builder, horVector);
        A.addVertical(builder, verVector);
        A.addAbsolute(builder, absVector);
        A.addInitialPk(builder, alignment.initialKP);
        const exported = A.endAlignment(builder);
        alignments.push(exported);
      }
      const algVector = C.createAlignmentsVector(builder, alignments);
      const coordVector = C.createCoordinationMatrixVector(
        builder,
        group.coordinationMatrix.elements
      );
      C.startCivilData(builder);
      C.addAlignments(builder, algVector);
      C.addCoordinationMatrix(builder, coordVector);
      civilData = C.endCivilData(builder);
    }
    for (const fragment of group.items) {
      const result2 = fragment.exportData();
      const itemsSize = [];
      for (const itemID of fragment.ids) {
        const instances = fragment.getInstancesIDs(itemID);
        if (!instances) {
          throw new Error("Instances not found!");
        }
        itemsSize.push(instances.size);
      }
      const posVector = F.createPositionVector(builder, result2.position);
      const normalVector = F.createNormalVector(builder, result2.normal);
      const indexVector = F.createIndexVector(builder, result2.index);
      const groupsVector = F.createGroupsVector(builder, result2.groups);
      const matsVector = F.createMaterialsVector(builder, result2.materials);
      const matricesVector = F.createMatricesVector(builder, result2.matrices);
      const colorsVector = F.createColorsVector(builder, result2.colors);
      const idsVector2 = F.createIdsVector(builder, result2.ids);
      const itemsSizeVector = F.createItemsSizeVector(builder, itemsSize);
      const idStr = builder.createString(result2.id);
      F.startFragment(builder);
      F.addPosition(builder, posVector);
      F.addNormal(builder, normalVector);
      F.addIndex(builder, indexVector);
      F.addGroups(builder, groupsVector);
      F.addMaterials(builder, matsVector);
      F.addMatrices(builder, matricesVector);
      F.addColors(builder, colorsVector);
      F.addIds(builder, idsVector2);
      F.addItemsSize(builder, itemsSizeVector);
      F.addId(builder, idStr);
      F.addCapacity(builder, fragment.capacity);
      F.addCapacityOffset(builder, fragment.capacityOffset);
      const exported = Fragment3.endFragment(builder);
      items.push(exported);
    }
    const itemsVector = G.createItemsVector(builder, items);
    const matrixVector = G.createCoordinationMatrixVector(
      builder,
      group.coordinationMatrix.elements
    );
    let fragmentKeys = "";
    for (const fragmentID of group.keyFragments.values()) {
      if (fragmentKeys.length) {
        fragmentKeys += this.separator;
      }
      fragmentKeys += fragmentID;
    }
    let globalIDs = "";
    for (const [globalID] of group.globalToExpressIDs) {
      if (globalIDs.length) {
        globalIDs += this.separator;
      }
      globalIDs += globalID;
    }
    const fragmentKeysRef = builder.createString(fragmentKeys);
    const globalIDsRef = builder.createString(globalIDs);
    const keyIndices = [];
    const itemsKeys = [];
    const relsIndices = [];
    const itemsRels = [];
    const ids = [];
    let keysCounter = 0;
    let relsCounter = 0;
    for (const [expressID, [keys, rels]] of group.data) {
      keyIndices.push(keysCounter);
      relsIndices.push(relsCounter);
      ids.push(expressID);
      for (const key of keys) {
        itemsKeys.push(key);
      }
      for (const rel of rels) {
        itemsRels.push(rel);
      }
      keysCounter += keys.length;
      relsCounter += rels.length;
    }
    const opaqueIDs = [];
    const transpIDs = [];
    for (const [geometryID, key] of group.geometryIDs.opaque) {
      opaqueIDs.push(geometryID, key);
    }
    for (const [geometryID, key] of group.geometryIDs.transparent) {
      transpIDs.push(geometryID, key);
    }
    const groupID = builder.createString(group.uuid);
    const groupName = builder.createString(group.name);
    const ifcName = builder.createString(group.ifcMetadata.name);
    const ifcDescription = builder.createString(group.ifcMetadata.description);
    const ifcSchema = builder.createString(group.ifcMetadata.schema);
    const keysIVector = G.createItemsKeysIndicesVector(builder, keyIndices);
    const keysVector = G.createItemsKeysVector(builder, itemsKeys);
    const relsIVector = G.createItemsRelsIndicesVector(builder, relsIndices);
    const relsVector = G.createItemsRelsVector(builder, itemsRels);
    const idsVector = G.createIdsVector(builder, ids);
    const oIdsVector = G.createOpaqueGeometriesIdsVector(builder, opaqueIDs);
    const tIdsVector = G.createTransparentGeometriesIdsVector(
      builder,
      transpIDs
    );
    const { min, max } = group.boundingBox;
    const bbox = [min.x, min.y, min.z, max.x, max.y, max.z];
    const bboxVector = G.createBoundingBoxVector(builder, bbox);
    G.startFragmentsGroup(builder);
    G.addId(builder, groupID);
    G.addName(builder, groupName);
    G.addIfcName(builder, ifcName);
    G.addIfcDescription(builder, ifcDescription);
    G.addIfcSchema(builder, ifcSchema);
    G.addMaxExpressId(builder, group.ifcMetadata.maxExpressID);
    G.addItems(builder, itemsVector);
    G.addFragmentKeys(builder, fragmentKeysRef);
    G.addGlobalIds(builder, globalIDsRef);
    G.addIds(builder, idsVector);
    G.addItemsKeysIndices(builder, keysIVector);
    G.addItemsKeys(builder, keysVector);
    G.addItemsRelsIndices(builder, relsIVector);
    G.addItemsRels(builder, relsVector);
    G.addCoordinationMatrix(builder, matrixVector);
    G.addBoundingBox(builder, bboxVector);
    G.addOpaqueGeometriesIds(builder, oIdsVector);
    G.addTransparentGeometriesIds(builder, tIdsVector);
    if (civilData !== null) {
      G.addCivil(builder, civilData);
    }
    const result = FragmentsGroup$1.endFragmentsGroup(builder);
    builder.finish(result);
    return builder.asUint8Array();
  }
  setID(fbFragment, fragment) {
    const id = fbFragment.id();
    if (id) {
      fragment.id = id;
      fragment.mesh.uuid = id;
    }
  }
  setInstances(fbFragment, fragment) {
    const matricesData = fbFragment.matricesArray();
    const colorData = fbFragment.colorsArray();
    const ids = fbFragment.idsArray();
    const itemsSize = fbFragment.itemsSizeArray();
    if (!matricesData || !ids || !itemsSize) {
      throw new Error(`Error: Can't load empty fragment!`);
    }
    const items = [];
    let offset = 0;
    for (let i = 0; i < itemsSize.length; i++) {
      const id = ids[i];
      const size = itemsSize[i];
      const transforms = [];
      const colorsArray = [];
      for (let j = 0; j < size; j++) {
        const mStart = offset * 16;
        const matrixArray = matricesData.subarray(mStart, mStart + 17);
        const transform = new Matrix4().fromArray(matrixArray);
        transforms.push(transform);
        if (colorData) {
          const cStart = offset * 3;
          const [r, g, b] = colorData.subarray(cStart, cStart + 4);
          const color = new Color(r, g, b);
          colorsArray.push(color);
        }
        offset++;
      }
      const colors = colorsArray.length ? colorsArray : void 0;
      items.push({ id, transforms, colors });
    }
    fragment.add(items);
  }
  constructMaterials(fragment) {
    const materials = fragment.materialsArray();
    const matArray = [];
    if (!materials)
      return matArray;
    for (let i = 0; i < materials.length; i += 5) {
      const opacity = materials[i];
      const transparent = Boolean(materials[i + 1]);
      const red = materials[i + 2];
      const green = materials[i + 3];
      const blue = materials[i + 4];
      const color = new Color(red, green, blue);
      const material = new MeshLambertMaterial({
        color,
        opacity,
        transparent
      });
      matArray.push(material);
    }
    return matArray;
  }
  constructFragmentGroup(group) {
    const fragmentsGroup = new FragmentsGroup3();
    const civil = group.civil();
    if (civil) {
      const matArray = civil.coordinationMatrixArray();
      const coordinationMatrix = new Matrix4();
      if (matArray) {
        coordinationMatrix.fromArray(matArray);
      }
      fragmentsGroup.civilData = { alignments: /* @__PURE__ */ new Map(), coordinationMatrix };
      const aligLength = civil.alignmentsLength();
      for (let i = 0; i < aligLength; i++) {
        const lineMat = new LineBasicMaterial({ color: 16777215 });
        const alignment = new Alignment3();
        const aligData = civil.alignments(i);
        if (!aligData) {
          throw new Error("Alignment not found!");
        }
        const horLength = aligData.horizontalLength();
        alignment.horizontal = this.constructCivilCurves(
          aligData,
          alignment,
          "horizontal",
          horLength,
          lineMat
        );
        const verLength = aligData.verticalLength();
        alignment.vertical = this.constructCivilCurves(
          aligData,
          alignment,
          "vertical",
          verLength,
          lineMat
        );
        const absLength = aligData.horizontalLength();
        alignment.absolute = this.constructCivilCurves(
          aligData,
          alignment,
          "absolute",
          absLength,
          lineMat
        );
        alignment.initialKP = aligData.initialPk();
        fragmentsGroup.civilData.alignments.set(i, alignment);
      }
    }
    fragmentsGroup.uuid = group.id() || fragmentsGroup.uuid;
    fragmentsGroup.name = group.name() || "";
    fragmentsGroup.ifcMetadata = {
      name: group.ifcName() || "",
      description: group.ifcDescription() || "",
      schema: group.ifcSchema() || "IFC2X3",
      maxExpressID: group.maxExpressId() || 0
    };
    const defaultMatrix = new Matrix4().elements;
    const matrixArray = group.coordinationMatrixArray() || defaultMatrix;
    const ids = group.idsArray() || new Uint32Array();
    const keysIndices = group.itemsKeysIndicesArray() || new Uint32Array();
    const keysArray = group.itemsKeysArray() || new Uint32Array();
    const relsArray = group.itemsRelsArray() || new Uint32Array();
    const relsIndices = group.itemsRelsIndicesArray() || new Uint32Array();
    const keysIdsString = group.fragmentKeys() || "";
    const keysIdsArray = keysIdsString.split(this.separator);
    const globalIdsString = group.globalIds() || "";
    const globalIdsArray = globalIdsString.split(this.separator);
    this.setGroupData(fragmentsGroup, ids, keysIndices, keysArray, 0);
    this.setGroupData(fragmentsGroup, ids, relsIndices, relsArray, 1);
    const opaqueIDs = group.opaqueGeometriesIdsArray() || new Uint32Array();
    const transpIDs = group.transparentGeometriesIdsArray() || new Uint32Array();
    const opaque = /* @__PURE__ */ new Map();
    for (let i = 0; i < opaqueIDs.length - 1; i += 2) {
      const geometryID = opaqueIDs[i];
      const key = opaqueIDs[i + 1];
      opaque.set(geometryID, key);
    }
    const transparent = /* @__PURE__ */ new Map();
    for (let i = 0; i < transpIDs.length - 1; i += 2) {
      const geometryID = transpIDs[i];
      const key = transpIDs[i + 1];
      transparent.set(geometryID, key);
    }
    fragmentsGroup.geometryIDs = { opaque, transparent };
    const bbox = group.boundingBoxArray() || [0, 0, 0, 0, 0, 0];
    const [minX, minY, minZ, maxX, maxY, maxZ] = bbox;
    fragmentsGroup.boundingBox.min.set(minX, minY, minZ);
    fragmentsGroup.boundingBox.max.set(maxX, maxY, maxZ);
    for (let i = 0; i < keysIdsArray.length; i++) {
      fragmentsGroup.keyFragments.set(i, keysIdsArray[i]);
    }
    if (matrixArray.length === 16) {
      fragmentsGroup.coordinationMatrix.fromArray(matrixArray);
    }
    for (let i = 0; i < ids.length; i++) {
      fragmentsGroup.globalToExpressIDs.set(globalIdsArray[i], ids[i]);
    }
    return fragmentsGroup;
  }
  setGroupData(group, ids, indices, array, index) {
    for (let i = 0; i < indices.length; i++) {
      const expressID = ids[i];
      const currentIndex = indices[i];
      const next = indices[i + 1];
      const nextIndex = next === void 0 ? array.length : next;
      const keys = [];
      for (let j = currentIndex; j < nextIndex; j++) {
        keys.push(array[j]);
      }
      if (!group.data.has(expressID)) {
        group.data.set(expressID, [[], []]);
      }
      const data = group.data.get(expressID);
      if (!data)
        continue;
      data[index] = keys;
    }
  }
  constructGeometry(fragment) {
    const position = fragment.positionArray() || new Float32Array();
    const normal = fragment.normalArray() || new Float32Array();
    const index = fragment.indexArray();
    const groups = fragment.groupsArray();
    if (!index)
      throw new Error("Index not found!");
    const geometry = new BufferGeometry();
    geometry.setIndex(Array.from(index));
    geometry.setAttribute("position", new BufferAttribute(position, 3));
    geometry.setAttribute("normal", new BufferAttribute(normal, 3));
    if (groups) {
      for (let i = 0; i < groups.length; i += 3) {
        const start = groups[i];
        const count = groups[i + 1];
        const materialIndex = groups[i + 2];
        geometry.addGroup(start, count, materialIndex);
      }
    }
    return geometry;
  }
  constructCivilCurves(alignData, alignment, option, length, lineMat) {
    const curves = [];
    for (let i = 0; i < length; i++) {
      const found = alignData[option](i);
      if (!found) {
        throw new Error("Curve not found!");
      }
      const points = found.pointsArray();
      if (points === null) {
        throw new Error("Curve points not found!");
      }
      let data = {};
      const curveData = found.data();
      if (curveData) {
        data = JSON.parse(curveData);
      }
      const geometry = new EdgesGeometry();
      const posAttr = new BufferAttribute(points, 3);
      geometry.setAttribute("position", posAttr);
      const index = [];
      for (let i2 = 0; i2 < points.length / 3 - 1; i2++) {
        index.push(i2, i2 + 1);
      }
      geometry.setIndex(index);
      const curveMesh = new CurveMesh(i, data, alignment, geometry, lineMat);
      curves.push(curveMesh.curve);
    }
    return curves;
  }
  saveCivilCurves(curves, builder) {
    const CC = CivilCurve$1;
    const curvesRef = [];
    for (const curve of curves) {
      const attrs = curve.mesh.geometry.attributes;
      const position = attrs.position.array;
      const posVector = CC.createPointsVector(builder, position);
      const dataStr = builder.createString(JSON.stringify(curve.data));
      CC.startCivilCurve(builder);
      CC.addPoints(builder, posVector);
      CC.addData(builder, dataStr);
      const exported = CC.endCivilCurve(builder);
      curvesRef.push(exported);
    }
    return curvesRef;
  }
};
var Serializer = class {
  constructor() {
    __publicField(this, "parsers", [
      new ParserV2(),
      new ParserV1()
    ]);
    __publicField(this, "version", "auto");
  }
  /** {@link FragmentParser.import} */
  import(bytes) {
    const latestVersion = this.parsers.length;
    if (this.version === "auto") {
      for (let i = 0; i < this.parsers.length; i++) {
        const parser2 = this.parsers[i];
        const result2 = parser2.import(bytes);
        if (Object.keys(result2).length === 0) {
          continue;
        }
        if (i !== 0) {
          const version = this.parsers.length - i;
          this.warnVersion(version, latestVersion);
        }
        return result2;
      }
      throw new Error("No valid parser found for this file");
    }
    this.checkCurrentVersionValid(this.version);
    const index = this.parsers.length - this.version;
    const parser = this.parsers[index];
    const result = parser.import(bytes);
    if (Object.keys(result).length === 0) {
      throw new Error(
        `The given version ${this.version} doesn't match to the given file. Try using "auto" in the version property to handle versions automatically.`
      );
    }
    return result;
  }
  /** {@link FragmentParser.export} */
  export(group) {
    if (this.version === "auto") {
      const latestParser = this.parsers[0];
      return latestParser.export(group);
    }
    this.checkCurrentVersionValid(this.version);
    const index = this.parsers.length - this.version;
    const parser = this.parsers[index];
    return parser.export(group);
  }
  checkCurrentVersionValid(latestVersion) {
    if (this.version === "auto")
      return;
    if (this.version !== latestVersion) {
      this.warnVersion(this.version, latestVersion);
    }
    const isInteger = Number.isInteger(this.version);
    if (!isInteger) {
      throw new Error(
        `Invalid version. Non-automatic versions must an integer.`
      );
    }
    if (this.version < 1 || this.version > latestVersion) {
      throw new Error(
        `Invalid version. Versions range from 1 to ${latestVersion}.`
      );
    }
  }
  warnVersion(version, latestVersion) {
    console.warn(
      `This fragment file version is ${version}. The latest version is ${latestVersion}. To avoid issues, please consider updating your fragments. You can do so by regenerating your fragments from the original IFC file.`
    );
  }
};
var StreamerFileDb = class {
  constructor(baseDirectory) {
    __publicField(this, "baseDirectory");
    __publicField(this, "maxDeadTime", 6e4);
    __publicField(this, "mode", "buffer");
    __publicField(this, "_memoryCleanTime", 1e4);
    __publicField(this, "_intervalID", null);
    __publicField(this, "_isCleaningMemory", false);
    __publicField(this, "cleanMemory", async () => {
      if (this._isCleaningMemory) {
        return;
      }
      this._isCleaningMemory = true;
      const rootDir = await this.getDir(this.baseDirectory);
      const filesToDelete = /* @__PURE__ */ new Set();
      const now = (/* @__PURE__ */ new Date()).getTime();
      for await (const entry of rootDir.values()) {
        const serializedLastAccessed = localStorage.getItem(entry.name) || "0";
        const lastAccess = parseInt(serializedLastAccessed, 10);
        const deadTime = now - lastAccess;
        if (deadTime > this.maxDeadTime) {
          filesToDelete.add(entry.name);
          localStorage.removeItem(entry.name);
        }
      }
      for (const name of filesToDelete) {
        rootDir.removeEntry(name);
      }
      this._isCleaningMemory = false;
    });
    this.baseDirectory = baseDirectory;
    this.setupMemoryCleanup();
  }
  get memoryCleanTime() {
    return this._memoryCleanTime;
  }
  set memoryCleanTime(value) {
    this._memoryCleanTime = value;
    this.dispose();
    this.setupMemoryCleanup();
  }
  isCached(name) {
    const encodedName = this.encodeName(name);
    return localStorage.getItem(encodedName) !== null;
  }
  async get(name) {
    const encodedName = this.encodeName(name);
    const baseDir = await this.getDir(this.baseDirectory);
    try {
      const fileHandle = await baseDir.getFileHandle(encodedName);
      const file = await fileHandle.getFile();
      this.updateLastAccessTime(encodedName);
      return file;
    } catch (e) {
      return null;
    }
  }
  async add(name, buffer) {
    const encodedName = this.encodeName(name);
    const baseDir = await this.getDir(this.baseDirectory);
    const fileHandle = await baseDir.getFileHandle(encodedName, {
      create: true
    });
    const writable = await fileHandle.createWritable();
    await writable.write(buffer);
    await writable.close();
    this.updateLastAccessTime(encodedName);
  }
  async clear() {
    const baseDir = await this.getDir(this.baseDirectory);
    for await (const [name] of baseDir.entries()) {
      await baseDir.removeEntry(name);
    }
  }
  dispose() {
    if (this._intervalID !== null) {
      window.clearInterval(this._intervalID);
    }
  }
  setupMemoryCleanup() {
    this._intervalID = window.setInterval(
      this.cleanMemory,
      this.memoryCleanTime
    );
  }
  async getDir(path) {
    const root = await navigator.storage.getDirectory();
    return root.getDirectoryHandle(path, {
      create: true
    });
  }
  encodeName(name) {
    const illegalChars = /[\\/:*?"<>|]/g;
    return name.replace(illegalChars, "");
  }
  updateLastAccessTime(encodedName) {
    const now = (/* @__PURE__ */ new Date()).getTime().toString();
    localStorage.setItem(encodedName, now);
  }
};
var _FragmentsGroup = class _FragmentsGroup2 extends Group {
  constructor() {
    super(...arguments);
    __publicField(this, "items", []);
    __publicField(this, "boundingBox", new Box3());
    __publicField(this, "coordinationMatrix", new Matrix4());
    __publicField(this, "keyFragments", /* @__PURE__ */ new Map());
    __publicField(this, "globalToExpressIDs", /* @__PURE__ */ new Map());
    __publicField(this, "data", /* @__PURE__ */ new Map());
    __publicField(this, "geometryIDs", {
      opaque: /* @__PURE__ */ new Map(),
      transparent: /* @__PURE__ */ new Map()
    });
    __publicField(this, "ifcMetadata", {
      name: "",
      description: "",
      schema: "IFC2X3",
      maxExpressID: 0
    });
    __publicField(this, "civilData");
    __publicField(this, "streamSettings", {
      baseFileName: "",
      ids: /* @__PURE__ */ new Map(),
      types: /* @__PURE__ */ new Map()
    });
    __publicField(this, "isStreamed", false);
    __publicField(this, "_properties");
  }
  /**
   * A getter that checks if this group has properties, either locally defined or streamed from a data source.
   */
  get hasProperties() {
    const hasLocalProps = this._properties !== void 0;
    const hasStreamProps = this.streamSettings.ids.size !== 0;
    return hasLocalProps || hasStreamProps;
  }
  /**
   * A method to create a map of fragment IDs and express IDs contained within them. This is useful because if you want to get "a chair", it might be made of 4 different geometries, and thus the subsets of 4 different fragments. Using this method, you would get exactly the fragments of where that chair is.
   * @param expressIDs - An iterable of express IDs to create the map for. If not provided, returns the fragment ID map for the whole group.
   * @returns A map where the keys are fragment IDs and the values are sets of express IDs.
   */
  getFragmentMap(expressIDs = this.data.keys()) {
    const fragmentMap = {};
    for (const expressID of expressIDs) {
      const data = this.data.get(expressID);
      if (!data)
        continue;
      for (const key of data[0]) {
        const fragmentID = this.keyFragments.get(key);
        if (fragmentID === void 0)
          continue;
        if (!fragmentMap[fragmentID]) {
          fragmentMap[fragmentID] = /* @__PURE__ */ new Set();
        }
        fragmentMap[fragmentID].add(expressID);
      }
    }
    return fragmentMap;
  }
  /**
   * Method to retrieve the vertices of a specific item within the fragments.
   * This method finds the fragments that contain the specified item,
   * then retrieves the vertices of those fragments.
   *
   * @param itemID - The ID of the item for which to retrieve vertices. Usually, an IFC expressID.
   * @returns An array of THREE.Vector3 objects representing the vertices of the specified item.
   *
   * @example
   * ```typescript
   * const itemVertices = fragmentsGroup.getItemVertices(12345);
   * for (const vertex of itemVertices) {
   *   console.log(`Vertex: ${vertex.x}, ${vertex.y}, ${vertex.z}`);
   * }
   * ```
   */
  getItemVertices(itemID) {
    const vertices = [];
    const fragmentIdMap = this.getFragmentMap([itemID]);
    for (const fragmentID in fragmentIdMap) {
      const fragment = this.items.find(
        (fragment2) => fragment2.id === fragmentID
      );
      if (!fragment)
        continue;
      const itemInstances = fragment.getInstancesIDs(itemID);
      if (!itemInstances)
        continue;
      for (const instance of itemInstances) {
        const matrix = new Matrix4();
        fragment.mesh.getMatrixAt(instance, matrix);
        for (const vertex of fragment.uniqueVertices) {
          const vector = vertex.clone().applyMatrix4(matrix);
          vertices.push(vector);
        }
      }
    }
    return vertices;
  }
  /**
   * Enables or disables the local property caching system.
   *
   * @param enabled - Whether to enable or disable it.
   */
  static setPropertiesDB(enabled) {
    if (enabled) {
      if (!_FragmentsGroup2.propertiesDB) {
        _FragmentsGroup2.propertiesDB = new StreamerFileDb(
          "that-open-company-streaming-properties"
        );
      }
    } else if (!enabled) {
      if (_FragmentsGroup2.propertiesDB) {
        _FragmentsGroup2.propertiesDB.dispose();
      }
    }
  }
  /**
   * Method to dispose of the resources used by the FragmentsGroup.
   *
   * @param disposeResources - If true, also dispose of the resources used by the fragments (geometries and materials). Default is true.
   */
  dispose(disposeResources = true) {
    for (const fragment of this.items) {
      fragment.dispose(disposeResources);
    }
    this.coordinationMatrix = new Matrix4();
    this.keyFragments.clear();
    this.data.clear();
    this._properties = {};
    this.removeFromParent();
    this.items = [];
    if (this.civilData) {
      const { alignments } = this.civilData;
      for (const [_id, alignment] of alignments) {
        this.disposeAlignment(alignment.vertical);
        this.disposeAlignment(alignment.horizontal);
        this.disposeAlignment(alignment.absolute);
      }
    }
    this.civilData = void 0;
  }
  /**
   * Method to set local properties of the fragments in this group.
   *
   * @param properties - An object containing properties of type IfcProperties.
   * The keys of the object are express IDs as strings, and the values are objects representing the properties of the corresponding express ID.
   *
   * @example
   * ```typescript
   * const properties: IfcProperties = {
   *   "12345": {
   *     name: "Chair",
   *     type: 1001,
   *     color: [0.5, 0.5, 0.5],
   *     //... other properties
   *   },
   *   "67890": {
   *     name: "Table",
   *     type: 1002,
   *     color: [0.8, 0.8, 0.8],
   *     //... other properties
   *   },
   *   //... more properties
   * };
   *
   * fragmentsGroup.setLocalProperties(properties);
   * ```
   */
  setLocalProperties(properties) {
    this._properties = properties;
  }
  /**
   * Method to retrieve the local properties of the fragments in this group.
   *
   * @returns {IfcProperties | undefined} - An object containing properties of type IfcProperties.
   * The keys of the object are express IDs as strings, and the values are objects representing the properties of the corresponding express ID.
   * If no local properties are set, it returns `undefined`.
   *
   * @example
   * ```typescript
   * const properties = fragmentsGroup.getLocalProperties();
   * if (properties) {
   *   for (const id in properties) {
   *     const property = properties[id];
   *     console.log(`ID: ${id}, Name: ${property.name}, Type: ${property.type}`);
   *   }
   * }
   * ```
   */
  getLocalProperties() {
    return this._properties;
  }
  /**
   * Method to retrieve all property IDs from either local properties or streamed properties.
   *
   * @returns {number[]} - An array of property IDs.
   *
   * @example
   * ```typescript
   * const propertyIDs = fragmentsGroup.getAllPropertiesIDs();
   * console.log(propertyIDs); // Output: [12345, 67890,...]
   * ```
   */
  getAllPropertiesIDs() {
    if (this._properties) {
      return Object.keys(this._properties).map((id) => parseInt(id, 10));
    }
    return Array.from(this.streamSettings.ids.keys());
  }
  /**
   * Method to retrieve all property types from either local properties or streamed properties.
   *
   * @returns {number[]} - An array of unique property types.
   *
   * @example
   * ```typescript
   * const propertyTypes = fragmentsGroup.getAllPropertiesTypes();
   * console.log(propertyTypes); // Output: [1001, 1002,...]
   * ```
   */
  getAllPropertiesTypes() {
    if (this._properties) {
      const types = /* @__PURE__ */ new Set();
      for (const id in this._properties) {
        const property = this._properties[id];
        if (property.type !== void 0) {
          types.add(property.type);
        }
      }
      return Array.from(types);
    }
    return Array.from(this.streamSettings.types.keys());
  }
  async getProperties(id) {
    if (this._properties) {
      return this._properties[id] || null;
    }
    const url = this.getPropsURL(id);
    const data = await this.getPropertiesData(url);
    return data ? data[id] : null;
  }
  /**
   * Method to set properties of a specific fragment in this group.
   *
   * @param id - The ID of the fragment for which to set properties.
   * @param value - The new properties to set for the fragment. If null, it deletes the properties for the fragment.
   * @throws Will throw an error if writing streamed properties, as it is not supported yet.
   *
   * @example
   * ```typescript
   * const properties: IfcProperties = {
   *   "12345": {
   *     name: "Chair",
   *     type: 1001,
   *     color: [0.5, 0.5, 0.5],
   *     //... other properties
   *   },
   * };
   *
   * fragmentsGroup.setProperties(12345, properties[12345]);
   * ```
   */
  async setProperties(id, value) {
    if (this._properties) {
      if (value !== null) {
        this._properties[id] = value;
      } else {
        delete this._properties[id];
      }
      return;
    }
    throw new Error("Writing streamed properties not supported yet!");
  }
  /**
   * Method to retrieve all properties of a specific type from either local properties or streamed properties.
   *
   * @param type - The type of properties to retrieve.
   * @returns A Promise that resolves to an object containing properties of type IfcProperties, or null if no properties of the specified type are found.
   *
   * @example
   * ```typescript
   * const type = 1001; // Example type
   * fragmentsGroup.getAllPropertiesOfType(type).then((properties) => {
   *   if (properties) {
   *     for (const id in properties) {
   *       const property = properties[id];
   *       console.log(`ID: ${id}, Name: ${property.name}, Type: ${property.type}`);
   *     }
   *   } else {
   *     console.log(`No properties of type ${type} found.`);
   *   }
   * });
   * ```
   */
  async getAllPropertiesOfType(type) {
    if (this._properties) {
      const result2 = {};
      let found = false;
      for (const id in this._properties) {
        const item = this._properties[id];
        if (item.type === type) {
          result2[item.expressID] = item;
          found = true;
        }
      }
      return found ? result2 : null;
    }
    const { types } = this.streamSettings;
    const fileIDs = types.get(type);
    if (fileIDs === void 0) {
      return null;
    }
    const result = {};
    for (const fileID of fileIDs) {
      const name = this.constructFileName(fileID);
      const data = await this.getPropertiesData(name);
      for (const key in data) {
        result[parseInt(key, 10)] = data[key];
      }
    }
    return result;
  }
  clone(_recursive) {
    throw new Error("Use FragmentsGroup.cloneGroup instead!");
  }
  /**
   * Creates a copy of the whole group or a part of it. Each fragment clone shares the geometry of with its respective original fragment, but has its own InstancedMesh data, so it also needs to be disposed.
   *
   * @param items - Optional - The part of the group to be cloned. If not given, the whole group is cloned.
   *
   */
  cloneGroup(items) {
    const newGroup = new _FragmentsGroup2();
    newGroup.coordinationMatrix = this.coordinationMatrix;
    newGroup.position.copy(this.position);
    newGroup.rotation.copy(this.rotation);
    newGroup.scale.copy(this.scale);
    newGroup.updateMatrix();
    newGroup.ifcMetadata = { ...this.ifcMetadata };
    if (!items) {
      items = this.getFragmentMap(this.data.keys());
    }
    const allIDs = /* @__PURE__ */ new Set();
    const fragmentIDConversion = /* @__PURE__ */ new Map();
    for (const fragment of this.items) {
      if (!items[fragment.id]) {
        continue;
      }
      const ids = items[fragment.id];
      const newFragment = fragment.clone(ids);
      fragmentIDConversion.set(fragment.id, newFragment.id);
      newGroup.items.push(newFragment);
      newGroup.add(newFragment.mesh);
      for (const expressID of ids) {
        allIDs.add(expressID);
      }
    }
    for (const id of allIDs) {
      const data = this.data.get(id);
      if (data) {
        newGroup.data.set(id, data);
      }
    }
    for (const [fragKey, fragID] of this.keyFragments) {
      if (fragmentIDConversion.has(fragID)) {
        const newID = fragmentIDConversion.get(fragID);
        if (newID === void 0) {
          throw new Error("Malformed fragment ID map during clone!");
        }
        newGroup.keyFragments.set(fragKey, newID);
      }
    }
    for (const [globalID, expressID] of this.globalToExpressIDs) {
      if (allIDs.has(expressID)) {
        newGroup.globalToExpressIDs.set(globalID, expressID);
      }
    }
    if (this.civilData) {
      newGroup.civilData = {
        coordinationMatrix: this.coordinationMatrix,
        alignments: /* @__PURE__ */ new Map()
      };
    }
    return newGroup;
  }
  getPropsURL(id) {
    const { ids } = this.streamSettings;
    const fileID = ids.get(id);
    if (fileID === void 0) {
      throw new Error("ID not found");
    }
    return this.constructFileName(fileID);
  }
  async getPropertiesData(name) {
    var _a;
    if ((_a = this.streamSettings.baseUrl) == null ? void 0 : _a.length) {
      console.warn(
        "streamSettings.baseUrl is deprecated. Use FragmentsGroup.url instead."
      );
      _FragmentsGroup2.url = this.streamSettings.baseUrl;
    }
    let fetched;
    if (_FragmentsGroup2.useCache) {
      let found = null;
      if (_FragmentsGroup2.propertiesDB) {
        found = await _FragmentsGroup2.propertiesDB.get(name);
      }
      if (found) {
        fetched = await found.text();
      } else {
        const dataFromBackend = await _FragmentsGroup2.fetch(name);
        fetched = await dataFromBackend.text();
        if (_FragmentsGroup2.propertiesDB) {
          const encoder = new TextEncoder();
          const buffer = encoder.encode(fetched);
          await _FragmentsGroup2.propertiesDB.add(name, buffer);
        }
      }
    } else {
      const dataFromBackend = await _FragmentsGroup2.fetch(name);
      fetched = await dataFromBackend.text();
    }
    return JSON.parse(fetched);
  }
  constructFileName(fileID) {
    if (_FragmentsGroup2.constructFileName) {
      return _FragmentsGroup2.constructFileName(fileID);
    }
    const { baseFileName } = this.streamSettings;
    return `${baseFileName}-${fileID}`;
  }
  disposeAlignment(alignment) {
    for (const curve of alignment) {
      curve.mesh.geometry.dispose();
      if (Array.isArray(curve.mesh.material)) {
        for (const mat of curve.mesh.material) {
          mat.dispose();
        }
      } else {
        curve.mesh.material.dispose();
      }
    }
    alignment.length = 0;
  }
};
__publicField(_FragmentsGroup, "fetch", async (url) => {
  return fetch(`${_FragmentsGroup.url}${url}`);
});
__publicField(_FragmentsGroup, "constructFileName", null);
__publicField(_FragmentsGroup, "url", "");
__publicField(_FragmentsGroup, "useCache", true);
__publicField(_FragmentsGroup, "propertiesDB", null);
var FragmentsGroup3 = _FragmentsGroup;
var Alignment3 = class {
  constructor() {
    __publicField(this, "vertical", []);
    __publicField(this, "horizontal", []);
    __publicField(this, "absolute", []);
    __publicField(this, "initialKP", 0);
  }
  /**
   * Returns the total length of the specified alignment type.
   * @param type - The type of alignment (vertical, horizontal, or absolute).
   * @returns The total length of the specified alignment type.
   */
  getLength(type) {
    let length = 0;
    for (const curve of this[type]) {
      length += curve.getLength();
    }
    return length;
  }
  /**
   * Returns the point at the specified percentage along the specified alignment type.
   * @param percentage - The percentage along the alignment type (between zero and one).
   * @param type - The type of alignment (vertical, horizontal, or absolute).
   * @returns The point at the specified percentage along the specified alignment type.
   * @throws Will throw an error if the percentage is out of range or if the point cannot be computed.
   */
  getPointAt(percentage, type) {
    const found = this.getCurveAt(percentage, type);
    return found.curve.getPointAt(found.percentage);
  }
  // Returns the percentage or null if the point is not contained in this alignment
  getPercentageAt(point, type, tolerance = 0.01) {
    const alignment = this[type];
    let currentLength = 0;
    for (const curve of alignment) {
      const factor = curve.getPercentageAt(point, tolerance);
      const curveLength = curve.getLength();
      if (factor !== null) {
        const foundLength = currentLength + factor * curveLength;
        const totalLength = this.getLength(type);
        return foundLength / totalLength;
      }
      currentLength += curveLength;
    }
    return null;
  }
  /**
   * Returns the curve and the percentage at the specified percentage along the specified alignment type.
   * If the percentage is out of range, it will be clamped to the nearest valid value (0 or 1).
   * If the point cannot be computed, an error will be thrown.
   *
   * @param percentage - The percentage along the alignment type (between zero and one).
   * @param type - The type of alignment (vertical, horizontal, or absolute).
   * @returns An object containing the curve and the percentage along the curve.
   * @throws Will throw an error if the percentage is out of range or if the point cannot be computed.
   */
  getCurveAt(percentage, type) {
    if (percentage < 0) {
      percentage = 0;
    } else if (percentage > 1) {
      percentage = 1;
    }
    const alignment = this[type];
    const alignmentLength = this.getLength(type);
    const targetLength = alignmentLength * percentage;
    let accumulatedLength = 0;
    for (const curve of alignment) {
      const curveLength = curve.getLength();
      if (accumulatedLength + curveLength >= targetLength) {
        const targetCurveLength = targetLength - accumulatedLength;
        const percentage2 = targetCurveLength / curveLength;
        return { curve, percentage: percentage2 };
      }
      accumulatedLength += curveLength;
    }
    throw new Error("Could not compute point!");
  }
};
var CivilCurve3 = class {
  /**
   * Constructs a new instance of CivilCurve.
   * @param index - The index of the curve.
   * @param mesh - The mesh associated with the curve.
   * @param data - Additional data associated with the curve.
   * @param alignment - The alignment of the curve.
   */
  constructor(index, mesh, data, alignment) {
    __publicField(this, "index");
    __publicField(this, "mesh");
    __publicField(this, "data");
    __publicField(this, "alignment");
    this.index = index;
    this.mesh = mesh;
    this.data = data;
    this.alignment = alignment;
  }
  get _index() {
    return this.mesh.geometry.index;
  }
  get _pos() {
    return this.mesh.geometry.attributes.position.array;
  }
  /**
   * Calculates the total length of the curve by summing up the lengths of all segments.
   * @returns The total length of the curve.
   */
  getLength() {
    let length = 0;
    for (let i = 0; i < this._index.array.length - 1; i += 2) {
      const { startPoint, endPoint } = this.getSegment(i);
      length += startPoint.distanceTo(endPoint);
    }
    return length;
  }
  /**
   * Calculates a point on the curve based on the given percentage.
   *
   * @param percentage - The percentage along the curve (between zero and one).
   * @returns A new THREE.Vector3 representing the point on the curve.
   *
   * @remarks
   * The method works by first finding the segment that corresponds to the given percentage.
   * It then normalizes the direction of the segment, multiplies it by the distance to the start of the segment,
   * and adds it to the start point of the segment.
   *
   * @throws Will throw an error if the percentage is outside the range [0, 1].
   */
  getPointAt(percentage) {
    const { startPoint, endPoint, distanceToStart } = this.getSegmentAt(percentage);
    const targetPoint = endPoint.clone();
    targetPoint.sub(startPoint);
    targetPoint.normalize();
    targetPoint.multiplyScalar(distanceToStart);
    targetPoint.add(startPoint);
    return targetPoint;
  }
  /**
   * Calculates a segment of the curve based on the given percentage.
   *
   * @param percentage - The percentage along the curve (between zero and one).
   * @returns An object containing the distance to the start of the segment, the index of the segment, and the start and end points of the segment.
   *
   * @remarks
   * The method works by first finding the segment that corresponds to the given percentage.
   * It then returns an object containing the distance to the start of the segment, the index of the segment, and the start and end points of the segment.
   *
   * @throws Will throw an error if the percentage is outside the range [0, 1].
   */
  getSegmentAt(percentage) {
    if (percentage < 0) {
      percentage = 0;
    } else if (percentage > 1) {
      percentage = 1;
    }
    const totalLength = this.getLength();
    const targetLength = totalLength * percentage;
    let accumulatedLength = 0;
    for (let index = 0; index < this._index.array.length - 1; index += 2) {
      const { startPoint, endPoint } = this.getSegment(index);
      const segmentLength = startPoint.distanceTo(endPoint);
      if (accumulatedLength + segmentLength >= targetLength) {
        const distanceToStart = targetLength - accumulatedLength;
        return { distanceToStart, index, startPoint, endPoint };
      }
      accumulatedLength += segmentLength;
    }
    throw new Error("Could not compute point");
  }
  /**
   * Calculates the percentage of the curve that corresponds to the given point.
   *
   * @param point - The point for which to calculate the percentage.
   * @param tolerance - The tolerance for determining if a point is on the curve. Default is 0.01.
   * @returns The percentage of the curve that corresponds to the given point, or null if the point is not contained in this curve.
   *
   * @remarks
   * The method works by iterating over each segment of the curve and checking if the given point is within the tolerance of the segment.
   * If a point is found, it calculates the percentage of the curve that corresponds to the point.
   * If no point is found, it returns null.
   */
  getPercentageAt(point, tolerance = 0.01) {
    let currentLength = 0;
    for (let i = 0; i < this._index.array.length - 1; i += 2) {
      const { startPoint, endPoint } = this.getSegment(i);
      const segmentLength = startPoint.distanceTo(endPoint);
      const startLength = point.distanceTo(startPoint);
      const endLength = point.distanceTo(endPoint);
      const combinedLength = startLength + endLength;
      const hasPoint = combinedLength - segmentLength <= tolerance;
      if (hasPoint) {
        const foundLength = currentLength + startLength;
        const totalLength = this.getLength();
        return foundLength / totalLength;
      }
      currentLength += segmentLength;
    }
    return null;
  }
  /**
   * Retrieves a segment of the curve based on the given index.
   *
   * @param index - The index of the segment.
   * @returns An object containing the start and end points of the segment.
   *
   * @remarks
   * The method calculates the start and end points of the segment based on the given index.
   * It uses the index array and position attribute of the curve's geometry to determine the start and end points.
   *
   * @throws Will throw an error if the index is out of range.
   */
  getSegment(index) {
    const start = this._index.array[index] * 3;
    const end = this._index.array[index + 1] * 3;
    const startPoint = new Vector3(
      this._pos[start],
      this._pos[start + 1],
      this._pos[start + 2]
    );
    const endPoint = new Vector3(
      this._pos[end],
      this._pos[end + 1],
      this._pos[end + 2]
    );
    return { startPoint, endPoint };
  }
};
var CurveMesh = class extends LineSegments {
  /**
   * Constructs a new instance of CurveMesh.
   *
   * @param index - The index of the curve mesh.
   * @param data - The data associated with the curve mesh.
   * @param alignment - The alignment of the curve mesh.
   * @param geometry - The geometry for the curve mesh. Optional.
   * @param material - The material(s) for the curve mesh. Optional.
   */
  constructor(index, data, alignment, geometry, material) {
    super(geometry, material);
    __publicField(this, "curve");
    this.curve = new CivilCurve3(index, this, data, alignment);
  }
};
var StreamedGeometry = class _StreamedGeometry {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsStreamedGeometry(bb, obj) {
    return (obj || new _StreamedGeometry()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsStreamedGeometry(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _StreamedGeometry()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  geometryId() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.readUint32(this.bb_pos + offset) : 0;
  }
  position(index) {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.readFloat32(
      this.bb.__vector(this.bb_pos + offset) + index * 4
    ) : 0;
  }
  positionLength() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  positionArray() {
    const offset = this.bb.__offset(this.bb_pos, 6);
    return offset ? new Float32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  normal(index) {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.readFloat32(
      this.bb.__vector(this.bb_pos + offset) + index * 4
    ) : 0;
  }
  normalLength() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  normalArray() {
    const offset = this.bb.__offset(this.bb_pos, 8);
    return offset ? new Float32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  index(index) {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.readUint32(this.bb.__vector(this.bb_pos + offset) + index * 4) : 0;
  }
  indexLength() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  indexArray() {
    const offset = this.bb.__offset(this.bb_pos, 10);
    return offset ? new Uint32Array(
      this.bb.bytes().buffer,
      this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + offset),
      this.bb.__vector_len(this.bb_pos + offset)
    ) : null;
  }
  static startStreamedGeometry(builder) {
    builder.startObject(4);
  }
  static addGeometryId(builder, geometryId) {
    builder.addFieldInt32(0, geometryId, 0);
  }
  static addPosition(builder, positionOffset) {
    builder.addFieldOffset(1, positionOffset, 0);
  }
  static createPositionVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]);
    }
    return builder.endVector();
  }
  static startPositionVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addNormal(builder, normalOffset) {
    builder.addFieldOffset(2, normalOffset, 0);
  }
  static createNormalVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]);
    }
    return builder.endVector();
  }
  static startNormalVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static addIndex(builder, indexOffset) {
    builder.addFieldOffset(3, indexOffset, 0);
  }
  static createIndexVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]);
    }
    return builder.endVector();
  }
  static startIndexVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endStreamedGeometry(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static createStreamedGeometry(builder, geometryId, positionOffset, normalOffset, indexOffset) {
    _StreamedGeometry.startStreamedGeometry(builder);
    _StreamedGeometry.addGeometryId(builder, geometryId);
    _StreamedGeometry.addPosition(builder, positionOffset);
    _StreamedGeometry.addNormal(builder, normalOffset);
    _StreamedGeometry.addIndex(builder, indexOffset);
    return _StreamedGeometry.endStreamedGeometry(builder);
  }
};
var StreamedGeometries = class _StreamedGeometries {
  constructor() {
    __publicField(this, "bb", null);
    __publicField(this, "bb_pos", 0);
  }
  __init(i, bb) {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }
  static getRootAsStreamedGeometries(bb, obj) {
    return (obj || new _StreamedGeometries()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  static getSizePrefixedRootAsStreamedGeometries(bb, obj) {
    bb.setPosition(bb.position() + SIZE_PREFIX_LENGTH);
    return (obj || new _StreamedGeometries()).__init(
      bb.readInt32(bb.position()) + bb.position(),
      bb
    );
  }
  geometries(index, obj) {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? (obj || new StreamedGeometry()).__init(
      this.bb.__indirect(
        this.bb.__vector(this.bb_pos + offset) + index * 4
      ),
      this.bb
    ) : null;
  }
  geometriesLength() {
    const offset = this.bb.__offset(this.bb_pos, 4);
    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;
  }
  static startStreamedGeometries(builder) {
    builder.startObject(1);
  }
  static addGeometries(builder, geometriesOffset) {
    builder.addFieldOffset(0, geometriesOffset, 0);
  }
  static createGeometriesVector(builder, data) {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]);
    }
    return builder.endVector();
  }
  static startGeometriesVector(builder, numElems) {
    builder.startVector(4, numElems, 4);
  }
  static endStreamedGeometries(builder) {
    const offset = builder.endObject();
    return offset;
  }
  static finishStreamedGeometriesBuffer(builder, offset) {
    builder.finish(offset);
  }
  static finishSizePrefixedStreamedGeometriesBuffer(builder, offset) {
    builder.finish(offset, void 0, true);
  }
  static createStreamedGeometries(builder, geometriesOffset) {
    _StreamedGeometries.startStreamedGeometries(builder);
    _StreamedGeometries.addGeometries(builder, geometriesOffset);
    return _StreamedGeometries.endStreamedGeometries(builder);
  }
};
var StreamSerializer = class {
  /**
   * Imports geometry data from a byte array in a streamed format.
   *
   * @param bytes - The byte array containing the serialized geometry data.
   * @returns A Map of geometry IDs to their respective position, normal, and index arrays.
   * @throws Will throw an error if the geometry ID is not found.
   */
  import(bytes) {
    const buffer = new ByteBuffer(bytes);
    const fbGeoms = StreamedGeometries.getRootAsStreamedGeometries(buffer);
    const geometries = /* @__PURE__ */ new Map();
    const length = fbGeoms.geometriesLength();
    for (let i = 0; i < length; i++) {
      const fbGeom = fbGeoms.geometries(i);
      if (!fbGeom)
        continue;
      const id = fbGeom.geometryId();
      if (id === null) {
        throw new Error("Error finding ID!");
      }
      const position = fbGeom.positionArray();
      const normal = fbGeom.normalArray();
      const index = fbGeom.indexArray();
      if (!position || !normal || !index) {
        continue;
      }
      geometries.set(id, { position, normal, index });
    }
    return geometries;
  }
  /**
   * Exports geometry data to a byte array in a streamed format.
   *
   * @param geometries - A Map of geometry IDs to their respective position, normal, and index arrays.
   * @returns A Uint8Array containing the serialized geometry data.
   */
  export(geometries) {
    const builder = new Builder(1024);
    const createdGeoms = [];
    const Gs = StreamedGeometries;
    const G = StreamedGeometry;
    for (const [id, { index, position, normal }] of geometries) {
      const indexVector = G.createIndexVector(builder, index);
      const posVector = G.createPositionVector(builder, position);
      const norVector = G.createNormalVector(builder, normal);
      G.startStreamedGeometry(builder);
      G.addGeometryId(builder, id);
      G.addIndex(builder, indexVector);
      G.addPosition(builder, posVector);
      G.addNormal(builder, norVector);
      const created = G.endStreamedGeometry(builder);
      createdGeoms.push(created);
    }
    const allGeoms = Gs.createGeometriesVector(builder, createdGeoms);
    Gs.startStreamedGeometries(builder);
    Gs.addGeometries(builder, allGeoms);
    const result = Gs.endStreamedGeometries(builder);
    builder.finish(result);
    return builder.asUint8Array();
  }
};
var FragmentUtils = class {
  static combine(maps) {
    if (maps.length === 0) {
      return {};
    }
    if (maps.length === 1) {
      return maps[0];
    }
    const result = {};
    for (const map of maps) {
      for (const fragID in map) {
        if (!result[fragID]) {
          result[fragID] = /* @__PURE__ */ new Set();
        }
        for (const expressID of map[fragID]) {
          result[fragID].add(expressID);
        }
      }
    }
    return result;
  }
  static intersect(maps) {
    if (maps.length === 0) {
      return {};
    }
    if (maps.length === 1) {
      return maps[0];
    }
    const visitedIDs = /* @__PURE__ */ new Map();
    let mapsCount = 0;
    for (const map of maps) {
      mapsCount++;
      for (const fragID in map) {
        if (!visitedIDs.has(fragID)) {
          visitedIDs.set(fragID, {
            count: 0,
            ids: /* @__PURE__ */ new Map()
          });
        }
        const current = visitedIDs.get(fragID);
        current.count++;
        for (const id of map[fragID]) {
          const idCount = current.ids.get(id) || 0;
          current.ids.set(id, idCount + 1);
        }
      }
    }
    const result = {};
    for (const [fragID, { count, ids }] of visitedIDs) {
      if (count !== mapsCount) {
        continue;
      }
      for (const [id, idCount] of ids) {
        if (idCount !== mapsCount) {
          continue;
        }
        if (!result[fragID]) {
          result[fragID] = /* @__PURE__ */ new Set();
        }
        result[fragID].add(id);
      }
    }
    return result;
  }
  static copy(map) {
    const copied = {};
    for (const id in map) {
      copied[id] = new Set(map[id]);
    }
    return copied;
  }
  static export(map) {
    const serialized = {};
    for (const fragID in map) {
      serialized[fragID] = Array.from(map[fragID]);
    }
    return serialized;
  }
  static import(serialized) {
    const map = {};
    for (const fragID in serialized) {
      map[fragID] = new Set(serialized[fragID]);
    }
    return map;
  }
};

// node_modules/@thatopen/components/dist/index.mjs
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => {
  __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var CENTER2 = 0;
var AVERAGE2 = 1;
var SAH2 = 2;
var CONTAINED2 = 2;
var TRIANGLE_INTERSECT_COST2 = 1.25;
var TRAVERSAL_COST2 = 1;
var BYTES_PER_NODE2 = 6 * 4 + 4 + 4;
var IS_LEAFNODE_FLAG2 = 65535;
var FLOAT32_EPSILON2 = Math.pow(2, -24);
var SKIP_GENERATION2 = Symbol("SKIP_GENERATION");
function getVertexCount2(geo) {
  return geo.index ? geo.index.count : geo.attributes.position.count;
}
function getTriCount2(geo) {
  return getVertexCount2(geo) / 3;
}
function getIndexArray2(vertexCount, BufferConstructor = ArrayBuffer) {
  if (vertexCount > 65535) {
    return new Uint32Array(new BufferConstructor(4 * vertexCount));
  } else {
    return new Uint16Array(new BufferConstructor(2 * vertexCount));
  }
}
function ensureIndex2(geo, options) {
  if (!geo.index) {
    const vertexCount = geo.attributes.position.count;
    const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
    const index = getIndexArray2(vertexCount, BufferConstructor);
    geo.setIndex(new BufferAttribute(index, 1));
    for (let i = 0; i < vertexCount; i++) {
      index[i] = i;
    }
  }
}
function getFullGeometryRange2(geo) {
  const triCount = getTriCount2(geo);
  const drawRange = geo.drawRange;
  const start = drawRange.start / 3;
  const end = (drawRange.start + drawRange.count) / 3;
  const offset = Math.max(0, start);
  const count = Math.min(triCount, end) - offset;
  return [{
    offset: Math.floor(offset),
    count: Math.floor(count)
  }];
}
function getRootIndexRanges2(geo) {
  if (!geo.groups || !geo.groups.length) {
    return getFullGeometryRange2(geo);
  }
  const ranges = [];
  const rangeBoundaries = /* @__PURE__ */ new Set();
  const drawRange = geo.drawRange;
  const drawRangeStart = drawRange.start / 3;
  const drawRangeEnd = (drawRange.start + drawRange.count) / 3;
  for (const group of geo.groups) {
    const groupStart = group.start / 3;
    const groupEnd = (group.start + group.count) / 3;
    rangeBoundaries.add(Math.max(drawRangeStart, groupStart));
    rangeBoundaries.add(Math.min(drawRangeEnd, groupEnd));
  }
  const sortedBoundaries = Array.from(rangeBoundaries.values()).sort((a, b) => a - b);
  for (let i = 0; i < sortedBoundaries.length - 1; i++) {
    const start = sortedBoundaries[i];
    const end = sortedBoundaries[i + 1];
    ranges.push({
      offset: Math.floor(start),
      count: Math.floor(end - start)
    });
  }
  return ranges;
}
function hasGroupGaps2(geometry) {
  if (geometry.groups.length === 0) {
    return false;
  }
  const vertexCount = getTriCount2(geometry);
  const groups = getRootIndexRanges2(geometry).sort((a, b) => a.offset - b.offset);
  const finalGroup = groups[groups.length - 1];
  finalGroup.count = Math.min(vertexCount - finalGroup.offset, finalGroup.count);
  let total = 0;
  groups.forEach(({ count }) => total += count);
  return vertexCount !== total;
}
function arrayToBox2(nodeIndex32, array, target) {
  target.min.x = array[nodeIndex32];
  target.min.y = array[nodeIndex32 + 1];
  target.min.z = array[nodeIndex32 + 2];
  target.max.x = array[nodeIndex32 + 3];
  target.max.y = array[nodeIndex32 + 4];
  target.max.z = array[nodeIndex32 + 5];
  return target;
}
function makeEmptyBounds2(target) {
  target[0] = target[1] = target[2] = Infinity;
  target[3] = target[4] = target[5] = -Infinity;
}
function getLongestEdgeIndex2(bounds) {
  let splitDimIdx = -1;
  let splitDist = -Infinity;
  for (let i = 0; i < 3; i++) {
    const dist = bounds[i + 3] - bounds[i];
    if (dist > splitDist) {
      splitDist = dist;
      splitDimIdx = i;
    }
  }
  return splitDimIdx;
}
function copyBounds2(source, target) {
  target.set(source);
}
function unionBounds2(a, b, target) {
  let aVal, bVal;
  for (let d = 0; d < 3; d++) {
    const d3 = d + 3;
    aVal = a[d];
    bVal = b[d];
    target[d] = aVal < bVal ? aVal : bVal;
    aVal = a[d3];
    bVal = b[d3];
    target[d3] = aVal > bVal ? aVal : bVal;
  }
}
function expandByTriangleBounds2(startIndex, triangleBounds, bounds) {
  for (let d = 0; d < 3; d++) {
    const tCenter = triangleBounds[startIndex + 2 * d];
    const tHalf = triangleBounds[startIndex + 2 * d + 1];
    const tMin = tCenter - tHalf;
    const tMax = tCenter + tHalf;
    if (tMin < bounds[d]) {
      bounds[d] = tMin;
    }
    if (tMax > bounds[d + 3]) {
      bounds[d + 3] = tMax;
    }
  }
}
function computeSurfaceArea2(bounds) {
  const d0 = bounds[3] - bounds[0];
  const d1 = bounds[4] - bounds[1];
  const d2 = bounds[5] - bounds[2];
  return 2 * (d0 * d1 + d1 * d2 + d2 * d0);
}
function getBounds2(triangleBounds, offset, count, target, centroidTarget = null) {
  let minx = Infinity;
  let miny = Infinity;
  let minz = Infinity;
  let maxx = -Infinity;
  let maxy = -Infinity;
  let maxz = -Infinity;
  let cminx = Infinity;
  let cminy = Infinity;
  let cminz = Infinity;
  let cmaxx = -Infinity;
  let cmaxy = -Infinity;
  let cmaxz = -Infinity;
  const includeCentroid = centroidTarget !== null;
  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {
    const cx = triangleBounds[i + 0];
    const hx = triangleBounds[i + 1];
    const lx = cx - hx;
    const rx = cx + hx;
    if (lx < minx)
      minx = lx;
    if (rx > maxx)
      maxx = rx;
    if (includeCentroid && cx < cminx)
      cminx = cx;
    if (includeCentroid && cx > cmaxx)
      cmaxx = cx;
    const cy = triangleBounds[i + 2];
    const hy = triangleBounds[i + 3];
    const ly = cy - hy;
    const ry = cy + hy;
    if (ly < miny)
      miny = ly;
    if (ry > maxy)
      maxy = ry;
    if (includeCentroid && cy < cminy)
      cminy = cy;
    if (includeCentroid && cy > cmaxy)
      cmaxy = cy;
    const cz = triangleBounds[i + 4];
    const hz = triangleBounds[i + 5];
    const lz = cz - hz;
    const rz = cz + hz;
    if (lz < minz)
      minz = lz;
    if (rz > maxz)
      maxz = rz;
    if (includeCentroid && cz < cminz)
      cminz = cz;
    if (includeCentroid && cz > cmaxz)
      cmaxz = cz;
  }
  target[0] = minx;
  target[1] = miny;
  target[2] = minz;
  target[3] = maxx;
  target[4] = maxy;
  target[5] = maxz;
  if (includeCentroid) {
    centroidTarget[0] = cminx;
    centroidTarget[1] = cminy;
    centroidTarget[2] = cminz;
    centroidTarget[3] = cmaxx;
    centroidTarget[4] = cmaxy;
    centroidTarget[5] = cmaxz;
  }
}
function getCentroidBounds2(triangleBounds, offset, count, centroidTarget) {
  let cminx = Infinity;
  let cminy = Infinity;
  let cminz = Infinity;
  let cmaxx = -Infinity;
  let cmaxy = -Infinity;
  let cmaxz = -Infinity;
  for (let i = offset * 6, end = (offset + count) * 6; i < end; i += 6) {
    const cx = triangleBounds[i + 0];
    if (cx < cminx)
      cminx = cx;
    if (cx > cmaxx)
      cmaxx = cx;
    const cy = triangleBounds[i + 2];
    if (cy < cminy)
      cminy = cy;
    if (cy > cmaxy)
      cmaxy = cy;
    const cz = triangleBounds[i + 4];
    if (cz < cminz)
      cminz = cz;
    if (cz > cmaxz)
      cmaxz = cz;
  }
  centroidTarget[0] = cminx;
  centroidTarget[1] = cminy;
  centroidTarget[2] = cminz;
  centroidTarget[3] = cmaxx;
  centroidTarget[4] = cmaxy;
  centroidTarget[5] = cmaxz;
}
function computeTriangleBounds2(geo, fullBounds) {
  makeEmptyBounds2(fullBounds);
  const posAttr = geo.attributes.position;
  const index = geo.index ? geo.index.array : null;
  const triCount = getTriCount2(geo);
  const triangleBounds = new Float32Array(triCount * 6);
  const normalized = posAttr.normalized;
  const posArr = posAttr.array;
  const bufferOffset = posAttr.offset || 0;
  let stride = 3;
  if (posAttr.isInterleavedBufferAttribute) {
    stride = posAttr.data.stride;
  }
  const getters = ["getX", "getY", "getZ"];
  for (let tri = 0; tri < triCount; tri++) {
    const tri3 = tri * 3;
    const tri6 = tri * 6;
    let ai = tri3 + 0;
    let bi = tri3 + 1;
    let ci = tri3 + 2;
    if (index) {
      ai = index[ai];
      bi = index[bi];
      ci = index[ci];
    }
    if (!normalized) {
      ai = ai * stride + bufferOffset;
      bi = bi * stride + bufferOffset;
      ci = ci * stride + bufferOffset;
    }
    for (let el = 0; el < 3; el++) {
      let a, b, c;
      if (normalized) {
        a = posAttr[getters[el]](ai);
        b = posAttr[getters[el]](bi);
        c = posAttr[getters[el]](ci);
      } else {
        a = posArr[ai + el];
        b = posArr[bi + el];
        c = posArr[ci + el];
      }
      let min = a;
      if (b < min)
        min = b;
      if (c < min)
        min = c;
      let max = a;
      if (b > max)
        max = b;
      if (c > max)
        max = c;
      const halfExtents = (max - min) / 2;
      const el2 = el * 2;
      triangleBounds[tri6 + el2 + 0] = min + halfExtents;
      triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * FLOAT32_EPSILON2;
      if (min < fullBounds[el])
        fullBounds[el] = min;
      if (max > fullBounds[el + 3])
        fullBounds[el + 3] = max;
    }
  }
  return triangleBounds;
}
var BIN_COUNT2 = 32;
var binsSort2 = (a, b) => a.candidate - b.candidate;
var sahBins2 = new Array(BIN_COUNT2).fill().map(() => {
  return {
    count: 0,
    bounds: new Float32Array(6),
    rightCacheBounds: new Float32Array(6),
    leftCacheBounds: new Float32Array(6),
    candidate: 0
  };
});
var leftBounds2 = new Float32Array(6);
function getOptimalSplit2(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {
  let axis = -1;
  let pos = 0;
  if (strategy === CENTER2) {
    axis = getLongestEdgeIndex2(centroidBoundingData);
    if (axis !== -1) {
      pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;
    }
  } else if (strategy === AVERAGE2) {
    axis = getLongestEdgeIndex2(nodeBoundingData);
    if (axis !== -1) {
      pos = getAverage2(triangleBounds, offset, count, axis);
    }
  } else if (strategy === SAH2) {
    const rootSurfaceArea = computeSurfaceArea2(nodeBoundingData);
    let bestCost = TRIANGLE_INTERSECT_COST2 * count;
    const cStart = offset * 6;
    const cEnd = (offset + count) * 6;
    for (let a = 0; a < 3; a++) {
      const axisLeft = centroidBoundingData[a];
      const axisRight = centroidBoundingData[a + 3];
      const axisLength = axisRight - axisLeft;
      const binWidth = axisLength / BIN_COUNT2;
      if (count < BIN_COUNT2 / 4) {
        const truncatedBins = [...sahBins2];
        truncatedBins.length = count;
        let b = 0;
        for (let c = cStart; c < cEnd; c += 6, b++) {
          const bin = truncatedBins[b];
          bin.candidate = triangleBounds[c + 2 * a];
          bin.count = 0;
          const {
            bounds,
            leftCacheBounds,
            rightCacheBounds
          } = bin;
          for (let d = 0; d < 3; d++) {
            rightCacheBounds[d] = Infinity;
            rightCacheBounds[d + 3] = -Infinity;
            leftCacheBounds[d] = Infinity;
            leftCacheBounds[d + 3] = -Infinity;
            bounds[d] = Infinity;
            bounds[d + 3] = -Infinity;
          }
          expandByTriangleBounds2(c, triangleBounds, bounds);
        }
        truncatedBins.sort(binsSort2);
        let splitCount = count;
        for (let bi = 0; bi < splitCount; bi++) {
          const bin = truncatedBins[bi];
          while (bi + 1 < splitCount && truncatedBins[bi + 1].candidate === bin.candidate) {
            truncatedBins.splice(bi + 1, 1);
            splitCount--;
          }
        }
        for (let c = cStart; c < cEnd; c += 6) {
          const center = triangleBounds[c + 2 * a];
          for (let bi = 0; bi < splitCount; bi++) {
            const bin = truncatedBins[bi];
            if (center >= bin.candidate) {
              expandByTriangleBounds2(c, triangleBounds, bin.rightCacheBounds);
            } else {
              expandByTriangleBounds2(c, triangleBounds, bin.leftCacheBounds);
              bin.count++;
            }
          }
        }
        for (let bi = 0; bi < splitCount; bi++) {
          const bin = truncatedBins[bi];
          const leftCount = bin.count;
          const rightCount = count - bin.count;
          const leftBounds22 = bin.leftCacheBounds;
          const rightBounds = bin.rightCacheBounds;
          let leftProb = 0;
          if (leftCount !== 0) {
            leftProb = computeSurfaceArea2(leftBounds22) / rootSurfaceArea;
          }
          let rightProb = 0;
          if (rightCount !== 0) {
            rightProb = computeSurfaceArea2(rightBounds) / rootSurfaceArea;
          }
          const cost = TRAVERSAL_COST2 + TRIANGLE_INTERSECT_COST2 * (leftProb * leftCount + rightProb * rightCount);
          if (cost < bestCost) {
            axis = a;
            bestCost = cost;
            pos = bin.candidate;
          }
        }
      } else {
        for (let i = 0; i < BIN_COUNT2; i++) {
          const bin = sahBins2[i];
          bin.count = 0;
          bin.candidate = axisLeft + binWidth + i * binWidth;
          const bounds = bin.bounds;
          for (let d = 0; d < 3; d++) {
            bounds[d] = Infinity;
            bounds[d + 3] = -Infinity;
          }
        }
        for (let c = cStart; c < cEnd; c += 6) {
          const triCenter = triangleBounds[c + 2 * a];
          const relativeCenter = triCenter - axisLeft;
          let binIndex = ~~(relativeCenter / binWidth);
          if (binIndex >= BIN_COUNT2)
            binIndex = BIN_COUNT2 - 1;
          const bin = sahBins2[binIndex];
          bin.count++;
          expandByTriangleBounds2(c, triangleBounds, bin.bounds);
        }
        const lastBin = sahBins2[BIN_COUNT2 - 1];
        copyBounds2(lastBin.bounds, lastBin.rightCacheBounds);
        for (let i = BIN_COUNT2 - 2; i >= 0; i--) {
          const bin = sahBins2[i];
          const nextBin = sahBins2[i + 1];
          unionBounds2(bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds);
        }
        let leftCount = 0;
        for (let i = 0; i < BIN_COUNT2 - 1; i++) {
          const bin = sahBins2[i];
          const binCount = bin.count;
          const bounds = bin.bounds;
          const nextBin = sahBins2[i + 1];
          const rightBounds = nextBin.rightCacheBounds;
          if (binCount !== 0) {
            if (leftCount === 0) {
              copyBounds2(bounds, leftBounds2);
            } else {
              unionBounds2(bounds, leftBounds2, leftBounds2);
            }
          }
          leftCount += binCount;
          let leftProb = 0;
          let rightProb = 0;
          if (leftCount !== 0) {
            leftProb = computeSurfaceArea2(leftBounds2) / rootSurfaceArea;
          }
          const rightCount = count - leftCount;
          if (rightCount !== 0) {
            rightProb = computeSurfaceArea2(rightBounds) / rootSurfaceArea;
          }
          const cost = TRAVERSAL_COST2 + TRIANGLE_INTERSECT_COST2 * (leftProb * leftCount + rightProb * rightCount);
          if (cost < bestCost) {
            axis = a;
            bestCost = cost;
            pos = bin.candidate;
          }
        }
      }
    }
  } else {
    console.warn(`MeshBVH: Invalid build strategy value ${strategy} used.`);
  }
  return { axis, pos };
}
function getAverage2(triangleBounds, offset, count, axis) {
  let avg = 0;
  for (let i = offset, end = offset + count; i < end; i++) {
    avg += triangleBounds[i * 6 + axis * 2];
  }
  return avg / count;
}
var MeshBVHNode2 = class {
  constructor() {
  }
};
function partition2(indirectBuffer, index, triangleBounds, offset, count, split) {
  let left = offset;
  let right = offset + count - 1;
  const pos = split.pos;
  const axisOffset = split.axis * 2;
  while (true) {
    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {
      left++;
    }
    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {
      right--;
    }
    if (left < right) {
      for (let i = 0; i < 3; i++) {
        let t0 = index[left * 3 + i];
        index[left * 3 + i] = index[right * 3 + i];
        index[right * 3 + i] = t0;
      }
      for (let i = 0; i < 6; i++) {
        let tb = triangleBounds[left * 6 + i];
        triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];
        triangleBounds[right * 6 + i] = tb;
      }
      left++;
      right--;
    } else {
      return left;
    }
  }
}
function partition_indirect2(indirectBuffer, index, triangleBounds, offset, count, split) {
  let left = offset;
  let right = offset + count - 1;
  const pos = split.pos;
  const axisOffset = split.axis * 2;
  while (true) {
    while (left <= right && triangleBounds[left * 6 + axisOffset] < pos) {
      left++;
    }
    while (left <= right && triangleBounds[right * 6 + axisOffset] >= pos) {
      right--;
    }
    if (left < right) {
      let t = indirectBuffer[left];
      indirectBuffer[left] = indirectBuffer[right];
      indirectBuffer[right] = t;
      for (let i = 0; i < 6; i++) {
        let tb = triangleBounds[left * 6 + i];
        triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];
        triangleBounds[right * 6 + i] = tb;
      }
      left++;
      right--;
    } else {
      return left;
    }
  }
}
function generateIndirectBuffer2(geometry, useSharedArrayBuffer) {
  const triCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;
  const useUint32 = triCount > 2 ** 16;
  const byteCount = useUint32 ? 4 : 2;
  const buffer = useSharedArrayBuffer ? new SharedArrayBuffer(triCount * byteCount) : new ArrayBuffer(triCount * byteCount);
  const indirectBuffer = useUint32 ? new Uint32Array(buffer) : new Uint16Array(buffer);
  for (let i = 0, l = indirectBuffer.length; i < l; i++) {
    indirectBuffer[i] = i;
  }
  return indirectBuffer;
}
function buildTree2(bvh, options) {
  const geometry = bvh.geometry;
  const indexArray = geometry.index ? geometry.index.array : null;
  const maxDepth = options.maxDepth;
  const verbose = options.verbose;
  const maxLeafTris = options.maxLeafTris;
  const strategy = options.strategy;
  const onProgress = options.onProgress;
  const totalTriangles = getTriCount2(geometry);
  const indirectBuffer = bvh._indirectBuffer;
  let reachedMaxDepth = false;
  const fullBounds = new Float32Array(6);
  const cacheCentroidBoundingData = new Float32Array(6);
  const triangleBounds = computeTriangleBounds2(geometry, fullBounds);
  const partionFunc = options.indirect ? partition_indirect2 : partition2;
  const roots = [];
  const ranges = options.indirect ? getFullGeometryRange2(geometry) : getRootIndexRanges2(geometry);
  if (ranges.length === 1) {
    const range = ranges[0];
    const root = new MeshBVHNode2();
    root.boundingData = fullBounds;
    getCentroidBounds2(triangleBounds, range.offset, range.count, cacheCentroidBoundingData);
    splitNode(root, range.offset, range.count, cacheCentroidBoundingData);
    roots.push(root);
  } else {
    for (let range of ranges) {
      const root = new MeshBVHNode2();
      root.boundingData = new Float32Array(6);
      getBounds2(triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData);
      splitNode(root, range.offset, range.count, cacheCentroidBoundingData);
      roots.push(root);
    }
  }
  return roots;
  function triggerProgress(trianglesProcessed) {
    if (onProgress) {
      onProgress(trianglesProcessed / totalTriangles);
    }
  }
  function splitNode(node, offset, count, centroidBoundingData = null, depth = 0) {
    if (!reachedMaxDepth && depth >= maxDepth) {
      reachedMaxDepth = true;
      if (verbose) {
        console.warn(`MeshBVH: Max depth of ${maxDepth} reached when generating BVH. Consider increasing maxDepth.`);
        console.warn(geometry);
      }
    }
    if (count <= maxLeafTris || depth >= maxDepth) {
      triggerProgress(offset + count);
      node.offset = offset;
      node.count = count;
      return node;
    }
    const split = getOptimalSplit2(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);
    if (split.axis === -1) {
      triggerProgress(offset + count);
      node.offset = offset;
      node.count = count;
      return node;
    }
    const splitOffset = partionFunc(indirectBuffer, indexArray, triangleBounds, offset, count, split);
    if (splitOffset === offset || splitOffset === offset + count) {
      triggerProgress(offset + count);
      node.offset = offset;
      node.count = count;
    } else {
      node.splitAxis = split.axis;
      const left = new MeshBVHNode2();
      const lstart = offset;
      const lcount = splitOffset - offset;
      node.left = left;
      left.boundingData = new Float32Array(6);
      getBounds2(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);
      splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);
      const right = new MeshBVHNode2();
      const rstart = splitOffset;
      const rcount = count - lcount;
      node.right = right;
      right.boundingData = new Float32Array(6);
      getBounds2(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);
      splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);
    }
    return node;
  }
}
function buildPackedTree2(bvh, options) {
  const geometry = bvh.geometry;
  if (options.indirect) {
    bvh._indirectBuffer = generateIndirectBuffer2(geometry, options.useSharedArrayBuffer);
    if (hasGroupGaps2(geometry) && !options.verbose) {
      console.warn(
        'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
      );
    }
  }
  if (!bvh._indirectBuffer) {
    ensureIndex2(geometry, options);
  }
  const roots = buildTree2(bvh, options);
  let float32Array;
  let uint32Array;
  let uint16Array;
  const packedRoots = [];
  const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;
  for (let i = 0; i < roots.length; i++) {
    const root = roots[i];
    let nodeCount = countNodes(root);
    const buffer = new BufferConstructor(BYTES_PER_NODE2 * nodeCount);
    float32Array = new Float32Array(buffer);
    uint32Array = new Uint32Array(buffer);
    uint16Array = new Uint16Array(buffer);
    populateBuffer(0, root);
    packedRoots.push(buffer);
  }
  bvh._roots = packedRoots;
  return;
  function countNodes(node) {
    if (node.count) {
      return 1;
    } else {
      return 1 + countNodes(node.left) + countNodes(node.right);
    }
  }
  function populateBuffer(byteOffset, node) {
    const stride4Offset = byteOffset / 4;
    const stride2Offset = byteOffset / 2;
    const isLeaf = !!node.count;
    const boundingData = node.boundingData;
    for (let i = 0; i < 6; i++) {
      float32Array[stride4Offset + i] = boundingData[i];
    }
    if (isLeaf) {
      const offset = node.offset;
      const count = node.count;
      uint32Array[stride4Offset + 6] = offset;
      uint16Array[stride2Offset + 14] = count;
      uint16Array[stride2Offset + 15] = IS_LEAFNODE_FLAG2;
      return byteOffset + BYTES_PER_NODE2;
    } else {
      const left = node.left;
      const right = node.right;
      const splitAxis = node.splitAxis;
      let nextUnusedPointer;
      nextUnusedPointer = populateBuffer(byteOffset + BYTES_PER_NODE2, left);
      if (nextUnusedPointer / 4 > Math.pow(2, 32)) {
        throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");
      }
      uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;
      nextUnusedPointer = populateBuffer(nextUnusedPointer, right);
      uint32Array[stride4Offset + 7] = splitAxis;
      return nextUnusedPointer;
    }
  }
}
var SeparatingAxisBounds2 = class {
  constructor() {
    this.min = Infinity;
    this.max = -Infinity;
  }
  setFromPointsField(points, field) {
    let min = Infinity;
    let max = -Infinity;
    for (let i = 0, l = points.length; i < l; i++) {
      const p = points[i];
      const val2 = p[field];
      min = val2 < min ? val2 : min;
      max = val2 > max ? val2 : max;
    }
    this.min = min;
    this.max = max;
  }
  setFromPoints(axis, points) {
    let min = Infinity;
    let max = -Infinity;
    for (let i = 0, l = points.length; i < l; i++) {
      const p = points[i];
      const val2 = axis.dot(p);
      min = val2 < min ? val2 : min;
      max = val2 > max ? val2 : max;
    }
    this.min = min;
    this.max = max;
  }
  isSeparated(other) {
    return this.min > other.max || other.min > this.max;
  }
};
SeparatingAxisBounds2.prototype.setFromBox = function() {
  const p = new Vector3();
  return function setFromBox(axis, box) {
    const boxMin = box.min;
    const boxMax = box.max;
    let min = Infinity;
    let max = -Infinity;
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          p.x = boxMin.x * x + boxMax.x * (1 - x);
          p.y = boxMin.y * y + boxMax.y * (1 - y);
          p.z = boxMin.z * z + boxMax.z * (1 - z);
          const val2 = axis.dot(p);
          min = Math.min(val2, min);
          max = Math.max(val2, max);
        }
      }
    }
    this.min = min;
    this.max = max;
  };
}();
var closestPointLineToLine2 = function() {
  const dir1 = new Vector3();
  const dir2 = new Vector3();
  const v02 = new Vector3();
  return function closestPointLineToLine22(l1, l2, result) {
    const v0 = l1.start;
    const v10 = dir1;
    const v2 = l2.start;
    const v32 = dir2;
    v02.subVectors(v0, v2);
    dir1.subVectors(l1.end, l1.start);
    dir2.subVectors(l2.end, l2.start);
    const d0232 = v02.dot(v32);
    const d3210 = v32.dot(v10);
    const d3232 = v32.dot(v32);
    const d0210 = v02.dot(v10);
    const d1010 = v10.dot(v10);
    const denom = d1010 * d3232 - d3210 * d3210;
    let d, d2;
    if (denom !== 0) {
      d = (d0232 * d3210 - d0210 * d3232) / denom;
    } else {
      d = 0;
    }
    d2 = (d0232 + d * d3210) / d3232;
    result.x = d;
    result.y = d2;
  };
}();
var closestPointsSegmentToSegment2 = function() {
  const paramResult = new Vector2();
  const temp122 = new Vector3();
  const temp222 = new Vector3();
  return function closestPointsSegmentToSegment22(l1, l2, target1, target2) {
    closestPointLineToLine2(l1, l2, paramResult);
    let d = paramResult.x;
    let d2 = paramResult.y;
    if (d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1) {
      l1.at(d, target1);
      l2.at(d2, target2);
      return;
    } else if (d >= 0 && d <= 1) {
      if (d2 < 0) {
        l2.at(0, target2);
      } else {
        l2.at(1, target2);
      }
      l1.closestPointToPoint(target2, true, target1);
      return;
    } else if (d2 >= 0 && d2 <= 1) {
      if (d < 0) {
        l1.at(0, target1);
      } else {
        l1.at(1, target1);
      }
      l2.closestPointToPoint(target1, true, target2);
      return;
    } else {
      let p;
      if (d < 0) {
        p = l1.start;
      } else {
        p = l1.end;
      }
      let p2;
      if (d2 < 0) {
        p2 = l2.start;
      } else {
        p2 = l2.end;
      }
      const closestPoint = temp122;
      const closestPoint2 = temp222;
      l1.closestPointToPoint(p2, true, temp122);
      l2.closestPointToPoint(p, true, temp222);
      if (closestPoint.distanceToSquared(p2) <= closestPoint2.distanceToSquared(p)) {
        target1.copy(closestPoint);
        target2.copy(p2);
        return;
      } else {
        target1.copy(p);
        target2.copy(closestPoint2);
        return;
      }
    }
  };
}();
var sphereIntersectTriangle2 = function() {
  const closestPointTemp = new Vector3();
  const projectedPointTemp = new Vector3();
  const planeTemp = new Plane();
  const lineTemp = new Line3();
  return function sphereIntersectTriangle22(sphere, triangle32) {
    const { radius, center } = sphere;
    const { a, b, c } = triangle32;
    lineTemp.start = a;
    lineTemp.end = b;
    const closestPoint1 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint1.distanceTo(center) <= radius)
      return true;
    lineTemp.start = a;
    lineTemp.end = c;
    const closestPoint2 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint2.distanceTo(center) <= radius)
      return true;
    lineTemp.start = b;
    lineTemp.end = c;
    const closestPoint3 = lineTemp.closestPointToPoint(center, true, closestPointTemp);
    if (closestPoint3.distanceTo(center) <= radius)
      return true;
    const plane = triangle32.getPlane(planeTemp);
    const dp = Math.abs(plane.distanceToPoint(center));
    if (dp <= radius) {
      const pp = plane.projectPoint(center, projectedPointTemp);
      const cp = triangle32.containsPoint(pp);
      if (cp)
        return true;
    }
    return false;
  };
}();
var ZERO_EPSILON2 = 1e-15;
function isNearZero2(value) {
  return Math.abs(value) < ZERO_EPSILON2;
}
var ExtendedTriangle2 = class extends Triangle {
  constructor(...args) {
    super(...args);
    this.isExtendedTriangle = true;
    this.satAxes = new Array(4).fill().map(() => new Vector3());
    this.satBounds = new Array(4).fill().map(() => new SeparatingAxisBounds2());
    this.points = [this.a, this.b, this.c];
    this.sphere = new Sphere();
    this.plane = new Plane();
    this.needsUpdate = true;
  }
  intersectsSphere(sphere) {
    return sphereIntersectTriangle2(sphere, this);
  }
  update() {
    const a = this.a;
    const b = this.b;
    const c = this.c;
    const points = this.points;
    const satAxes = this.satAxes;
    const satBounds = this.satBounds;
    const axis0 = satAxes[0];
    const sab0 = satBounds[0];
    this.getNormal(axis0);
    sab0.setFromPoints(axis0, points);
    const axis1 = satAxes[1];
    const sab1 = satBounds[1];
    axis1.subVectors(a, b);
    sab1.setFromPoints(axis1, points);
    const axis2 = satAxes[2];
    const sab2 = satBounds[2];
    axis2.subVectors(b, c);
    sab2.setFromPoints(axis2, points);
    const axis3 = satAxes[3];
    const sab3 = satBounds[3];
    axis3.subVectors(c, a);
    sab3.setFromPoints(axis3, points);
    this.sphere.setFromPoints(this.points);
    this.plane.setFromNormalAndCoplanarPoint(axis0, a);
    this.needsUpdate = false;
  }
};
ExtendedTriangle2.prototype.closestPointToSegment = function() {
  const point1 = new Vector3();
  const point2 = new Vector3();
  const edge = new Line3();
  return function distanceToSegment(segment, target1 = null, target2 = null) {
    const { start, end } = segment;
    const points = this.points;
    let distSq;
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 3; i++) {
      const nexti = (i + 1) % 3;
      edge.start.copy(points[i]);
      edge.end.copy(points[nexti]);
      closestPointsSegmentToSegment2(edge, segment, point1, point2);
      distSq = point1.distanceToSquared(point2);
      if (distSq < closestDistanceSq) {
        closestDistanceSq = distSq;
        if (target1)
          target1.copy(point1);
        if (target2)
          target2.copy(point2);
      }
    }
    this.closestPointToPoint(start, point1);
    distSq = start.distanceToSquared(point1);
    if (distSq < closestDistanceSq) {
      closestDistanceSq = distSq;
      if (target1)
        target1.copy(point1);
      if (target2)
        target2.copy(start);
    }
    this.closestPointToPoint(end, point1);
    distSq = end.distanceToSquared(point1);
    if (distSq < closestDistanceSq) {
      closestDistanceSq = distSq;
      if (target1)
        target1.copy(point1);
      if (target2)
        target2.copy(end);
    }
    return Math.sqrt(closestDistanceSq);
  };
}();
ExtendedTriangle2.prototype.intersectsTriangle = function() {
  const saTri2 = new ExtendedTriangle2();
  const arr1 = new Array(3);
  const arr2 = new Array(3);
  const cachedSatBounds = new SeparatingAxisBounds2();
  const cachedSatBounds2 = new SeparatingAxisBounds2();
  const cachedAxis = new Vector3();
  const dir = new Vector3();
  const dir1 = new Vector3();
  const dir2 = new Vector3();
  const tempDir = new Vector3();
  const edge = new Line3();
  const edge1 = new Line3();
  const edge2 = new Line3();
  const tempPoint = new Vector3();
  function triIntersectPlane(tri, plane, targetEdge) {
    const points = tri.points;
    let count = 0;
    let startPointIntersection = -1;
    for (let i = 0; i < 3; i++) {
      const { start, end } = edge;
      start.copy(points[i]);
      end.copy(points[(i + 1) % 3]);
      edge.delta(dir);
      const startIntersects = isNearZero2(plane.distanceToPoint(start));
      if (isNearZero2(plane.normal.dot(dir)) && startIntersects) {
        targetEdge.copy(edge);
        count = 2;
        break;
      }
      const doesIntersect = plane.intersectLine(edge, tempPoint);
      if (!doesIntersect && startIntersects) {
        tempPoint.copy(start);
      }
      if ((doesIntersect || startIntersects) && !isNearZero2(tempPoint.distanceTo(end))) {
        if (count <= 1) {
          const point = count === 1 ? targetEdge.start : targetEdge.end;
          point.copy(tempPoint);
          if (startIntersects) {
            startPointIntersection = count;
          }
        } else if (count >= 2) {
          const point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;
          point.copy(tempPoint);
          count = 2;
          break;
        }
        count++;
        if (count === 2 && startPointIntersection === -1) {
          break;
        }
      }
    }
    return count;
  }
  return function intersectsTriangle(other, target = null, suppressLog = false) {
    if (this.needsUpdate) {
      this.update();
    }
    if (!other.isExtendedTriangle) {
      saTri2.copy(other);
      saTri2.update();
      other = saTri2;
    } else if (other.needsUpdate) {
      other.update();
    }
    const plane1 = this.plane;
    const plane2 = other.plane;
    if (Math.abs(plane1.normal.dot(plane2.normal)) > 1 - 1e-10) {
      const satBounds1 = this.satBounds;
      const satAxes1 = this.satAxes;
      arr2[0] = other.a;
      arr2[1] = other.b;
      arr2[2] = other.c;
      for (let i = 0; i < 4; i++) {
        const sb = satBounds1[i];
        const sa = satAxes1[i];
        cachedSatBounds.setFromPoints(sa, arr2);
        if (sb.isSeparated(cachedSatBounds))
          return false;
      }
      const satBounds2 = other.satBounds;
      const satAxes2 = other.satAxes;
      arr1[0] = this.a;
      arr1[1] = this.b;
      arr1[2] = this.c;
      for (let i = 0; i < 4; i++) {
        const sb = satBounds2[i];
        const sa = satAxes2[i];
        cachedSatBounds.setFromPoints(sa, arr1);
        if (sb.isSeparated(cachedSatBounds))
          return false;
      }
      for (let i = 0; i < 4; i++) {
        const sa1 = satAxes1[i];
        for (let i2 = 0; i2 < 4; i2++) {
          const sa2 = satAxes2[i2];
          cachedAxis.crossVectors(sa1, sa2);
          cachedSatBounds.setFromPoints(cachedAxis, arr1);
          cachedSatBounds2.setFromPoints(cachedAxis, arr2);
          if (cachedSatBounds.isSeparated(cachedSatBounds2))
            return false;
        }
      }
      if (target) {
        if (!suppressLog) {
          console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.");
        }
        target.start.set(0, 0, 0);
        target.end.set(0, 0, 0);
      }
      return true;
    } else {
      const count1 = triIntersectPlane(this, plane2, edge1);
      if (count1 === 1 && other.containsPoint(edge1.end)) {
        if (target) {
          target.start.copy(edge1.end);
          target.end.copy(edge1.end);
        }
        return true;
      } else if (count1 !== 2) {
        return false;
      }
      const count2 = triIntersectPlane(other, plane1, edge2);
      if (count2 === 1 && this.containsPoint(edge2.end)) {
        if (target) {
          target.start.copy(edge2.end);
          target.end.copy(edge2.end);
        }
        return true;
      } else if (count2 !== 2) {
        return false;
      }
      edge1.delta(dir1);
      edge2.delta(dir2);
      if (dir1.dot(dir2) < 0) {
        let tmp = edge2.start;
        edge2.start = edge2.end;
        edge2.end = tmp;
      }
      const s1 = edge1.start.dot(dir1);
      const e1 = edge1.end.dot(dir1);
      const s2 = edge2.start.dot(dir1);
      const e2 = edge2.end.dot(dir1);
      const separated1 = e1 < s2;
      const separated2 = s1 < e2;
      if (s1 !== e2 && s2 !== e1 && separated1 === separated2) {
        return false;
      }
      if (target) {
        tempDir.subVectors(edge1.start, edge2.start);
        if (tempDir.dot(dir1) > 0) {
          target.start.copy(edge1.start);
        } else {
          target.start.copy(edge2.start);
        }
        tempDir.subVectors(edge1.end, edge2.end);
        if (tempDir.dot(dir1) < 0) {
          target.end.copy(edge1.end);
        } else {
          target.end.copy(edge2.end);
        }
      }
      return true;
    }
  };
}();
ExtendedTriangle2.prototype.distanceToPoint = function() {
  const target = new Vector3();
  return function distanceToPoint(point) {
    this.closestPointToPoint(point, target);
    return point.distanceTo(target);
  };
}();
ExtendedTriangle2.prototype.distanceToTriangle = function() {
  const point = new Vector3();
  const point2 = new Vector3();
  const cornerFields = ["a", "b", "c"];
  const line1 = new Line3();
  const line2 = new Line3();
  return function distanceToTriangle(other, target1 = null, target2 = null) {
    const lineTarget = target1 || target2 ? line1 : null;
    if (this.intersectsTriangle(other, lineTarget)) {
      if (target1 || target2) {
        if (target1)
          lineTarget.getCenter(target1);
        if (target2)
          lineTarget.getCenter(target2);
      }
      return 0;
    }
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 3; i++) {
      let dist;
      const field = cornerFields[i];
      const otherVec = other[field];
      this.closestPointToPoint(otherVec, point);
      dist = otherVec.distanceToSquared(point);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(point);
        if (target2)
          target2.copy(otherVec);
      }
      const thisVec = this[field];
      other.closestPointToPoint(thisVec, point);
      dist = thisVec.distanceToSquared(point);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(thisVec);
        if (target2)
          target2.copy(point);
      }
    }
    for (let i = 0; i < 3; i++) {
      const f11 = cornerFields[i];
      const f12 = cornerFields[(i + 1) % 3];
      line1.set(this[f11], this[f12]);
      for (let i2 = 0; i2 < 3; i2++) {
        const f21 = cornerFields[i2];
        const f22 = cornerFields[(i2 + 1) % 3];
        line2.set(other[f21], other[f22]);
        closestPointsSegmentToSegment2(line1, line2, point, point2);
        const dist = point.distanceToSquared(point2);
        if (dist < closestDistanceSq) {
          closestDistanceSq = dist;
          if (target1)
            target1.copy(point);
          if (target2)
            target2.copy(point2);
        }
      }
    }
    return Math.sqrt(closestDistanceSq);
  };
}();
var OrientedBox2 = class {
  constructor(min, max, matrix) {
    this.isOrientedBox = true;
    this.min = new Vector3();
    this.max = new Vector3();
    this.matrix = new Matrix4();
    this.invMatrix = new Matrix4();
    this.points = new Array(8).fill().map(() => new Vector3());
    this.satAxes = new Array(3).fill().map(() => new Vector3());
    this.satBounds = new Array(3).fill().map(() => new SeparatingAxisBounds2());
    this.alignedSatBounds = new Array(3).fill().map(() => new SeparatingAxisBounds2());
    this.needsUpdate = false;
    if (min)
      this.min.copy(min);
    if (max)
      this.max.copy(max);
    if (matrix)
      this.matrix.copy(matrix);
  }
  set(min, max, matrix) {
    this.min.copy(min);
    this.max.copy(max);
    this.matrix.copy(matrix);
    this.needsUpdate = true;
  }
  copy(other) {
    this.min.copy(other.min);
    this.max.copy(other.max);
    this.matrix.copy(other.matrix);
    this.needsUpdate = true;
  }
};
OrientedBox2.prototype.update = /* @__PURE__ */ function() {
  return function update() {
    const matrix = this.matrix;
    const min = this.min;
    const max = this.max;
    const points = this.points;
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          const i = (1 << 0) * x | (1 << 1) * y | (1 << 2) * z;
          const v = points[i];
          v.x = x ? max.x : min.x;
          v.y = y ? max.y : min.y;
          v.z = z ? max.z : min.z;
          v.applyMatrix4(matrix);
        }
      }
    }
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    const minVec = points[0];
    for (let i = 0; i < 3; i++) {
      const axis = satAxes[i];
      const sb = satBounds[i];
      const index = 1 << i;
      const pi = points[index];
      axis.subVectors(minVec, pi);
      sb.setFromPoints(axis, points);
    }
    const alignedSatBounds = this.alignedSatBounds;
    alignedSatBounds[0].setFromPointsField(points, "x");
    alignedSatBounds[1].setFromPointsField(points, "y");
    alignedSatBounds[2].setFromPointsField(points, "z");
    this.invMatrix.copy(this.matrix).invert();
    this.needsUpdate = false;
  };
}();
OrientedBox2.prototype.intersectsBox = function() {
  const aabbBounds = new SeparatingAxisBounds2();
  return function intersectsBox(box) {
    if (this.needsUpdate) {
      this.update();
    }
    const min = box.min;
    const max = box.max;
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    const alignedSatBounds = this.alignedSatBounds;
    aabbBounds.min = min.x;
    aabbBounds.max = max.x;
    if (alignedSatBounds[0].isSeparated(aabbBounds))
      return false;
    aabbBounds.min = min.y;
    aabbBounds.max = max.y;
    if (alignedSatBounds[1].isSeparated(aabbBounds))
      return false;
    aabbBounds.min = min.z;
    aabbBounds.max = max.z;
    if (alignedSatBounds[2].isSeparated(aabbBounds))
      return false;
    for (let i = 0; i < 3; i++) {
      const axis = satAxes[i];
      const sb = satBounds[i];
      aabbBounds.setFromBox(axis, box);
      if (sb.isSeparated(aabbBounds))
        return false;
    }
    return true;
  };
}();
OrientedBox2.prototype.intersectsTriangle = function() {
  const saTri = new ExtendedTriangle2();
  const pointsArr = new Array(3);
  const cachedSatBounds = new SeparatingAxisBounds2();
  const cachedSatBounds2 = new SeparatingAxisBounds2();
  const cachedAxis = new Vector3();
  return function intersectsTriangle(triangle32) {
    if (this.needsUpdate) {
      this.update();
    }
    if (!triangle32.isExtendedTriangle) {
      saTri.copy(triangle32);
      saTri.update();
      triangle32 = saTri;
    } else if (triangle32.needsUpdate) {
      triangle32.update();
    }
    const satBounds = this.satBounds;
    const satAxes = this.satAxes;
    pointsArr[0] = triangle32.a;
    pointsArr[1] = triangle32.b;
    pointsArr[2] = triangle32.c;
    for (let i = 0; i < 3; i++) {
      const sb = satBounds[i];
      const sa = satAxes[i];
      cachedSatBounds.setFromPoints(sa, pointsArr);
      if (sb.isSeparated(cachedSatBounds))
        return false;
    }
    const triSatBounds = triangle32.satBounds;
    const triSatAxes = triangle32.satAxes;
    const points = this.points;
    for (let i = 0; i < 3; i++) {
      const sb = triSatBounds[i];
      const sa = triSatAxes[i];
      cachedSatBounds.setFromPoints(sa, points);
      if (sb.isSeparated(cachedSatBounds))
        return false;
    }
    for (let i = 0; i < 3; i++) {
      const sa1 = satAxes[i];
      for (let i2 = 0; i2 < 4; i2++) {
        const sa2 = triSatAxes[i2];
        cachedAxis.crossVectors(sa1, sa2);
        cachedSatBounds.setFromPoints(cachedAxis, pointsArr);
        cachedSatBounds2.setFromPoints(cachedAxis, points);
        if (cachedSatBounds.isSeparated(cachedSatBounds2))
          return false;
      }
    }
    return true;
  };
}();
OrientedBox2.prototype.closestPointToPoint = /* @__PURE__ */ function() {
  return function closestPointToPoint22(point, target1) {
    if (this.needsUpdate) {
      this.update();
    }
    target1.copy(point).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix);
    return target1;
  };
}();
OrientedBox2.prototype.distanceToPoint = function() {
  const target = new Vector3();
  return function distanceToPoint(point) {
    this.closestPointToPoint(point, target);
    return point.distanceTo(target);
  };
}();
OrientedBox2.prototype.distanceToBox = function() {
  const xyzFields = ["x", "y", "z"];
  const segments1 = new Array(12).fill().map(() => new Line3());
  const segments2 = new Array(12).fill().map(() => new Line3());
  const point1 = new Vector3();
  const point2 = new Vector3();
  return function distanceToBox(box, threshold = 0, target1 = null, target2 = null) {
    if (this.needsUpdate) {
      this.update();
    }
    if (this.intersectsBox(box)) {
      if (target1 || target2) {
        box.getCenter(point2);
        this.closestPointToPoint(point2, point1);
        box.closestPointToPoint(point1, point2);
        if (target1)
          target1.copy(point1);
        if (target2)
          target2.copy(point2);
      }
      return 0;
    }
    const threshold2 = threshold * threshold;
    const min = box.min;
    const max = box.max;
    const points = this.points;
    let closestDistanceSq = Infinity;
    for (let i = 0; i < 8; i++) {
      const p = points[i];
      point2.copy(p).clamp(min, max);
      const dist = p.distanceToSquared(point2);
      if (dist < closestDistanceSq) {
        closestDistanceSq = dist;
        if (target1)
          target1.copy(p);
        if (target2)
          target2.copy(point2);
        if (dist < threshold2)
          return Math.sqrt(dist);
      }
    }
    let count = 0;
    for (let i = 0; i < 3; i++) {
      for (let i1 = 0; i1 <= 1; i1++) {
        for (let i2 = 0; i2 <= 1; i2++) {
          const nextIndex = (i + 1) % 3;
          const nextIndex2 = (i + 2) % 3;
          const index = i1 << nextIndex | i2 << nextIndex2;
          const index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;
          const p1 = points[index];
          const p2 = points[index2];
          const line1 = segments1[count];
          line1.set(p1, p2);
          const f1 = xyzFields[i];
          const f2 = xyzFields[nextIndex];
          const f3 = xyzFields[nextIndex2];
          const line2 = segments2[count];
          const start = line2.start;
          const end = line2.end;
          start[f1] = min[f1];
          start[f2] = i1 ? min[f2] : max[f2];
          start[f3] = i2 ? min[f3] : max[f2];
          end[f1] = max[f1];
          end[f2] = i1 ? min[f2] : max[f2];
          end[f3] = i2 ? min[f3] : max[f2];
          count++;
        }
      }
    }
    for (let x = 0; x <= 1; x++) {
      for (let y = 0; y <= 1; y++) {
        for (let z = 0; z <= 1; z++) {
          point2.x = x ? max.x : min.x;
          point2.y = y ? max.y : min.y;
          point2.z = z ? max.z : min.z;
          this.closestPointToPoint(point2, point1);
          const dist = point2.distanceToSquared(point1);
          if (dist < closestDistanceSq) {
            closestDistanceSq = dist;
            if (target1)
              target1.copy(point1);
            if (target2)
              target2.copy(point2);
            if (dist < threshold2)
              return Math.sqrt(dist);
          }
        }
      }
    }
    for (let i = 0; i < 12; i++) {
      const l1 = segments1[i];
      for (let i2 = 0; i2 < 12; i2++) {
        const l2 = segments2[i2];
        closestPointsSegmentToSegment2(l1, l2, point1, point2);
        const dist = point1.distanceToSquared(point2);
        if (dist < closestDistanceSq) {
          closestDistanceSq = dist;
          if (target1)
            target1.copy(point1);
          if (target2)
            target2.copy(point2);
          if (dist < threshold2)
            return Math.sqrt(dist);
        }
      }
    }
    return Math.sqrt(closestDistanceSq);
  };
}();
var PrimitivePool2 = class {
  constructor(getNewPrimitive) {
    this._getNewPrimitive = getNewPrimitive;
    this._primitives = [];
  }
  getPrimitive() {
    const primitives = this._primitives;
    if (primitives.length === 0) {
      return this._getNewPrimitive();
    } else {
      return primitives.pop();
    }
  }
  releasePrimitive(primitive) {
    this._primitives.push(primitive);
  }
};
var ExtendedTrianglePoolBase2 = class extends PrimitivePool2 {
  constructor() {
    super(() => new ExtendedTriangle2());
  }
};
var ExtendedTrianglePool2 = new ExtendedTrianglePoolBase2();
function IS_LEAF2(n16, uint16Array) {
  return uint16Array[n16 + 15] === 65535;
}
function OFFSET2(n32, uint32Array) {
  return uint32Array[n32 + 6];
}
function COUNT2(n16, uint16Array) {
  return uint16Array[n16 + 14];
}
function LEFT_NODE2(n32) {
  return n32 + 8;
}
function RIGHT_NODE2(n32, uint32Array) {
  return uint32Array[n32 + 6];
}
function SPLIT_AXIS2(n32, uint32Array) {
  return uint32Array[n32 + 7];
}
function BOUNDING_DATA_INDEX2(n32) {
  return n32;
}
var _BufferStack2 = class {
  constructor() {
    this.float32Array = null;
    this.uint16Array = null;
    this.uint32Array = null;
    const stack = [];
    let prevBuffer = null;
    this.setBuffer = (buffer) => {
      if (prevBuffer) {
        stack.push(prevBuffer);
      }
      prevBuffer = buffer;
      this.float32Array = new Float32Array(buffer);
      this.uint16Array = new Uint16Array(buffer);
      this.uint32Array = new Uint32Array(buffer);
    };
    this.clearBuffer = () => {
      prevBuffer = null;
      this.float32Array = null;
      this.uint16Array = null;
      this.uint32Array = null;
      if (stack.length !== 0) {
        this.setBuffer(stack.pop());
      }
    };
  }
};
var BufferStack2 = new _BufferStack2();
var _box12;
var _box22;
var boxStack2 = [];
var boxPool2 = new PrimitivePool2(() => new Box3());
function shapecast2(bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset) {
  _box12 = boxPool2.getPrimitive();
  _box22 = boxPool2.getPrimitive();
  boxStack2.push(_box12, _box22);
  BufferStack2.setBuffer(bvh._roots[root]);
  const result = shapecastTraverse2(0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);
  BufferStack2.clearBuffer();
  boxPool2.releasePrimitive(_box12);
  boxPool2.releasePrimitive(_box22);
  boxStack2.pop();
  boxStack2.pop();
  const length = boxStack2.length;
  if (length > 0) {
    _box22 = boxStack2[length - 1];
    _box12 = boxStack2[length - 2];
  }
  return result;
}
function shapecastTraverse2(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc = null, nodeIndexByteOffset = 0, depth = 0) {
  const { float32Array, uint16Array, uint32Array } = BufferStack2;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF2(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET2(nodeIndex32, uint32Array);
    const count = COUNT2(nodeIndex16, uint16Array);
    arrayToBox2(BOUNDING_DATA_INDEX2(nodeIndex32), float32Array, _box12);
    return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box12);
  } else {
    let getLeftOffset = function(nodeIndex322) {
      const { uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack2;
      let nodeIndex162 = nodeIndex322 * 2;
      while (!IS_LEAF2(nodeIndex162, uint16Array2)) {
        nodeIndex322 = LEFT_NODE2(nodeIndex322);
        nodeIndex162 = nodeIndex322 * 2;
      }
      return OFFSET2(nodeIndex322, uint32Array2);
    }, getRightEndOffset = function(nodeIndex322) {
      const { uint16Array: uint16Array2, uint32Array: uint32Array2 } = BufferStack2;
      let nodeIndex162 = nodeIndex322 * 2;
      while (!IS_LEAF2(nodeIndex162, uint16Array2)) {
        nodeIndex322 = RIGHT_NODE2(nodeIndex322, uint32Array2);
        nodeIndex162 = nodeIndex322 * 2;
      }
      return OFFSET2(nodeIndex322, uint32Array2) + COUNT2(nodeIndex162, uint16Array2);
    };
    const left = LEFT_NODE2(nodeIndex32);
    const right = RIGHT_NODE2(nodeIndex32, uint32Array);
    let c1 = left;
    let c2 = right;
    let score1, score2;
    let box1, box2;
    if (nodeScoreFunc) {
      box1 = _box12;
      box2 = _box22;
      arrayToBox2(BOUNDING_DATA_INDEX2(c1), float32Array, box1);
      arrayToBox2(BOUNDING_DATA_INDEX2(c2), float32Array, box2);
      score1 = nodeScoreFunc(box1);
      score2 = nodeScoreFunc(box2);
      if (score2 < score1) {
        c1 = right;
        c2 = left;
        const temp52 = score1;
        score1 = score2;
        score2 = temp52;
        box1 = box2;
      }
    }
    if (!box1) {
      box1 = _box12;
      arrayToBox2(BOUNDING_DATA_INDEX2(c1), float32Array, box1);
    }
    const isC1Leaf = IS_LEAF2(c1 * 2, uint16Array);
    const c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);
    let c1StopTraversal;
    if (c1Intersection === CONTAINED2) {
      const offset = getLeftOffset(c1);
      const end = getRightEndOffset(c1);
      const count = end - offset;
      c1StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1);
    } else {
      c1StopTraversal = c1Intersection && shapecastTraverse2(
        c1,
        geometry,
        intersectsBoundsFunc,
        intersectsRangeFunc,
        nodeScoreFunc,
        nodeIndexByteOffset,
        depth + 1
      );
    }
    if (c1StopTraversal)
      return true;
    box2 = _box22;
    arrayToBox2(BOUNDING_DATA_INDEX2(c2), float32Array, box2);
    const isC2Leaf = IS_LEAF2(c2 * 2, uint16Array);
    const c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);
    let c2StopTraversal;
    if (c2Intersection === CONTAINED2) {
      const offset = getLeftOffset(c2);
      const end = getRightEndOffset(c2);
      const count = end - offset;
      c2StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2);
    } else {
      c2StopTraversal = c2Intersection && shapecastTraverse2(
        c2,
        geometry,
        intersectsBoundsFunc,
        intersectsRangeFunc,
        nodeScoreFunc,
        nodeIndexByteOffset,
        depth + 1
      );
    }
    if (c2StopTraversal)
      return true;
    return false;
  }
}
var temp5 = new Vector3();
var temp1$22 = new Vector3();
function closestPointToPoint2(bvh, point, target = {}, minThreshold = 0, maxThreshold = Infinity) {
  const minThresholdSq = minThreshold * minThreshold;
  const maxThresholdSq = maxThreshold * maxThreshold;
  let closestDistanceSq = Infinity;
  let closestDistanceTriIndex = null;
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        temp5.copy(point).clamp(box.min, box.max);
        return temp5.distanceToSquared(point);
      },
      intersectsBounds: (box, isLeaf, score) => {
        return score < closestDistanceSq && score < maxThresholdSq;
      },
      intersectsTriangle: (tri, triIndex) => {
        tri.closestPointToPoint(point, temp5);
        const distSq = point.distanceToSquared(temp5);
        if (distSq < closestDistanceSq) {
          temp1$22.copy(temp5);
          closestDistanceSq = distSq;
          closestDistanceTriIndex = triIndex;
        }
        if (distSq < minThresholdSq) {
          return true;
        } else {
          return false;
        }
      }
    }
  );
  if (closestDistanceSq === Infinity)
    return null;
  const closestDistance = Math.sqrt(closestDistanceSq);
  if (!target.point)
    target.point = temp1$22.clone();
  else
    target.point.copy(temp1$22);
  target.distance = closestDistance, target.faceIndex = closestDistanceTriIndex;
  return target;
}
var _vA2 = new Vector3();
var _vB2 = new Vector3();
var _vC2 = new Vector3();
var _uvA2 = new Vector2();
var _uvB2 = new Vector2();
var _uvC2 = new Vector2();
var _normalA2 = new Vector3();
var _normalB2 = new Vector3();
var _normalC2 = new Vector3();
var _intersectionPoint2 = new Vector3();
function checkIntersection2(ray22, pA, pB, pC, point, side) {
  let intersect;
  if (side === BackSide) {
    intersect = ray22.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray22.intersectTriangle(pA, pB, pC, side !== DoubleSide, point);
  }
  if (intersect === null)
    return null;
  const distance = ray22.origin.distanceTo(point);
  return {
    distance,
    point: point.clone()
  };
}
function checkBufferGeometryIntersection2(ray22, position, normal, uv, uv1, a, b, c, side) {
  _vA2.fromBufferAttribute(position, a);
  _vB2.fromBufferAttribute(position, b);
  _vC2.fromBufferAttribute(position, c);
  const intersection = checkIntersection2(ray22, _vA2, _vB2, _vC2, _intersectionPoint2, side);
  if (intersection) {
    if (uv) {
      _uvA2.fromBufferAttribute(uv, a);
      _uvB2.fromBufferAttribute(uv, b);
      _uvC2.fromBufferAttribute(uv, c);
      intersection.uv = Triangle.getInterpolation(_intersectionPoint2, _vA2, _vB2, _vC2, _uvA2, _uvB2, _uvC2, new Vector2());
    }
    if (uv1) {
      _uvA2.fromBufferAttribute(uv1, a);
      _uvB2.fromBufferAttribute(uv1, b);
      _uvC2.fromBufferAttribute(uv1, c);
      intersection.uv1 = Triangle.getInterpolation(_intersectionPoint2, _vA2, _vB2, _vC2, _uvA2, _uvB2, _uvC2, new Vector2());
    }
    if (normal) {
      _normalA2.fromBufferAttribute(normal, a);
      _normalB2.fromBufferAttribute(normal, b);
      _normalC2.fromBufferAttribute(normal, c);
      intersection.normal = Triangle.getInterpolation(_intersectionPoint2, _vA2, _vB2, _vC2, _normalA2, _normalB2, _normalC2, new Vector3());
      if (intersection.normal.dot(ray22.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
    }
    const face = {
      a,
      b,
      c,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA2, _vB2, _vC2, face.normal);
    intersection.face = face;
    intersection.faceIndex = a;
  }
  return intersection;
}
function intersectTri2(geo, side, ray22, tri, intersections) {
  const triOffset = tri * 3;
  let a = triOffset + 0;
  let b = triOffset + 1;
  let c = triOffset + 2;
  const index = geo.index;
  if (geo.index) {
    a = index.getX(a);
    b = index.getX(b);
    c = index.getX(c);
  }
  const { position, normal, uv, uv1 } = geo.attributes;
  const intersection = checkBufferGeometryIntersection2(ray22, position, normal, uv, uv1, a, b, c, side);
  if (intersection) {
    intersection.faceIndex = tri;
    if (intersections)
      intersections.push(intersection);
    return intersection;
  }
  return null;
}
function setTriangle2(tri, i, index, pos) {
  const ta = tri.a;
  const tb = tri.b;
  const tc = tri.c;
  let i0 = i;
  let i1 = i + 1;
  let i2 = i + 2;
  if (index) {
    i0 = index.getX(i0);
    i1 = index.getX(i1);
    i2 = index.getX(i2);
  }
  ta.x = pos.getX(i0);
  ta.y = pos.getY(i0);
  ta.z = pos.getZ(i0);
  tb.x = pos.getX(i1);
  tb.y = pos.getY(i1);
  tb.z = pos.getZ(i1);
  tc.x = pos.getX(i2);
  tc.y = pos.getY(i2);
  tc.z = pos.getZ(i2);
}
function intersectTris2(bvh, side, ray22, offset, count, intersections) {
  const { geometry, _indirectBuffer } = bvh;
  for (let i = offset, end = offset + count; i < end; i++) {
    intersectTri2(geometry, side, ray22, i, intersections);
  }
}
function intersectClosestTri2(bvh, side, ray22, offset, count) {
  const { geometry, _indirectBuffer } = bvh;
  let dist = Infinity;
  let res = null;
  for (let i = offset, end = offset + count; i < end; i++) {
    let intersection;
    intersection = intersectTri2(geometry, side, ray22, i);
    if (intersection && intersection.distance < dist) {
      res = intersection;
      dist = intersection.distance;
    }
  }
  return res;
}
function iterateOverTriangles2(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle32) {
  const { geometry } = bvh;
  const { index } = geometry;
  const pos = geometry.attributes.position;
  for (let i = offset, l = count + offset; i < l; i++) {
    let tri;
    tri = i;
    setTriangle2(triangle32, tri * 3, index, pos);
    triangle32.needsUpdate = true;
    if (intersectsTriangleFunc(triangle32, tri, contained, depth)) {
      return true;
    }
  }
  return false;
}
function refit2(bvh, nodeIndices = null) {
  if (nodeIndices && Array.isArray(nodeIndices)) {
    nodeIndices = new Set(nodeIndices);
  }
  const geometry = bvh.geometry;
  const indexArr = geometry.index ? geometry.index.array : null;
  const posAttr = geometry.attributes.position;
  let buffer, uint32Array, uint16Array, float32Array;
  let byteOffset = 0;
  const roots = bvh._roots;
  for (let i = 0, l = roots.length; i < l; i++) {
    buffer = roots[i];
    uint32Array = new Uint32Array(buffer);
    uint16Array = new Uint16Array(buffer);
    float32Array = new Float32Array(buffer);
    _traverse22(0, byteOffset);
    byteOffset += buffer.byteLength;
  }
  function _traverse22(node32Index, byteOffset2, force = false) {
    const node16Index = node32Index * 2;
    const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG2;
    if (isLeaf) {
      const offset = uint32Array[node32Index + 6];
      const count = uint16Array[node16Index + 14];
      let minx = Infinity;
      let miny = Infinity;
      let minz = Infinity;
      let maxx = -Infinity;
      let maxy = -Infinity;
      let maxz = -Infinity;
      for (let i = 3 * offset, l = 3 * (offset + count); i < l; i++) {
        let index = indexArr[i];
        const x = posAttr.getX(index);
        const y = posAttr.getY(index);
        const z = posAttr.getZ(index);
        if (x < minx)
          minx = x;
        if (x > maxx)
          maxx = x;
        if (y < miny)
          miny = y;
        if (y > maxy)
          maxy = y;
        if (z < minz)
          minz = z;
        if (z > maxz)
          maxz = z;
      }
      if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {
        float32Array[node32Index + 0] = minx;
        float32Array[node32Index + 1] = miny;
        float32Array[node32Index + 2] = minz;
        float32Array[node32Index + 3] = maxx;
        float32Array[node32Index + 4] = maxy;
        float32Array[node32Index + 5] = maxz;
        return true;
      } else {
        return false;
      }
    } else {
      const left = node32Index + 8;
      const right = uint32Array[node32Index + 6];
      const offsetLeft = left + byteOffset2;
      const offsetRight = right + byteOffset2;
      let forceChildren = force;
      let includesLeft = false;
      let includesRight = false;
      if (nodeIndices) {
        if (!forceChildren) {
          includesLeft = nodeIndices.has(offsetLeft);
          includesRight = nodeIndices.has(offsetRight);
          forceChildren = !includesLeft && !includesRight;
        }
      } else {
        includesLeft = true;
        includesRight = true;
      }
      const traverseLeft = forceChildren || includesLeft;
      const traverseRight = forceChildren || includesRight;
      let leftChange = false;
      if (traverseLeft) {
        leftChange = _traverse22(left, byteOffset2, forceChildren);
      }
      let rightChange = false;
      if (traverseRight) {
        rightChange = _traverse22(right, byteOffset2, forceChildren);
      }
      const didChange = leftChange || rightChange;
      if (didChange) {
        for (let i = 0; i < 3; i++) {
          const lefti = left + i;
          const righti = right + i;
          const minLeftValue = float32Array[lefti];
          const maxLeftValue = float32Array[lefti + 3];
          const minRightValue = float32Array[righti];
          const maxRightValue = float32Array[righti + 3];
          float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;
          float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;
        }
      }
      return didChange;
    }
  }
}
var _boundingBox2 = new Box3();
function intersectRay2(nodeIndex32, array, ray22, target) {
  arrayToBox2(nodeIndex32, array, _boundingBox2);
  return ray22.intersectBox(_boundingBox2, target);
}
function intersectTris_indirect2(bvh, side, ray22, offset, count, intersections) {
  const { geometry, _indirectBuffer } = bvh;
  for (let i = offset, end = offset + count; i < end; i++) {
    let vi = _indirectBuffer ? _indirectBuffer[i] : i;
    intersectTri2(geometry, side, ray22, vi, intersections);
  }
}
function intersectClosestTri_indirect2(bvh, side, ray22, offset, count) {
  const { geometry, _indirectBuffer } = bvh;
  let dist = Infinity;
  let res = null;
  for (let i = offset, end = offset + count; i < end; i++) {
    let intersection;
    intersection = intersectTri2(geometry, side, ray22, _indirectBuffer ? _indirectBuffer[i] : i);
    if (intersection && intersection.distance < dist) {
      res = intersection;
      dist = intersection.distance;
    }
  }
  return res;
}
function iterateOverTriangles_indirect2(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle32) {
  const { geometry } = bvh;
  const { index } = geometry;
  const pos = geometry.attributes.position;
  for (let i = offset, l = count + offset; i < l; i++) {
    let tri;
    tri = bvh.resolveTriangleIndex(i);
    setTriangle2(triangle32, tri * 3, index, pos);
    triangle32.needsUpdate = true;
    if (intersectsTriangleFunc(triangle32, tri, contained, depth)) {
      return true;
    }
  }
  return false;
}
var _boxIntersection$32 = new Vector3();
function raycast2(bvh, root, side, ray22, intersects2) {
  BufferStack2.setBuffer(bvh._roots[root]);
  _raycast$12(0, bvh, side, ray22, intersects2);
  BufferStack2.clearBuffer();
}
function _raycast$12(nodeIndex32, bvh, side, ray22, intersects2) {
  const { float32Array, uint16Array, uint32Array } = BufferStack2;
  const nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF2(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET2(nodeIndex32, uint32Array);
    const count = COUNT2(nodeIndex16, uint16Array);
    intersectTris2(bvh, side, ray22, offset, count, intersects2);
  } else {
    const leftIndex = LEFT_NODE2(nodeIndex32);
    if (intersectRay2(leftIndex, float32Array, ray22, _boxIntersection$32)) {
      _raycast$12(leftIndex, bvh, side, ray22, intersects2);
    }
    const rightIndex = RIGHT_NODE2(nodeIndex32, uint32Array);
    if (intersectRay2(rightIndex, float32Array, ray22, _boxIntersection$32)) {
      _raycast$12(rightIndex, bvh, side, ray22, intersects2);
    }
  }
}
var _boxIntersection$22 = new Vector3();
var _xyzFields$12 = ["x", "y", "z"];
function raycastFirst2(bvh, root, side, ray22) {
  BufferStack2.setBuffer(bvh._roots[root]);
  const result = _raycastFirst$12(0, bvh, side, ray22);
  BufferStack2.clearBuffer();
  return result;
}
function _raycastFirst$12(nodeIndex32, bvh, side, ray22) {
  const { float32Array, uint16Array, uint32Array } = BufferStack2;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF2(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET2(nodeIndex32, uint32Array);
    const count = COUNT2(nodeIndex16, uint16Array);
    return intersectClosestTri2(bvh, side, ray22, offset, count);
  } else {
    const splitAxis = SPLIT_AXIS2(nodeIndex32, uint32Array);
    const xyzAxis = _xyzFields$12[splitAxis];
    const rayDir = ray22.direction[xyzAxis];
    const leftToRight = rayDir >= 0;
    let c1, c2;
    if (leftToRight) {
      c1 = LEFT_NODE2(nodeIndex32);
      c2 = RIGHT_NODE2(nodeIndex32, uint32Array);
    } else {
      c1 = RIGHT_NODE2(nodeIndex32, uint32Array);
      c2 = LEFT_NODE2(nodeIndex32);
    }
    const c1Intersection = intersectRay2(c1, float32Array, ray22, _boxIntersection$22);
    const c1Result = c1Intersection ? _raycastFirst$12(c1, bvh, side, ray22) : null;
    if (c1Result) {
      const point = c1Result.point[xyzAxis];
      const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : (
        // min bounding data
        point >= float32Array[c2 + splitAxis + 3]
      );
      if (isOutside) {
        return c1Result;
      }
    }
    const c2Intersection = intersectRay2(c2, float32Array, ray22, _boxIntersection$22);
    const c2Result = c2Intersection ? _raycastFirst$12(c2, bvh, side, ray22) : null;
    if (c1Result && c2Result) {
      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;
    } else {
      return c1Result || c2Result || null;
    }
  }
}
var boundingBox$12 = new Box3();
var triangle$12 = new ExtendedTriangle2();
var triangle2$12 = new ExtendedTriangle2();
var invertedMat$12 = new Matrix4();
var obb$42 = new OrientedBox2();
var obb2$32 = new OrientedBox2();
function intersectsGeometry2(bvh, root, otherGeometry, geometryToBvh) {
  BufferStack2.setBuffer(bvh._roots[root]);
  const result = _intersectsGeometry$12(0, bvh, otherGeometry, geometryToBvh);
  BufferStack2.clearBuffer();
  return result;
}
function _intersectsGeometry$12(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {
  const { float32Array, uint16Array, uint32Array } = BufferStack2;
  let nodeIndex16 = nodeIndex32 * 2;
  if (cachedObb === null) {
    if (!otherGeometry.boundingBox) {
      otherGeometry.computeBoundingBox();
    }
    obb$42.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
    cachedObb = obb$42;
  }
  const isLeaf = IS_LEAF2(nodeIndex16, uint16Array);
  if (isLeaf) {
    const thisGeometry = bvh.geometry;
    const thisIndex = thisGeometry.index;
    const thisPos = thisGeometry.attributes.position;
    const index = otherGeometry.index;
    const pos = otherGeometry.attributes.position;
    const offset = OFFSET2(nodeIndex32, uint32Array);
    const count = COUNT2(nodeIndex16, uint16Array);
    invertedMat$12.copy(geometryToBvh).invert();
    if (otherGeometry.boundsTree) {
      arrayToBox2(BOUNDING_DATA_INDEX2(nodeIndex32), float32Array, obb2$32);
      obb2$32.matrix.copy(invertedMat$12);
      obb2$32.needsUpdate = true;
      const res = otherGeometry.boundsTree.shapecast({
        intersectsBounds: (box) => obb2$32.intersectsBox(box),
        intersectsTriangle: (tri) => {
          tri.a.applyMatrix4(geometryToBvh);
          tri.b.applyMatrix4(geometryToBvh);
          tri.c.applyMatrix4(geometryToBvh);
          tri.needsUpdate = true;
          for (let i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {
            setTriangle2(triangle2$12, i, thisIndex, thisPos);
            triangle2$12.needsUpdate = true;
            if (tri.intersectsTriangle(triangle2$12)) {
              return true;
            }
          }
          return false;
        }
      });
      return res;
    } else {
      for (let i = offset * 3, l = (count + offset) * 3; i < l; i += 3) {
        setTriangle2(triangle$12, i, thisIndex, thisPos);
        triangle$12.a.applyMatrix4(invertedMat$12);
        triangle$12.b.applyMatrix4(invertedMat$12);
        triangle$12.c.applyMatrix4(invertedMat$12);
        triangle$12.needsUpdate = true;
        for (let i2 = 0, l2 = index.count; i2 < l2; i2 += 3) {
          setTriangle2(triangle2$12, i2, index, pos);
          triangle2$12.needsUpdate = true;
          if (triangle$12.intersectsTriangle(triangle2$12)) {
            return true;
          }
        }
      }
    }
  } else {
    const left = nodeIndex32 + 8;
    const right = uint32Array[nodeIndex32 + 6];
    arrayToBox2(BOUNDING_DATA_INDEX2(left), float32Array, boundingBox$12);
    const leftIntersection = cachedObb.intersectsBox(boundingBox$12) && _intersectsGeometry$12(left, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (leftIntersection)
      return true;
    arrayToBox2(BOUNDING_DATA_INDEX2(right), float32Array, boundingBox$12);
    const rightIntersection = cachedObb.intersectsBox(boundingBox$12) && _intersectsGeometry$12(right, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (rightIntersection)
      return true;
    return false;
  }
}
var tempMatrix$12 = new Matrix4();
var obb$32 = new OrientedBox2();
var obb2$22 = new OrientedBox2();
var temp1$12 = new Vector3();
var temp2$12 = new Vector3();
var temp3$12 = new Vector3();
var temp4$12 = new Vector3();
function closestPointToGeometry2(bvh, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
  if (!otherGeometry.boundingBox) {
    otherGeometry.computeBoundingBox();
  }
  obb$32.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
  obb$32.needsUpdate = true;
  const geometry = bvh.geometry;
  const pos = geometry.attributes.position;
  const index = geometry.index;
  const otherPos = otherGeometry.attributes.position;
  const otherIndex = otherGeometry.index;
  const triangle32 = ExtendedTrianglePool2.getPrimitive();
  const triangle222 = ExtendedTrianglePool2.getPrimitive();
  let tempTarget1 = temp1$12;
  let tempTargetDest1 = temp2$12;
  let tempTarget2 = null;
  let tempTargetDest2 = null;
  if (target2) {
    tempTarget2 = temp3$12;
    tempTargetDest2 = temp4$12;
  }
  let closestDistance = Infinity;
  let closestDistanceTriIndex = null;
  let closestDistanceOtherTriIndex = null;
  tempMatrix$12.copy(geometryToBvh).invert();
  obb2$22.matrix.copy(tempMatrix$12);
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        return obb$32.distanceToBox(box);
      },
      intersectsBounds: (box, isLeaf, score) => {
        if (score < closestDistance && score < maxThreshold) {
          if (isLeaf) {
            obb2$22.min.copy(box.min);
            obb2$22.max.copy(box.max);
            obb2$22.needsUpdate = true;
          }
          return true;
        }
        return false;
      },
      intersectsRange: (offset, count) => {
        if (otherGeometry.boundsTree) {
          const otherBvh = otherGeometry.boundsTree;
          return otherBvh.shapecast({
            boundsTraverseOrder: (box) => {
              return obb2$22.distanceToBox(box);
            },
            intersectsBounds: (box, isLeaf, score) => {
              return score < closestDistance && score < maxThreshold;
            },
            intersectsRange: (otherOffset, otherCount) => {
              for (let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++) {
                setTriangle2(triangle222, 3 * i2, otherIndex, otherPos);
                triangle222.a.applyMatrix4(geometryToBvh);
                triangle222.b.applyMatrix4(geometryToBvh);
                triangle222.c.applyMatrix4(geometryToBvh);
                triangle222.needsUpdate = true;
                for (let i = offset, l = offset + count; i < l; i++) {
                  setTriangle2(triangle32, 3 * i, index, pos);
                  triangle32.needsUpdate = true;
                  const dist = triangle32.distanceToTriangle(triangle222, tempTarget1, tempTarget2);
                  if (dist < closestDistance) {
                    tempTargetDest1.copy(tempTarget1);
                    if (tempTargetDest2) {
                      tempTargetDest2.copy(tempTarget2);
                    }
                    closestDistance = dist;
                    closestDistanceTriIndex = i;
                    closestDistanceOtherTriIndex = i2;
                  }
                  if (dist < minThreshold) {
                    return true;
                  }
                }
              }
            }
          });
        } else {
          const triCount = getTriCount2(otherGeometry);
          for (let i2 = 0, l2 = triCount; i2 < l2; i2++) {
            setTriangle2(triangle222, 3 * i2, otherIndex, otherPos);
            triangle222.a.applyMatrix4(geometryToBvh);
            triangle222.b.applyMatrix4(geometryToBvh);
            triangle222.c.applyMatrix4(geometryToBvh);
            triangle222.needsUpdate = true;
            for (let i = offset, l = offset + count; i < l; i++) {
              setTriangle2(triangle32, 3 * i, index, pos);
              triangle32.needsUpdate = true;
              const dist = triangle32.distanceToTriangle(triangle222, tempTarget1, tempTarget2);
              if (dist < closestDistance) {
                tempTargetDest1.copy(tempTarget1);
                if (tempTargetDest2) {
                  tempTargetDest2.copy(tempTarget2);
                }
                closestDistance = dist;
                closestDistanceTriIndex = i;
                closestDistanceOtherTriIndex = i2;
              }
              if (dist < minThreshold) {
                return true;
              }
            }
          }
        }
      }
    }
  );
  ExtendedTrianglePool2.releasePrimitive(triangle32);
  ExtendedTrianglePool2.releasePrimitive(triangle222);
  if (closestDistance === Infinity) {
    return null;
  }
  if (!target1.point) {
    target1.point = tempTargetDest1.clone();
  } else {
    target1.point.copy(tempTargetDest1);
  }
  target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;
  if (target2) {
    if (!target2.point)
      target2.point = tempTargetDest2.clone();
    else
      target2.point.copy(tempTargetDest2);
    target2.point.applyMatrix4(tempMatrix$12);
    tempTargetDest1.applyMatrix4(tempMatrix$12);
    target2.distance = tempTargetDest1.sub(target2.point).length();
    target2.faceIndex = closestDistanceOtherTriIndex;
  }
  return target1;
}
function refit_indirect2(bvh, nodeIndices = null) {
  if (nodeIndices && Array.isArray(nodeIndices)) {
    nodeIndices = new Set(nodeIndices);
  }
  const geometry = bvh.geometry;
  const indexArr = geometry.index ? geometry.index.array : null;
  const posAttr = geometry.attributes.position;
  let buffer, uint32Array, uint16Array, float32Array;
  let byteOffset = 0;
  const roots = bvh._roots;
  for (let i = 0, l = roots.length; i < l; i++) {
    buffer = roots[i];
    uint32Array = new Uint32Array(buffer);
    uint16Array = new Uint16Array(buffer);
    float32Array = new Float32Array(buffer);
    _traverse22(0, byteOffset);
    byteOffset += buffer.byteLength;
  }
  function _traverse22(node32Index, byteOffset2, force = false) {
    const node16Index = node32Index * 2;
    const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG2;
    if (isLeaf) {
      const offset = uint32Array[node32Index + 6];
      const count = uint16Array[node16Index + 14];
      let minx = Infinity;
      let miny = Infinity;
      let minz = Infinity;
      let maxx = -Infinity;
      let maxy = -Infinity;
      let maxz = -Infinity;
      for (let i = offset, l = offset + count; i < l; i++) {
        const t = 3 * bvh.resolveTriangleIndex(i);
        for (let j = 0; j < 3; j++) {
          let index = t + j;
          index = indexArr ? indexArr[index] : index;
          const x = posAttr.getX(index);
          const y = posAttr.getY(index);
          const z = posAttr.getZ(index);
          if (x < minx)
            minx = x;
          if (x > maxx)
            maxx = x;
          if (y < miny)
            miny = y;
          if (y > maxy)
            maxy = y;
          if (z < minz)
            minz = z;
          if (z > maxz)
            maxz = z;
        }
      }
      if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {
        float32Array[node32Index + 0] = minx;
        float32Array[node32Index + 1] = miny;
        float32Array[node32Index + 2] = minz;
        float32Array[node32Index + 3] = maxx;
        float32Array[node32Index + 4] = maxy;
        float32Array[node32Index + 5] = maxz;
        return true;
      } else {
        return false;
      }
    } else {
      const left = node32Index + 8;
      const right = uint32Array[node32Index + 6];
      const offsetLeft = left + byteOffset2;
      const offsetRight = right + byteOffset2;
      let forceChildren = force;
      let includesLeft = false;
      let includesRight = false;
      if (nodeIndices) {
        if (!forceChildren) {
          includesLeft = nodeIndices.has(offsetLeft);
          includesRight = nodeIndices.has(offsetRight);
          forceChildren = !includesLeft && !includesRight;
        }
      } else {
        includesLeft = true;
        includesRight = true;
      }
      const traverseLeft = forceChildren || includesLeft;
      const traverseRight = forceChildren || includesRight;
      let leftChange = false;
      if (traverseLeft) {
        leftChange = _traverse22(left, byteOffset2, forceChildren);
      }
      let rightChange = false;
      if (traverseRight) {
        rightChange = _traverse22(right, byteOffset2, forceChildren);
      }
      const didChange = leftChange || rightChange;
      if (didChange) {
        for (let i = 0; i < 3; i++) {
          const lefti = left + i;
          const righti = right + i;
          const minLeftValue = float32Array[lefti];
          const maxLeftValue = float32Array[lefti + 3];
          const minRightValue = float32Array[righti];
          const maxRightValue = float32Array[righti + 3];
          float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;
          float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;
        }
      }
      return didChange;
    }
  }
}
var _boxIntersection$12 = new Vector3();
function raycast_indirect2(bvh, root, side, ray22, intersects2) {
  BufferStack2.setBuffer(bvh._roots[root]);
  _raycast2(0, bvh, side, ray22, intersects2);
  BufferStack2.clearBuffer();
}
function _raycast2(nodeIndex32, bvh, side, ray22, intersects2) {
  const { float32Array, uint16Array, uint32Array } = BufferStack2;
  const nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF2(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET2(nodeIndex32, uint32Array);
    const count = COUNT2(nodeIndex16, uint16Array);
    intersectTris_indirect2(bvh, side, ray22, offset, count, intersects2);
  } else {
    const leftIndex = LEFT_NODE2(nodeIndex32);
    if (intersectRay2(leftIndex, float32Array, ray22, _boxIntersection$12)) {
      _raycast2(leftIndex, bvh, side, ray22, intersects2);
    }
    const rightIndex = RIGHT_NODE2(nodeIndex32, uint32Array);
    if (intersectRay2(rightIndex, float32Array, ray22, _boxIntersection$12)) {
      _raycast2(rightIndex, bvh, side, ray22, intersects2);
    }
  }
}
var _boxIntersection2 = new Vector3();
var _xyzFields2 = ["x", "y", "z"];
function raycastFirst_indirect2(bvh, root, side, ray22) {
  BufferStack2.setBuffer(bvh._roots[root]);
  const result = _raycastFirst2(0, bvh, side, ray22);
  BufferStack2.clearBuffer();
  return result;
}
function _raycastFirst2(nodeIndex32, bvh, side, ray22) {
  const { float32Array, uint16Array, uint32Array } = BufferStack2;
  let nodeIndex16 = nodeIndex32 * 2;
  const isLeaf = IS_LEAF2(nodeIndex16, uint16Array);
  if (isLeaf) {
    const offset = OFFSET2(nodeIndex32, uint32Array);
    const count = COUNT2(nodeIndex16, uint16Array);
    return intersectClosestTri_indirect2(bvh, side, ray22, offset, count);
  } else {
    const splitAxis = SPLIT_AXIS2(nodeIndex32, uint32Array);
    const xyzAxis = _xyzFields2[splitAxis];
    const rayDir = ray22.direction[xyzAxis];
    const leftToRight = rayDir >= 0;
    let c1, c2;
    if (leftToRight) {
      c1 = LEFT_NODE2(nodeIndex32);
      c2 = RIGHT_NODE2(nodeIndex32, uint32Array);
    } else {
      c1 = RIGHT_NODE2(nodeIndex32, uint32Array);
      c2 = LEFT_NODE2(nodeIndex32);
    }
    const c1Intersection = intersectRay2(c1, float32Array, ray22, _boxIntersection2);
    const c1Result = c1Intersection ? _raycastFirst2(c1, bvh, side, ray22) : null;
    if (c1Result) {
      const point = c1Result.point[xyzAxis];
      const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : (
        // min bounding data
        point >= float32Array[c2 + splitAxis + 3]
      );
      if (isOutside) {
        return c1Result;
      }
    }
    const c2Intersection = intersectRay2(c2, float32Array, ray22, _boxIntersection2);
    const c2Result = c2Intersection ? _raycastFirst2(c2, bvh, side, ray22) : null;
    if (c1Result && c2Result) {
      return c1Result.distance <= c2Result.distance ? c1Result : c2Result;
    } else {
      return c1Result || c2Result || null;
    }
  }
}
var boundingBox2 = new Box3();
var triangle3 = new ExtendedTriangle2();
var triangle22 = new ExtendedTriangle2();
var invertedMat2 = new Matrix4();
var obb$22 = new OrientedBox2();
var obb2$12 = new OrientedBox2();
function intersectsGeometry_indirect2(bvh, root, otherGeometry, geometryToBvh) {
  BufferStack2.setBuffer(bvh._roots[root]);
  const result = _intersectsGeometry2(0, bvh, otherGeometry, geometryToBvh);
  BufferStack2.clearBuffer();
  return result;
}
function _intersectsGeometry2(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {
  const { float32Array, uint16Array, uint32Array } = BufferStack2;
  let nodeIndex16 = nodeIndex32 * 2;
  if (cachedObb === null) {
    if (!otherGeometry.boundingBox) {
      otherGeometry.computeBoundingBox();
    }
    obb$22.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
    cachedObb = obb$22;
  }
  const isLeaf = IS_LEAF2(nodeIndex16, uint16Array);
  if (isLeaf) {
    const thisGeometry = bvh.geometry;
    const thisIndex = thisGeometry.index;
    const thisPos = thisGeometry.attributes.position;
    const index = otherGeometry.index;
    const pos = otherGeometry.attributes.position;
    const offset = OFFSET2(nodeIndex32, uint32Array);
    const count = COUNT2(nodeIndex16, uint16Array);
    invertedMat2.copy(geometryToBvh).invert();
    if (otherGeometry.boundsTree) {
      arrayToBox2(BOUNDING_DATA_INDEX2(nodeIndex32), float32Array, obb2$12);
      obb2$12.matrix.copy(invertedMat2);
      obb2$12.needsUpdate = true;
      const res = otherGeometry.boundsTree.shapecast({
        intersectsBounds: (box) => obb2$12.intersectsBox(box),
        intersectsTriangle: (tri) => {
          tri.a.applyMatrix4(geometryToBvh);
          tri.b.applyMatrix4(geometryToBvh);
          tri.c.applyMatrix4(geometryToBvh);
          tri.needsUpdate = true;
          for (let i = offset, l = count + offset; i < l; i++) {
            setTriangle2(triangle22, 3 * bvh.resolveTriangleIndex(i), thisIndex, thisPos);
            triangle22.needsUpdate = true;
            if (tri.intersectsTriangle(triangle22)) {
              return true;
            }
          }
          return false;
        }
      });
      return res;
    } else {
      for (let i = offset, l = count + offset; i < l; i++) {
        const ti = bvh.resolveTriangleIndex(i);
        setTriangle2(triangle3, 3 * ti, thisIndex, thisPos);
        triangle3.a.applyMatrix4(invertedMat2);
        triangle3.b.applyMatrix4(invertedMat2);
        triangle3.c.applyMatrix4(invertedMat2);
        triangle3.needsUpdate = true;
        for (let i2 = 0, l2 = index.count; i2 < l2; i2 += 3) {
          setTriangle2(triangle22, i2, index, pos);
          triangle22.needsUpdate = true;
          if (triangle3.intersectsTriangle(triangle22)) {
            return true;
          }
        }
      }
    }
  } else {
    const left = nodeIndex32 + 8;
    const right = uint32Array[nodeIndex32 + 6];
    arrayToBox2(BOUNDING_DATA_INDEX2(left), float32Array, boundingBox2);
    const leftIntersection = cachedObb.intersectsBox(boundingBox2) && _intersectsGeometry2(left, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (leftIntersection)
      return true;
    arrayToBox2(BOUNDING_DATA_INDEX2(right), float32Array, boundingBox2);
    const rightIntersection = cachedObb.intersectsBox(boundingBox2) && _intersectsGeometry2(right, bvh, otherGeometry, geometryToBvh, cachedObb);
    if (rightIntersection)
      return true;
    return false;
  }
}
var tempMatrix2 = new Matrix4();
var obb$12 = new OrientedBox2();
var obb22 = new OrientedBox2();
var temp12 = new Vector3();
var temp22 = new Vector3();
var temp32 = new Vector3();
var temp42 = new Vector3();
function closestPointToGeometry_indirect2(bvh, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
  if (!otherGeometry.boundingBox) {
    otherGeometry.computeBoundingBox();
  }
  obb$12.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);
  obb$12.needsUpdate = true;
  const geometry = bvh.geometry;
  const pos = geometry.attributes.position;
  const index = geometry.index;
  const otherPos = otherGeometry.attributes.position;
  const otherIndex = otherGeometry.index;
  const triangle32 = ExtendedTrianglePool2.getPrimitive();
  const triangle222 = ExtendedTrianglePool2.getPrimitive();
  let tempTarget1 = temp12;
  let tempTargetDest1 = temp22;
  let tempTarget2 = null;
  let tempTargetDest2 = null;
  if (target2) {
    tempTarget2 = temp32;
    tempTargetDest2 = temp42;
  }
  let closestDistance = Infinity;
  let closestDistanceTriIndex = null;
  let closestDistanceOtherTriIndex = null;
  tempMatrix2.copy(geometryToBvh).invert();
  obb22.matrix.copy(tempMatrix2);
  bvh.shapecast(
    {
      boundsTraverseOrder: (box) => {
        return obb$12.distanceToBox(box);
      },
      intersectsBounds: (box, isLeaf, score) => {
        if (score < closestDistance && score < maxThreshold) {
          if (isLeaf) {
            obb22.min.copy(box.min);
            obb22.max.copy(box.max);
            obb22.needsUpdate = true;
          }
          return true;
        }
        return false;
      },
      intersectsRange: (offset, count) => {
        if (otherGeometry.boundsTree) {
          const otherBvh = otherGeometry.boundsTree;
          return otherBvh.shapecast({
            boundsTraverseOrder: (box) => {
              return obb22.distanceToBox(box);
            },
            intersectsBounds: (box, isLeaf, score) => {
              return score < closestDistance && score < maxThreshold;
            },
            intersectsRange: (otherOffset, otherCount) => {
              for (let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++) {
                const ti2 = otherBvh.resolveTriangleIndex(i2);
                setTriangle2(triangle222, 3 * ti2, otherIndex, otherPos);
                triangle222.a.applyMatrix4(geometryToBvh);
                triangle222.b.applyMatrix4(geometryToBvh);
                triangle222.c.applyMatrix4(geometryToBvh);
                triangle222.needsUpdate = true;
                for (let i = offset, l = offset + count; i < l; i++) {
                  const ti = bvh.resolveTriangleIndex(i);
                  setTriangle2(triangle32, 3 * ti, index, pos);
                  triangle32.needsUpdate = true;
                  const dist = triangle32.distanceToTriangle(triangle222, tempTarget1, tempTarget2);
                  if (dist < closestDistance) {
                    tempTargetDest1.copy(tempTarget1);
                    if (tempTargetDest2) {
                      tempTargetDest2.copy(tempTarget2);
                    }
                    closestDistance = dist;
                    closestDistanceTriIndex = i;
                    closestDistanceOtherTriIndex = i2;
                  }
                  if (dist < minThreshold) {
                    return true;
                  }
                }
              }
            }
          });
        } else {
          const triCount = getTriCount2(otherGeometry);
          for (let i2 = 0, l2 = triCount; i2 < l2; i2++) {
            setTriangle2(triangle222, 3 * i2, otherIndex, otherPos);
            triangle222.a.applyMatrix4(geometryToBvh);
            triangle222.b.applyMatrix4(geometryToBvh);
            triangle222.c.applyMatrix4(geometryToBvh);
            triangle222.needsUpdate = true;
            for (let i = offset, l = offset + count; i < l; i++) {
              const ti = bvh.resolveTriangleIndex(i);
              setTriangle2(triangle32, 3 * ti, index, pos);
              triangle32.needsUpdate = true;
              const dist = triangle32.distanceToTriangle(triangle222, tempTarget1, tempTarget2);
              if (dist < closestDistance) {
                tempTargetDest1.copy(tempTarget1);
                if (tempTargetDest2) {
                  tempTargetDest2.copy(tempTarget2);
                }
                closestDistance = dist;
                closestDistanceTriIndex = i;
                closestDistanceOtherTriIndex = i2;
              }
              if (dist < minThreshold) {
                return true;
              }
            }
          }
        }
      }
    }
  );
  ExtendedTrianglePool2.releasePrimitive(triangle32);
  ExtendedTrianglePool2.releasePrimitive(triangle222);
  if (closestDistance === Infinity) {
    return null;
  }
  if (!target1.point) {
    target1.point = tempTargetDest1.clone();
  } else {
    target1.point.copy(tempTargetDest1);
  }
  target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;
  if (target2) {
    if (!target2.point)
      target2.point = tempTargetDest2.clone();
    else
      target2.point.copy(tempTargetDest2);
    target2.point.applyMatrix4(tempMatrix2);
    tempTargetDest1.applyMatrix4(tempMatrix2);
    target2.distance = tempTargetDest1.sub(target2.point).length();
    target2.faceIndex = closestDistanceOtherTriIndex;
  }
  return target1;
}
function isSharedArrayBufferSupported2() {
  return typeof SharedArrayBuffer !== "undefined";
}
var _bufferStack12 = new BufferStack2.constructor();
var _bufferStack22 = new BufferStack2.constructor();
var _boxPool2 = new PrimitivePool2(() => new Box3());
var _leftBox12 = new Box3();
var _rightBox12 = new Box3();
var _leftBox22 = new Box3();
var _rightBox22 = new Box3();
var _active2 = false;
function bvhcast2(bvh, otherBvh, matrixToLocal, intersectsRanges) {
  if (_active2) {
    throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");
  }
  _active2 = true;
  const roots = bvh._roots;
  const otherRoots = otherBvh._roots;
  let result;
  let offset1 = 0;
  let offset2 = 0;
  const invMat = new Matrix4().copy(matrixToLocal).invert();
  for (let i = 0, il = roots.length; i < il; i++) {
    _bufferStack12.setBuffer(roots[i]);
    offset2 = 0;
    const localBox = _boxPool2.getPrimitive();
    arrayToBox2(BOUNDING_DATA_INDEX2(0), _bufferStack12.float32Array, localBox);
    localBox.applyMatrix4(invMat);
    for (let j = 0, jl = otherRoots.length; j < jl; j++) {
      _bufferStack22.setBuffer(otherRoots[i]);
      result = _traverse2(
        0,
        0,
        matrixToLocal,
        invMat,
        intersectsRanges,
        offset1,
        offset2,
        0,
        0,
        localBox
      );
      _bufferStack22.clearBuffer();
      offset2 += otherRoots[j].length;
      if (result) {
        break;
      }
    }
    _boxPool2.releasePrimitive(localBox);
    _bufferStack12.clearBuffer();
    offset1 += roots[i].length;
    if (result) {
      break;
    }
  }
  _active2 = false;
  return result;
}
function _traverse2(node1Index32, node2Index32, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset = 0, node2IndexByteOffset = 0, depth1 = 0, depth2 = 0, currBox = null, reversed = false) {
  let bufferStack1, bufferStack2;
  if (reversed) {
    bufferStack1 = _bufferStack22;
    bufferStack2 = _bufferStack12;
  } else {
    bufferStack1 = _bufferStack12;
    bufferStack2 = _bufferStack22;
  }
  const float32Array1 = bufferStack1.float32Array, uint32Array1 = bufferStack1.uint32Array, uint16Array1 = bufferStack1.uint16Array, float32Array2 = bufferStack2.float32Array, uint32Array2 = bufferStack2.uint32Array, uint16Array2 = bufferStack2.uint16Array;
  const node1Index16 = node1Index32 * 2;
  const node2Index16 = node2Index32 * 2;
  const isLeaf1 = IS_LEAF2(node1Index16, uint16Array1);
  const isLeaf2 = IS_LEAF2(node2Index16, uint16Array2);
  let result = false;
  if (isLeaf2 && isLeaf1) {
    if (reversed) {
      result = intersectsRangesFunc(
        OFFSET2(node2Index32, uint32Array2),
        COUNT2(node2Index32 * 2, uint16Array2),
        OFFSET2(node1Index32, uint32Array1),
        COUNT2(node1Index32 * 2, uint16Array1),
        depth2,
        node2IndexByteOffset + node2Index32,
        depth1,
        node1IndexByteOffset + node1Index32
      );
    } else {
      result = intersectsRangesFunc(
        OFFSET2(node1Index32, uint32Array1),
        COUNT2(node1Index32 * 2, uint16Array1),
        OFFSET2(node2Index32, uint32Array2),
        COUNT2(node2Index32 * 2, uint16Array2),
        depth1,
        node1IndexByteOffset + node1Index32,
        depth2,
        node2IndexByteOffset + node2Index32
      );
    }
  } else if (isLeaf2) {
    const newBox = _boxPool2.getPrimitive();
    arrayToBox2(BOUNDING_DATA_INDEX2(node2Index32), float32Array2, newBox);
    newBox.applyMatrix4(matrix2to1);
    const cl1 = LEFT_NODE2(node1Index32);
    const cr1 = RIGHT_NODE2(node1Index32, uint32Array1);
    arrayToBox2(BOUNDING_DATA_INDEX2(cl1), float32Array1, _leftBox12);
    arrayToBox2(BOUNDING_DATA_INDEX2(cr1), float32Array1, _rightBox12);
    const intersectCl1 = newBox.intersectsBox(_leftBox12);
    const intersectCr1 = newBox.intersectsBox(_rightBox12);
    result = intersectCl1 && _traverse2(
      node2Index32,
      cl1,
      matrix1to2,
      matrix2to1,
      intersectsRangesFunc,
      node2IndexByteOffset,
      node1IndexByteOffset,
      depth2,
      depth1 + 1,
      newBox,
      !reversed
    ) || intersectCr1 && _traverse2(
      node2Index32,
      cr1,
      matrix1to2,
      matrix2to1,
      intersectsRangesFunc,
      node2IndexByteOffset,
      node1IndexByteOffset,
      depth2,
      depth1 + 1,
      newBox,
      !reversed
    );
    _boxPool2.releasePrimitive(newBox);
  } else {
    const cl2 = LEFT_NODE2(node2Index32);
    const cr2 = RIGHT_NODE2(node2Index32, uint32Array2);
    arrayToBox2(BOUNDING_DATA_INDEX2(cl2), float32Array2, _leftBox22);
    arrayToBox2(BOUNDING_DATA_INDEX2(cr2), float32Array2, _rightBox22);
    const leftIntersects = currBox.intersectsBox(_leftBox22);
    const rightIntersects = currBox.intersectsBox(_rightBox22);
    if (leftIntersects && rightIntersects) {
      result = _traverse2(
        node1Index32,
        cl2,
        matrix2to1,
        matrix1to2,
        intersectsRangesFunc,
        node1IndexByteOffset,
        node2IndexByteOffset,
        depth1,
        depth2 + 1,
        currBox,
        reversed
      ) || _traverse2(
        node1Index32,
        cr2,
        matrix2to1,
        matrix1to2,
        intersectsRangesFunc,
        node1IndexByteOffset,
        node2IndexByteOffset,
        depth1,
        depth2 + 1,
        currBox,
        reversed
      );
    } else if (leftIntersects) {
      if (isLeaf1) {
        result = _traverse2(
          node1Index32,
          cl2,
          matrix2to1,
          matrix1to2,
          intersectsRangesFunc,
          node1IndexByteOffset,
          node2IndexByteOffset,
          depth1,
          depth2 + 1,
          currBox,
          reversed
        );
      } else {
        const newBox = _boxPool2.getPrimitive();
        newBox.copy(_leftBox22).applyMatrix4(matrix2to1);
        const cl1 = LEFT_NODE2(node1Index32);
        const cr1 = RIGHT_NODE2(node1Index32, uint32Array1);
        arrayToBox2(BOUNDING_DATA_INDEX2(cl1), float32Array1, _leftBox12);
        arrayToBox2(BOUNDING_DATA_INDEX2(cr1), float32Array1, _rightBox12);
        const intersectCl1 = newBox.intersectsBox(_leftBox12);
        const intersectCr1 = newBox.intersectsBox(_rightBox12);
        result = intersectCl1 && _traverse2(
          cl2,
          cl1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        ) || intersectCr1 && _traverse2(
          cl2,
          cr1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        );
        _boxPool2.releasePrimitive(newBox);
      }
    } else if (rightIntersects) {
      if (isLeaf1) {
        result = _traverse2(
          node1Index32,
          cr2,
          matrix2to1,
          matrix1to2,
          intersectsRangesFunc,
          node1IndexByteOffset,
          node2IndexByteOffset,
          depth1,
          depth2 + 1,
          currBox,
          reversed
        );
      } else {
        const newBox = _boxPool2.getPrimitive();
        newBox.copy(_rightBox22).applyMatrix4(matrix2to1);
        const cl1 = LEFT_NODE2(node1Index32);
        const cr1 = RIGHT_NODE2(node1Index32, uint32Array1);
        arrayToBox2(BOUNDING_DATA_INDEX2(cl1), float32Array1, _leftBox12);
        arrayToBox2(BOUNDING_DATA_INDEX2(cr1), float32Array1, _rightBox12);
        const intersectCl1 = newBox.intersectsBox(_leftBox12);
        const intersectCr1 = newBox.intersectsBox(_rightBox12);
        result = intersectCl1 && _traverse2(
          cr2,
          cl1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        ) || intersectCr1 && _traverse2(
          cr2,
          cr1,
          matrix1to2,
          matrix2to1,
          intersectsRangesFunc,
          node2IndexByteOffset,
          node1IndexByteOffset,
          depth2,
          depth1 + 1,
          newBox,
          !reversed
        );
        _boxPool2.releasePrimitive(newBox);
      }
    }
  }
  return result;
}
var obb3 = new OrientedBox2();
var tempBox2 = new Box3();
var MeshBVH2 = class _MeshBVH {
  static serialize(bvh, options = {}) {
    options = {
      cloneBuffers: true,
      ...options
    };
    const geometry = bvh.geometry;
    const rootData = bvh._roots;
    const indirectBuffer = bvh._indirectBuffer;
    const indexAttribute = geometry.getIndex();
    let result;
    if (options.cloneBuffers) {
      result = {
        roots: rootData.map((root) => root.slice()),
        index: indexAttribute.array.slice(),
        indirectBuffer: indirectBuffer ? indirectBuffer.slice() : null
      };
    } else {
      result = {
        roots: rootData,
        index: indexAttribute.array,
        indirectBuffer
      };
    }
    return result;
  }
  static deserialize(data, geometry, options = {}) {
    options = {
      setIndex: true,
      indirect: Boolean(data.indirectBuffer),
      ...options
    };
    const { index, roots, indirectBuffer } = data;
    const bvh = new _MeshBVH(geometry, { ...options, [SKIP_GENERATION2]: true });
    bvh._roots = roots;
    bvh._indirectBuffer = indirectBuffer || null;
    if (options.setIndex) {
      const indexAttribute = geometry.getIndex();
      if (indexAttribute === null) {
        const newIndex = new BufferAttribute(data.index, 1, false);
        geometry.setIndex(newIndex);
      } else if (indexAttribute.array !== index) {
        indexAttribute.array.set(index);
        indexAttribute.needsUpdate = true;
      }
    }
    return bvh;
  }
  get indirect() {
    return !!this._indirectBuffer;
  }
  constructor(geometry, options = {}) {
    if (!geometry.isBufferGeometry) {
      throw new Error("MeshBVH: Only BufferGeometries are supported.");
    } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {
      throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");
    }
    options = Object.assign({
      strategy: CENTER2,
      maxDepth: 40,
      maxLeafTris: 10,
      verbose: true,
      useSharedArrayBuffer: false,
      setBoundingBox: true,
      onProgress: null,
      indirect: false,
      // undocumented options
      // Whether to skip generating the tree. Used for deserialization.
      [SKIP_GENERATION2]: false
    }, options);
    if (options.useSharedArrayBuffer && !isSharedArrayBufferSupported2()) {
      throw new Error("MeshBVH: SharedArrayBuffer is not available.");
    }
    this.geometry = geometry;
    this._roots = null;
    this._indirectBuffer = null;
    if (!options[SKIP_GENERATION2]) {
      buildPackedTree2(this, options);
      if (!geometry.boundingBox && options.setBoundingBox) {
        geometry.boundingBox = this.getBoundingBox(new Box3());
      }
    }
    const { _indirectBuffer } = this;
    this.resolveTriangleIndex = options.indirect ? (i) => _indirectBuffer[i] : (i) => i;
  }
  refit(nodeIndices = null) {
    const refitFunc = this.indirect ? refit_indirect2 : refit2;
    return refitFunc(this, nodeIndices);
  }
  traverse(callback, rootIndex = 0) {
    const buffer = this._roots[rootIndex];
    const uint32Array = new Uint32Array(buffer);
    const uint16Array = new Uint16Array(buffer);
    _traverse22(0);
    function _traverse22(node32Index, depth = 0) {
      const node16Index = node32Index * 2;
      const isLeaf = uint16Array[node16Index + 15] === IS_LEAFNODE_FLAG2;
      if (isLeaf) {
        const offset = uint32Array[node32Index + 6];
        const count = uint16Array[node16Index + 14];
        callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);
      } else {
        const left = node32Index + BYTES_PER_NODE2 / 4;
        const right = uint32Array[node32Index + 6];
        const splitAxis = uint32Array[node32Index + 7];
        const stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);
        if (!stopTraversal) {
          _traverse22(left, depth + 1);
          _traverse22(right, depth + 1);
        }
      }
    }
  }
  /* Core Cast Functions */
  raycast(ray22, materialOrSide = FrontSide) {
    const roots = this._roots;
    const geometry = this.geometry;
    const intersects2 = [];
    const isMaterial = materialOrSide.isMaterial;
    const isArrayMaterial = Array.isArray(materialOrSide);
    const groups = geometry.groups;
    const side = isMaterial ? materialOrSide.side : materialOrSide;
    const raycastFunc = this.indirect ? raycast_indirect2 : raycast2;
    for (let i = 0, l = roots.length; i < l; i++) {
      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;
      const startCount = intersects2.length;
      raycastFunc(this, i, materialSide, ray22, intersects2);
      if (isArrayMaterial) {
        const materialIndex = groups[i].materialIndex;
        for (let j = startCount, jl = intersects2.length; j < jl; j++) {
          intersects2[j].face.materialIndex = materialIndex;
        }
      }
    }
    return intersects2;
  }
  raycastFirst(ray22, materialOrSide = FrontSide) {
    const roots = this._roots;
    const geometry = this.geometry;
    const isMaterial = materialOrSide.isMaterial;
    const isArrayMaterial = Array.isArray(materialOrSide);
    let closestResult = null;
    const groups = geometry.groups;
    const side = isMaterial ? materialOrSide.side : materialOrSide;
    const raycastFirstFunc = this.indirect ? raycastFirst_indirect2 : raycastFirst2;
    for (let i = 0, l = roots.length; i < l; i++) {
      const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;
      const result = raycastFirstFunc(this, i, materialSide, ray22);
      if (result != null && (closestResult == null || result.distance < closestResult.distance)) {
        closestResult = result;
        if (isArrayMaterial) {
          result.face.materialIndex = groups[i].materialIndex;
        }
      }
    }
    return closestResult;
  }
  intersectsGeometry(otherGeometry, geomToMesh) {
    let result = false;
    const roots = this._roots;
    const intersectsGeometryFunc = this.indirect ? intersectsGeometry_indirect2 : intersectsGeometry2;
    for (let i = 0, l = roots.length; i < l; i++) {
      result = intersectsGeometryFunc(this, i, otherGeometry, geomToMesh);
      if (result) {
        break;
      }
    }
    return result;
  }
  shapecast(callbacks) {
    const triangle32 = ExtendedTrianglePool2.getPrimitive();
    const iterateFunc = this.indirect ? iterateOverTriangles_indirect2 : iterateOverTriangles2;
    let {
      boundsTraverseOrder,
      intersectsBounds,
      intersectsRange,
      intersectsTriangle
    } = callbacks;
    if (intersectsRange && intersectsTriangle) {
      const originalIntersectsRange = intersectsRange;
      intersectsRange = (offset, count, contained, depth, nodeIndex) => {
        if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {
          return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle32);
        }
        return true;
      };
    } else if (!intersectsRange) {
      if (intersectsTriangle) {
        intersectsRange = (offset, count, contained, depth) => {
          return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle32);
        };
      } else {
        intersectsRange = (offset, count, contained) => {
          return contained;
        };
      }
    }
    let result = false;
    let byteOffset = 0;
    const roots = this._roots;
    for (let i = 0, l = roots.length; i < l; i++) {
      const root = roots[i];
      result = shapecast2(this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);
      if (result) {
        break;
      }
      byteOffset += root.byteLength;
    }
    ExtendedTrianglePool2.releasePrimitive(triangle32);
    return result;
  }
  bvhcast(otherBvh, matrixToLocal, callbacks) {
    let {
      intersectsRanges,
      intersectsTriangles
    } = callbacks;
    const triangle1 = ExtendedTrianglePool2.getPrimitive();
    const indexAttr1 = this.geometry.index;
    const positionAttr1 = this.geometry.attributes.position;
    const assignTriangle1 = this.indirect ? (i1) => {
      const ti = this.resolveTriangleIndex(i1);
      setTriangle2(triangle1, ti * 3, indexAttr1, positionAttr1);
    } : (i1) => {
      setTriangle2(triangle1, i1 * 3, indexAttr1, positionAttr1);
    };
    const triangle222 = ExtendedTrianglePool2.getPrimitive();
    const indexAttr2 = otherBvh.geometry.index;
    const positionAttr2 = otherBvh.geometry.attributes.position;
    const assignTriangle2 = otherBvh.indirect ? (i2) => {
      const ti2 = otherBvh.resolveTriangleIndex(i2);
      setTriangle2(triangle222, ti2 * 3, indexAttr2, positionAttr2);
    } : (i2) => {
      setTriangle2(triangle222, i2 * 3, indexAttr2, positionAttr2);
    };
    if (intersectsTriangles) {
      const iterateOverDoubleTriangles = (offset1, count1, offset2, count2, depth1, index1, depth2, index2) => {
        for (let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++) {
          assignTriangle2(i2);
          triangle222.a.applyMatrix4(matrixToLocal);
          triangle222.b.applyMatrix4(matrixToLocal);
          triangle222.c.applyMatrix4(matrixToLocal);
          triangle222.needsUpdate = true;
          for (let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++) {
            assignTriangle1(i1);
            triangle1.needsUpdate = true;
            if (intersectsTriangles(triangle1, triangle222, i1, i2, depth1, index1, depth2, index2)) {
              return true;
            }
          }
        }
        return false;
      };
      if (intersectsRanges) {
        const originalIntersectsRanges = intersectsRanges;
        intersectsRanges = function(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {
          if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {
            return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);
          }
          return true;
        };
      } else {
        intersectsRanges = iterateOverDoubleTriangles;
      }
    }
    return bvhcast2(this, otherBvh, matrixToLocal, intersectsRanges);
  }
  /* Derived Cast Functions */
  intersectsBox(box, boxToMesh) {
    obb3.set(box.min, box.max, boxToMesh);
    obb3.needsUpdate = true;
    return this.shapecast(
      {
        intersectsBounds: (box2) => obb3.intersectsBox(box2),
        intersectsTriangle: (tri) => obb3.intersectsTriangle(tri)
      }
    );
  }
  intersectsSphere(sphere) {
    return this.shapecast(
      {
        intersectsBounds: (box) => sphere.intersectsBox(box),
        intersectsTriangle: (tri) => tri.intersectsSphere(sphere)
      }
    );
  }
  closestPointToGeometry(otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {
    const closestPointToGeometryFunc = this.indirect ? closestPointToGeometry_indirect2 : closestPointToGeometry2;
    return closestPointToGeometryFunc(
      this,
      otherGeometry,
      geometryToBvh,
      target1,
      target2,
      minThreshold,
      maxThreshold
    );
  }
  closestPointToPoint(point, target = {}, minThreshold = 0, maxThreshold = Infinity) {
    return closestPointToPoint2(
      this,
      point,
      target,
      minThreshold,
      maxThreshold
    );
  }
  getBoundingBox(target) {
    target.makeEmpty();
    const roots = this._roots;
    roots.forEach((buffer) => {
      arrayToBox2(0, new Float32Array(buffer), tempBox2);
      target.union(tempBox2);
    });
    return target;
  }
};
function convertRaycastIntersect2(hit, object, raycaster) {
  if (hit === null) {
    return null;
  }
  hit.point.applyMatrix4(object.matrixWorld);
  hit.distance = hit.point.distanceTo(raycaster.ray.origin);
  hit.object = object;
  if (hit.distance < raycaster.near || hit.distance > raycaster.far) {
    return null;
  } else {
    return hit;
  }
}
var ray2 = new Ray();
var tmpInverseMatrix2 = new Matrix4();
var origMeshRaycastFunc2 = Mesh.prototype.raycast;
function acceleratedRaycast2(raycaster, intersects2) {
  if (this.geometry.boundsTree) {
    if (this.material === void 0)
      return;
    tmpInverseMatrix2.copy(this.matrixWorld).invert();
    ray2.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix2);
    const bvh = this.geometry.boundsTree;
    if (raycaster.firstHitOnly === true) {
      const hit = convertRaycastIntersect2(bvh.raycastFirst(ray2, this.material), this, raycaster);
      if (hit) {
        intersects2.push(hit);
      }
    } else {
      const hits = bvh.raycast(ray2, this.material);
      for (let i = 0, l = hits.length; i < l; i++) {
        const hit = convertRaycastIntersect2(hits[i], this, raycaster);
        if (hit) {
          intersects2.push(hit);
        }
      }
    }
  } else {
    origMeshRaycastFunc2.call(this, raycaster, intersects2);
  }
}
function computeBoundsTree2(options) {
  this.boundsTree = new MeshBVH2(this, options);
  return this.boundsTree;
}
function disposeBoundsTree2() {
  this.boundsTree = null;
}
var Event = class {
  constructor() {
    __publicField2(this, "enabled", true);
    __publicField2(this, "trigger", (data) => {
      if (!this.enabled) {
        return;
      }
      const handlers = this.handlers.slice(0);
      for (const handler of handlers) {
        handler(data);
      }
    });
    __publicField2(this, "handlers", []);
  }
  /**
   * Add a callback to this event instance.
   * @param handler - the callback to be added to this event.
   */
  add(handler) {
    this.handlers.push(handler);
  }
  /**
   * Removes a callback from this event instance.
   * @param handler - the callback to be removed from this event.
   */
  remove(handler) {
    this.handlers = this.handlers.filter((h) => h !== handler);
  }
  /** Gets rid of all the suscribed events. */
  reset() {
    this.handlers.length = 0;
  }
};
var AsyncEvent = class {
  constructor() {
    __publicField2(this, "enabled", true);
    __publicField2(this, "trigger", async (data) => {
      if (!this.enabled) {
        return;
      }
      const handlers = this.handlers.slice(0);
      for (const handler of handlers) {
        await handler(data);
      }
    });
    __publicField2(this, "handlers", []);
  }
  /**
   * Add a callback to this event instance.
   * @param handler - the callback to be added to this event.
   */
  add(handler) {
    this.handlers.push(handler);
  }
  /**
   * Removes a callback from this event instance.
   * @param handler - the callback to be removed from this event.
   */
  remove(handler) {
    this.handlers = this.handlers.filter((h) => h !== handler);
  }
  /** Gets rid of all the suscribed events. */
  reset() {
    this.handlers.length = 0;
  }
};
var Base = class {
  constructor(components) {
    __publicField2(this, "isDisposeable", () => {
      return "dispose" in this && "onDisposed" in this;
    });
    __publicField2(this, "isResizeable", () => {
      return "resize" in this && "getSize" in this;
    });
    __publicField2(this, "isUpdateable", () => {
      return "onAfterUpdate" in this && "onBeforeUpdate" in this && "update" in this;
    });
    __publicField2(this, "isHideable", () => {
      return "visible" in this;
    });
    __publicField2(this, "isConfigurable", () => {
      return "setup" in this && "config" in this && "onSetup" in this;
    });
    this.components = components;
  }
};
var Component = class extends Base {
};
var BaseWorldItem = class extends Base {
  constructor(components) {
    super(components);
    __publicField2(this, "worlds", /* @__PURE__ */ new Map());
    __publicField2(this, "onWorldChanged", new Event());
    __publicField2(this, "currentWorld", null);
    this.onWorldChanged.add(({ world, action }) => {
      if (action === "removed") {
        this.worlds.delete(world.uuid);
      }
    });
  }
};
var BaseCamera = class extends BaseWorldItem {
  constructor() {
    super(...arguments);
    __publicField2(this, "hasCameraControls", () => {
      return "controls" in this;
    });
  }
};
var BaseRenderer = class extends BaseWorldItem {
  constructor() {
    super(...arguments);
    __publicField2(this, "onAfterUpdate", new Event());
    __publicField2(this, "onBeforeUpdate", new Event());
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "onResize", new Event());
    __publicField2(this, "onClippingPlanesUpdated", new Event());
    __publicField2(this, "clippingPlanes", []);
  }
  /**
   * Updates the clipping planes and triggers the `onClippingPlanesUpdated` event.
   *
   * @remarks
   * This method is typically called when there is a change to the list of clipping planes
   * used by the active renderer.
   */
  updateClippingPlanes() {
    this.onClippingPlanesUpdated.trigger();
  }
  /**
   * Sets or removes a clipping plane from the renderer.
   *
   * @param active - A boolean indicating whether the clipping plane should be active or not.
   * @param plane - The clipping plane to be added or removed.
   * @param isLocal - An optional boolean indicating whether the clipping plane is local to the object. If not provided, it defaults to `false`.
   *
   * @remarks
   * This method adds or removes a clipping plane from the `clippingPlanes` array.
   * If `active` is `true` and the plane is not already in the array, it is added.
   * If `active` is `false` and the plane is in the array, it is removed.
   * The `three.clippingPlanes` property is then updated to reflect the current state of the `clippingPlanes` array,
   * excluding any planes marked as local.
   */
  setPlane(active, plane, isLocal) {
    plane.isLocal = isLocal;
    const index = this.clippingPlanes.indexOf(plane);
    if (active && index === -1) {
      this.clippingPlanes.push(plane);
    } else if (!active && index > -1) {
      this.clippingPlanes.splice(index, 1);
    }
    this.three.clippingPlanes = this.clippingPlanes.filter(
      (plane2) => !plane2.isLocal
    );
  }
};
var _Disposer = class _Disposer2 extends Component {
  constructor(components) {
    super(components);
    __publicField2(this, "_disposedComponents", /* @__PURE__ */ new Set());
    __publicField2(this, "enabled", true);
    components.add(_Disposer2.uuid, this);
  }
  // TODO: Remove this?
  /**
   * Return the UUIDs of all disposed components.
   */
  get() {
    return this._disposedComponents;
  }
  /**
   * Removes a mesh, its geometry and its materials from memory. If you are
   * using any of these in other parts of the application, make sure that you
   * remove them from the mesh before disposing it.
   *
   * @param object - the [object](https://threejs.org/docs/#api/en/core/Object3D)
   * to remove.
   *
   * @param materials - whether to dispose the materials of the mesh.
   *
   * @param recursive - whether to recursively dispose the children of the mesh.
   */
  destroy(object, materials = true, recursive = true) {
    object.removeFromParent();
    const item = object;
    if (item.dispose) {
      item.dispose();
    }
    this.disposeGeometryAndMaterials(object, materials);
    if (recursive && item.children && item.children.length) {
      this.disposeChildren(item);
    }
    object.children.length = 0;
  }
  /**
   * Disposes a geometry from memory.
   *
   * @param geometry - the
   * [geometry](https://threejs.org/docs/#api/en/core/BufferGeometry)
   * to remove.
   */
  disposeGeometry(geometry) {
    if (geometry.boundsTree && geometry.disposeBoundsTree) {
      geometry.disposeBoundsTree();
    }
    geometry.dispose();
  }
  disposeGeometryAndMaterials(mesh, materials) {
    const item = mesh;
    if (item.geometry) {
      this.disposeGeometry(item.geometry);
    }
    if (materials && item.material) {
      _Disposer2.disposeMaterial(item);
    }
    item.material = [];
    item.geometry = null;
  }
  disposeChildren(mesh) {
    for (const child of mesh.children) {
      this.destroy(child);
    }
  }
  static disposeMaterial(mesh) {
    if (mesh.material) {
      if (Array.isArray(mesh.material)) {
        for (const mat of mesh.material) {
          mat.dispose();
        }
      } else {
        mesh.material.dispose();
      }
    }
  }
};
__publicField2(_Disposer, "uuid", "76e9cd8e-ad8f-4753-9ef6-cbc60f7247fe");
var Disposer = _Disposer;
var BaseScene = class extends BaseWorldItem {
  constructor(components) {
    super(components);
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "directionalLights", /* @__PURE__ */ new Map());
    __publicField2(this, "ambientLights", /* @__PURE__ */ new Map());
  }
  /** {@link Disposable.dispose} */
  dispose() {
    const disposer = this.components.get(Disposer);
    for (const child of this.three.children) {
      const mesh = child;
      if (mesh.geometry) {
        disposer.destroy(mesh);
      }
    }
    this.deleteAllLights();
    this.three.children = [];
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  deleteAllLights() {
    for (const [, light] of this.directionalLights) {
      light.removeFromParent();
      light.target.removeFromParent();
      light.dispose();
    }
    this.directionalLights.clear();
    for (const [, light] of this.ambientLights) {
      light.removeFromParent();
      light.dispose();
    }
    this.ambientLights.clear();
  }
};
var DataSet = class extends Set {
  /**
   * Constructs a new instance of the DataSet class.
   *
   * @param iterable - An optional iterable object to initialize the set with.
   */
  constructor(iterable) {
    super(iterable);
    __publicField2(this, "onItemAdded", new Event());
    __publicField2(this, "onItemDeleted", new Event());
    __publicField2(this, "onCleared", new Event());
    __publicField2(this, "guard", () => true);
  }
  /**
   * Clears the set and triggers the onCleared event.
   */
  clear() {
    super.clear();
    this.onCleared.trigger();
  }
  /**
   * Adds one or multiple values to the set and triggers the onItemAdded event per each.
   *
   * @param value - The value to add to the set.
   * @returns - The set instance.
   */
  add(...value) {
    for (const item of value) {
      const existing = this.has(item);
      if (existing)
        continue;
      const isValid = this.guard(item);
      if (!isValid)
        continue;
      super.add(item);
      if (!this.onItemAdded)
        this.onItemAdded = new Event();
      this.onItemAdded.trigger(item);
    }
    return this;
  }
  /**
   * Deletes a value from the set and triggers the onItemDeleted event.
   *
   * @param value - The value to delete from the set.
   * @returns - True if the value was successfully deleted, false otherwise.
   */
  delete(value) {
    const deleted = super.delete(value);
    if (deleted)
      this.onItemDeleted.trigger();
    return deleted;
  }
  /**
   * Clears the set and resets the onItemAdded, onItemDeleted, and onCleared events.
   */
  dispose() {
    this.clear();
    this.onItemAdded.reset();
    this.onItemDeleted.reset();
    this.onCleared.reset();
  }
};
var DataMap = class extends Map {
  /**
   * Constructs a new DataMap instance.
   *
   * @param iterable - An iterable object containing key-value pairs to populate the map.
   */
  constructor(iterable) {
    super(iterable);
    __publicField2(this, "onItemSet", new Event());
    __publicField2(this, "onItemUpdated", new Event());
    __publicField2(this, "onItemDeleted", new Event());
    __publicField2(this, "onCleared", new Event());
    __publicField2(this, "guard", () => true);
  }
  /**
   * Clears the map and triggers the onCleared event.
   */
  clear() {
    super.clear();
    this.onCleared.trigger();
  }
  /**
   * Sets the value for the specified key in the map.
   * If the item is new, then onItemSet is triggered.
   * If the item is already in the map, then onItemUpdated is triggered.
   *
   * @param key - The key of the item to set.
   * @param value - The value of the item to set.
   * @returns The DataMap instance.
   */
  set(key, value) {
    const triggerUpdate = this.has(key);
    const guard = this.guard ?? (() => true);
    const isValid = guard(key, value);
    if (!isValid)
      return this;
    const result = super.set(key, value);
    if (triggerUpdate) {
      if (!this.onItemUpdated) {
        this.onItemUpdated = new Event();
      }
      this.onItemUpdated.trigger({ key, value });
    } else {
      if (!this.onItemSet) {
        this.onItemSet = new Event();
      }
      this.onItemSet.trigger({ key, value });
    }
    return result;
  }
  /**
   * Deletes the specified key from the map and triggers the onItemDeleted event if the key was found.
   *
   * @param key - The key of the item to delete.
   * @returns True if the key was found and deleted; otherwise, false.
   */
  delete(key) {
    const deleted = super.delete(key);
    if (deleted)
      this.onItemDeleted.trigger(key);
    return deleted;
  }
  /**
   * Clears the map and resets the events.
   */
  dispose() {
    this.clear();
    this.onItemSet.reset();
    this.onItemDeleted.reset();
    this.onCleared.reset();
  }
};
var ComponentWithUI = class extends Component {
};
var ControlsUtils = class {
  static isEntry(item) {
    const types = /* @__PURE__ */ new Set([
      "Boolean",
      "Color",
      "Text",
      "Number",
      "Select",
      "Vector3",
      "TextSet",
      "None"
    ]);
    return types.has(item.type);
  }
  static copySchema(schema, copy = {}) {
    for (const name in schema) {
      const entry = schema[name];
      if (this.isEntry(entry)) {
        copy[name] = this.copyEntry(entry);
      } else {
        copy[name] = {};
        this.copySchema(entry, copy[name]);
      }
    }
    return copy;
  }
  static copyEntry(controlEntry) {
    if (controlEntry.type === "Boolean") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: entry.value
      };
    }
    if (controlEntry.type === "Color") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: entry.value.clone()
      };
    }
    if (controlEntry.type === "Text") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: entry.value
      };
    }
    if (controlEntry.type === "Number") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: entry.value,
        min: entry.min,
        max: entry.max,
        interpolable: entry.interpolable
      };
    }
    if (controlEntry.type === "Select") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: entry.value,
        multiple: entry.multiple,
        options: new Set(entry.options)
      };
    }
    if (controlEntry.type === "Vector3") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: entry.value.clone()
      };
    }
    if (controlEntry.type === "TextSet") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: new Set(entry.value)
      };
    }
    if (controlEntry.type === "None") {
      const entry = controlEntry;
      return {
        type: entry.type,
        value: entry.value
      };
    }
    throw new Error("Invalid entry!");
  }
};
var EventManager = class {
  constructor() {
    __publicField2(this, "list", /* @__PURE__ */ new Set());
  }
  /**
   * Adds events to this manager.
   * @param events the events to add.
   */
  add(events) {
    for (const event of events) {
      this.list.add(event);
    }
  }
  /**
   * Removes events from this manager.
   * @param events the events to remove.
   */
  remove(events) {
    for (const event of events) {
      this.list.delete(event);
    }
  }
  /**
   * Sets all the events managed by this instance as enabled or disabled.
   * @param active whether to turn on or off the events.
   */
  set(active) {
    for (const event of this.list) {
      event.enabled = active;
    }
  }
  /**
   * Resets all the events managed by this instance.
   */
  reset() {
    for (const event of this.list) {
      event.reset();
    }
  }
};
var Visible = 0;
var Deleted = 1;
var _v1$1 = new Vector3();
var _line3 = new Line3();
var _plane = new Plane();
var _closestPoint = new Vector3();
var _triangle = new Triangle();
var ConvexHull = class {
  constructor() {
    this.tolerance = -1;
    this.faces = [];
    this.newFaces = [];
    this.assigned = new VertexList();
    this.unassigned = new VertexList();
    this.vertices = [];
  }
  setFromPoints(points) {
    if (points.length >= 4) {
      this.makeEmpty();
      for (let i = 0, l = points.length; i < l; i++) {
        this.vertices.push(new VertexNode(points[i]));
      }
      this.compute();
    }
    return this;
  }
  setFromObject(object) {
    const points = [];
    object.updateMatrixWorld(true);
    object.traverse(function(node) {
      const geometry = node.geometry;
      if (geometry !== void 0) {
        const attribute = geometry.attributes.position;
        if (attribute !== void 0) {
          for (let i = 0, l = attribute.count; i < l; i++) {
            const point = new Vector3();
            point.fromBufferAttribute(attribute, i).applyMatrix4(node.matrixWorld);
            points.push(point);
          }
        }
      }
    });
    return this.setFromPoints(points);
  }
  containsPoint(point) {
    const faces = this.faces;
    for (let i = 0, l = faces.length; i < l; i++) {
      const face = faces[i];
      if (face.distanceToPoint(point) > this.tolerance)
        return false;
    }
    return true;
  }
  intersectRay(ray22, target) {
    const faces = this.faces;
    let tNear = -Infinity;
    let tFar = Infinity;
    for (let i = 0, l = faces.length; i < l; i++) {
      const face = faces[i];
      const vN = face.distanceToPoint(ray22.origin);
      const vD = face.normal.dot(ray22.direction);
      if (vN > 0 && vD >= 0)
        return null;
      const t = vD !== 0 ? -vN / vD : 0;
      if (t <= 0)
        continue;
      if (vD > 0) {
        tFar = Math.min(t, tFar);
      } else {
        tNear = Math.max(t, tNear);
      }
      if (tNear > tFar) {
        return null;
      }
    }
    if (tNear !== -Infinity) {
      ray22.at(tNear, target);
    } else {
      ray22.at(tFar, target);
    }
    return target;
  }
  intersectsRay(ray22) {
    return this.intersectRay(ray22, _v1$1) !== null;
  }
  makeEmpty() {
    this.faces = [];
    this.vertices = [];
    return this;
  }
  // Adds a vertex to the 'assigned' list of vertices and assigns it to the given face
  addVertexToFace(vertex, face) {
    vertex.face = face;
    if (face.outside === null) {
      this.assigned.append(vertex);
    } else {
      this.assigned.insertBefore(face.outside, vertex);
    }
    face.outside = vertex;
    return this;
  }
  // Removes a vertex from the 'assigned' list of vertices and from the given face
  removeVertexFromFace(vertex, face) {
    if (vertex === face.outside) {
      if (vertex.next !== null && vertex.next.face === face) {
        face.outside = vertex.next;
      } else {
        face.outside = null;
      }
    }
    this.assigned.remove(vertex);
    return this;
  }
  // Removes all the visible vertices that a given face is able to see which are stored in the 'assigned' vertex list
  removeAllVerticesFromFace(face) {
    if (face.outside !== null) {
      const start = face.outside;
      let end = face.outside;
      while (end.next !== null && end.next.face === face) {
        end = end.next;
      }
      this.assigned.removeSubList(start, end);
      start.prev = end.next = null;
      face.outside = null;
      return start;
    }
  }
  // Removes all the visible vertices that 'face' is able to see
  deleteFaceVertices(face, absorbingFace) {
    const faceVertices = this.removeAllVerticesFromFace(face);
    if (faceVertices !== void 0) {
      if (absorbingFace === void 0) {
        this.unassigned.appendChain(faceVertices);
      } else {
        let vertex = faceVertices;
        do {
          const nextVertex = vertex.next;
          const distance = absorbingFace.distanceToPoint(vertex.point);
          if (distance > this.tolerance) {
            this.addVertexToFace(vertex, absorbingFace);
          } else {
            this.unassigned.append(vertex);
          }
          vertex = nextVertex;
        } while (vertex !== null);
      }
    }
    return this;
  }
  // Reassigns as many vertices as possible from the unassigned list to the new faces
  resolveUnassignedPoints(newFaces) {
    if (this.unassigned.isEmpty() === false) {
      let vertex = this.unassigned.first();
      do {
        const nextVertex = vertex.next;
        let maxDistance = this.tolerance;
        let maxFace = null;
        for (let i = 0; i < newFaces.length; i++) {
          const face = newFaces[i];
          if (face.mark === Visible) {
            const distance = face.distanceToPoint(vertex.point);
            if (distance > maxDistance) {
              maxDistance = distance;
              maxFace = face;
            }
            if (maxDistance > 1e3 * this.tolerance)
              break;
          }
        }
        if (maxFace !== null) {
          this.addVertexToFace(vertex, maxFace);
        }
        vertex = nextVertex;
      } while (vertex !== null);
    }
    return this;
  }
  // Computes the extremes of a simplex which will be the initial hull
  computeExtremes() {
    const min = new Vector3();
    const max = new Vector3();
    const minVertices = [];
    const maxVertices = [];
    for (let i = 0; i < 3; i++) {
      minVertices[i] = maxVertices[i] = this.vertices[0];
    }
    min.copy(this.vertices[0].point);
    max.copy(this.vertices[0].point);
    for (let i = 0, l = this.vertices.length; i < l; i++) {
      const vertex = this.vertices[i];
      const point = vertex.point;
      for (let j = 0; j < 3; j++) {
        if (point.getComponent(j) < min.getComponent(j)) {
          min.setComponent(j, point.getComponent(j));
          minVertices[j] = vertex;
        }
      }
      for (let j = 0; j < 3; j++) {
        if (point.getComponent(j) > max.getComponent(j)) {
          max.setComponent(j, point.getComponent(j));
          maxVertices[j] = vertex;
        }
      }
    }
    this.tolerance = 3 * Number.EPSILON * (Math.max(Math.abs(min.x), Math.abs(max.x)) + Math.max(Math.abs(min.y), Math.abs(max.y)) + Math.max(Math.abs(min.z), Math.abs(max.z)));
    return { min: minVertices, max: maxVertices };
  }
  // Computes the initial simplex assigning to its faces all the points
  // that are candidates to form part of the hull
  computeInitialHull() {
    const vertices = this.vertices;
    const extremes = this.computeExtremes();
    const min = extremes.min;
    const max = extremes.max;
    let maxDistance = 0;
    let index = 0;
    for (let i = 0; i < 3; i++) {
      const distance = max[i].point.getComponent(i) - min[i].point.getComponent(i);
      if (distance > maxDistance) {
        maxDistance = distance;
        index = i;
      }
    }
    const v0 = min[index];
    const v1 = max[index];
    let v2;
    let v3;
    maxDistance = 0;
    _line3.set(v0.point, v1.point);
    for (let i = 0, l = this.vertices.length; i < l; i++) {
      const vertex = vertices[i];
      if (vertex !== v0 && vertex !== v1) {
        _line3.closestPointToPoint(vertex.point, true, _closestPoint);
        const distance = _closestPoint.distanceToSquared(vertex.point);
        if (distance > maxDistance) {
          maxDistance = distance;
          v2 = vertex;
        }
      }
    }
    maxDistance = -1;
    _plane.setFromCoplanarPoints(v0.point, v1.point, v2.point);
    for (let i = 0, l = this.vertices.length; i < l; i++) {
      const vertex = vertices[i];
      if (vertex !== v0 && vertex !== v1 && vertex !== v2) {
        const distance = Math.abs(_plane.distanceToPoint(vertex.point));
        if (distance > maxDistance) {
          maxDistance = distance;
          v3 = vertex;
        }
      }
    }
    const faces = [];
    if (_plane.distanceToPoint(v3.point) < 0) {
      faces.push(
        Face.create(v0, v1, v2),
        Face.create(v3, v1, v0),
        Face.create(v3, v2, v1),
        Face.create(v3, v0, v2)
      );
      for (let i = 0; i < 3; i++) {
        const j = (i + 1) % 3;
        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge(j));
        faces[i + 1].getEdge(1).setTwin(faces[j + 1].getEdge(0));
      }
    } else {
      faces.push(
        Face.create(v0, v2, v1),
        Face.create(v3, v0, v1),
        Face.create(v3, v1, v2),
        Face.create(v3, v2, v0)
      );
      for (let i = 0; i < 3; i++) {
        const j = (i + 1) % 3;
        faces[i + 1].getEdge(2).setTwin(faces[0].getEdge((3 - i) % 3));
        faces[i + 1].getEdge(0).setTwin(faces[j + 1].getEdge(1));
      }
    }
    for (let i = 0; i < 4; i++) {
      this.faces.push(faces[i]);
    }
    for (let i = 0, l = vertices.length; i < l; i++) {
      const vertex = vertices[i];
      if (vertex !== v0 && vertex !== v1 && vertex !== v2 && vertex !== v3) {
        maxDistance = this.tolerance;
        let maxFace = null;
        for (let j = 0; j < 4; j++) {
          const distance = this.faces[j].distanceToPoint(vertex.point);
          if (distance > maxDistance) {
            maxDistance = distance;
            maxFace = this.faces[j];
          }
        }
        if (maxFace !== null) {
          this.addVertexToFace(vertex, maxFace);
        }
      }
    }
    return this;
  }
  // Removes inactive faces
  reindexFaces() {
    const activeFaces = [];
    for (let i = 0; i < this.faces.length; i++) {
      const face = this.faces[i];
      if (face.mark === Visible) {
        activeFaces.push(face);
      }
    }
    this.faces = activeFaces;
    return this;
  }
  // Finds the next vertex to create faces with the current hull
  nextVertexToAdd() {
    if (this.assigned.isEmpty() === false) {
      let eyeVertex, maxDistance = 0;
      const eyeFace = this.assigned.first().face;
      let vertex = eyeFace.outside;
      do {
        const distance = eyeFace.distanceToPoint(vertex.point);
        if (distance > maxDistance) {
          maxDistance = distance;
          eyeVertex = vertex;
        }
        vertex = vertex.next;
      } while (vertex !== null && vertex.face === eyeFace);
      return eyeVertex;
    }
  }
  // Computes a chain of half edges in CCW order called the 'horizon'.
  // For an edge to be part of the horizon it must join a face that can see
  // 'eyePoint' and a face that cannot see 'eyePoint'.
  computeHorizon(eyePoint, crossEdge, face, horizon) {
    this.deleteFaceVertices(face);
    face.mark = Deleted;
    let edge;
    if (crossEdge === null) {
      edge = crossEdge = face.getEdge(0);
    } else {
      edge = crossEdge.next;
    }
    do {
      const twinEdge = edge.twin;
      const oppositeFace = twinEdge.face;
      if (oppositeFace.mark === Visible) {
        if (oppositeFace.distanceToPoint(eyePoint) > this.tolerance) {
          this.computeHorizon(eyePoint, twinEdge, oppositeFace, horizon);
        } else {
          horizon.push(edge);
        }
      }
      edge = edge.next;
    } while (edge !== crossEdge);
    return this;
  }
  // Creates a face with the vertices 'eyeVertex.point', 'horizonEdge.tail' and 'horizonEdge.head' in CCW order
  addAdjoiningFace(eyeVertex, horizonEdge) {
    const face = Face.create(eyeVertex, horizonEdge.tail(), horizonEdge.head());
    this.faces.push(face);
    face.getEdge(-1).setTwin(horizonEdge.twin);
    return face.getEdge(0);
  }
  //  Adds 'horizon.length' faces to the hull, each face will be linked with the
  //  horizon opposite face and the face on the left/right
  addNewFaces(eyeVertex, horizon) {
    this.newFaces = [];
    let firstSideEdge = null;
    let previousSideEdge = null;
    for (let i = 0; i < horizon.length; i++) {
      const horizonEdge = horizon[i];
      const sideEdge = this.addAdjoiningFace(eyeVertex, horizonEdge);
      if (firstSideEdge === null) {
        firstSideEdge = sideEdge;
      } else {
        sideEdge.next.setTwin(previousSideEdge);
      }
      this.newFaces.push(sideEdge.face);
      previousSideEdge = sideEdge;
    }
    firstSideEdge.next.setTwin(previousSideEdge);
    return this;
  }
  // Adds a vertex to the hull
  addVertexToHull(eyeVertex) {
    const horizon = [];
    this.unassigned.clear();
    this.removeVertexFromFace(eyeVertex, eyeVertex.face);
    this.computeHorizon(eyeVertex.point, null, eyeVertex.face, horizon);
    this.addNewFaces(eyeVertex, horizon);
    this.resolveUnassignedPoints(this.newFaces);
    return this;
  }
  cleanup() {
    this.assigned.clear();
    this.unassigned.clear();
    this.newFaces = [];
    return this;
  }
  compute() {
    let vertex;
    this.computeInitialHull();
    while ((vertex = this.nextVertexToAdd()) !== void 0) {
      this.addVertexToHull(vertex);
    }
    this.reindexFaces();
    this.cleanup();
    return this;
  }
};
var Face = class _Face {
  constructor() {
    this.normal = new Vector3();
    this.midpoint = new Vector3();
    this.area = 0;
    this.constant = 0;
    this.outside = null;
    this.mark = Visible;
    this.edge = null;
  }
  static create(a, b, c) {
    const face = new _Face();
    const e0 = new HalfEdge(a, face);
    const e1 = new HalfEdge(b, face);
    const e2 = new HalfEdge(c, face);
    e0.next = e2.prev = e1;
    e1.next = e0.prev = e2;
    e2.next = e1.prev = e0;
    face.edge = e0;
    return face.compute();
  }
  getEdge(i) {
    let edge = this.edge;
    while (i > 0) {
      edge = edge.next;
      i--;
    }
    while (i < 0) {
      edge = edge.prev;
      i++;
    }
    return edge;
  }
  compute() {
    const a = this.edge.tail();
    const b = this.edge.head();
    const c = this.edge.next.head();
    _triangle.set(a.point, b.point, c.point);
    _triangle.getNormal(this.normal);
    _triangle.getMidpoint(this.midpoint);
    this.area = _triangle.getArea();
    this.constant = this.normal.dot(this.midpoint);
    return this;
  }
  distanceToPoint(point) {
    return this.normal.dot(point) - this.constant;
  }
};
var HalfEdge = class {
  constructor(vertex, face) {
    this.vertex = vertex;
    this.prev = null;
    this.next = null;
    this.twin = null;
    this.face = face;
  }
  head() {
    return this.vertex;
  }
  tail() {
    return this.prev ? this.prev.vertex : null;
  }
  length() {
    const head = this.head();
    const tail = this.tail();
    if (tail !== null) {
      return tail.point.distanceTo(head.point);
    }
    return -1;
  }
  lengthSquared() {
    const head = this.head();
    const tail = this.tail();
    if (tail !== null) {
      return tail.point.distanceToSquared(head.point);
    }
    return -1;
  }
  setTwin(edge) {
    this.twin = edge;
    edge.twin = this;
    return this;
  }
};
var VertexNode = class {
  constructor(point) {
    this.point = point;
    this.prev = null;
    this.next = null;
    this.face = null;
  }
};
var VertexList = class {
  constructor() {
    this.head = null;
    this.tail = null;
  }
  first() {
    return this.head;
  }
  last() {
    return this.tail;
  }
  clear() {
    this.head = this.tail = null;
    return this;
  }
  // Inserts a vertex before the target vertex
  insertBefore(target, vertex) {
    vertex.prev = target.prev;
    vertex.next = target;
    if (vertex.prev === null) {
      this.head = vertex;
    } else {
      vertex.prev.next = vertex;
    }
    target.prev = vertex;
    return this;
  }
  // Inserts a vertex after the target vertex
  insertAfter(target, vertex) {
    vertex.prev = target;
    vertex.next = target.next;
    if (vertex.next === null) {
      this.tail = vertex;
    } else {
      vertex.next.prev = vertex;
    }
    target.next = vertex;
    return this;
  }
  // Appends a vertex to the end of the linked list
  append(vertex) {
    if (this.head === null) {
      this.head = vertex;
    } else {
      this.tail.next = vertex;
    }
    vertex.prev = this.tail;
    vertex.next = null;
    this.tail = vertex;
    return this;
  }
  // Appends a chain of vertices where 'vertex' is the head.
  appendChain(vertex) {
    if (this.head === null) {
      this.head = vertex;
    } else {
      this.tail.next = vertex;
    }
    vertex.prev = this.tail;
    while (vertex.next !== null) {
      vertex = vertex.next;
    }
    this.tail = vertex;
    return this;
  }
  // Removes a vertex from the linked list
  remove(vertex) {
    if (vertex.prev === null) {
      this.head = vertex.next;
    } else {
      vertex.prev.next = vertex.next;
    }
    if (vertex.next === null) {
      this.tail = vertex.prev;
    } else {
      vertex.next.prev = vertex.prev;
    }
    return this;
  }
  // Removes a list of vertices whose 'head' is 'a' and whose 'tail' is b
  removeSubList(a, b) {
    if (a.prev === null) {
      this.head = b.next;
    } else {
      a.prev.next = b.next;
    }
    if (b.next === null) {
      this.tail = a.prev;
    } else {
      b.next.prev = a.prev;
    }
    return this;
  }
  isEmpty() {
    return this.head === null;
  }
};
var colVal = [2, 2, 1];
var rowVal = [1, 0, 0];
function getElementIndex(column, row) {
  return column * 3 + row;
}
function frobeniusNorm(matrix) {
  const e = matrix.elements;
  let norm = 0;
  for (let i = 0; i < 9; i++) {
    norm += e[i] * e[i];
  }
  return Math.sqrt(norm);
}
function offDiagonalFrobeniusNorm(source) {
  const e = source.elements;
  let norm = 0;
  for (let i = 0; i < 3; i++) {
    const t = e[getElementIndex(colVal[i], rowVal[i])];
    norm += 2 * t * t;
  }
  return Math.sqrt(norm);
}
function shurDecomposition(source, result) {
  let maxDiagonal = 0;
  let rotAxis = 1;
  const e = source.elements;
  for (let i = 0; i < 3; i++) {
    const t = Math.abs(e[getElementIndex(colVal[i], rowVal[i])]);
    if (t > maxDiagonal) {
      maxDiagonal = t;
      rotAxis = i;
    }
  }
  let c = 1;
  let s = 0;
  const p = rowVal[rotAxis];
  const q = colVal[rotAxis];
  if (Math.abs(e[getElementIndex(q, p)]) > Number.EPSILON) {
    const qq = e[getElementIndex(q, q)];
    const pp = e[getElementIndex(p, p)];
    const qp = e[getElementIndex(q, p)];
    const tau = (qq - pp) / 2 / qp;
    let t;
    if (tau < 0) {
      t = -1 / (-tau + Math.sqrt(1 + tau * tau));
    } else {
      t = 1 / (tau + Math.sqrt(1 + tau * tau));
    }
    c = 1 / Math.sqrt(1 + t * t);
    s = t * c;
  }
  result.identity();
  result.elements[getElementIndex(p, p)] = c;
  result.elements[getElementIndex(q, q)] = c;
  result.elements[getElementIndex(q, p)] = s;
  result.elements[getElementIndex(p, q)] = -s;
  return result;
}
function eigenDecomposition(source, result) {
  let count = 0;
  let sweep = 0;
  const maxSweeps = 10;
  result.unitary.identity();
  result.diagonal.copy(source);
  const unitaryMatrix = result.unitary;
  const diagonalMatrix = result.diagonal;
  const m1 = new Matrix3();
  const m2 = new Matrix3();
  const epsilon = Number.EPSILON * frobeniusNorm(diagonalMatrix);
  while (sweep < maxSweeps && offDiagonalFrobeniusNorm(diagonalMatrix) > epsilon) {
    shurDecomposition(diagonalMatrix, m1);
    m2.copy(m1).transpose();
    diagonalMatrix.multiply(m1);
    diagonalMatrix.premultiply(m2);
    unitaryMatrix.multiply(m1);
    if (++count > 2) {
      sweep++;
      count = 0;
    }
  }
  return result;
}
function obbFromPoints(vertices) {
  const points = [];
  for (let i = 0; i < vertices.length - 2; i += 3) {
    const x2 = vertices[i];
    const y2 = vertices[i + 1];
    const z2 = vertices[i + 2];
    points.push(new Vector3(x2, y2, z2));
  }
  const convexHull = new ConvexHull();
  convexHull.setFromPoints(points);
  const eigenDecomposed = {
    unitary: new Matrix3(),
    diagonal: new Matrix3()
  };
  const faces = convexHull.faces;
  const edges = [];
  const triangles = [];
  for (let i = 0, il = faces.length; i < il; i++) {
    const face = faces[i];
    let edge = face.edge;
    edges.length = 0;
    do {
      edges.push(edge);
      edge = edge.next;
    } while (edge !== face.edge);
    const triangleCount = edges.length - 2;
    for (let j = 1, jl = triangleCount; j <= jl; j++) {
      const v12 = edges[0].vertex;
      const v22 = edges[j + 0].vertex;
      const v32 = edges[j + 1].vertex;
      triangles.push(v12.point.x, v12.point.y, v12.point.z);
      triangles.push(v22.point.x, v22.point.y, v22.point.z);
      triangles.push(v32.point.x, v32.point.y, v32.point.z);
    }
  }
  const p = new Vector3();
  const q = new Vector3();
  const r = new Vector3();
  const qp = new Vector3();
  const rp = new Vector3();
  const v = new Vector3();
  const mean = new Vector3();
  const weightedMean = new Vector3();
  let areaSum = 0;
  let cxx = 0;
  let cxy = 0;
  let cxz = 0;
  let cyy = 0;
  let cyz = 0;
  let czz = 0;
  for (let i = 0, l = triangles.length; i < l; i += 9) {
    p.fromArray(triangles, i);
    q.fromArray(triangles, i + 3);
    r.fromArray(triangles, i + 6);
    mean.set(0, 0, 0);
    mean.add(p).add(q).add(r).divideScalar(3);
    qp.subVectors(q, p);
    rp.subVectors(r, p);
    const area2 = v.crossVectors(qp, rp).length() / 2;
    weightedMean.add(v.copy(mean).multiplyScalar(area2));
    areaSum += area2;
    cxx += (9 * mean.x * mean.x + p.x * p.x + q.x * q.x + r.x * r.x) * (area2 / 12);
    cxy += (9 * mean.x * mean.y + p.x * p.y + q.x * q.y + r.x * r.y) * (area2 / 12);
    cxz += (9 * mean.x * mean.z + p.x * p.z + q.x * q.z + r.x * r.z) * (area2 / 12);
    cyy += (9 * mean.y * mean.y + p.y * p.y + q.y * q.y + r.y * r.y) * (area2 / 12);
    cyz += (9 * mean.y * mean.z + p.y * p.z + q.y * q.z + r.y * r.z) * (area2 / 12);
    czz += (9 * mean.z * mean.z + p.z * p.z + q.z * q.z + r.z * r.z) * (area2 / 12);
  }
  weightedMean.divideScalar(areaSum);
  cxx /= areaSum;
  cxy /= areaSum;
  cxz /= areaSum;
  cyy /= areaSum;
  cyz /= areaSum;
  czz /= areaSum;
  cxx -= weightedMean.x * weightedMean.x;
  cxy -= weightedMean.x * weightedMean.y;
  cxz -= weightedMean.x * weightedMean.z;
  cyy -= weightedMean.y * weightedMean.y;
  cyz -= weightedMean.y * weightedMean.z;
  czz -= weightedMean.z * weightedMean.z;
  const covarianceMatrix = new Matrix3();
  covarianceMatrix.elements[0] = cxx;
  covarianceMatrix.elements[1] = cxy;
  covarianceMatrix.elements[2] = cxz;
  covarianceMatrix.elements[3] = cxy;
  covarianceMatrix.elements[4] = cyy;
  covarianceMatrix.elements[5] = cyz;
  covarianceMatrix.elements[6] = cxz;
  covarianceMatrix.elements[7] = cyz;
  covarianceMatrix.elements[8] = czz;
  eigenDecomposition(covarianceMatrix, eigenDecomposed);
  const unitary = eigenDecomposed.unitary;
  const v1 = new Vector3();
  const v2 = new Vector3();
  const v3 = new Vector3();
  unitary.extractBasis(v1, v2, v3);
  let u1 = -Infinity;
  let u2 = -Infinity;
  let u3 = -Infinity;
  let l1 = Infinity;
  let l2 = Infinity;
  let l3 = Infinity;
  for (let i = 0, l = points.length; i < l; i++) {
    const p2 = points[i];
    u1 = Math.max(v1.dot(p2), u1);
    u2 = Math.max(v2.dot(p2), u2);
    u3 = Math.max(v3.dot(p2), u3);
    l1 = Math.min(v1.dot(p2), l1);
    l2 = Math.min(v2.dot(p2), l2);
    l3 = Math.min(v3.dot(p2), l3);
  }
  v1.multiplyScalar(0.5 * (l1 + u1));
  v2.multiplyScalar(0.5 * (l2 + u2));
  v3.multiplyScalar(0.5 * (l3 + u3));
  const center = new Vector3();
  const halfSizes = new Vector3();
  const rotation = new Matrix3();
  center.add(v1).add(v2).add(v3);
  halfSizes.x = u1 - l1;
  halfSizes.y = u2 - l2;
  halfSizes.z = u3 - l3;
  halfSizes.multiplyScalar(0.5);
  rotation.copy(unitary);
  const { x, y, z } = halfSizes;
  const scale = new Matrix4();
  scale.makeScale(x * 2, y * 2, z * 2);
  const offset = new Matrix4();
  offset.makeTranslation(-x, -y, -z);
  const translation = new Matrix4();
  translation.makeTranslation(center.x, center.y, center.z);
  const rot = new Matrix4();
  rot.setFromMatrix3(rotation);
  const transformation = new Matrix4();
  transformation.multiply(translation);
  transformation.multiply(rot);
  transformation.multiply(offset);
  transformation.multiply(scale);
  return { center, halfSizes, rotation, transformation };
}
function isPointInFrontOfPlane(point, planePoint, planeNormal) {
  const vectorToPlane = [
    point[0] - planePoint[0],
    point[1] - planePoint[1],
    point[2] - planePoint[2]
  ];
  const dotProduct = planeNormal[0] * vectorToPlane[0] + planeNormal[1] * vectorToPlane[1] + planeNormal[2] * vectorToPlane[2];
  return dotProduct > 0;
}
var MaterialsUtils = class {
  static isTransparent(material) {
    return material.transparent && material.opacity < 1;
  }
};
var _UUID = class _UUID2 {
  // Copied from three.js source
  // Original source: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
  static create() {
    const d0 = Math.random() * 4294967295 | 0;
    const d1 = Math.random() * 4294967295 | 0;
    const d2 = Math.random() * 4294967295 | 0;
    const d3 = Math.random() * 4294967295 | 0;
    const uuid = `${_UUID2._lut[d0 & 255] + _UUID2._lut[d0 >> 8 & 255] + _UUID2._lut[d0 >> 16 & 255] + _UUID2._lut[d0 >> 24 & 255]}-${_UUID2._lut[d1 & 255]}${_UUID2._lut[d1 >> 8 & 255]}-${_UUID2._lut[d1 >> 16 & 15 | 64]}${_UUID2._lut[d1 >> 24 & 255]}-${_UUID2._lut[d2 & 63 | 128]}${_UUID2._lut[d2 >> 8 & 255]}-${_UUID2._lut[d2 >> 16 & 255]}${_UUID2._lut[d2 >> 24 & 255]}${_UUID2._lut[d3 & 255]}${_UUID2._lut[d3 >> 8 & 255]}${_UUID2._lut[d3 >> 16 & 255]}${_UUID2._lut[d3 >> 24 & 255]}`;
    return uuid.toLowerCase();
  }
  static validate(uuid) {
    if (!_UUID2._pattern.test(uuid))
      throw new Error(
        `${uuid} is not a valid UUID v4.

- If you're the tool creator, you can take one from https://www.uuidgenerator.net/.

- If you're using a platform tool, verify the uuid isn't misspelled or contact the tool creator.`
      );
  }
};
__publicField2(_UUID, "_pattern", /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-4[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/);
__publicField2(_UUID, "_lut", [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff"
]);
var UUID = _UUID;
var VertexPicker = class extends Component {
  constructor(components, config) {
    super(components);
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "onVertexFound", new Event());
    __publicField2(this, "onVertexLost", new Event());
    __publicField2(this, "onEnabled", new Event());
    __publicField2(this, "components");
    __publicField2(this, "workingPlane", null);
    __publicField2(this, "_pickedPoint", null);
    __publicField2(this, "_config");
    __publicField2(this, "_enabled", false);
    this.components = components;
    this.config = {
      snapDistance: 0.25,
      showOnlyVertex: false,
      ...config
    };
    this.enabled = false;
  }
  /**
   * Sets the enabled state of the VertexPicker.
   * When enabled, the VertexPicker will actively search for vertices in the 3D scene.
   * When disabled, the VertexPicker will stop searching for vertices and reset the picked point.
   *
   * @param value - The new enabled state.
   */
  set enabled(value) {
    this._enabled = value;
    if (!value) {
      this._pickedPoint = null;
    }
    this.onEnabled.trigger(value);
  }
  /**
   * Gets the current enabled state of the VertexPicker.
   *
   * @returns The current enabled state.
   */
  get enabled() {
    return this._enabled;
  }
  /**
   * Sets the configuration for the VertexPicker component.
   *
   * @param value - A Partial object containing the configuration properties to update.
   * The properties not provided in the value object will retain their current values.
   *
   * @example
   * ```typescript
   * vertexPicker.config = {
   *   snapDistance: 0.5,
   *   showOnlyVertex: true,
   * };
   * ```
   */
  set config(value) {
    this._config = { ...this._config, ...value };
  }
  /**
   * Gets the current configuration for the VertexPicker component.
   *
   * @returns A copy of the current VertexPickerConfig object.
   *
   * @example
   * ```typescript
   * const currentConfig = vertexPicker.config;
   * console.log(currentConfig.snapDistance); // Output: 0.25
   * ```
   */
  get config() {
    return this._config;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.onVertexFound.reset();
    this.onVertexLost.reset();
    this.components = null;
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  /**
   * Performs the vertex picking operation based on the current state of the VertexPicker.
   *
   * @param world - The World instance to use for raycasting.
   *
   * @returns The current picked point, or null if no point is picked.
   *
   * @remarks
   * This method checks if the VertexPicker is enabled. If not, it returns the current picked point.
   * If enabled, it performs raycasting to find the closest intersecting object.
   * It then determines the closest vertex or point on the face, based on the configuration settings.
   * If the picked point is on the working plane (if defined), it triggers the `onVertexFound` event and updates the `pickedPoint`.
   * If the picked point is not on the working plane, it resets the `pickedPoint`.
   * If no intersecting object is found, it triggers the `onVertexLost` event and resets the `pickedPoint`.
   */
  get(world) {
    if (!this.enabled)
      return this._pickedPoint;
    const casters = this.components.get(Raycasters);
    const caster = casters.get(world);
    const intersects2 = caster.castRay();
    if (!intersects2) {
      if (this._pickedPoint !== null) {
        this.onVertexLost.trigger();
        this._pickedPoint = null;
      }
      return this._pickedPoint;
    }
    const point = this.getClosestVertex(intersects2);
    if (!point) {
      if (this._pickedPoint !== null) {
        this.onVertexLost.trigger();
        this._pickedPoint = null;
      }
      return this._pickedPoint;
    }
    const isOnPlane = !this.workingPlane ? true : Math.abs(this.workingPlane.distanceToPoint(point)) < 1e-3;
    if (!isOnPlane) {
      this._pickedPoint = null;
      return this._pickedPoint;
    }
    if (this._pickedPoint === null || !this._pickedPoint.equals(point)) {
      this._pickedPoint = point.clone();
      this.onVertexFound.trigger(this._pickedPoint);
    }
    return this._pickedPoint;
  }
  getClosestVertex(intersects2) {
    let closestVertex = new Vector3();
    let vertexFound = false;
    let closestDistance = Number.MAX_SAFE_INTEGER;
    const vertices = this.getVertices(intersects2);
    if (vertices === null) {
      return null;
    }
    for (const vertex of vertices) {
      if (!vertex) {
        continue;
      }
      const distance = intersects2.point.distanceTo(vertex);
      if (distance > closestDistance || distance > this._config.snapDistance) {
        continue;
      }
      vertexFound = true;
      closestVertex = vertex;
      closestDistance = intersects2.point.distanceTo(vertex);
    }
    if (vertexFound) {
      return closestVertex;
    }
    return this.config.showOnlyVertex ? null : intersects2.point;
  }
  getVertices(intersects2) {
    const mesh = intersects2.object;
    if (!intersects2.face || !mesh)
      return null;
    const geom = mesh.geometry;
    const instanceTransform = new Matrix4();
    const { instanceId } = intersects2;
    const instanceFound = instanceId !== void 0;
    const isInstance = mesh instanceof InstancedMesh;
    if (isInstance && instanceFound) {
      mesh.getMatrixAt(instanceId, instanceTransform);
    }
    return [
      this.getVertex(intersects2.face.a, geom),
      this.getVertex(intersects2.face.b, geom),
      this.getVertex(intersects2.face.c, geom)
    ].map((vertex) => {
      if (vertex) {
        if (isInstance && instanceFound) {
          vertex.applyMatrix4(instanceTransform);
        }
        vertex.applyMatrix4(mesh.matrixWorld);
      }
      return vertex;
    });
  }
  getVertex(index, geom) {
    if (index === void 0)
      return null;
    const vertices = geom.attributes.position;
    return new Vector3(
      vertices.getX(index),
      vertices.getY(index),
      vertices.getZ(index)
    );
  }
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var earcut$2 = { exports: {} };
earcut$2.exports = earcut;
earcut$2.exports.default = earcut;
function earcut(data, holeIndices, dim) {
  dim = dim || 2;
  var hasHoles = holeIndices && holeIndices.length, outerLen = hasHoles ? holeIndices[0] * dim : data.length, outerNode = linkedList(data, 0, outerLen, dim, true), triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev)
    return triangles;
  var minX, minY, maxX, maxY, x, y, invSize;
  if (hasHoles)
    outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
  if (data.length > 80 * dim) {
    minX = maxX = data[0];
    minY = maxY = data[1];
    for (var i = dim; i < outerLen; i += dim) {
      x = data[i];
      y = data[i + 1];
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (x > maxX)
        maxX = x;
      if (y > maxY)
        maxY = y;
    }
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 32767 / invSize : 0;
  }
  earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
  return triangles;
}
function linkedList(data, start, end, dim, clockwise) {
  var i, last;
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim)
      last = insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim)
      last = insertNode(i, data[i], data[i + 1], last);
  }
  if (last && equals(last, last.next)) {
    removeNode(last);
    last = last.next;
  }
  return last;
}
function filterPoints(start, end) {
  if (!start)
    return start;
  if (!end)
    end = start;
  var p = start, again;
  do {
    again = false;
    if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
      removeNode(p);
      p = end = p.prev;
      if (p === p.next)
        break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear)
    return;
  if (!pass && invSize)
    indexCurve(ear, minX, minY, invSize);
  var stop = ear, prev, next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim | 0);
      triangles.push(ear.i / dim | 0);
      triangles.push(next.i / dim | 0);
      removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
}
function isEar(ear) {
  var a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0)
    return false;
  var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
  var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  var p = c.next;
  while (p !== a) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.next;
  }
  return true;
}
function isEarHashed(ear, minX, minY, invSize) {
  var a = ear.prev, b = ear, c = ear.next;
  if (area(a, b, c) >= 0)
    return false;
  var ax = a.x, bx = b.x, cx = c.x, ay = a.y, by = b.y, cy = c.y;
  var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx, y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy, x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx, y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
  var minZ = zOrder(x0, y0, minX, minY, invSize), maxZ = zOrder(x1, y1, minX, minY, invSize);
  var p = ear.prevZ, n = ear.nextZ;
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  while (p && p.z >= minZ) {
    if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  return true;
}
function cureLocalIntersections(start, triangles, dim) {
  var p = start;
  do {
    var a = p.prev, b = p.next.next;
    if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
      triangles.push(a.i / dim | 0);
      triangles.push(p.i / dim | 0);
      triangles.push(b.i / dim | 0);
      removeNode(p);
      removeNode(p.next);
      p = start = b;
    }
    p = p.next;
  } while (p !== start);
  return filterPoints(p);
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  var a = start;
  do {
    var b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        var c = splitPolygon(a, b);
        a = filterPoints(a, a.next);
        c = filterPoints(c, c.next);
        earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
        earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start);
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  var queue = [], i, len, start, end, list;
  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = linkedList(data, start, end, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(getLeftmost(list));
  }
  queue.sort(compareX);
  for (i = 0; i < queue.length; i++) {
    outerNode = eliminateHole(queue[i], outerNode);
  }
  return outerNode;
}
function compareX(a, b) {
  return a.x - b.x;
}
function eliminateHole(hole, outerNode) {
  var bridge = findHoleBridge(hole, outerNode);
  if (!bridge) {
    return outerNode;
  }
  var bridgeReverse = splitPolygon(bridge, hole);
  filterPoints(bridgeReverse, bridgeReverse.next);
  return filterPoints(bridge, bridge.next);
}
function findHoleBridge(hole, outerNode) {
  var p = outerNode, hx = hole.x, hy = hole.y, qx = -Infinity, m;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        m = p.x < p.next.x ? p : p.next;
        if (x === hx)
          return m;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m)
    return null;
  var stop = m, mx = m.x, my = m.y, tanMin = Infinity, tan;
  p = m;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x);
      if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
        m = p;
        tanMin = tan;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m;
}
function sectorContainsSector(m, p) {
  return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
}
function indexCurve(start, minX, minY, invSize) {
  var p = start;
  do {
    if (p.z === 0)
      p.z = zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  sortLinked(p);
}
function sortLinked(list) {
  var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || qSize > 0 && q) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e;
        else
          list = e;
        e.prevZ = tail;
        tail = e;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
}
function zOrder(x, y, minX, minY, invSize) {
  x = (x - minX) * invSize | 0;
  y = (y - minY) * invSize | 0;
  x = (x | x << 8) & 16711935;
  x = (x | x << 4) & 252645135;
  x = (x | x << 2) & 858993459;
  x = (x | x << 1) & 1431655765;
  y = (y | y << 8) & 16711935;
  y = (y | y << 4) & 252645135;
  y = (y | y << 2) & 858993459;
  y = (y | y << 1) & 1431655765;
  return x | y << 1;
}
function getLeftmost(start) {
  var p = start, leftmost = start;
  do {
    if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y)
      leftmost = p;
    p = p.next;
  } while (p !== start);
  return leftmost;
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
}
function isValidDiagonal(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges
  (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible
  (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors
  equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0);
}
function area(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
}
function intersects(p1, q1, p2, q2) {
  var o1 = sign(area(p1, q1, p2));
  var o2 = sign(area(p1, q1, q2));
  var o3 = sign(area(p2, q2, p1));
  var o4 = sign(area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && onSegment(p2, q1, q2))
    return true;
  return false;
}
function onSegment(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
}
function intersectsPolygon(a, b) {
  var p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b))
      return true;
    p = p.next;
  } while (p !== a);
  return false;
}
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}
function middleInside(a, b) {
  var p = a, inside = false, px = (a.x + b.x) / 2, py = (a.y + b.y) / 2;
  do {
    if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x)
      inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
}
function splitPolygon(a, b) {
  var a2 = new Node(a.i, a.x, a.y), b2 = new Node(b.i, b.x, b.y), an = a.next, bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
}
function insertNode(i, x, y, last) {
  var p = new Node(i, x, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
}
function removeNode(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ)
    p.prevZ.nextZ = p.nextZ;
  if (p.nextZ)
    p.nextZ.prevZ = p.prevZ;
}
function Node(i, x, y) {
  this.i = i;
  this.x = x;
  this.y = y;
  this.prev = null;
  this.next = null;
  this.z = 0;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
}
earcut.deviation = function(data, holeIndices, dim, triangles) {
  var hasHoles = holeIndices && holeIndices.length;
  var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
  var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
  if (hasHoles) {
    for (var i = 0, len = holeIndices.length; i < len; i++) {
      var start = holeIndices[i] * dim;
      var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      polygonArea -= Math.abs(signedArea(data, start, end, dim));
    }
  }
  var trianglesArea = 0;
  for (i = 0; i < triangles.length; i += 3) {
    var a = triangles[i] * dim;
    var b = triangles[i + 1] * dim;
    var c = triangles[i + 2] * dim;
    trianglesArea += Math.abs(
      (data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1])
    );
  }
  return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
};
function signedArea(data, start, end, dim) {
  var sum = 0;
  for (var i = start, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }
  return sum;
}
earcut.flatten = function(data) {
  var dim = data[0][0].length, result = { vertices: [], holes: [], dimensions: dim }, holeIndex = 0;
  for (var i = 0; i < data.length; i++) {
    for (var j = 0; j < data[i].length; j++) {
      for (var d = 0; d < dim; d++)
        result.vertices.push(data[i][j][d]);
    }
    if (i > 0) {
      holeIndex += data[i - 1].length;
      result.holes.push(holeIndex);
    }
  }
  return result;
};
var earcutExports = earcut$2.exports;
var earcut$1 = getDefaultExportFromCjs(earcutExports);
var SectionGenerator = class extends Component {
  constructor() {
    super(...arguments);
    __publicField2(this, "enabled", true);
    __publicField2(this, "_inverseMatrix", new Matrix4());
    __publicField2(this, "_localPlane", new Plane());
    __publicField2(this, "_tempLine", new Line3());
    __publicField2(this, "_tempVector", new Vector3());
    __publicField2(this, "_plane");
    __publicField2(this, "_plane2DCoordinateSystem", new Matrix4());
    __publicField2(this, "_precission", 1e4);
    __publicField2(this, "_planeAxis");
  }
  get plane() {
    if (!this._plane) {
      throw new Error("Plane not set");
    }
    return this._plane;
  }
  set plane(plane) {
    this._plane = plane;
  }
  // This assumes that the mesh that contains the posAttr is aligned with the current plane
  createEdges(data) {
    const { meshes, posAttr } = data;
    let index = 0;
    posAttr.array.fill(0);
    const indexes = [];
    let lastIndex = 0;
    const tempMesh = new Mesh();
    for (const mesh of meshes) {
      if (!mesh.geometry) {
        continue;
      }
      if (!mesh.geometry.boundsTree) {
        mesh.geometry.computeBoundsTree();
      }
      if (!mesh.geometry.boundsTree) {
        throw new Error("Bounds tree not found for edges generation.");
      }
      if (mesh instanceof InstancedMesh) {
        if (mesh.count === 0) {
          continue;
        }
        const instanced = mesh;
        for (let i = 0; i < instanced.count; i++) {
          tempMesh.geometry = mesh.geometry;
          tempMesh.matrix.copy(mesh.matrix);
          const tempMatrix22 = new Matrix4();
          instanced.getMatrixAt(i, tempMatrix22);
          tempMesh.applyMatrix4(tempMatrix22);
          tempMesh.applyMatrix4(mesh.matrixWorld);
          tempMesh.updateMatrix();
          tempMesh.updateMatrixWorld();
          this._inverseMatrix.copy(tempMesh.matrixWorld).invert();
          this._localPlane.copy(this.plane).applyMatrix4(this._inverseMatrix);
          index = this.shapecast(tempMesh, posAttr, index);
          if (index !== lastIndex) {
            indexes.push(index);
            lastIndex = index;
          }
        }
      } else {
        this._inverseMatrix.copy(mesh.matrixWorld).invert();
        this._localPlane.copy(this.plane).applyMatrix4(this._inverseMatrix);
        index = this.shapecast(mesh, posAttr, index);
        if (index !== lastIndex) {
          indexes.push(index);
          lastIndex = index;
        }
      }
    }
    return { indexes, index };
  }
  createFills(buffer, trianglesIndices) {
    this.updatePlane2DCoordinateSystem();
    const allIndices = [];
    let currentTriangle = 0;
    for (let i = 0; i < trianglesIndices.length; i++) {
      const nextTriangle = trianglesIndices[i];
      const vertices = [];
      for (let j = currentTriangle; j < nextTriangle; j += 2) {
        vertices.push(j * 3);
      }
      const indices = this.computeFill(vertices, buffer);
      for (const index of indices) {
        allIndices.push(index);
      }
      currentTriangle = nextTriangle;
    }
    return allIndices;
  }
  computeFill(vertices, buffer) {
    const indices = /* @__PURE__ */ new Map();
    const all2DVertices = {};
    const shapes = /* @__PURE__ */ new Map();
    let nextShapeID = 0;
    const shapesEnds = /* @__PURE__ */ new Map();
    const shapesStarts = /* @__PURE__ */ new Map();
    const openShapes = /* @__PURE__ */ new Set();
    const p = this._precission;
    for (let i = 0; i < vertices.length; i++) {
      const startVertexIndex = vertices[i];
      let x1 = 0;
      let y1 = 0;
      let x2 = 0;
      let y2 = 0;
      const globalX1 = buffer[startVertexIndex];
      const globalY1 = buffer[startVertexIndex + 1];
      const globalZ1 = buffer[startVertexIndex + 2];
      const globalX2 = buffer[startVertexIndex + 3];
      const globalY2 = buffer[startVertexIndex + 4];
      const globalZ2 = buffer[startVertexIndex + 5];
      this._tempVector.set(globalX1, globalY1, globalZ1);
      this._tempVector.applyMatrix4(this._plane2DCoordinateSystem);
      x1 = Math.trunc(this._tempVector.x * p) / p;
      y1 = Math.trunc(this._tempVector.y * p) / p;
      this._tempVector.set(globalX2, globalY2, globalZ2);
      this._tempVector.applyMatrix4(this._plane2DCoordinateSystem);
      x2 = Math.trunc(this._tempVector.x * p) / p;
      y2 = Math.trunc(this._tempVector.y * p) / p;
      if (x1 === x2 && y1 === y2) {
        continue;
      }
      const startCode = `${x1}|${y1}`;
      const endCode = `${x2}|${y2}`;
      if (!indices.has(startCode)) {
        indices.set(startCode, startVertexIndex / 3);
      }
      if (!indices.has(endCode)) {
        indices.set(endCode, startVertexIndex / 3 + 1);
      }
      const start = indices.get(startCode);
      const end = indices.get(endCode);
      all2DVertices[start] = [x1, y1];
      all2DVertices[end] = [x2, y2];
      const startMatchesStart = shapesStarts.has(start);
      const startMatchesEnd = shapesEnds.has(start);
      const endMatchesStart = shapesStarts.has(end);
      const endMatchesEnd = shapesEnds.has(end);
      const noMatches = !startMatchesStart && !startMatchesEnd && !endMatchesStart && !endMatchesEnd;
      if (noMatches) {
        shapesStarts.set(start, nextShapeID);
        shapesEnds.set(end, nextShapeID);
        openShapes.add(nextShapeID);
        shapes.set(nextShapeID, [start, end]);
        nextShapeID++;
      } else if (startMatchesStart && endMatchesEnd) {
        const startIndex = shapesStarts.get(start);
        const endIndex = shapesEnds.get(end);
        const isShapeMerge = startIndex !== endIndex;
        if (isShapeMerge) {
          const endShape = shapes.get(endIndex);
          const startShape = shapes.get(startIndex);
          if (!endShape || !startShape) {
            continue;
          }
          shapes.delete(startIndex);
          openShapes.delete(startIndex);
          shapesEnds.set(startShape[startShape.length - 1], endIndex);
          shapesEnds.delete(endShape[endShape.length - 1]);
          for (const index of startShape) {
            endShape.push(index);
          }
        } else {
          openShapes.delete(endIndex);
        }
        shapesStarts.delete(start);
        shapesEnds.delete(end);
      } else if (startMatchesEnd && endMatchesStart) {
        const startIndex = shapesStarts.get(end);
        const endIndex = shapesEnds.get(start);
        const isShapeMerge = startIndex !== endIndex;
        if (isShapeMerge) {
          const endShape = shapes.get(endIndex);
          const startShape = shapes.get(startIndex);
          if (!endShape || !startShape) {
            continue;
          }
          shapes.delete(startIndex);
          openShapes.delete(startIndex);
          shapesEnds.set(startShape[startShape.length - 1], endIndex);
          shapesEnds.delete(endShape[endShape.length - 1]);
          for (const index of startShape) {
            endShape.push(index);
          }
        } else {
          openShapes.delete(endIndex);
        }
        shapesStarts.delete(end);
        shapesEnds.delete(start);
      } else if (startMatchesStart && endMatchesStart) {
        const startIndex1 = shapesStarts.get(end);
        const startIndex2 = shapesStarts.get(start);
        const startShape2 = shapes.get(startIndex2);
        const startShape1 = shapes.get(startIndex1);
        if (!startShape2 || !startShape1) {
          continue;
        }
        shapes.delete(startIndex1);
        openShapes.delete(startIndex1);
        shapesStarts.delete(startShape2[0]);
        shapesStarts.delete(startShape1[0]);
        shapesEnds.delete(startShape1[startShape1.length - 1]);
        shapesStarts.set(startShape1[startShape1.length - 1], startIndex2);
        startShape1.reverse();
        startShape2.splice(0, 0, ...startShape1);
      } else if (startMatchesEnd && endMatchesEnd) {
        const endIndex1 = shapesEnds.get(end);
        const endIndex2 = shapesEnds.get(start);
        const endShape2 = shapes.get(endIndex2);
        const endShape1 = shapes.get(endIndex1);
        if (!endShape2 || !endShape1) {
          continue;
        }
        shapes.delete(endIndex1);
        openShapes.delete(endIndex1);
        shapesEnds.delete(endShape2[endShape2.length - 1]);
        shapesEnds.delete(endShape1[endShape1.length - 1]);
        shapesStarts.delete(endShape1[0]);
        shapesEnds.set(endShape1[0], endIndex2);
        endShape1.reverse();
        endShape2.push(...endShape1);
      } else if (startMatchesStart) {
        const shapeIndex = shapesStarts.get(start);
        const shape = shapes.get(shapeIndex);
        if (!shape) {
          continue;
        }
        shape.unshift(end);
        shapesStarts.delete(start);
        shapesStarts.set(end, shapeIndex);
      } else if (startMatchesEnd) {
        const shapeIndex = shapesEnds.get(start);
        const shape = shapes.get(shapeIndex);
        if (!shape) {
          continue;
        }
        shape.push(end);
        shapesEnds.delete(start);
        shapesEnds.set(end, shapeIndex);
      } else if (endMatchesStart) {
        const shapeIndex = shapesStarts.get(end);
        const shape = shapes.get(shapeIndex);
        if (!shape) {
          continue;
        }
        shape.unshift(start);
        shapesStarts.delete(end);
        shapesStarts.set(start, shapeIndex);
      } else if (endMatchesEnd) {
        const shapeIndex = shapesEnds.get(end);
        const shape = shapes.get(shapeIndex);
        if (!shape) {
          continue;
        }
        shape.push(start);
        shapesEnds.delete(end);
        shapesEnds.set(start, shapeIndex);
      }
    }
    const trueIndices = [];
    for (const [id, shape] of shapes) {
      if (openShapes.has(id)) {
        continue;
      }
      const vertices2 = [];
      const indexMap = /* @__PURE__ */ new Map();
      let counter = 0;
      for (const index of shape) {
        const vertex = all2DVertices[index];
        vertices2.push(vertex[0], vertex[1]);
        indexMap.set(counter++, index);
      }
      const result = earcut$1(vertices2);
      for (const index of result) {
        const trueIndex = indexMap.get(index);
        if (trueIndex === void 0) {
          throw new Error("Map error!");
        }
        trueIndices.push(trueIndex);
      }
    }
    return trueIndices;
  }
  updatePlane2DCoordinateSystem() {
    this._plane2DCoordinateSystem = new Matrix4();
    const xAxis = new Vector3(1, 0, 0);
    const yAxis = new Vector3(0, 1, 0);
    const zAxis = this.plane.normal;
    const pos = new Vector3();
    this.plane.coplanarPoint(pos);
    if (this._planeAxis === "x") {
      xAxis.crossVectors(yAxis, zAxis);
    } else if (this._planeAxis === "y") {
      yAxis.crossVectors(zAxis, xAxis);
    } else if (this._planeAxis === "z")
      ;
    else {
      xAxis.crossVectors(yAxis, zAxis).normalize();
      yAxis.crossVectors(zAxis, xAxis);
    }
    this._plane2DCoordinateSystem.fromArray([
      xAxis.x,
      xAxis.y,
      xAxis.z,
      0,
      yAxis.x,
      yAxis.y,
      yAxis.z,
      0,
      zAxis.x,
      zAxis.y,
      zAxis.z,
      0,
      pos.x,
      pos.y,
      pos.z,
      1
    ]);
    this._plane2DCoordinateSystem.invert();
  }
  shapecast(mesh, posAttr, index) {
    mesh.geometry.boundsTree.shapecast({
      intersectsBounds: (box) => {
        return this._localPlane.intersectsBox(box);
      },
      // @ts-ignore
      intersectsTriangle: (tri) => {
        let count = 0;
        this._tempLine.start.copy(tri.a);
        this._tempLine.end.copy(tri.b);
        if (this._localPlane.intersectLine(this._tempLine, this._tempVector)) {
          const result = this._tempVector.applyMatrix4(mesh.matrixWorld);
          posAttr.setXYZ(index, result.x, result.y, result.z);
          count++;
          index++;
        }
        this._tempLine.start.copy(tri.b);
        this._tempLine.end.copy(tri.c);
        if (this._localPlane.intersectLine(this._tempLine, this._tempVector)) {
          const result = this._tempVector.applyMatrix4(mesh.matrixWorld);
          posAttr.setXYZ(index, result.x, result.y, result.z);
          count++;
          index++;
        }
        this._tempLine.start.copy(tri.c);
        this._tempLine.end.copy(tri.a);
        if (this._localPlane.intersectLine(this._tempLine, this._tempVector)) {
          const result = this._tempVector.applyMatrix4(mesh.matrixWorld);
          posAttr.setXYZ(index, result.x, result.y, result.z);
          count++;
          index++;
        }
        if (count !== 2) {
          index -= count;
        }
      }
    });
    return index;
  }
};
__publicField2(SectionGenerator, "uuid", "1a193b87-6376-46c8-9e65-62a1576fdb64");
var _Components = class _Components2 {
  constructor() {
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "list", /* @__PURE__ */ new Map());
    __publicField2(this, "enabled", false);
    __publicField2(this, "_clock");
    __publicField2(this, "onInit", new Event());
    __publicField2(this, "update", () => {
      if (!this.enabled)
        return;
      const delta = this._clock.getDelta();
      for (const [_id, component] of this.list) {
        if (component.enabled && component.isUpdateable()) {
          component.update(delta);
        }
      }
      requestAnimationFrame(this.update);
    });
    this._clock = new Clock();
    _Components2.setupBVH();
  }
  /**
   * Adds a component to the list of components.
   * Throws an error if a component with the same UUID already exists.
   *
   * @param uuid - The unique identifier of the component.
   * @param instance - The instance of the component to be added.
   *
   * @throws Will throw an error if a component with the same UUID already exists.
   *
   * @internal
   */
  add(uuid, instance) {
    if (this.list.has(uuid))
      throw new Error(
        `You're trying to add a component that already exists in the components instance. Use Components.get() instead.`
      );
    UUID.validate(uuid);
    this.list.set(uuid, instance);
  }
  /**
   * Retrieves a component instance by its constructor function.
   * If the component does not exist in the list, it will be created and added.
   *
   * @template U - The type of the component to retrieve.
   * @param Component - The constructor function of the component to retrieve.
   *
   * @returns The instance of the requested component.
   *
   * @throws Will throw an error if a component with the same UUID already exists.
   *
   * @internal
   */
  get(Component2) {
    const uuid = Component2.uuid;
    if (!this.list.has(uuid)) {
      const toolInstance = new Component2(this);
      if (!this.list.has(uuid)) {
        this.add(uuid, toolInstance);
      }
      return toolInstance;
    }
    return this.list.get(uuid);
  }
  /**
   * Initializes the Components instance.
   * This method starts the animation loop, sets the enabled flag to true,
   * and calls the update method.
   */
  init() {
    this.enabled = true;
    this._clock.start();
    this.update();
    this.onInit.trigger();
  }
  /**
   * Disposes the memory of all the components and tools of this instance of
   * the library. A memory leak will be created if:
   *
   * - An instance of the library ends up out of scope and this function isn't
   * called. This is especially relevant in Single Page Applications (React,
   * Angular, Vue, etc).
   *
   * - Any of the objects of this instance (meshes, geometries,materials, etc) is
   * referenced by a reference type (object or array).
   *
   * You can learn more about how Three.js handles memory leaks
   * [here](https://threejs.org/docs/#manual/en/introduction/How-to-dispose-of-objects).
   *
   */
  dispose() {
    this.enabled = false;
    for (const [_id, component] of this.list) {
      component.enabled = false;
      if (component.isDisposeable()) {
        component.dispose();
      }
    }
    this._clock.stop();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  static setupBVH() {
    BufferGeometry.prototype.computeBoundsTree = computeBoundsTree2;
    BufferGeometry.prototype.disposeBoundsTree = disposeBoundsTree2;
    Mesh.prototype.raycast = acceleratedRaycast2;
  }
};
__publicField2(_Components, "release", "2.4.5");
var Components = _Components;
var SimpleWorld = class extends Base {
  constructor() {
    super(...arguments);
    __publicField2(this, "meshes", /* @__PURE__ */ new Set());
    __publicField2(this, "onAfterUpdate", new Event());
    __publicField2(this, "onBeforeUpdate", new Event());
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "isDisposing", false);
    __publicField2(this, "enabled", true);
    __publicField2(this, "uuid", UUID.create());
    __publicField2(this, "name");
    __publicField2(this, "_scene");
    __publicField2(this, "_camera");
    __publicField2(this, "_renderer", null);
  }
  /**
   * Getter for the scene. If no scene is initialized, it throws an error.
   * @returns The current scene.
   */
  get scene() {
    if (!this._scene) {
      throw new Error("No scene initialized!");
    }
    return this._scene;
  }
  /**
   * Setter for the scene. It sets the current scene, adds the world to the scene's worlds set,
   * sets the current world in the scene, and triggers the scene's onWorldChanged event with the added action.
   * @param scene - The new scene to be set.
   */
  set scene(scene) {
    this._scene = scene;
    scene.worlds.set(this.uuid, this);
    scene.currentWorld = this;
    scene.onWorldChanged.trigger({ world: this, action: "added" });
  }
  /**
   * Getter for the camera. If no camera is initialized, it throws an error.
   * @returns The current camera.
   */
  get camera() {
    if (!this._camera) {
      throw new Error("No camera initialized!");
    }
    return this._camera;
  }
  /**
   * Setter for the camera. It sets the current camera, adds the world to the camera's worlds set,
   * sets the current world in the camera, and triggers the camera's onWorldChanged event with the added action.
   * @param camera - The new camera to be set.
   */
  set camera(camera) {
    this._camera = camera;
    camera.worlds.set(this.uuid, this);
    camera.currentWorld = this;
    camera.onWorldChanged.trigger({ world: this, action: "added" });
  }
  /**
   * Getter for the renderer.
   * @returns The current renderer or null if no renderer is set. Some worlds don't need a renderer to work (when your mail goal is not to display a 3D viewport to the user).
   */
  get renderer() {
    return this._renderer;
  }
  /**
   * Setter for the renderer. It sets the current renderer, adds the world to the renderer's worlds set,
   * sets the current world in the renderer, and triggers the renderer's onWorldChanged event with the added action.
   * If a new renderer is set, it also triggers the onWorldChanged event with the removed action for the old renderer.
   * @param renderer - The new renderer to be set or null to remove the current renderer.
   */
  set renderer(renderer) {
    this._renderer = renderer;
    if (renderer) {
      renderer.worlds.set(this.uuid, this);
      renderer.currentWorld = this;
      renderer.onWorldChanged.trigger({ world: this, action: "added" });
    }
  }
  /** {@link Updateable.update} */
  update(delta) {
    if (!this.enabled)
      return;
    if (!this._scene || !this._camera) {
      return;
    }
    this.scene.currentWorld = this;
    this.camera.currentWorld = this;
    if (this.renderer) {
      this.renderer.currentWorld = this;
    }
    this.onBeforeUpdate.trigger();
    if (this.scene.isUpdateable()) {
      this.scene.update(delta);
    }
    if (this.camera.isUpdateable()) {
      this.camera.update(delta);
    }
    if (this.renderer) {
      this.renderer.update(delta);
    }
    this.onAfterUpdate.trigger();
  }
  /** {@link Disposable.dispose} */
  dispose(disposeResources = true) {
    this.enabled = false;
    this.isDisposing = true;
    this.scene.onWorldChanged.trigger({ world: this, action: "removed" });
    this.camera.onWorldChanged.trigger({ world: this, action: "removed" });
    if (this.renderer) {
      this.renderer.onWorldChanged.trigger({ world: this, action: "removed" });
    }
    if (disposeResources) {
      const disposer = this.components.get(Disposer);
      this.scene.dispose();
      if (this.camera.isDisposeable()) {
        this.camera.dispose();
      }
      if (this.renderer) {
        this.renderer.dispose();
      }
      for (const mesh of this.meshes) {
        disposer.destroy(mesh);
      }
      this.meshes.clear();
    }
    this._scene = null;
    this._camera = null;
    this._renderer = null;
    const worlds = this.components.get(Worlds);
    worlds.list.delete(this.uuid);
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
};
var Configurator = class {
  constructor(component, components, name, uuid) {
    __publicField2(this, "_component");
    __publicField2(this, "name");
    __publicField2(this, "uuid");
    this._component = component;
    this.name = name;
    this.uuid = uuid ?? UUID.create();
    const configManager = components.get(ConfigManager);
    configManager.list.set(this.uuid, this);
  }
  get controls() {
    return ControlsUtils.copySchema(this._config);
  }
  set(data) {
    for (const name in data) {
      if (name in this) {
        const key = name;
        this[key] = data[name].value;
      }
    }
  }
  export(controls = this._config, exported = {}) {
    for (const id in controls) {
      const control = controls[id];
      const isControl = ControlsUtils.isEntry(control);
      if (isControl) {
        if (control.type === "Color") {
          const { r, g, b } = control.value;
          exported[id] = { ...control, value: { r, g, b } };
        } else if (control.type === "Vector3") {
          const { x, y, z } = control.value;
          exported[id] = { ...control, value: { x, y, z } };
        } else if (control.type === "TextSet") {
          const value = Array.from(control.value);
          exported[id] = { ...control, value };
        } else if (control.type === "Select") {
          const options = Array.from(control.options);
          exported[id] = { ...control, options };
        } else {
          exported[id] = { ...control };
        }
      } else {
        exported[id] = {};
        this.export(control, exported[id]);
      }
    }
    return exported;
  }
  import(exported, imported = {}, first = true) {
    for (const id in exported) {
      const control = exported[id];
      const isControl = ControlsUtils.isEntry(control);
      if (isControl) {
        if (control.type === "Color") {
          const { r, g, b } = control.value;
          imported[id] = { ...control, value: new Color(r, g, b) };
        } else if (control.type === "Vector3") {
          const { x, y, z } = control.value;
          imported[id] = { ...control, value: new Vector3(x, y, z) };
        } else if (control.type === "TextSet") {
          imported[id] = { ...control, value: new Set(control.value) };
        } else if (control.type === "Select") {
          imported[id] = { ...control, options: new Set(control.options) };
        } else {
          imported[id] = { ...control };
        }
      } else {
        imported[id] = {};
        this.import(control, imported[id], false);
      }
    }
    if (first) {
      this.set(imported);
    }
  }
};
var _ConfigManager = class _ConfigManager2 extends Component {
  constructor(components) {
    super(components);
    __publicField2(this, "list", new DataMap());
    __publicField2(this, "enabled", true);
    components.add(_ConfigManager2.uuid, this);
  }
};
__publicField2(_ConfigManager, "uuid", "b8c764e0-6b24-4e77-9a32-35fa728ee5b4");
var ConfigManager = _ConfigManager;
var DirectionalLightConfig = class {
  constructor(list, scene) {
    __publicField2(this, "_list");
    __publicField2(this, "_scene");
    this._list = list;
    this._scene = scene;
  }
  get color() {
    return this._list.directionalLight.color.value;
  }
  set color(value) {
    this._list.directionalLight.color.value = value;
    for (const [, light] of this._scene.directionalLights) {
      light.color.copy(value);
    }
  }
  get intensity() {
    return this._list.directionalLight.intensity.value;
  }
  set intensity(value) {
    this._list.directionalLight.intensity.value = value;
    for (const [, light] of this._scene.directionalLights) {
      light.intensity = value;
    }
  }
  get position() {
    return this._list.directionalLight.position.value.clone();
  }
  set position(value) {
    this._list.directionalLight.position.value = value;
    for (const [, light] of this._scene.directionalLights) {
      light.position.copy(value);
    }
  }
};
var AmbientLightConfig = class {
  constructor(list, scene) {
    __publicField2(this, "_list");
    __publicField2(this, "_scene");
    this._list = list;
    this._scene = scene;
  }
  get color() {
    return this._list.ambientLight.color.value;
  }
  set color(value) {
    this._list.ambientLight.color.value = value;
    for (const [, light] of this._scene.ambientLights) {
      light.color.copy(value);
    }
  }
  get intensity() {
    return this._list.ambientLight.intensity.value;
  }
  set intensity(value) {
    this._list.ambientLight.intensity.value = value;
    for (const [, light] of this._scene.ambientLights) {
      light.intensity = value;
    }
  }
};
var SimpleSceneConfigManager = class extends Configurator {
  constructor() {
    super(...arguments);
    __publicField2(this, "_config", {
      backgroundColor: {
        value: new Color(),
        type: "Color"
      },
      ambientLight: {
        color: {
          type: "Color",
          value: new Color()
        },
        intensity: {
          type: "Number",
          interpolable: true,
          min: 0,
          max: 10,
          value: 2
        }
      },
      directionalLight: {
        color: {
          type: "Color",
          value: new Color()
        },
        intensity: {
          type: "Number",
          interpolable: true,
          min: 0,
          max: 10,
          value: 2
        },
        position: {
          type: "Vector3",
          value: new Vector3()
        }
      }
    });
    __publicField2(this, "ambientLight", new AmbientLightConfig(this._config, this._component));
    __publicField2(this, "directionalLight", new DirectionalLightConfig(this._config, this._component));
  }
  get backgroundColor() {
    return this._config.backgroundColor.value;
  }
  set backgroundColor(value) {
    this._config.backgroundColor.value = value;
    this._component.three.background = value;
  }
};
var SimpleScene = class extends BaseScene {
  constructor(components) {
    super(components);
    __publicField2(this, "onSetup", new Event());
    __publicField2(this, "isSetup", false);
    __publicField2(this, "three");
    __publicField2(this, "config", new SimpleSceneConfigManager(this, this.components, "Scene"));
    __publicField2(this, "_defaultConfig", {
      backgroundColor: new Color(2107698),
      directionalLight: {
        color: new Color("white"),
        intensity: 1.5,
        position: new Vector3(5, 10, 3)
      },
      ambientLight: {
        color: new Color("white"),
        intensity: 1
      }
    });
    this.three = new Scene();
    this.three.background = new Color(2107698);
  }
  /** {@link Configurable.setup} */
  setup(config) {
    const fullConfig = { ...this._defaultConfig, ...config };
    this.config.backgroundColor = fullConfig.backgroundColor;
    const ambLightData = fullConfig.ambientLight;
    this.config.ambientLight.color = ambLightData.color;
    this.config.ambientLight.intensity = ambLightData.intensity;
    const dirLightData = fullConfig.directionalLight;
    this.config.directionalLight.color = dirLightData.color;
    this.config.directionalLight.intensity = dirLightData.intensity;
    this.config.directionalLight.position = dirLightData.position;
    this.deleteAllLights();
    const { color: dc, intensity: di } = this.config.directionalLight;
    const directionalLight = new DirectionalLight(dc, di);
    directionalLight.position.copy(dirLightData.position);
    const { color: ac, intensity: ai } = this.config.directionalLight;
    const ambientLight = new AmbientLight(ac, ai);
    this.three.add(directionalLight, ambientLight);
    this.directionalLights.set(directionalLight.uuid, directionalLight);
    this.ambientLights.set(ambientLight.uuid, ambientLight);
    this.isSetup = true;
    this.onSetup.trigger();
  }
  dispose() {
    super.dispose();
    const configs = this.components.get(ConfigManager);
    configs.list.delete(this.config.uuid);
  }
};
var SimpleRenderer = class extends BaseRenderer {
  /**
   * Constructor for the SimpleRenderer class.
   *
   * @param components - The components instance.
   * @param container - The HTML container where the THREE.js canvas will be rendered.
   * @param parameters - Optional parameters for the THREE.js WebGLRenderer.
   */
  constructor(components, container, parameters) {
    super(components);
    __publicField2(this, "enabled", true);
    __publicField2(this, "container");
    __publicField2(this, "three");
    __publicField2(this, "_canvas");
    __publicField2(this, "_parameters");
    __publicField2(this, "_resizeObserver", null);
    __publicField2(this, "onContainerUpdated", new Event());
    __publicField2(this, "_resizing", false);
    __publicField2(this, "resize", (size) => {
      if (this._resizing)
        return;
      this._resizing = true;
      this.onContainerUpdated.trigger();
      const width = size ? size.x : this.container.clientWidth;
      const height = size ? size.y : this.container.clientHeight;
      this.three.setSize(width, height);
      this.onResize.trigger(new Vector2(width, height));
      this._resizing = false;
    });
    __publicField2(this, "resizeEvent", () => {
      this.resize();
    });
    __publicField2(this, "onContextLost", (event) => {
      event.preventDefault();
      this.enabled = false;
    });
    __publicField2(this, "onContextBack", () => {
      this.three.setRenderTarget(null);
      this.three.dispose();
      this.three = new WebGLRenderer({
        canvas: this._canvas,
        antialias: true,
        alpha: true,
        ...this._parameters
      });
      this.enabled = true;
    });
    this.container = container;
    this._parameters = parameters;
    this.three = new WebGLRenderer({
      antialias: true,
      alpha: true,
      ...parameters
    });
    this.three.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    this.setupRenderer();
    this.setupEvents(true);
    this.resize();
    this._canvas = this.three.domElement;
    const context = this.three.getContext();
    const { canvas } = context;
    canvas.addEventListener("webglcontextlost", this.onContextLost, false);
    canvas.addEventListener("webglcontextrestored", this.onContextBack, false);
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled || !this.currentWorld)
      return;
    this.onBeforeUpdate.trigger(this);
    const scene = this.currentWorld.scene.three;
    const camera = this.currentWorld.camera.three;
    this.three.render(scene, camera);
    this.onAfterUpdate.trigger(this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false;
    this.setupEvents(false);
    this.three.domElement.remove();
    this.three.forceContextLoss();
    this.three.dispose();
    this.onResize.reset();
    this.onAfterUpdate.reset();
    this.onBeforeUpdate.reset();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  /** {@link Resizeable.getSize}. */
  getSize() {
    return new Vector2(
      this.three.domElement.clientWidth,
      this.three.domElement.clientHeight
    );
  }
  /**
   * Sets up and manages the event listeners for the renderer.
   *
   * @param active - A boolean indicating whether to activate or deactivate the event listeners.
   *
   * @throws Will throw an error if the renderer does not have an HTML container.
   */
  setupEvents(active) {
    const dom = this.three.domElement.parentElement;
    if (!dom) {
      throw new Error("This renderer needs to have an HTML container!");
    }
    if (this._resizeObserver) {
      this._resizeObserver.disconnect();
      this._resizeObserver = null;
    }
    window.removeEventListener("resize", this.resizeEvent);
    if (active) {
      this._resizeObserver = new ResizeObserver(this.resizeEvent);
      this._resizeObserver.observe(dom);
      window.addEventListener("resize", this.resizeEvent);
    }
  }
  setupRenderer() {
    this.three.localClippingEnabled = true;
    if (this.container) {
      this.container.appendChild(this.three.domElement);
    }
    this.onContainerUpdated.trigger();
  }
};
var MOUSE_BUTTON = {
  LEFT: 1,
  RIGHT: 2,
  MIDDLE: 4
};
var ACTION = Object.freeze({
  NONE: 0,
  ROTATE: 1,
  TRUCK: 2,
  OFFSET: 4,
  DOLLY: 8,
  ZOOM: 16,
  TOUCH_ROTATE: 32,
  TOUCH_TRUCK: 64,
  TOUCH_OFFSET: 128,
  TOUCH_DOLLY: 256,
  TOUCH_ZOOM: 512,
  TOUCH_DOLLY_TRUCK: 1024,
  TOUCH_DOLLY_OFFSET: 2048,
  TOUCH_DOLLY_ROTATE: 4096,
  TOUCH_ZOOM_TRUCK: 8192,
  TOUCH_ZOOM_OFFSET: 16384,
  TOUCH_ZOOM_ROTATE: 32768
});
var DOLLY_DIRECTION = {
  NONE: 0,
  IN: 1,
  OUT: -1
};
function isPerspectiveCamera(camera) {
  return camera.isPerspectiveCamera;
}
function isOrthographicCamera(camera) {
  return camera.isOrthographicCamera;
}
var PI_2 = Math.PI * 2;
var PI_HALF = Math.PI / 2;
var EPSILON = 1e-5;
var DEG2RAD = Math.PI / 180;
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function approxZero(number, error = EPSILON) {
  return Math.abs(number) < error;
}
function approxEquals(a, b, error = EPSILON) {
  return approxZero(a - b, error);
}
function roundToStep(value, step) {
  return Math.round(value / step) * step;
}
function infinityToMaxNumber(value) {
  if (isFinite(value))
    return value;
  if (value < 0)
    return -Number.MAX_VALUE;
  return Number.MAX_VALUE;
}
function maxNumberToInfinity(value) {
  if (Math.abs(value) < Number.MAX_VALUE)
    return value;
  return value * Infinity;
}
function smoothDamp(current, target, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime) {
  smoothTime = Math.max(1e-4, smoothTime);
  const omega = 2 / smoothTime;
  const x = omega * deltaTime;
  const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
  let change = current - target;
  const originalTo = target;
  const maxChange = maxSpeed * smoothTime;
  change = clamp(change, -maxChange, maxChange);
  target = current - change;
  const temp52 = (currentVelocityRef.value + omega * change) * deltaTime;
  currentVelocityRef.value = (currentVelocityRef.value - omega * temp52) * exp;
  let output = target + (change + temp52) * exp;
  if (originalTo - current > 0 === output > originalTo) {
    output = originalTo;
    currentVelocityRef.value = (output - originalTo) / deltaTime;
  }
  return output;
}
function smoothDampVec3(current, target, currentVelocityRef, smoothTime, maxSpeed = Infinity, deltaTime, out) {
  smoothTime = Math.max(1e-4, smoothTime);
  const omega = 2 / smoothTime;
  const x = omega * deltaTime;
  const exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
  let targetX = target.x;
  let targetY = target.y;
  let targetZ = target.z;
  let changeX = current.x - targetX;
  let changeY = current.y - targetY;
  let changeZ = current.z - targetZ;
  const originalToX = targetX;
  const originalToY = targetY;
  const originalToZ = targetZ;
  const maxChange = maxSpeed * smoothTime;
  const maxChangeSq = maxChange * maxChange;
  const magnitudeSq = changeX * changeX + changeY * changeY + changeZ * changeZ;
  if (magnitudeSq > maxChangeSq) {
    const magnitude = Math.sqrt(magnitudeSq);
    changeX = changeX / magnitude * maxChange;
    changeY = changeY / magnitude * maxChange;
    changeZ = changeZ / magnitude * maxChange;
  }
  targetX = current.x - changeX;
  targetY = current.y - changeY;
  targetZ = current.z - changeZ;
  const tempX = (currentVelocityRef.x + omega * changeX) * deltaTime;
  const tempY = (currentVelocityRef.y + omega * changeY) * deltaTime;
  const tempZ = (currentVelocityRef.z + omega * changeZ) * deltaTime;
  currentVelocityRef.x = (currentVelocityRef.x - omega * tempX) * exp;
  currentVelocityRef.y = (currentVelocityRef.y - omega * tempY) * exp;
  currentVelocityRef.z = (currentVelocityRef.z - omega * tempZ) * exp;
  out.x = targetX + (changeX + tempX) * exp;
  out.y = targetY + (changeY + tempY) * exp;
  out.z = targetZ + (changeZ + tempZ) * exp;
  const origMinusCurrentX = originalToX - current.x;
  const origMinusCurrentY = originalToY - current.y;
  const origMinusCurrentZ = originalToZ - current.z;
  const outMinusOrigX = out.x - originalToX;
  const outMinusOrigY = out.y - originalToY;
  const outMinusOrigZ = out.z - originalToZ;
  if (origMinusCurrentX * outMinusOrigX + origMinusCurrentY * outMinusOrigY + origMinusCurrentZ * outMinusOrigZ > 0) {
    out.x = originalToX;
    out.y = originalToY;
    out.z = originalToZ;
    currentVelocityRef.x = (out.x - originalToX) / deltaTime;
    currentVelocityRef.y = (out.y - originalToY) / deltaTime;
    currentVelocityRef.z = (out.z - originalToZ) / deltaTime;
  }
  return out;
}
function extractClientCoordFromEvent(pointers, out) {
  out.set(0, 0);
  pointers.forEach((pointer) => {
    out.x += pointer.clientX;
    out.y += pointer.clientY;
  });
  out.x /= pointers.length;
  out.y /= pointers.length;
}
function notSupportedInOrthographicCamera(camera, message) {
  if (isOrthographicCamera(camera)) {
    console.warn(`${message} is not supported in OrthographicCamera`);
    return true;
  }
  return false;
}
var EventDispatcher = class {
  constructor() {
    this._listeners = {};
  }
  /**
   * Adds the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(type, listener) {
    const listeners = this._listeners;
    if (listeners[type] === void 0)
      listeners[type] = [];
    if (listeners[type].indexOf(listener) === -1)
      listeners[type].push(listener);
  }
  /**
   * Presence of the specified event listener.
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  hasEventListener(type, listener) {
    const listeners = this._listeners;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  /**
   * Removes the specified event listener
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(type, listener) {
    const listeners = this._listeners;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1)
        listenerArray.splice(index, 1);
    }
  }
  /**
   * Removes all event listeners
   * @param type event name
   * @category Methods
   */
  removeAllEventListeners(type) {
    if (!type) {
      this._listeners = {};
      return;
    }
    if (Array.isArray(this._listeners[type]))
      this._listeners[type].length = 0;
  }
  /**
   * Fire an event type.
   * @param event DispatcherEvent
   * @category Methods
   */
  dispatchEvent(event) {
    const listeners = this._listeners;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event);
      }
    }
  }
};
var VERSION = "2.7.3";
var TOUCH_DOLLY_FACTOR = 1 / 8;
var isBrowser = typeof window !== "undefined";
var isMac = isBrowser && /Mac/.test(navigator.platform);
var isPointerEventsNotSupported = !(isBrowser && "PointerEvent" in window);
var THREE;
var _ORIGIN;
var _AXIS_Y;
var _AXIS_Z;
var _v2$1;
var _v3A;
var _v3B;
var _v3C;
var _cameraDirection;
var _xColumn;
var _yColumn;
var _zColumn;
var _deltaTarget;
var _deltaOffset;
var _sphericalA;
var _sphericalB;
var _box3A;
var _box3B;
var _sphere;
var _quaternionA;
var _quaternionB;
var _rotationMatrix;
var _raycaster$1;
var CameraControls = class _CameraControls extends EventDispatcher {
  /**
       * Injects THREE as the dependency. You can then proceed to use CameraControls.
       *
       * e.g
       * ```javascript
       * CameraControls.install( { THREE: THREE } );
       * ```
       *
       * Note: If you do not wish to use enter three.js to reduce file size(tree-shaking for example), make a subset to install.
       *
       * ```js
       * import {
       * 	Vector2,
       * 	Vector3,
       * 	Vector4,
       * 	Quaternion,
       * 	Matrix4,
       * 	Spherical,
       * 	Box3,
       * 	Sphere,
       * 	Raycaster,
       * 	MathUtils,
       * } from 'three';
       *
       * const subsetOfTHREE = {
       * 	Vector2   : Vector2,
       * 	Vector3   : Vector3,
       * 	Vector4   : Vector4,
       * 	Quaternion: Quaternion,
       * 	Matrix4   : Matrix4,
       * 	Spherical : Spherical,
       * 	Box3      : Box3,
       * 	Sphere    : Sphere,
       * 	Raycaster : Raycaster,
       * };
  
       * CameraControls.install( { THREE: subsetOfTHREE } );
       * ```
       * @category Statics
       */
  static install(libs) {
    THREE = libs.THREE;
    _ORIGIN = Object.freeze(new THREE.Vector3(0, 0, 0));
    _AXIS_Y = Object.freeze(new THREE.Vector3(0, 1, 0));
    _AXIS_Z = Object.freeze(new THREE.Vector3(0, 0, 1));
    _v2$1 = new THREE.Vector2();
    _v3A = new THREE.Vector3();
    _v3B = new THREE.Vector3();
    _v3C = new THREE.Vector3();
    _cameraDirection = new THREE.Vector3();
    _xColumn = new THREE.Vector3();
    _yColumn = new THREE.Vector3();
    _zColumn = new THREE.Vector3();
    _deltaTarget = new THREE.Vector3();
    _deltaOffset = new THREE.Vector3();
    _sphericalA = new THREE.Spherical();
    _sphericalB = new THREE.Spherical();
    _box3A = new THREE.Box3();
    _box3B = new THREE.Box3();
    _sphere = new THREE.Sphere();
    _quaternionA = new THREE.Quaternion();
    _quaternionB = new THREE.Quaternion();
    _rotationMatrix = new THREE.Matrix4();
    _raycaster$1 = new THREE.Raycaster();
  }
  /**
   * list all ACTIONs
   * @category Statics
   */
  static get ACTION() {
    return ACTION;
  }
  /**
   * Creates a `CameraControls` instance.
   *
   * Note:
   * You **must install** three.js before using camera-controls. see [#install](#install)
   * Not doing so will lead to runtime errors (`undefined` references to THREE).
   *
   * e.g.
   * ```
   * CameraControls.install( { THREE } );
   * const cameraControls = new CameraControls( camera, domElement );
   * ```
   *
   * @param camera A `THREE.PerspectiveCamera` or `THREE.OrthographicCamera` to be controlled.
   * @param domElement A `HTMLElement` for the draggable area, usually `renderer.domElement`.
   * @category Constructor
   */
  constructor(camera, domElement) {
    super();
    this.minPolarAngle = 0;
    this.maxPolarAngle = Math.PI;
    this.minAzimuthAngle = -Infinity;
    this.maxAzimuthAngle = Infinity;
    this.minDistance = Number.EPSILON;
    this.maxDistance = Infinity;
    this.infinityDolly = false;
    this.minZoom = 0.01;
    this.maxZoom = Infinity;
    this.smoothTime = 0.25;
    this.draggingSmoothTime = 0.125;
    this.maxSpeed = Infinity;
    this.azimuthRotateSpeed = 1;
    this.polarRotateSpeed = 1;
    this.dollySpeed = 1;
    this.dollyDragInverted = false;
    this.truckSpeed = 2;
    this.dollyToCursor = false;
    this.dragToOffset = false;
    this.verticalDragToForward = false;
    this.boundaryFriction = 0;
    this.restThreshold = 0.01;
    this.colliderMeshes = [];
    this.cancel = () => {
    };
    this._enabled = true;
    this._state = ACTION.NONE;
    this._viewport = null;
    this._changedDolly = 0;
    this._changedZoom = 0;
    this._hasRested = true;
    this._boundaryEnclosesCamera = false;
    this._needsUpdate = true;
    this._updatedLastTime = false;
    this._elementRect = new DOMRect();
    this._isDragging = false;
    this._dragNeedsUpdate = true;
    this._activePointers = [];
    this._lockedPointer = null;
    this._interactiveArea = new DOMRect(0, 0, 1, 1);
    this._isUserControllingRotate = false;
    this._isUserControllingDolly = false;
    this._isUserControllingTruck = false;
    this._isUserControllingOffset = false;
    this._isUserControllingZoom = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._thetaVelocity = { value: 0 };
    this._phiVelocity = { value: 0 };
    this._radiusVelocity = { value: 0 };
    this._targetVelocity = new THREE.Vector3();
    this._focalOffsetVelocity = new THREE.Vector3();
    this._zoomVelocity = { value: 0 };
    this._truckInternal = (deltaX, deltaY, dragToOffset) => {
      let truckX;
      let pedestalY;
      if (isPerspectiveCamera(this._camera)) {
        const offset = _v3A.copy(this._camera.position).sub(this._target);
        const fov = this._camera.getEffectiveFOV() * DEG2RAD;
        const targetDistance = offset.length() * Math.tan(fov * 0.5);
        truckX = this.truckSpeed * deltaX * targetDistance / this._elementRect.height;
        pedestalY = this.truckSpeed * deltaY * targetDistance / this._elementRect.height;
      } else if (isOrthographicCamera(this._camera)) {
        const camera2 = this._camera;
        truckX = deltaX * (camera2.right - camera2.left) / camera2.zoom / this._elementRect.width;
        pedestalY = deltaY * (camera2.top - camera2.bottom) / camera2.zoom / this._elementRect.height;
      } else {
        return;
      }
      if (this.verticalDragToForward) {
        dragToOffset ? this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y, this._focalOffsetEnd.z, true) : this.truck(truckX, 0, true);
        this.forward(-pedestalY, true);
      } else {
        dragToOffset ? this.setFocalOffset(this._focalOffsetEnd.x + truckX, this._focalOffsetEnd.y + pedestalY, this._focalOffsetEnd.z, true) : this.truck(truckX, pedestalY, true);
      }
    };
    this._rotateInternal = (deltaX, deltaY) => {
      const theta = PI_2 * this.azimuthRotateSpeed * deltaX / this._elementRect.height;
      const phi = PI_2 * this.polarRotateSpeed * deltaY / this._elementRect.height;
      this.rotate(theta, phi, true);
    };
    this._dollyInternal = (delta, x, y) => {
      const dollyScale = Math.pow(0.95, -delta * this.dollySpeed);
      const lastDistance = this._sphericalEnd.radius;
      const distance = this._sphericalEnd.radius * dollyScale;
      const clampedDistance = clamp(distance, this.minDistance, this.maxDistance);
      const overflowedDistance = clampedDistance - distance;
      if (this.infinityDolly && this.dollyToCursor) {
        this._dollyToNoClamp(distance, true);
      } else if (this.infinityDolly && !this.dollyToCursor) {
        this.dollyInFixed(overflowedDistance, true);
        this._dollyToNoClamp(clampedDistance, true);
      } else {
        this._dollyToNoClamp(clampedDistance, true);
      }
      if (this.dollyToCursor) {
        this._changedDolly += (this.infinityDolly ? distance : clampedDistance) - lastDistance;
        this._dollyControlCoord.set(x, y);
      }
      this._lastDollyDirection = Math.sign(-delta);
    };
    this._zoomInternal = (delta, x, y) => {
      const zoomScale = Math.pow(0.95, delta * this.dollySpeed);
      const lastZoom = this._zoom;
      const zoom = this._zoom * zoomScale;
      this.zoomTo(zoom, true);
      if (this.dollyToCursor) {
        this._changedZoom += zoom - lastZoom;
        this._dollyControlCoord.set(x, y);
      }
    };
    if (typeof THREE === "undefined") {
      console.error("camera-controls: `THREE` is undefined. You must first run `CameraControls.install( { THREE: THREE } )`. Check the docs for further information.");
    }
    this._camera = camera;
    this._yAxisUpSpace = new THREE.Quaternion().setFromUnitVectors(this._camera.up, _AXIS_Y);
    this._yAxisUpSpaceInverse = this._yAxisUpSpace.clone().invert();
    this._state = ACTION.NONE;
    this._target = new THREE.Vector3();
    this._targetEnd = this._target.clone();
    this._focalOffset = new THREE.Vector3();
    this._focalOffsetEnd = this._focalOffset.clone();
    this._spherical = new THREE.Spherical().setFromVector3(_v3A.copy(this._camera.position).applyQuaternion(this._yAxisUpSpace));
    this._sphericalEnd = this._spherical.clone();
    this._lastDistance = this._spherical.radius;
    this._zoom = this._camera.zoom;
    this._zoomEnd = this._zoom;
    this._lastZoom = this._zoom;
    this._nearPlaneCorners = [
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3(),
      new THREE.Vector3()
    ];
    this._updateNearPlaneCorners();
    this._boundary = new THREE.Box3(new THREE.Vector3(-Infinity, -Infinity, -Infinity), new THREE.Vector3(Infinity, Infinity, Infinity));
    this._cameraUp0 = this._camera.up.clone();
    this._target0 = this._target.clone();
    this._position0 = this._camera.position.clone();
    this._zoom0 = this._zoom;
    this._focalOffset0 = this._focalOffset.clone();
    this._dollyControlCoord = new THREE.Vector2();
    this.mouseButtons = {
      left: ACTION.ROTATE,
      middle: ACTION.DOLLY,
      right: ACTION.TRUCK,
      wheel: isPerspectiveCamera(this._camera) ? ACTION.DOLLY : isOrthographicCamera(this._camera) ? ACTION.ZOOM : ACTION.NONE
    };
    this.touches = {
      one: ACTION.TOUCH_ROTATE,
      two: isPerspectiveCamera(this._camera) ? ACTION.TOUCH_DOLLY_TRUCK : isOrthographicCamera(this._camera) ? ACTION.TOUCH_ZOOM_TRUCK : ACTION.NONE,
      three: ACTION.TOUCH_TRUCK
    };
    const dragStartPosition = new THREE.Vector2();
    const lastDragPosition = new THREE.Vector2();
    const dollyStart = new THREE.Vector2();
    const onPointerDown2 = (event) => {
      if (!this._enabled || !this._domElement)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const elRect = this._domElement.getBoundingClientRect();
        const left = event.clientX / elRect.width;
        const top = event.clientY / elRect.height;
        if (left < this._interactiveArea.left || left > this._interactiveArea.right || top < this._interactiveArea.top || top > this._interactiveArea.bottom)
          return;
      }
      const mouseButton = event.pointerType !== "mouse" ? null : (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.LEFT : (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE ? MOUSE_BUTTON.MIDDLE : (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT ? MOUSE_BUTTON.RIGHT : null;
      if (mouseButton !== null) {
        const zombiePointer = this._findPointerByMouseButton(mouseButton);
        zombiePointer && this._disposePointer(zombiePointer);
      }
      if ((event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT && this._lockedPointer)
        return;
      const pointer = {
        pointerId: event.pointerId,
        clientX: event.clientX,
        clientY: event.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton
      };
      this._activePointers.push(pointer);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove2, { passive: false });
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp2);
      this._domElement.ownerDocument.addEventListener("pointermove", onPointerMove2, { passive: false });
      this._domElement.ownerDocument.addEventListener("pointerup", onPointerUp2);
      this._isDragging = true;
      startDragging(event);
    };
    const onMouseDown = (event) => {
      if (!this._enabled || !this._domElement || this._lockedPointer)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const elRect = this._domElement.getBoundingClientRect();
        const left = event.clientX / elRect.width;
        const top = event.clientY / elRect.height;
        if (left < this._interactiveArea.left || left > this._interactiveArea.right || top < this._interactiveArea.top || top > this._interactiveArea.bottom)
          return;
      }
      const mouseButton = (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.LEFT : (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE ? MOUSE_BUTTON.MIDDLE : (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT ? MOUSE_BUTTON.RIGHT : null;
      if (mouseButton !== null) {
        const zombiePointer = this._findPointerByMouseButton(mouseButton);
        zombiePointer && this._disposePointer(zombiePointer);
      }
      const pointer = {
        pointerId: 1,
        clientX: event.clientX,
        clientY: event.clientY,
        deltaX: 0,
        deltaY: 0,
        mouseButton: (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.LEFT : (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.MIDDLE : (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.LEFT ? MOUSE_BUTTON.RIGHT : null
      };
      this._activePointers.push(pointer);
      this._domElement.ownerDocument.removeEventListener("mousemove", onMouseMove);
      this._domElement.ownerDocument.removeEventListener("mouseup", onMouseUp);
      this._domElement.ownerDocument.addEventListener("mousemove", onMouseMove);
      this._domElement.ownerDocument.addEventListener("mouseup", onMouseUp);
      this._isDragging = true;
      startDragging(event);
    };
    const onPointerMove2 = (event) => {
      if (event.cancelable)
        event.preventDefault();
      const pointerId = event.pointerId;
      const pointer = this._lockedPointer || this._findPointerById(pointerId);
      if (!pointer)
        return;
      pointer.clientX = event.clientX;
      pointer.clientY = event.clientY;
      pointer.deltaX = event.movementX;
      pointer.deltaY = event.movementY;
      this._state = 0;
      if (event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        if (!this._isDragging && this._lockedPointer || this._isDragging && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
          this._state = this._state | this.mouseButtons.left;
        }
        if (this._isDragging && (event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
          this._state = this._state | this.mouseButtons.middle;
        }
        if (this._isDragging && (event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
          this._state = this._state | this.mouseButtons.right;
        }
      }
      dragging();
    };
    const onMouseMove = (event) => {
      const pointer = this._lockedPointer || this._findPointerById(1);
      if (!pointer)
        return;
      pointer.clientX = event.clientX;
      pointer.clientY = event.clientY;
      pointer.deltaX = event.movementX;
      pointer.deltaY = event.movementY;
      this._state = 0;
      if (this._lockedPointer || (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
        this._state = this._state | this.mouseButtons.left;
      }
      if ((event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
        this._state = this._state | this.mouseButtons.middle;
      }
      if ((event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
        this._state = this._state | this.mouseButtons.right;
      }
      dragging();
    };
    const onPointerUp2 = (event) => {
      const pointer = this._findPointerById(event.pointerId);
      if (pointer && pointer === this._lockedPointer)
        return;
      pointer && this._disposePointer(pointer);
      if (event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 0:
            this._state = ACTION.NONE;
            break;
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        this._state = ACTION.NONE;
      }
      endDragging();
    };
    const onMouseUp = () => {
      const pointer = this._findPointerById(1);
      if (pointer && pointer === this._lockedPointer)
        return;
      pointer && this._disposePointer(pointer);
      this._state = ACTION.NONE;
      endDragging();
    };
    let lastScrollTimeStamp = -1;
    const onMouseWheel = (event) => {
      if (!this._domElement)
        return;
      if (!this._enabled || this.mouseButtons.wheel === ACTION.NONE)
        return;
      if (this._interactiveArea.left !== 0 || this._interactiveArea.top !== 0 || this._interactiveArea.width !== 1 || this._interactiveArea.height !== 1) {
        const elRect = this._domElement.getBoundingClientRect();
        const left = event.clientX / elRect.width;
        const top = event.clientY / elRect.height;
        if (left < this._interactiveArea.left || left > this._interactiveArea.right || top < this._interactiveArea.top || top > this._interactiveArea.bottom)
          return;
      }
      event.preventDefault();
      if (this.dollyToCursor || this.mouseButtons.wheel === ACTION.ROTATE || this.mouseButtons.wheel === ACTION.TRUCK) {
        const now = performance.now();
        if (lastScrollTimeStamp - now < 1e3)
          this._getClientRect(this._elementRect);
        lastScrollTimeStamp = now;
      }
      const deltaYFactor = isMac ? -1 : -3;
      const delta = event.deltaMode === 1 ? event.deltaY / deltaYFactor : event.deltaY / (deltaYFactor * 10);
      const x = this.dollyToCursor ? (event.clientX - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
      const y = this.dollyToCursor ? (event.clientY - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
      switch (this.mouseButtons.wheel) {
        case ACTION.ROTATE: {
          this._rotateInternal(event.deltaX, event.deltaY);
          this._isUserControllingRotate = true;
          break;
        }
        case ACTION.TRUCK: {
          this._truckInternal(event.deltaX, event.deltaY, false);
          this._isUserControllingTruck = true;
          break;
        }
        case ACTION.OFFSET: {
          this._truckInternal(event.deltaX, event.deltaY, true);
          this._isUserControllingOffset = true;
          break;
        }
        case ACTION.DOLLY: {
          this._dollyInternal(-delta, x, y);
          this._isUserControllingDolly = true;
          break;
        }
        case ACTION.ZOOM: {
          this._zoomInternal(-delta, x, y);
          this._isUserControllingZoom = true;
          break;
        }
      }
      this.dispatchEvent({ type: "control" });
    };
    const onContextMenu = (event) => {
      if (!this._domElement || !this._enabled)
        return;
      if (this.mouseButtons.right === _CameraControls.ACTION.NONE) {
        const pointerId = event instanceof PointerEvent ? event.pointerId : event instanceof MouseEvent ? 0 : 0;
        const pointer = this._findPointerById(pointerId);
        pointer && this._disposePointer(pointer);
        this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove2, { passive: false });
        this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp2);
        this._domElement.ownerDocument.removeEventListener("mousemove", onMouseMove);
        this._domElement.ownerDocument.removeEventListener("mouseup", onMouseUp);
        return;
      }
      event.preventDefault();
    };
    const startDragging = (event) => {
      if (!this._enabled)
        return;
      extractClientCoordFromEvent(this._activePointers, _v2$1);
      this._getClientRect(this._elementRect);
      dragStartPosition.copy(_v2$1);
      lastDragPosition.copy(_v2$1);
      const isMultiTouch = this._activePointers.length >= 2;
      if (isMultiTouch) {
        const dx = _v2$1.x - this._activePointers[1].clientX;
        const dy = _v2$1.y - this._activePointers[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        dollyStart.set(0, distance);
        const x = (this._activePointers[0].clientX + this._activePointers[1].clientX) * 0.5;
        const y = (this._activePointers[0].clientY + this._activePointers[1].clientY) * 0.5;
        lastDragPosition.set(x, y);
      }
      this._state = 0;
      if (!event) {
        if (this._lockedPointer)
          this._state = this._state | this.mouseButtons.left;
      } else if ("pointerType" in event && event.pointerType === "touch") {
        switch (this._activePointers.length) {
          case 1:
            this._state = this.touches.one;
            break;
          case 2:
            this._state = this.touches.two;
            break;
          case 3:
            this._state = this.touches.three;
            break;
        }
      } else {
        if (!this._lockedPointer && (event.buttons & MOUSE_BUTTON.LEFT) === MOUSE_BUTTON.LEFT) {
          this._state = this._state | this.mouseButtons.left;
        }
        if ((event.buttons & MOUSE_BUTTON.MIDDLE) === MOUSE_BUTTON.MIDDLE) {
          this._state = this._state | this.mouseButtons.middle;
        }
        if ((event.buttons & MOUSE_BUTTON.RIGHT) === MOUSE_BUTTON.RIGHT) {
          this._state = this._state | this.mouseButtons.right;
        }
      }
      if ((this._state & ACTION.ROTATE) === ACTION.ROTATE || (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._sphericalEnd.theta = this._spherical.theta;
        this._sphericalEnd.phi = this._spherical.phi;
        this._thetaVelocity.value = 0;
        this._phiVelocity.value = 0;
      }
      if ((this._state & ACTION.TRUCK) === ACTION.TRUCK || (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK) {
        this._targetEnd.copy(this._target);
        this._targetVelocity.set(0, 0, 0);
      }
      if ((this._state & ACTION.DOLLY) === ACTION.DOLLY || (this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE) {
        this._sphericalEnd.radius = this._spherical.radius;
        this._radiusVelocity.value = 0;
      }
      if ((this._state & ACTION.ZOOM) === ACTION.ZOOM || (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._zoomEnd = this._zoom;
        this._zoomVelocity.value = 0;
      }
      if ((this._state & ACTION.OFFSET) === ACTION.OFFSET || (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {
        this._focalOffsetEnd.copy(this._focalOffset);
        this._focalOffsetVelocity.set(0, 0, 0);
      }
      this.dispatchEvent({ type: "controlstart" });
    };
    const dragging = () => {
      if (!this._enabled || !this._dragNeedsUpdate)
        return;
      this._dragNeedsUpdate = false;
      extractClientCoordFromEvent(this._activePointers, _v2$1);
      const isPointerLockActive = this._domElement && document.pointerLockElement === this._domElement;
      const lockedPointer = isPointerLockActive ? this._lockedPointer || this._activePointers[0] : null;
      const deltaX = lockedPointer ? -lockedPointer.deltaX : lastDragPosition.x - _v2$1.x;
      const deltaY = lockedPointer ? -lockedPointer.deltaY : lastDragPosition.y - _v2$1.y;
      lastDragPosition.copy(_v2$1);
      if ((this._state & ACTION.ROTATE) === ACTION.ROTATE || (this._state & ACTION.TOUCH_ROTATE) === ACTION.TOUCH_ROTATE || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        this._rotateInternal(deltaX, deltaY);
        this._isUserControllingRotate = true;
      }
      if ((this._state & ACTION.DOLLY) === ACTION.DOLLY || (this._state & ACTION.ZOOM) === ACTION.ZOOM) {
        const dollyX = this.dollyToCursor ? (dragStartPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
        const dollyY = this.dollyToCursor ? (dragStartPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        const dollyDirection = this.dollyDragInverted ? -1 : 1;
        if ((this._state & ACTION.DOLLY) === ACTION.DOLLY) {
          this._dollyInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingDolly = true;
        } else {
          this._zoomInternal(dollyDirection * deltaY * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingZoom = true;
        }
      }
      if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_ZOOM) === ACTION.TOUCH_ZOOM || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_ZOOM_ROTATE) === ACTION.TOUCH_ZOOM_ROTATE) {
        const dx = _v2$1.x - this._activePointers[1].clientX;
        const dy = _v2$1.y - this._activePointers[1].clientY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const dollyDelta = dollyStart.y - distance;
        dollyStart.set(0, distance);
        const dollyX = this.dollyToCursor ? (lastDragPosition.x - this._elementRect.x) / this._elementRect.width * 2 - 1 : 0;
        const dollyY = this.dollyToCursor ? (lastDragPosition.y - this._elementRect.y) / this._elementRect.height * -2 + 1 : 0;
        if ((this._state & ACTION.TOUCH_DOLLY) === ACTION.TOUCH_DOLLY || (this._state & ACTION.TOUCH_DOLLY_ROTATE) === ACTION.TOUCH_DOLLY_ROTATE || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET) {
          this._dollyInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingDolly = true;
        } else {
          this._zoomInternal(dollyDelta * TOUCH_DOLLY_FACTOR, dollyX, dollyY);
          this._isUserControllingZoom = true;
        }
      }
      if ((this._state & ACTION.TRUCK) === ACTION.TRUCK || (this._state & ACTION.TOUCH_TRUCK) === ACTION.TOUCH_TRUCK || (this._state & ACTION.TOUCH_DOLLY_TRUCK) === ACTION.TOUCH_DOLLY_TRUCK || (this._state & ACTION.TOUCH_ZOOM_TRUCK) === ACTION.TOUCH_ZOOM_TRUCK) {
        this._truckInternal(deltaX, deltaY, false);
        this._isUserControllingTruck = true;
      }
      if ((this._state & ACTION.OFFSET) === ACTION.OFFSET || (this._state & ACTION.TOUCH_OFFSET) === ACTION.TOUCH_OFFSET || (this._state & ACTION.TOUCH_DOLLY_OFFSET) === ACTION.TOUCH_DOLLY_OFFSET || (this._state & ACTION.TOUCH_ZOOM_OFFSET) === ACTION.TOUCH_ZOOM_OFFSET) {
        this._truckInternal(deltaX, deltaY, true);
        this._isUserControllingOffset = true;
      }
      this.dispatchEvent({ type: "control" });
    };
    const endDragging = () => {
      extractClientCoordFromEvent(this._activePointers, _v2$1);
      lastDragPosition.copy(_v2$1);
      this._dragNeedsUpdate = false;
      if (this._activePointers.length === 0 || this._activePointers.length === 1 && this._activePointers[0] === this._lockedPointer) {
        this._isDragging = false;
      }
      if (this._activePointers.length === 0 && this._domElement) {
        this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove2, { passive: false });
        this._domElement.ownerDocument.removeEventListener("mousemove", onMouseMove);
        this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp2);
        this._domElement.ownerDocument.removeEventListener("mouseup", onMouseUp);
        this.dispatchEvent({ type: "controlend" });
      }
    };
    this.lockPointer = () => {
      if (!this._enabled || !this._domElement)
        return;
      this.cancel();
      this._lockedPointer = {
        pointerId: -1,
        clientX: 0,
        clientY: 0,
        deltaX: 0,
        deltaY: 0,
        mouseButton: null
      };
      this._activePointers.push(this._lockedPointer);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove2, { passive: false });
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp2);
      this._domElement.requestPointerLock();
      this._domElement.ownerDocument.addEventListener("pointerlockchange", onPointerLockChange);
      this._domElement.ownerDocument.addEventListener("pointerlockerror", onPointerLockError);
      this._domElement.ownerDocument.addEventListener("pointermove", onPointerMove2, { passive: false });
      this._domElement.ownerDocument.addEventListener("pointerup", onPointerUp2);
      startDragging();
    };
    this.unlockPointer = () => {
      if (this._lockedPointer !== null) {
        this._disposePointer(this._lockedPointer);
        this._lockedPointer = null;
      }
      document.exitPointerLock();
      this.cancel();
      if (!this._domElement)
        return;
      this._domElement.ownerDocument.removeEventListener("pointerlockchange", onPointerLockChange);
      this._domElement.ownerDocument.removeEventListener("pointerlockerror", onPointerLockError);
    };
    const onPointerLockChange = () => {
      const isPointerLockActive = this._domElement && this._domElement.ownerDocument.pointerLockElement === this._domElement;
      if (!isPointerLockActive)
        this.unlockPointer();
    };
    const onPointerLockError = () => {
      this.unlockPointer();
    };
    this._addAllEventListeners = (domElement2) => {
      this._domElement = domElement2;
      this._domElement.style.touchAction = "none";
      this._domElement.style.userSelect = "none";
      this._domElement.style.webkitUserSelect = "none";
      this._domElement.addEventListener("pointerdown", onPointerDown2);
      isPointerEventsNotSupported && this._domElement.addEventListener("mousedown", onMouseDown);
      this._domElement.addEventListener("pointercancel", onPointerUp2);
      this._domElement.addEventListener("wheel", onMouseWheel, { passive: false });
      this._domElement.addEventListener("contextmenu", onContextMenu);
    };
    this._removeAllEventListeners = () => {
      if (!this._domElement)
        return;
      this._domElement.style.touchAction = "";
      this._domElement.style.userSelect = "";
      this._domElement.style.webkitUserSelect = "";
      this._domElement.removeEventListener("pointerdown", onPointerDown2);
      this._domElement.removeEventListener("mousedown", onMouseDown);
      this._domElement.removeEventListener("pointercancel", onPointerUp2);
      this._domElement.removeEventListener("wheel", onMouseWheel, { passive: false });
      this._domElement.removeEventListener("contextmenu", onContextMenu);
      this._domElement.ownerDocument.removeEventListener("pointermove", onPointerMove2, { passive: false });
      this._domElement.ownerDocument.removeEventListener("mousemove", onMouseMove);
      this._domElement.ownerDocument.removeEventListener("pointerup", onPointerUp2);
      this._domElement.ownerDocument.removeEventListener("mouseup", onMouseUp);
      this._domElement.ownerDocument.removeEventListener("pointerlockchange", onPointerLockChange);
      this._domElement.ownerDocument.removeEventListener("pointerlockerror", onPointerLockError);
    };
    this.cancel = () => {
      if (this._state === ACTION.NONE)
        return;
      this._state = ACTION.NONE;
      this._activePointers.length = 0;
      endDragging();
    };
    if (domElement)
      this.connect(domElement);
    this.update(0);
  }
  /**
   * The camera to be controlled
   * @category Properties
   */
  get camera() {
    return this._camera;
  }
  set camera(camera) {
    this._camera = camera;
    this.updateCameraUp();
    this._camera.updateProjectionMatrix();
    this._updateNearPlaneCorners();
    this._needsUpdate = true;
  }
  /**
   * Whether or not the controls are enabled.
   * `false` to disable user dragging/touch-move, but all methods works.
   * @category Properties
   */
  get enabled() {
    return this._enabled;
  }
  set enabled(enabled) {
    this._enabled = enabled;
    if (!this._domElement)
      return;
    if (enabled) {
      this._domElement.style.touchAction = "none";
      this._domElement.style.userSelect = "none";
      this._domElement.style.webkitUserSelect = "none";
    } else {
      this.cancel();
      this._domElement.style.touchAction = "";
      this._domElement.style.userSelect = "";
      this._domElement.style.webkitUserSelect = "";
    }
  }
  /**
   * Returns `true` if the controls are active updating.
   * readonly value.
   * @category Properties
   */
  get active() {
    return !this._hasRested;
  }
  /**
   * Getter for the current `ACTION`.
   * readonly value.
   * @category Properties
   */
  get currentAction() {
    return this._state;
  }
  /**
   * get/set Current distance.
   * @category Properties
   */
  get distance() {
    return this._spherical.radius;
  }
  set distance(distance) {
    if (this._spherical.radius === distance && this._sphericalEnd.radius === distance)
      return;
    this._spherical.radius = distance;
    this._sphericalEnd.radius = distance;
    this._needsUpdate = true;
  }
  // horizontal angle
  /**
   * get/set the azimuth angle (horizontal) in radians.
   * Every 360 degrees turn is added to `.azimuthAngle` value, which is accumulative.
   * @category Properties
   */
  get azimuthAngle() {
    return this._spherical.theta;
  }
  set azimuthAngle(azimuthAngle) {
    if (this._spherical.theta === azimuthAngle && this._sphericalEnd.theta === azimuthAngle)
      return;
    this._spherical.theta = azimuthAngle;
    this._sphericalEnd.theta = azimuthAngle;
    this._needsUpdate = true;
  }
  // vertical angle
  /**
   * get/set the polar angle (vertical) in radians.
   * @category Properties
   */
  get polarAngle() {
    return this._spherical.phi;
  }
  set polarAngle(polarAngle) {
    if (this._spherical.phi === polarAngle && this._sphericalEnd.phi === polarAngle)
      return;
    this._spherical.phi = polarAngle;
    this._sphericalEnd.phi = polarAngle;
    this._needsUpdate = true;
  }
  /**
   * Whether camera position should be enclosed in the boundary or not.
   * @category Properties
   */
  get boundaryEnclosesCamera() {
    return this._boundaryEnclosesCamera;
  }
  set boundaryEnclosesCamera(boundaryEnclosesCamera) {
    this._boundaryEnclosesCamera = boundaryEnclosesCamera;
    this._needsUpdate = true;
  }
  /**
   * Set drag-start, touches and wheel enable area in the domElement.
   * each values are between `0` and `1` inclusive, where `0` is left/top and `1` is right/bottom of the screen.
   * e.g. `{ x: 0, y: 0, width: 1, height: 1 }` for entire area.
   * @category Properties
   */
  set interactiveArea(interactiveArea) {
    this._interactiveArea.width = clamp(interactiveArea.width, 0, 1);
    this._interactiveArea.height = clamp(interactiveArea.height, 0, 1);
    this._interactiveArea.x = clamp(interactiveArea.x, 0, 1 - this._interactiveArea.width);
    this._interactiveArea.y = clamp(interactiveArea.y, 0, 1 - this._interactiveArea.height);
  }
  /**
   * Adds the specified event listener.
   * Applicable event types (which is `K`) are:
   * | Event name          | Timing |
   * | ------------------- | ------ |
   * | `'controlstart'`    | When the user starts to control the camera via mouse / touches.  |
   * | `'control'`         | When the user controls the camera (dragging). |
   * | `'controlend'`      | When the user ends to control the camera.  |
   * | `'transitionstart'` | When any kind of transition starts, either user control or using a method with `enableTransition = true` |
   * | `'update'`          | When the camera position is updated. |
   * | `'wake'`            | When the camera starts moving. |
   * | `'rest'`            | When the camera movement is below `.restThreshold` . |
   * | `'sleep'`           | When the camera end moving. |
   *
   * 1. `mouseButtons.wheel` (Mouse wheel control) does not emit `'controlstart'` and `'controlend'`. `mouseButtons.wheel` uses scroll-event internally, and scroll-event happens intermittently. That means "start" and "end" cannot be detected.
   * 2. Due to damping, `sleep` will usually fire a few seconds after the camera _appears_ to have stopped moving. If you want to do something (e.g. enable UI, perform another transition) at the point when the camera has stopped, you probably want the `rest` event. This can be fine tuned using the `.restThreshold` parameter. See the [Rest and Sleep Example](https://yomotsu.github.io/camera-controls/examples/rest-and-sleep.html).
   *
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  addEventListener(type, listener) {
    super.addEventListener(type, listener);
  }
  /**
   * Removes the specified event listener
   * e.g.
   * ```
   * cameraControl.addEventListener( 'controlstart', myCallbackFunction );
   * ```
   * @param type event name
   * @param listener handler function
   * @category Methods
   */
  removeEventListener(type, listener) {
    super.removeEventListener(type, listener);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical).
   * Every value is added to the current value.
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotate(azimuthAngle, polarAngle, enableTransition = false) {
    return this.rotateTo(this._sphericalEnd.theta + azimuthAngle, this._sphericalEnd.phi + polarAngle, enableTransition);
  }
  /**
   * Rotate azimuthal angle(horizontal) to the given angle and keep the same polar angle(vertical) target.
   *
   * e.g.
   * ```
   * cameraControls.rotateAzimuthTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param azimuthAngle Azimuth rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotateAzimuthTo(azimuthAngle, enableTransition = false) {
    return this.rotateTo(azimuthAngle, this._sphericalEnd.phi, enableTransition);
  }
  /**
   * Rotate polar angle(vertical) to the given angle and keep the same azimuthal angle(horizontal) target.
   *
   * e.g.
   * ```
   * cameraControls.rotatePolarTo( 30 * THREE.MathUtils.DEG2RAD, true );
   * ```
   * @param polarAngle Polar rotate angle. In radian.
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  rotatePolarTo(polarAngle, enableTransition = false) {
    return this.rotateTo(this._sphericalEnd.theta, polarAngle, enableTransition);
  }
  /**
   * Rotate azimuthal angle(horizontal) and polar angle(vertical) to the given angle.
   * Camera view will rotate over the orbit pivot absolutely:
   *
   * azimuthAngle
   * ```
   *       0
   *         \
   * 90 -----+----- -90
   *           \
   *           180
   * ```
   * | direction | angle                  |
   * | --------- | ---------------------- |
   * | front     | 0                     |
   * | left      | 90 (`Math.PI / 2`)    |
   * | right     | -90 (`- Math.PI / 2`) |
   * | back      | 180 (`Math.PI`)       |
   *
   * polarAngle
   * ```
   *     180
   *      |
   *      90
   *      |
   *      0
   * ```
   * | direction            | angle                  |
   * | -------------------- | ---------------------- |
   * | top/sky              | 180 (`Math.PI`)       |
   * | horizontal from view | 90 (`Math.PI / 2`)    |
   * | bottom/floor         | 0                     |
   *
   * @param azimuthAngle Azimuth rotate angle to. In radian.
   * @param polarAngle Polar rotate angle to. In radian.
   * @param enableTransition  Whether to move smoothly or immediately
   * @category Methods
   */
  rotateTo(azimuthAngle, polarAngle, enableTransition = false) {
    this._isUserControllingRotate = false;
    const theta = clamp(azimuthAngle, this.minAzimuthAngle, this.maxAzimuthAngle);
    const phi = clamp(polarAngle, this.minPolarAngle, this.maxPolarAngle);
    this._sphericalEnd.theta = theta;
    this._sphericalEnd.phi = phi;
    this._sphericalEnd.makeSafe();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._spherical.theta = this._sphericalEnd.theta;
      this._spherical.phi = this._sphericalEnd.phi;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Dolly in/out camera position.
   * @param distance Distance of dollyIn. Negative number for dollyOut.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dolly(distance, enableTransition = false) {
    return this.dollyTo(this._sphericalEnd.radius - distance, enableTransition);
  }
  /**
   * Dolly in/out camera position to given distance.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyTo(distance, enableTransition = false) {
    this._isUserControllingDolly = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    return this._dollyToNoClamp(clamp(distance, this.minDistance, this.maxDistance), enableTransition);
  }
  _dollyToNoClamp(distance, enableTransition = false) {
    const lastRadius = this._sphericalEnd.radius;
    const hasCollider = this.colliderMeshes.length >= 1;
    if (hasCollider) {
      const maxDistanceByCollisionTest = this._collisionTest();
      const isCollided = approxEquals(maxDistanceByCollisionTest, this._spherical.radius);
      const isDollyIn = lastRadius > distance;
      if (!isDollyIn && isCollided)
        return Promise.resolve();
      this._sphericalEnd.radius = Math.min(distance, maxDistanceByCollisionTest);
    } else {
      this._sphericalEnd.radius = distance;
    }
    this._needsUpdate = true;
    if (!enableTransition) {
      this._spherical.radius = this._sphericalEnd.radius;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Dolly in, but does not change the distance between the target and the camera, and moves the target position instead.
   * Specify a negative value for dolly out.
   * @param distance Distance of dolly.
   * @param enableTransition Whether to move smoothly or immediately.
   * @category Methods
   */
  dollyInFixed(distance, enableTransition = false) {
    this._targetEnd.add(this._getCameraDirection(_cameraDirection).multiplyScalar(distance));
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Zoom in/out camera. The value is added to camera zoom.
   * Limits set with `.minZoom` and `.maxZoom`
   * @param zoomStep zoom scale
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  zoom(zoomStep, enableTransition = false) {
    return this.zoomTo(this._zoomEnd + zoomStep, enableTransition);
  }
  /**
   * Zoom in/out camera to given scale. The value overwrites camera zoom.
   * Limits set with .minZoom and .maxZoom
   * @param zoom
   * @param enableTransition
   * @category Methods
   */
  zoomTo(zoom, enableTransition = false) {
    this._isUserControllingZoom = false;
    this._zoomEnd = clamp(zoom, this.minZoom, this.maxZoom);
    this._needsUpdate = true;
    if (!enableTransition) {
      this._zoom = this._zoomEnd;
    }
    const resolveImmediately = !enableTransition || approxEquals(this._zoom, this._zoomEnd, this.restThreshold);
    this._changedZoom = 0;
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * @deprecated `pan()` has been renamed to `truck()`
   * @category Methods
   */
  pan(x, y, enableTransition = false) {
    console.warn("`pan` has been renamed to `truck`");
    return this.truck(x, y, enableTransition);
  }
  /**
   * Truck and pedestal camera using current azimuthal angle
   * @param x Horizontal translate amount
   * @param y Vertical translate amount
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  truck(x, y, enableTransition = false) {
    this._camera.updateMatrix();
    _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
    _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
    _xColumn.multiplyScalar(x);
    _yColumn.multiplyScalar(-y);
    const offset = _v3A.copy(_xColumn).add(_yColumn);
    const to = _v3B.copy(this._targetEnd).add(offset);
    return this.moveTo(to.x, to.y, to.z, enableTransition);
  }
  /**
   * Move forward / backward.
   * @param distance Amount to move forward / backward. Negative value to move backward
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  forward(distance, enableTransition = false) {
    _v3A.setFromMatrixColumn(this._camera.matrix, 0);
    _v3A.crossVectors(this._camera.up, _v3A);
    _v3A.multiplyScalar(distance);
    const to = _v3B.copy(this._targetEnd).add(_v3A);
    return this.moveTo(to.x, to.y, to.z, enableTransition);
  }
  /**
   * Move up / down.
   * @param height Amount to move up / down. Negative value to move down
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  elevate(height, enableTransition = false) {
    _v3A.copy(this._camera.up).multiplyScalar(height);
    return this.moveTo(this._targetEnd.x + _v3A.x, this._targetEnd.y + _v3A.y, this._targetEnd.z + _v3A.z, enableTransition);
  }
  /**
   * Move target position to given point.
   * @param x x coord to move center position
   * @param y y coord to move center position
   * @param z z coord to move center position
   * @param enableTransition Whether to move smoothly or immediately
   * @category Methods
   */
  moveTo(x, y, z, enableTransition = false) {
    this._isUserControllingTruck = false;
    const offset = _v3A.set(x, y, z).sub(this._targetEnd);
    this._encloseToBoundary(this._targetEnd, offset, this.boundaryFriction);
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Look in the given point direction.
   * @param x point x.
   * @param y point y.
   * @param z point z.
   * @param enableTransition Whether to move smoothly or immediately.
   * @returns Transition end promise
   * @category Methods
   */
  lookInDirectionOf(x, y, z, enableTransition = false) {
    const point = _v3A.set(x, y, z);
    const direction = point.sub(this._targetEnd).normalize();
    const position = direction.multiplyScalar(-this._sphericalEnd.radius);
    return this.setPosition(position.x, position.y, position.z, enableTransition);
  }
  /**
   * Fit the viewport to the box or the bounding box of the object, using the nearest axis. paddings are in unit.
   * set `cover: true` to fill enter screen.
   * e.g.
   * ```
   * cameraControls.fitToBox( myMesh );
   * ```
   * @param box3OrObject Axis aligned bounding box to fit the view.
   * @param enableTransition Whether to move smoothly or immediately.
   * @param options | `<object>` { cover: boolean, paddingTop: number, paddingLeft: number, paddingBottom: number, paddingRight: number }
   * @returns Transition end promise
   * @category Methods
   */
  fitToBox(box3OrObject, enableTransition, { cover = false, paddingLeft = 0, paddingRight = 0, paddingBottom = 0, paddingTop = 0 } = {}) {
    const promises = [];
    const aabb = box3OrObject.isBox3 ? _box3A.copy(box3OrObject) : _box3A.setFromObject(box3OrObject);
    if (aabb.isEmpty()) {
      console.warn("camera-controls: fitTo() cannot be used with an empty box. Aborting");
      Promise.resolve();
    }
    const theta = roundToStep(this._sphericalEnd.theta, PI_HALF);
    const phi = roundToStep(this._sphericalEnd.phi, PI_HALF);
    promises.push(this.rotateTo(theta, phi, enableTransition));
    const normal = _v3A.setFromSpherical(this._sphericalEnd).normalize();
    const rotation = _quaternionA.setFromUnitVectors(normal, _AXIS_Z);
    const viewFromPolar = approxEquals(Math.abs(normal.y), 1);
    if (viewFromPolar) {
      rotation.multiply(_quaternionB.setFromAxisAngle(_AXIS_Y, theta));
    }
    rotation.multiply(this._yAxisUpSpaceInverse);
    const bb = _box3B.makeEmpty();
    _v3B.copy(aabb.min).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setX(aabb.max.x).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setY(aabb.max.y).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setZ(aabb.min.z).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.min).setZ(aabb.max.z).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setY(aabb.min.y).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).setX(aabb.min.x).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    _v3B.copy(aabb.max).applyQuaternion(rotation);
    bb.expandByPoint(_v3B);
    bb.min.x -= paddingLeft;
    bb.min.y -= paddingBottom;
    bb.max.x += paddingRight;
    bb.max.y += paddingTop;
    rotation.setFromUnitVectors(_AXIS_Z, normal);
    if (viewFromPolar) {
      rotation.premultiply(_quaternionB.invert());
    }
    rotation.premultiply(this._yAxisUpSpace);
    const bbSize = bb.getSize(_v3A);
    const center = bb.getCenter(_v3B).applyQuaternion(rotation);
    if (isPerspectiveCamera(this._camera)) {
      const distance = this.getDistanceToFitBox(bbSize.x, bbSize.y, bbSize.z, cover);
      promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));
      promises.push(this.dollyTo(distance, enableTransition));
      promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    } else if (isOrthographicCamera(this._camera)) {
      const camera = this._camera;
      const width = camera.right - camera.left;
      const height = camera.top - camera.bottom;
      const zoom = cover ? Math.max(width / bbSize.x, height / bbSize.y) : Math.min(width / bbSize.x, height / bbSize.y);
      promises.push(this.moveTo(center.x, center.y, center.z, enableTransition));
      promises.push(this.zoomTo(zoom, enableTransition));
      promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    }
    return Promise.all(promises);
  }
  /**
   * Fit the viewport to the sphere or the bounding sphere of the object.
   * @param sphereOrMesh
   * @param enableTransition
   * @category Methods
   */
  fitToSphere(sphereOrMesh, enableTransition) {
    const promises = [];
    const isSphere = sphereOrMesh instanceof THREE.Sphere;
    const boundingSphere = isSphere ? _sphere.copy(sphereOrMesh) : _CameraControls.createBoundingSphere(sphereOrMesh, _sphere);
    promises.push(this.moveTo(boundingSphere.center.x, boundingSphere.center.y, boundingSphere.center.z, enableTransition));
    if (isPerspectiveCamera(this._camera)) {
      const distanceToFit = this.getDistanceToFitSphere(boundingSphere.radius);
      promises.push(this.dollyTo(distanceToFit, enableTransition));
    } else if (isOrthographicCamera(this._camera)) {
      const width = this._camera.right - this._camera.left;
      const height = this._camera.top - this._camera.bottom;
      const diameter = 2 * boundingSphere.radius;
      const zoom = Math.min(width / diameter, height / diameter);
      promises.push(this.zoomTo(zoom, enableTransition));
    }
    promises.push(this.setFocalOffset(0, 0, 0, enableTransition));
    return Promise.all(promises);
  }
  /**
   * Look at the `target` from the `position`.
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setLookAt(positionX, positionY, positionZ, targetX, targetY, targetZ, enableTransition = false) {
    this._isUserControllingRotate = false;
    this._isUserControllingDolly = false;
    this._isUserControllingTruck = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    const target = _v3B.set(targetX, targetY, targetZ);
    const position = _v3A.set(positionX, positionY, positionZ);
    this._targetEnd.copy(target);
    this._sphericalEnd.setFromVector3(position.sub(target).applyQuaternion(this._yAxisUpSpace));
    this.normalizeRotations();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
      this._spherical.copy(this._sphericalEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) && approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Similar to setLookAt, but it interpolates between two states.
   * @param positionAX
   * @param positionAY
   * @param positionAZ
   * @param targetAX
   * @param targetAY
   * @param targetAZ
   * @param positionBX
   * @param positionBY
   * @param positionBZ
   * @param targetBX
   * @param targetBY
   * @param targetBZ
   * @param t
   * @param enableTransition
   * @category Methods
   */
  lerpLookAt(positionAX, positionAY, positionAZ, targetAX, targetAY, targetAZ, positionBX, positionBY, positionBZ, targetBX, targetBY, targetBZ, t, enableTransition = false) {
    this._isUserControllingRotate = false;
    this._isUserControllingDolly = false;
    this._isUserControllingTruck = false;
    this._lastDollyDirection = DOLLY_DIRECTION.NONE;
    this._changedDolly = 0;
    const targetA = _v3A.set(targetAX, targetAY, targetAZ);
    const positionA = _v3B.set(positionAX, positionAY, positionAZ);
    _sphericalA.setFromVector3(positionA.sub(targetA).applyQuaternion(this._yAxisUpSpace));
    const targetB = _v3C.set(targetBX, targetBY, targetBZ);
    const positionB = _v3B.set(positionBX, positionBY, positionBZ);
    _sphericalB.setFromVector3(positionB.sub(targetB).applyQuaternion(this._yAxisUpSpace));
    this._targetEnd.copy(targetA.lerp(targetB, t));
    const deltaTheta = _sphericalB.theta - _sphericalA.theta;
    const deltaPhi = _sphericalB.phi - _sphericalA.phi;
    const deltaRadius = _sphericalB.radius - _sphericalA.radius;
    this._sphericalEnd.set(_sphericalA.radius + deltaRadius * t, _sphericalA.phi + deltaPhi * t, _sphericalA.theta + deltaTheta * t);
    this.normalizeRotations();
    this._needsUpdate = true;
    if (!enableTransition) {
      this._target.copy(this._targetEnd);
      this._spherical.copy(this._sphericalEnd);
    }
    const resolveImmediately = !enableTransition || approxEquals(this._target.x, this._targetEnd.x, this.restThreshold) && approxEquals(this._target.y, this._targetEnd.y, this.restThreshold) && approxEquals(this._target.z, this._targetEnd.z, this.restThreshold) && approxEquals(this._spherical.theta, this._sphericalEnd.theta, this.restThreshold) && approxEquals(this._spherical.phi, this._sphericalEnd.phi, this.restThreshold) && approxEquals(this._spherical.radius, this._sphericalEnd.radius, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Set angle and distance by given position.
   * An alias of `setLookAt()`, without target change. Thus keep gazing at the current target
   * @param positionX
   * @param positionY
   * @param positionZ
   * @param enableTransition
   * @category Methods
   */
  setPosition(positionX, positionY, positionZ, enableTransition = false) {
    return this.setLookAt(positionX, positionY, positionZ, this._targetEnd.x, this._targetEnd.y, this._targetEnd.z, enableTransition);
  }
  /**
   * Set the target position where gaze at.
   * An alias of `setLookAt()`, without position change. Thus keep the same position.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @param enableTransition
   * @category Methods
   */
  setTarget(targetX, targetY, targetZ, enableTransition = false) {
    const pos = this.getPosition(_v3A);
    const promise = this.setLookAt(pos.x, pos.y, pos.z, targetX, targetY, targetZ, enableTransition);
    this._sphericalEnd.phi = clamp(this._sphericalEnd.phi, this.minPolarAngle, this.maxPolarAngle);
    return promise;
  }
  /**
   * Set focal offset using the screen parallel coordinates. z doesn't affect in Orthographic as with Dolly.
   * @param x
   * @param y
   * @param z
   * @param enableTransition
   * @category Methods
   */
  setFocalOffset(x, y, z, enableTransition = false) {
    this._isUserControllingOffset = false;
    this._focalOffsetEnd.set(x, y, z);
    this._needsUpdate = true;
    if (!enableTransition)
      this._focalOffset.copy(this._focalOffsetEnd);
    const resolveImmediately = !enableTransition || approxEquals(this._focalOffset.x, this._focalOffsetEnd.x, this.restThreshold) && approxEquals(this._focalOffset.y, this._focalOffsetEnd.y, this.restThreshold) && approxEquals(this._focalOffset.z, this._focalOffsetEnd.z, this.restThreshold);
    return this._createOnRestPromise(resolveImmediately);
  }
  /**
   * Set orbit point without moving the camera.
   * SHOULD NOT RUN DURING ANIMATIONS. `setOrbitPoint()` will immediately fix the positions.
   * @param targetX
   * @param targetY
   * @param targetZ
   * @category Methods
   */
  setOrbitPoint(targetX, targetY, targetZ) {
    this._camera.updateMatrixWorld();
    _xColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 0);
    _yColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 1);
    _zColumn.setFromMatrixColumn(this._camera.matrixWorldInverse, 2);
    const position = _v3A.set(targetX, targetY, targetZ);
    const distance = position.distanceTo(this._camera.position);
    const cameraToPoint = position.sub(this._camera.position);
    _xColumn.multiplyScalar(cameraToPoint.x);
    _yColumn.multiplyScalar(cameraToPoint.y);
    _zColumn.multiplyScalar(cameraToPoint.z);
    _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
    _v3A.z = _v3A.z + distance;
    this.dollyTo(distance, false);
    this.setFocalOffset(-_v3A.x, _v3A.y, -_v3A.z, false);
    this.moveTo(targetX, targetY, targetZ, false);
  }
  /**
   * Set the boundary box that encloses the target of the camera. box3 is in THREE.Box3
   * @param box3
   * @category Methods
   */
  setBoundary(box3) {
    if (!box3) {
      this._boundary.min.set(-Infinity, -Infinity, -Infinity);
      this._boundary.max.set(Infinity, Infinity, Infinity);
      this._needsUpdate = true;
      return;
    }
    this._boundary.copy(box3);
    this._boundary.clampPoint(this._targetEnd, this._targetEnd);
    this._needsUpdate = true;
  }
  /**
   * Set (or unset) the current viewport.
   * Set this when you want to use renderer viewport and .dollyToCursor feature at the same time.
   * @param viewportOrX
   * @param y
   * @param width
   * @param height
   * @category Methods
   */
  setViewport(viewportOrX, y, width, height) {
    if (viewportOrX === null) {
      this._viewport = null;
      return;
    }
    this._viewport = this._viewport || new THREE.Vector4();
    if (typeof viewportOrX === "number") {
      this._viewport.set(viewportOrX, y, width, height);
    } else {
      this._viewport.copy(viewportOrX);
    }
  }
  /**
   * Calculate the distance to fit the box.
   * @param width box width
   * @param height box height
   * @param depth box depth
   * @returns distance
   * @category Methods
   */
  getDistanceToFitBox(width, height, depth, cover = false) {
    if (notSupportedInOrthographicCamera(this._camera, "getDistanceToFitBox"))
      return this._spherical.radius;
    const boundingRectAspect = width / height;
    const fov = this._camera.getEffectiveFOV() * DEG2RAD;
    const aspect = this._camera.aspect;
    const heightToFit = (cover ? boundingRectAspect > aspect : boundingRectAspect < aspect) ? height : width / aspect;
    return heightToFit * 0.5 / Math.tan(fov * 0.5) + depth * 0.5;
  }
  /**
   * Calculate the distance to fit the sphere.
   * @param radius sphere radius
   * @returns distance
   * @category Methods
   */
  getDistanceToFitSphere(radius) {
    if (notSupportedInOrthographicCamera(this._camera, "getDistanceToFitSphere"))
      return this._spherical.radius;
    const vFOV = this._camera.getEffectiveFOV() * DEG2RAD;
    const hFOV = Math.atan(Math.tan(vFOV * 0.5) * this._camera.aspect) * 2;
    const fov = 1 < this._camera.aspect ? vFOV : hFOV;
    return radius / Math.sin(fov * 0.5);
  }
  /**
   * Returns the orbit center position, where the camera looking at.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getTarget(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.copy(receiveEndValue ? this._targetEnd : this._target);
  }
  /**
   * Returns the camera position.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getPosition(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.setFromSpherical(receiveEndValue ? this._sphericalEnd : this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(receiveEndValue ? this._targetEnd : this._target);
  }
  /**
   * Returns the spherical coordinates of the orbit.
   * @param out The receiving Spherical instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getSpherical(out, receiveEndValue = true) {
    const _out = !!out && out instanceof THREE.Spherical ? out : new THREE.Spherical();
    return _out.copy(receiveEndValue ? this._sphericalEnd : this._spherical);
  }
  /**
   * Returns the focal offset, which is how much the camera appears to be translated in screen parallel coordinates.
   * @param out The receiving Vector3 instance to copy the result
   * @param receiveEndValue Whether receive the transition end coords or current. default is `true`
   * @category Methods
   */
  getFocalOffset(out, receiveEndValue = true) {
    const _out = !!out && out.isVector3 ? out : new THREE.Vector3();
    return _out.copy(receiveEndValue ? this._focalOffsetEnd : this._focalOffset);
  }
  /**
   * Normalize camera azimuth angle rotation between 0 and 360 degrees.
   * @category Methods
   */
  normalizeRotations() {
    this._sphericalEnd.theta = this._sphericalEnd.theta % PI_2;
    if (this._sphericalEnd.theta < 0)
      this._sphericalEnd.theta += PI_2;
    this._spherical.theta += PI_2 * Math.round((this._sphericalEnd.theta - this._spherical.theta) / PI_2);
  }
  /**
   * Reset all rotation and position to defaults.
   * @param enableTransition
   * @category Methods
   */
  reset(enableTransition = false) {
    if (!approxEquals(this._camera.up.x, this._cameraUp0.x) || !approxEquals(this._camera.up.y, this._cameraUp0.y) || !approxEquals(this._camera.up.z, this._cameraUp0.z)) {
      this._camera.up.copy(this._cameraUp0);
      const position = this.getPosition(_v3A);
      this.updateCameraUp();
      this.setPosition(position.x, position.y, position.z);
    }
    const promises = [
      this.setLookAt(this._position0.x, this._position0.y, this._position0.z, this._target0.x, this._target0.y, this._target0.z, enableTransition),
      this.setFocalOffset(this._focalOffset0.x, this._focalOffset0.y, this._focalOffset0.z, enableTransition),
      this.zoomTo(this._zoom0, enableTransition)
    ];
    return Promise.all(promises);
  }
  /**
   * Set current camera position as the default position.
   * @category Methods
   */
  saveState() {
    this._cameraUp0.copy(this._camera.up);
    this.getTarget(this._target0);
    this.getPosition(this._position0);
    this._zoom0 = this._zoom;
    this._focalOffset0.copy(this._focalOffset);
  }
  /**
   * Sync camera-up direction.
   * When camera-up vector is changed, `.updateCameraUp()` must be called.
   * @category Methods
   */
  updateCameraUp() {
    this._yAxisUpSpace.setFromUnitVectors(this._camera.up, _AXIS_Y);
    this._yAxisUpSpaceInverse.copy(this._yAxisUpSpace).invert();
  }
  /**
   * Apply current camera-up direction to the camera.
   * The orbit system will be re-initialized with the current position.
   * @category Methods
   */
  applyCameraUp() {
    const cameraDirection = _v3A.subVectors(this._target, this._camera.position).normalize();
    const side = _v3B.crossVectors(cameraDirection, this._camera.up);
    this._camera.up.crossVectors(side, cameraDirection).normalize();
    this._camera.updateMatrixWorld();
    const position = this.getPosition(_v3A);
    this.updateCameraUp();
    this.setPosition(position.x, position.y, position.z);
  }
  /**
   * Update camera position and directions.
   * This should be called in your tick loop every time, and returns true if re-rendering is needed.
   * @param delta
   * @returns updated
   * @category Methods
   */
  update(delta) {
    const deltaTheta = this._sphericalEnd.theta - this._spherical.theta;
    const deltaPhi = this._sphericalEnd.phi - this._spherical.phi;
    const deltaRadius = this._sphericalEnd.radius - this._spherical.radius;
    const deltaTarget = _deltaTarget.subVectors(this._targetEnd, this._target);
    const deltaOffset = _deltaOffset.subVectors(this._focalOffsetEnd, this._focalOffset);
    const deltaZoom = this._zoomEnd - this._zoom;
    if (approxZero(deltaTheta)) {
      this._thetaVelocity.value = 0;
      this._spherical.theta = this._sphericalEnd.theta;
    } else {
      const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.theta = smoothDamp(this._spherical.theta, this._sphericalEnd.theta, this._thetaVelocity, smoothTime, Infinity, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaPhi)) {
      this._phiVelocity.value = 0;
      this._spherical.phi = this._sphericalEnd.phi;
    } else {
      const smoothTime = this._isUserControllingRotate ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.phi = smoothDamp(this._spherical.phi, this._sphericalEnd.phi, this._phiVelocity, smoothTime, Infinity, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaRadius)) {
      this._radiusVelocity.value = 0;
      this._spherical.radius = this._sphericalEnd.radius;
    } else {
      const smoothTime = this._isUserControllingDolly ? this.draggingSmoothTime : this.smoothTime;
      this._spherical.radius = smoothDamp(this._spherical.radius, this._sphericalEnd.radius, this._radiusVelocity, smoothTime, this.maxSpeed, delta);
      this._needsUpdate = true;
    }
    if (approxZero(deltaTarget.x) && approxZero(deltaTarget.y) && approxZero(deltaTarget.z)) {
      this._targetVelocity.set(0, 0, 0);
      this._target.copy(this._targetEnd);
    } else {
      const smoothTime = this._isUserControllingTruck ? this.draggingSmoothTime : this.smoothTime;
      smoothDampVec3(this._target, this._targetEnd, this._targetVelocity, smoothTime, this.maxSpeed, delta, this._target);
      this._needsUpdate = true;
    }
    if (approxZero(deltaOffset.x) && approxZero(deltaOffset.y) && approxZero(deltaOffset.z)) {
      this._focalOffsetVelocity.set(0, 0, 0);
      this._focalOffset.copy(this._focalOffsetEnd);
    } else {
      const smoothTime = this._isUserControllingOffset ? this.draggingSmoothTime : this.smoothTime;
      smoothDampVec3(this._focalOffset, this._focalOffsetEnd, this._focalOffsetVelocity, smoothTime, this.maxSpeed, delta, this._focalOffset);
      this._needsUpdate = true;
    }
    if (approxZero(deltaZoom)) {
      this._zoomVelocity.value = 0;
      this._zoom = this._zoomEnd;
    } else {
      const smoothTime = this._isUserControllingZoom ? this.draggingSmoothTime : this.smoothTime;
      this._zoom = smoothDamp(this._zoom, this._zoomEnd, this._zoomVelocity, smoothTime, Infinity, delta);
    }
    if (this.dollyToCursor) {
      if (isPerspectiveCamera(this._camera) && this._changedDolly !== 0) {
        const dollyControlAmount = this._spherical.radius - this._lastDistance;
        const camera = this._camera;
        const cameraDirection = this._getCameraDirection(_cameraDirection);
        const planeX = _v3A.copy(cameraDirection).cross(camera.up).normalize();
        if (planeX.lengthSq() === 0)
          planeX.x = 1;
        const planeY = _v3B.crossVectors(planeX, cameraDirection);
        const worldToScreen = this._sphericalEnd.radius * Math.tan(camera.getEffectiveFOV() * DEG2RAD * 0.5);
        const prevRadius = this._sphericalEnd.radius - dollyControlAmount;
        const lerpRatio = (prevRadius - this._sphericalEnd.radius) / this._sphericalEnd.radius;
        const cursor = _v3C.copy(this._targetEnd).add(planeX.multiplyScalar(this._dollyControlCoord.x * worldToScreen * camera.aspect)).add(planeY.multiplyScalar(this._dollyControlCoord.y * worldToScreen));
        const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);
        const isMin = this._lastDollyDirection === DOLLY_DIRECTION.IN && this._spherical.radius <= this.minDistance;
        const isMax = this._lastDollyDirection === DOLLY_DIRECTION.OUT && this.maxDistance <= this._spherical.radius;
        if (this.infinityDolly && (isMin || isMax)) {
          this._sphericalEnd.radius -= dollyControlAmount;
          this._spherical.radius -= dollyControlAmount;
          const dollyAmount = _v3B.copy(cameraDirection).multiplyScalar(-dollyControlAmount);
          newTargetEnd.add(dollyAmount);
        }
        this._boundary.clampPoint(newTargetEnd, newTargetEnd);
        const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);
        this._targetEnd.copy(newTargetEnd);
        this._target.add(targetEndDiff);
        this._changedDolly -= dollyControlAmount;
        if (approxZero(this._changedDolly))
          this._changedDolly = 0;
      } else if (isOrthographicCamera(this._camera) && this._changedZoom !== 0) {
        const dollyControlAmount = this._zoom - this._lastZoom;
        const camera = this._camera;
        const worldCursorPosition = _v3A.set(this._dollyControlCoord.x, this._dollyControlCoord.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera);
        const quaternion = _v3B.set(0, 0, -1).applyQuaternion(camera.quaternion);
        const cursor = _v3C.copy(worldCursorPosition).add(quaternion.multiplyScalar(-worldCursorPosition.dot(camera.up)));
        const prevZoom = this._zoom - dollyControlAmount;
        const lerpRatio = -(prevZoom - this._zoom) / this._zoom;
        const cameraDirection = this._getCameraDirection(_cameraDirection);
        const prevPlaneConstant = this._targetEnd.dot(cameraDirection);
        const newTargetEnd = _v3A.copy(this._targetEnd).lerp(cursor, lerpRatio);
        const newPlaneConstant = newTargetEnd.dot(cameraDirection);
        const pullBack = cameraDirection.multiplyScalar(newPlaneConstant - prevPlaneConstant);
        newTargetEnd.sub(pullBack);
        this._boundary.clampPoint(newTargetEnd, newTargetEnd);
        const targetEndDiff = _v3B.subVectors(newTargetEnd, this._targetEnd);
        this._targetEnd.copy(newTargetEnd);
        this._target.add(targetEndDiff);
        this._changedZoom -= dollyControlAmount;
        if (approxZero(this._changedZoom))
          this._changedZoom = 0;
      }
    }
    if (this._camera.zoom !== this._zoom) {
      this._camera.zoom = this._zoom;
      this._camera.updateProjectionMatrix();
      this._updateNearPlaneCorners();
      this._needsUpdate = true;
    }
    this._dragNeedsUpdate = true;
    const maxDistance = this._collisionTest();
    this._spherical.radius = Math.min(this._spherical.radius, maxDistance);
    this._spherical.makeSafe();
    this._camera.position.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse).add(this._target);
    this._camera.lookAt(this._target);
    const affectOffset = !approxZero(this._focalOffset.x) || !approxZero(this._focalOffset.y) || !approxZero(this._focalOffset.z);
    if (affectOffset) {
      this._camera.updateMatrixWorld();
      _xColumn.setFromMatrixColumn(this._camera.matrix, 0);
      _yColumn.setFromMatrixColumn(this._camera.matrix, 1);
      _zColumn.setFromMatrixColumn(this._camera.matrix, 2);
      _xColumn.multiplyScalar(this._focalOffset.x);
      _yColumn.multiplyScalar(-this._focalOffset.y);
      _zColumn.multiplyScalar(this._focalOffset.z);
      _v3A.copy(_xColumn).add(_yColumn).add(_zColumn);
      this._camera.position.add(_v3A);
    }
    if (this._boundaryEnclosesCamera) {
      this._encloseToBoundary(this._camera.position.copy(this._target), _v3A.setFromSpherical(this._spherical).applyQuaternion(this._yAxisUpSpaceInverse), 1);
    }
    const updated = this._needsUpdate;
    if (updated && !this._updatedLastTime) {
      this._hasRested = false;
      this.dispatchEvent({ type: "wake" });
      this.dispatchEvent({ type: "update" });
    } else if (updated) {
      this.dispatchEvent({ type: "update" });
      if (approxZero(deltaTheta, this.restThreshold) && approxZero(deltaPhi, this.restThreshold) && approxZero(deltaRadius, this.restThreshold) && approxZero(deltaTarget.x, this.restThreshold) && approxZero(deltaTarget.y, this.restThreshold) && approxZero(deltaTarget.z, this.restThreshold) && approxZero(deltaOffset.x, this.restThreshold) && approxZero(deltaOffset.y, this.restThreshold) && approxZero(deltaOffset.z, this.restThreshold) && approxZero(deltaZoom, this.restThreshold) && !this._hasRested) {
        this._hasRested = true;
        this.dispatchEvent({ type: "rest" });
      }
    } else if (!updated && this._updatedLastTime) {
      this.dispatchEvent({ type: "sleep" });
    }
    this._lastDistance = this._spherical.radius;
    this._lastZoom = this._zoom;
    this._updatedLastTime = updated;
    this._needsUpdate = false;
    return updated;
  }
  /**
   * Get all state in JSON string
   * @category Methods
   */
  toJSON() {
    return JSON.stringify({
      enabled: this._enabled,
      minDistance: this.minDistance,
      maxDistance: infinityToMaxNumber(this.maxDistance),
      minZoom: this.minZoom,
      maxZoom: infinityToMaxNumber(this.maxZoom),
      minPolarAngle: this.minPolarAngle,
      maxPolarAngle: infinityToMaxNumber(this.maxPolarAngle),
      minAzimuthAngle: infinityToMaxNumber(this.minAzimuthAngle),
      maxAzimuthAngle: infinityToMaxNumber(this.maxAzimuthAngle),
      smoothTime: this.smoothTime,
      draggingSmoothTime: this.draggingSmoothTime,
      dollySpeed: this.dollySpeed,
      truckSpeed: this.truckSpeed,
      dollyToCursor: this.dollyToCursor,
      verticalDragToForward: this.verticalDragToForward,
      target: this._targetEnd.toArray(),
      position: _v3A.setFromSpherical(this._sphericalEnd).add(this._targetEnd).toArray(),
      zoom: this._zoomEnd,
      focalOffset: this._focalOffsetEnd.toArray(),
      target0: this._target0.toArray(),
      position0: this._position0.toArray(),
      zoom0: this._zoom0,
      focalOffset0: this._focalOffset0.toArray()
    });
  }
  /**
   * Reproduce the control state with JSON. enableTransition is where anim or not in a boolean.
   * @param json
   * @param enableTransition
   * @category Methods
   */
  fromJSON(json, enableTransition = false) {
    const obj = JSON.parse(json);
    this.enabled = obj.enabled;
    this.minDistance = obj.minDistance;
    this.maxDistance = maxNumberToInfinity(obj.maxDistance);
    this.minZoom = obj.minZoom;
    this.maxZoom = maxNumberToInfinity(obj.maxZoom);
    this.minPolarAngle = obj.minPolarAngle;
    this.maxPolarAngle = maxNumberToInfinity(obj.maxPolarAngle);
    this.minAzimuthAngle = maxNumberToInfinity(obj.minAzimuthAngle);
    this.maxAzimuthAngle = maxNumberToInfinity(obj.maxAzimuthAngle);
    this.smoothTime = obj.smoothTime;
    this.draggingSmoothTime = obj.draggingSmoothTime;
    this.dollySpeed = obj.dollySpeed;
    this.truckSpeed = obj.truckSpeed;
    this.dollyToCursor = obj.dollyToCursor;
    this.verticalDragToForward = obj.verticalDragToForward;
    this._target0.fromArray(obj.target0);
    this._position0.fromArray(obj.position0);
    this._zoom0 = obj.zoom0;
    this._focalOffset0.fromArray(obj.focalOffset0);
    this.moveTo(obj.target[0], obj.target[1], obj.target[2], enableTransition);
    _sphericalA.setFromVector3(_v3A.fromArray(obj.position).sub(this._targetEnd).applyQuaternion(this._yAxisUpSpace));
    this.rotateTo(_sphericalA.theta, _sphericalA.phi, enableTransition);
    this.dollyTo(_sphericalA.radius, enableTransition);
    this.zoomTo(obj.zoom, enableTransition);
    this.setFocalOffset(obj.focalOffset[0], obj.focalOffset[1], obj.focalOffset[2], enableTransition);
    this._needsUpdate = true;
  }
  /**
   * Attach all internal event handlers to enable drag control.
   * @category Methods
   */
  connect(domElement) {
    if (this._domElement) {
      console.warn("camera-controls is already connected.");
      return;
    }
    domElement.setAttribute("data-camera-controls-version", VERSION);
    this._addAllEventListeners(domElement);
    this._getClientRect(this._elementRect);
  }
  /**
   * Detach all internal event handlers to disable drag control.
   */
  disconnect() {
    this.cancel();
    this._removeAllEventListeners();
    if (this._domElement) {
      this._domElement.removeAttribute("data-camera-controls-version");
      this._domElement = void 0;
    }
  }
  /**
   * Dispose the cameraControls instance itself, remove all eventListeners.
   * @category Methods
   */
  dispose() {
    this.removeAllEventListeners();
    this.disconnect();
  }
  // it's okay to expose public though
  _getTargetDirection(out) {
    return out.setFromSpherical(this._spherical).divideScalar(this._spherical.radius).applyQuaternion(this._yAxisUpSpaceInverse);
  }
  // it's okay to expose public though
  _getCameraDirection(out) {
    return this._getTargetDirection(out).negate();
  }
  _findPointerById(pointerId) {
    return this._activePointers.find((activePointer) => activePointer.pointerId === pointerId);
  }
  _findPointerByMouseButton(mouseButton) {
    return this._activePointers.find((activePointer) => activePointer.mouseButton === mouseButton);
  }
  _disposePointer(pointer) {
    this._activePointers.splice(this._activePointers.indexOf(pointer), 1);
  }
  _encloseToBoundary(position, offset, friction) {
    const offsetLength2 = offset.lengthSq();
    if (offsetLength2 === 0) {
      return position;
    }
    const newTarget = _v3B.copy(offset).add(position);
    const clampedTarget = this._boundary.clampPoint(newTarget, _v3C);
    const deltaClampedTarget = clampedTarget.sub(newTarget);
    const deltaClampedTargetLength2 = deltaClampedTarget.lengthSq();
    if (deltaClampedTargetLength2 === 0) {
      return position.add(offset);
    } else if (deltaClampedTargetLength2 === offsetLength2) {
      return position;
    } else if (friction === 0) {
      return position.add(offset).add(deltaClampedTarget);
    } else {
      const offsetFactor = 1 + friction * deltaClampedTargetLength2 / offset.dot(deltaClampedTarget);
      return position.add(_v3B.copy(offset).multiplyScalar(offsetFactor)).add(deltaClampedTarget.multiplyScalar(1 - friction));
    }
  }
  _updateNearPlaneCorners() {
    if (isPerspectiveCamera(this._camera)) {
      const camera = this._camera;
      const near = camera.near;
      const fov = camera.getEffectiveFOV() * DEG2RAD;
      const heightHalf = Math.tan(fov * 0.5) * near;
      const widthHalf = heightHalf * camera.aspect;
      this._nearPlaneCorners[0].set(-widthHalf, -heightHalf, 0);
      this._nearPlaneCorners[1].set(widthHalf, -heightHalf, 0);
      this._nearPlaneCorners[2].set(widthHalf, heightHalf, 0);
      this._nearPlaneCorners[3].set(-widthHalf, heightHalf, 0);
    } else if (isOrthographicCamera(this._camera)) {
      const camera = this._camera;
      const zoomInv = 1 / camera.zoom;
      const left = camera.left * zoomInv;
      const right = camera.right * zoomInv;
      const top = camera.top * zoomInv;
      const bottom = camera.bottom * zoomInv;
      this._nearPlaneCorners[0].set(left, top, 0);
      this._nearPlaneCorners[1].set(right, top, 0);
      this._nearPlaneCorners[2].set(right, bottom, 0);
      this._nearPlaneCorners[3].set(left, bottom, 0);
    }
  }
  // lateUpdate
  _collisionTest() {
    let distance = Infinity;
    const hasCollider = this.colliderMeshes.length >= 1;
    if (!hasCollider)
      return distance;
    if (notSupportedInOrthographicCamera(this._camera, "_collisionTest"))
      return distance;
    const rayDirection = this._getTargetDirection(_cameraDirection);
    _rotationMatrix.lookAt(_ORIGIN, rayDirection, this._camera.up);
    for (let i = 0; i < 4; i++) {
      const nearPlaneCorner = _v3B.copy(this._nearPlaneCorners[i]);
      nearPlaneCorner.applyMatrix4(_rotationMatrix);
      const origin = _v3C.addVectors(this._target, nearPlaneCorner);
      _raycaster$1.set(origin, rayDirection);
      _raycaster$1.far = this._spherical.radius + 1;
      const intersects2 = _raycaster$1.intersectObjects(this.colliderMeshes);
      if (intersects2.length !== 0 && intersects2[0].distance < distance) {
        distance = intersects2[0].distance;
      }
    }
    return distance;
  }
  /**
   * Get its client rect and package into given `DOMRect` .
   */
  _getClientRect(target) {
    if (!this._domElement)
      return;
    const rect = this._domElement.getBoundingClientRect();
    target.x = rect.left;
    target.y = rect.top;
    if (this._viewport) {
      target.x += this._viewport.x;
      target.y += rect.height - this._viewport.w - this._viewport.y;
      target.width = this._viewport.z;
      target.height = this._viewport.w;
    } else {
      target.width = rect.width;
      target.height = rect.height;
    }
    return target;
  }
  _createOnRestPromise(resolveImmediately) {
    if (resolveImmediately)
      return Promise.resolve();
    this._hasRested = false;
    this.dispatchEvent({ type: "transitionstart" });
    return new Promise((resolve) => {
      const onResolve = () => {
        this.removeEventListener("rest", onResolve);
        resolve();
      };
      this.addEventListener("rest", onResolve);
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  _addAllEventListeners(_domElement) {
  }
  _removeAllEventListeners() {
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  get dampingFactor() {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
    return 0;
  }
  /**
   * backward compatible
   * @deprecated use smoothTime (in seconds) instead
   * @category Properties
   */
  set dampingFactor(_) {
    console.warn(".dampingFactor has been deprecated. use smoothTime (in seconds) instead.");
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  get draggingDampingFactor() {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
    return 0;
  }
  /**
   * backward compatible
   * @deprecated use draggingSmoothTime (in seconds) instead
   * @category Properties
   */
  set draggingDampingFactor(_) {
    console.warn(".draggingDampingFactor has been deprecated. use draggingSmoothTime (in seconds) instead.");
  }
  static createBoundingSphere(object3d, out = new THREE.Sphere()) {
    const boundingSphere = out;
    const center = boundingSphere.center;
    _box3A.makeEmpty();
    object3d.traverseVisible((object) => {
      if (!object.isMesh)
        return;
      _box3A.expandByObject(object);
    });
    _box3A.getCenter(center);
    let maxRadiusSq = 0;
    object3d.traverseVisible((object) => {
      if (!object.isMesh)
        return;
      const mesh = object;
      const geometry = mesh.geometry.clone();
      geometry.applyMatrix4(mesh.matrixWorld);
      const bufferGeometry = geometry;
      const position = bufferGeometry.attributes.position;
      for (let i = 0, l = position.count; i < l; i++) {
        _v3A.fromBufferAttribute(position, i);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_v3A));
      }
    });
    boundingSphere.radius = Math.sqrt(maxRadiusSq);
    return boundingSphere;
  }
};
var SimpleCamera = class _SimpleCamera extends BaseCamera {
  constructor(components) {
    super(components);
    __publicField2(this, "onBeforeUpdate", new Event());
    __publicField2(this, "onAfterUpdate", new Event());
    __publicField2(this, "onAspectUpdated", new Event());
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "three");
    __publicField2(this, "_allControls", /* @__PURE__ */ new Map());
    __publicField2(this, "updateAspect", () => {
      var _a;
      if (!this.currentWorld || !this.currentWorld.renderer)
        return;
      if (this.three instanceof OrthographicCamera) {
        this.onAspectUpdated.trigger();
        return;
      }
      if ((_a = this.currentWorld.renderer) == null ? void 0 : _a.isResizeable()) {
        const size = this.currentWorld.renderer.getSize();
        this.three.aspect = size.width / size.height;
        this.three.updateProjectionMatrix();
        this.onAspectUpdated.trigger();
      }
    });
    this.three = this.setupCamera();
    this.setupEvents(true);
    this.onWorldChanged.add(({ action, world }) => {
      if (action === "added") {
        const controls = this.newCameraControls();
        this._allControls.set(world.uuid, controls);
      }
      if (action === "removed") {
        const controls = this._allControls.get(world.uuid);
        if (controls) {
          controls.dispose();
          this._allControls.delete(world.uuid);
        }
      }
    });
  }
  /**
   * The object that controls the camera. An instance of
   * [yomotsu's cameracontrols](https://github.com/yomotsu/camera-controls).
   * Transforming the camera directly will have no effect: you need to use this
   * object to move, rotate, look at objects, etc.
   */
  get controls() {
    if (!this.currentWorld) {
      throw new Error("This camera needs a world to work!");
    }
    const controls = this._allControls.get(this.currentWorld.uuid);
    if (!controls) {
      throw new Error("Controls not found!");
    }
    return controls;
  }
  /**
   * Getter for the enabled state of the camera controls.
   * If the current world is null, it returns false.
   * Otherwise, it returns the enabled state of the camera controls.
   *
   * @returns {boolean} The enabled state of the camera controls.
   */
  get enabled() {
    if (this.currentWorld === null) {
      return false;
    }
    return this.controls.enabled;
  }
  /**
   * Setter for the enabled state of the camera controls.
   * If the current world is not null, it sets the enabled state of the camera controls to the provided value.
   *
   * @param {boolean} enabled - The new enabled state of the camera controls.
   */
  set enabled(enabled) {
    if (this.currentWorld !== null) {
      this.controls.enabled = enabled;
    }
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false);
    this.onAspectUpdated.reset();
    this.onBeforeUpdate.reset();
    this.onAfterUpdate.reset();
    this.three.removeFromParent();
    this.onDisposed.trigger();
    this.onDisposed.reset();
    for (const [_id, controls] of this._allControls) {
      controls.dispose();
    }
  }
  /** {@link Updateable.update} */
  update(_delta) {
    if (this.enabled) {
      this.onBeforeUpdate.trigger(this);
      this.controls.update(_delta);
      this.onAfterUpdate.trigger(this);
    }
  }
  setupCamera() {
    const aspect = window.innerWidth / window.innerHeight;
    const camera = new PerspectiveCamera(60, aspect, 1, 1e3);
    camera.position.set(50, 50, 50);
    camera.lookAt(new Vector3(0, 0, 0));
    return camera;
  }
  newCameraControls() {
    if (!this.currentWorld) {
      throw new Error("This camera needs a world to work!");
    }
    if (!this.currentWorld.renderer) {
      throw new Error("This camera needs a renderer to work!");
    }
    CameraControls.install({ THREE: _SimpleCamera.getSubsetOfThree() });
    const { domElement } = this.currentWorld.renderer.three;
    const controls = new CameraControls(this.three, domElement);
    controls.smoothTime = 0.2;
    controls.dollyToCursor = true;
    controls.infinityDolly = true;
    controls.minDistance = 6;
    return controls;
  }
  setupEvents(active) {
    if (active) {
      window.addEventListener("resize", this.updateAspect);
    } else {
      window.removeEventListener("resize", this.updateAspect);
    }
  }
  static getSubsetOfThree() {
    return {
      MOUSE,
      Vector2,
      Vector3,
      Vector4,
      Quaternion,
      Matrix4,
      Spherical,
      Box3,
      Sphere,
      Raycaster,
      MathUtils
    };
  }
};
var _Worlds = class _Worlds2 extends Component {
  constructor(components) {
    super(components);
    __publicField2(this, "onAfterUpdate", new Event());
    __publicField2(this, "onBeforeUpdate", new Event());
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "list", new DataMap());
    __publicField2(this, "enabled", true);
    components.add(_Worlds2.uuid, this);
  }
  /**
   * Creates a new instance of a SimpleWorld and adds it to the list of worlds.
   *
   * @template T - The type of the scene, extending from BaseScene. Defaults to BaseScene.
   * @template U - The type of the camera, extending from BaseCamera. Defaults to BaseCamera.
   * @template S - The type of the renderer, extending from BaseRenderer. Defaults to BaseRenderer.
   *
   * @throws {Error} - Throws an error if a world with the same UUID already exists in the list.
   */
  create() {
    const world = new SimpleWorld(this.components);
    const id = world.uuid;
    if (this.list.has(id)) {
      throw new Error("There is already a world with this name!");
    }
    this.list.set(id, world);
    return world;
  }
  /**
   * Deletes a world from the list of worlds.
   *
   * @param {World} world - The world to be deleted.
   *
   * @throws {Error} - Throws an error if the provided world is not found in the list.
   */
  delete(world) {
    if (!this.list.has(world.uuid)) {
      throw new Error("The provided world is not found in the list!");
    }
    this.list.delete(world.uuid);
    world.dispose();
  }
  /**
   * Disposes of the Worlds component and all its managed worlds.
   * This method sets the enabled flag to false, disposes of all worlds, clears the list,
   * and triggers the onDisposed event.
   */
  dispose() {
    this.enabled = false;
    for (const [_id, world] of this.list) {
      world.dispose();
    }
    this.list.clear();
    this.onDisposed.trigger();
  }
  /** {@link Updateable.update} */
  update(delta) {
    if (!this.enabled)
      return;
    for (const [_id, world] of this.list) {
      world.update(delta);
    }
  }
};
__publicField2(_Worlds, "uuid", "fdb61dc4-2ec1-4966-b83d-54ea795fad4a");
var Worlds = _Worlds;
function clientWaitAsync(gl, sync, flags, intervalMilliseconds) {
  return new Promise((resolve, reject) => {
    function test() {
      const res = gl.clientWaitSync(sync, flags, 0);
      if (res === gl.WAIT_FAILED) {
        reject();
        return;
      }
      if (res === gl.TIMEOUT_EXPIRED) {
        setTimeout(test, intervalMilliseconds);
        return;
      }
      resolve();
    }
    test();
  });
}
async function getBufferSubDataAsync(gl, target, buffer, srcByteOffset, dstBuffer, dstOffset, length) {
  const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
  gl.flush();
  await clientWaitAsync(gl, sync, 0, 10);
  gl.deleteSync(sync);
  gl.bindBuffer(target, buffer);
  gl.getBufferSubData(target, srcByteOffset, dstBuffer, dstOffset, length);
  gl.bindBuffer(target, null);
}
async function readPixelsAsync(gl, x, y, w, h, format, type, dest) {
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
  gl.bufferData(gl.PIXEL_PACK_BUFFER, dest.byteLength, gl.STREAM_READ);
  gl.readPixels(x, y, w, h, format, type, 0);
  gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
  await getBufferSubDataAsync(gl, gl.PIXEL_PACK_BUFFER, buf, 0, dest);
  gl.deleteBuffer(buf);
  return dest;
}
var CullerRendererConfigManager = class extends Configurator {
  constructor() {
    super(...arguments);
    __publicField2(this, "_config", {
      enabled: {
        value: true,
        type: "Boolean"
      },
      width: {
        type: "Number",
        interpolable: true,
        value: 512,
        min: 32,
        max: 1024
      },
      height: {
        type: "Number",
        interpolable: true,
        value: 512,
        min: 32,
        max: 1024
      },
      autoUpdate: {
        value: true,
        type: "Boolean"
      },
      renderDebugFrame: {
        value: false,
        type: "Boolean"
      },
      updateInterval: {
        type: "Number",
        interpolable: true,
        value: 1,
        min: 0,
        max: 1
      },
      threshold: {
        type: "Number",
        interpolable: true,
        value: 100,
        min: 1,
        max: 512
      }
    });
    __publicField2(this, "_interval", null);
  }
  get enabled() {
    return this._config.enabled.value;
  }
  set enabled(value) {
    this._config.enabled.value = value;
    this._component.enabled = value;
  }
  get width() {
    return this._config.width.value;
  }
  set width(value) {
    this.setWidthHeight(value, this.height);
  }
  get height() {
    return this._config.height.value;
  }
  set height(value) {
    this.setWidthHeight(this.width, value);
  }
  get autoUpdate() {
    return this._config.autoUpdate.value;
  }
  set autoUpdate(value) {
    this.setAutoAndInterval(value, this.updateInterval);
  }
  get updateInterval() {
    return this._config.updateInterval.value;
  }
  set updateInterval(value) {
    this.setAutoAndInterval(this.autoUpdate, value);
  }
  get renderDebugFrame() {
    return this._config.renderDebugFrame.value;
  }
  set renderDebugFrame(value) {
    this._config.renderDebugFrame.value = value;
  }
  get threshold() {
    return this._config.threshold.value;
  }
  set threshold(value) {
    this._config.threshold.value = value;
  }
  setWidthHeight(width, height) {
    if (width <= 0 || height <= 0) {
      throw new Error(
        "The width and height of the culler renderer must be more than 0!"
      );
    }
    this._config.width.value = width;
    this._config.height.value = height;
    this.resetRenderTarget();
  }
  setAutoAndInterval(auto, interval) {
    if (interval <= 0) {
      throw new Error(
        "The updateInterval of the culler renderer must be more than 0!"
      );
    }
    this._config.autoUpdate.value = auto;
    this._config.updateInterval.value = interval;
    this.resetInterval(auto);
  }
  resetRenderTarget() {
    this._component.renderTarget.dispose();
    this._component.renderTarget = new WebGLRenderTarget(
      this.width,
      this.height
    );
    this._component.bufferSize = this.width * this.height * 4;
    this._component.buffer = new Uint8Array(this._component.bufferSize);
  }
  resetInterval(enabled) {
    if (this._interval !== null) {
      window.clearInterval(this._interval);
    }
    if (!enabled)
      return;
    this._interval = window.setInterval(async () => {
      if (!this._component.preventUpdate) {
        await this._component.updateVisibility();
      }
    }, this.updateInterval);
  }
};
var CullerRenderer = class {
  constructor(components, world) {
    __publicField2(this, "onSetup", new Event());
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "onViewUpdated", new AsyncEvent());
    __publicField2(this, "enabled", true);
    __publicField2(this, "needsUpdate", false);
    __publicField2(this, "components");
    __publicField2(this, "renderTarget", new WebGLRenderTarget());
    __publicField2(this, "bufferSize", 1);
    __publicField2(this, "buffer", new Uint8Array());
    __publicField2(this, "preventUpdate", false);
    __publicField2(this, "config");
    __publicField2(this, "isSetup", false);
    __publicField2(this, "world");
    __publicField2(this, "renderer");
    __publicField2(this, "_defaultConfig", {
      enabled: true,
      height: 512,
      width: 512,
      updateInterval: 1e3,
      autoUpdate: true,
      renderDebugFrame: false,
      threshold: 100
    });
    __publicField2(this, "worker");
    __publicField2(this, "scene", new Scene());
    __publicField2(this, "_availableColor", 1);
    __publicField2(this, "_isWorkerBusy", false);
    __publicField2(this, "updateVisibility", async (force) => {
      if (!this.enabled)
        return;
      if (!this.needsUpdate && !force)
        return;
      if (this._isWorkerBusy)
        return;
      this._isWorkerBusy = true;
      const camera = this.world.camera.three;
      camera.updateMatrix();
      const { width, height } = this.config;
      this.renderer.setSize(width, height);
      this.renderer.setRenderTarget(this.renderTarget);
      this.renderer.render(this.scene, camera);
      const context = this.renderer.getContext();
      await readPixelsAsync(
        context,
        0,
        0,
        width,
        height,
        context.RGBA,
        context.UNSIGNED_BYTE,
        this.buffer
      );
      this.renderer.setRenderTarget(null);
      if (this.config.renderDebugFrame) {
        this.renderer.render(this.scene, camera);
      }
      this.worker.postMessage({
        buffer: this.buffer
      });
      this.needsUpdate = false;
    });
    if (!world.renderer) {
      throw new Error("The given world must have a renderer!");
    }
    this.components = components;
    this.config = new CullerRendererConfigManager(
      this,
      this.components,
      "Culler renderer"
    );
    this.world = world;
    this.renderer = new WebGLRenderer();
    this.renderer.clippingPlanes = world.renderer.clippingPlanes;
    const code = `
      addEventListener("message", (event) => {
        const { buffer } = event.data;
        const colors = new Map();
        for (let i = 0; i < buffer.length; i += 4) {
          const r = buffer[i];
          const g = buffer[i + 1];
          const b = buffer[i + 2];
          const code = "" + r + "-" + g + "-" + b;
          if(colors.has(code)) {
            colors.set(code, colors.get(code) + 1);
          } else {
            colors.set(code, 1);
          }
        }
        postMessage({ colors });
      });
    `;
    const blob = new Blob([code], { type: "application/javascript" });
    this.worker = new Worker(URL.createObjectURL(blob));
    this.setup();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false;
    this.config.autoUpdate = false;
    const configs = this.components.get(ConfigManager);
    configs.list.delete(this.config.uuid);
    for (const child of this.scene.children) {
      child.removeFromParent();
    }
    this.onViewUpdated.reset();
    this.worker.terminate();
    this.renderer.forceContextLoss();
    this.renderer.dispose();
    this.renderTarget.dispose();
    this.buffer = null;
    this.onDisposed.reset();
  }
  setup(config) {
    const fullConfig = { ...this._defaultConfig, ...config };
    const { width, height } = fullConfig;
    this.config.setWidthHeight(width, height);
    const { updateInterval, autoUpdate } = fullConfig;
    this.config.setAutoAndInterval(autoUpdate, updateInterval);
    this.config.threshold = fullConfig.threshold;
    this.isSetup = true;
    this.onSetup.trigger();
  }
  getAvailableColor() {
    let bigOne = BigInt(this._availableColor.toString());
    const colorArray = [];
    do {
      colorArray.unshift(Number(bigOne % 256n));
      bigOne /= 256n;
    } while (bigOne);
    while (colorArray.length !== 3) {
      colorArray.unshift(0);
    }
    const [r, g, b] = colorArray;
    const code = `${r}-${g}-${b}`;
    return { r, g, b, code };
  }
  increaseColor() {
    if (this._availableColor === 256 * 256 * 256) {
      console.warn("Color can't be increased over 256 x 256 x 256!");
      return;
    }
    this._availableColor++;
  }
  decreaseColor() {
    if (this._availableColor === 1) {
      console.warn("Color can't be decreased under 0!");
      return;
    }
    this._availableColor--;
  }
};
var MeshCullerRenderer = class extends CullerRenderer {
  constructor(components, world) {
    super(components, world);
    __publicField2(this, "onViewUpdated", new Event());
    __publicField2(this, "colorMeshes", /* @__PURE__ */ new Map());
    __publicField2(this, "_colorCodeMeshMap", /* @__PURE__ */ new Map());
    __publicField2(this, "_meshIDColorCodeMap", /* @__PURE__ */ new Map());
    __publicField2(this, "_currentVisibleMeshes", /* @__PURE__ */ new Set());
    __publicField2(this, "_recentlyHiddenMeshes", /* @__PURE__ */ new Set());
    __publicField2(this, "_transparentMat", new MeshBasicMaterial({
      transparent: true,
      opacity: 0
    }));
    __publicField2(this, "handleWorkerMessage", async (event) => {
      if (this.preventUpdate) {
        return;
      }
      const colors = event.data.colors;
      this._recentlyHiddenMeshes = new Set(this._currentVisibleMeshes);
      this._currentVisibleMeshes.clear();
      for (const [code, pixels] of colors) {
        if (pixels < this.config.threshold) {
          continue;
        }
        const mesh = this._colorCodeMeshMap.get(code);
        if (mesh) {
          this._currentVisibleMeshes.add(mesh);
          this._recentlyHiddenMeshes.delete(mesh);
        }
      }
      this.onViewUpdated.trigger({
        seen: this._currentVisibleMeshes,
        unseen: this._recentlyHiddenMeshes
      });
      this._isWorkerBusy = false;
    });
    this.worker.addEventListener("message", this.handleWorkerMessage);
    this.onViewUpdated.add(({ seen, unseen }) => {
      for (const mesh of seen) {
        mesh.visible = true;
      }
      for (const mesh of unseen) {
        mesh.visible = false;
      }
    });
  }
  /**
   * @deprecated use config.threshold instead.
   */
  get threshold() {
    return this.config.threshold;
  }
  /**
   * @deprecated use config.threshold instead.
   */
  set threshold(value) {
    this.config.threshold = value;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    super.dispose();
    this._currentVisibleMeshes.clear();
    this._recentlyHiddenMeshes.clear();
    this._meshIDColorCodeMap.clear();
    this._transparentMat.dispose();
    this._colorCodeMeshMap.clear();
    const disposer = this.components.get(Disposer);
    for (const id in this.colorMeshes) {
      const mesh = this.colorMeshes.get(id);
      if (mesh) {
        disposer.destroy(mesh, true);
      }
    }
    this.colorMeshes.clear();
  }
  /**
   * Adds a mesh to the culler. When the mesh is not visibile anymore, it will be removed from the scene. When it's visible again, it will be added to the scene.
   * @param mesh - The mesh to add. It can be a regular THREE.Mesh or an instance of THREE.InstancedMesh.
   */
  add(mesh) {
    if (!this.enabled)
      return;
    if (this.preventUpdate) {
      console.log("Culler processing not finished yet.");
      return;
    }
    this.preventUpdate = true;
    const isInstanced = mesh instanceof InstancedMesh;
    const { geometry, material } = mesh;
    const { colorMaterial, code } = this.getAvailableMaterial();
    let newMaterial;
    if (Array.isArray(material)) {
      let transparentOnly = true;
      const matArray = [];
      for (const mat of material) {
        if (MaterialsUtils.isTransparent(mat)) {
          matArray.push(this._transparentMat);
        } else {
          transparentOnly = false;
          matArray.push(colorMaterial);
        }
      }
      if (transparentOnly) {
        colorMaterial.dispose();
        this.preventUpdate = false;
        return;
      }
      newMaterial = matArray;
    } else if (MaterialsUtils.isTransparent(material)) {
      colorMaterial.dispose();
      this.preventUpdate = false;
      return;
    } else {
      newMaterial = colorMaterial;
    }
    this._colorCodeMeshMap.set(code, mesh);
    this._meshIDColorCodeMap.set(mesh.uuid, code);
    const count = isInstanced ? mesh.count : 1;
    const colorMesh = new InstancedMesh(geometry, newMaterial, count);
    if (isInstanced) {
      colorMesh.instanceMatrix = mesh.instanceMatrix;
    } else {
      colorMesh.setMatrixAt(0, new Matrix4());
    }
    mesh.visible = false;
    mesh.updateWorldMatrix(true, false);
    colorMesh.applyMatrix4(mesh.matrixWorld);
    colorMesh.updateMatrix();
    this.scene.add(colorMesh);
    this.colorMeshes.set(mesh.uuid, colorMesh);
    this.increaseColor();
    this.preventUpdate = false;
  }
  /**
   * Removes a mesh from the culler, so its visibility is not controlled by the culler anymore.
   * When the mesh is removed, it will be hidden from the scene and its color-coded mesh will be destroyed.
   * @param mesh - The mesh to remove. It can be a regular THREE.Mesh or an instance of THREE.InstancedMesh.
   */
  remove(mesh) {
    if (this.preventUpdate) {
      console.log("Culler processing not finished yet.");
      return;
    }
    this.preventUpdate = true;
    const disposer = this.components.get(Disposer);
    this._currentVisibleMeshes.delete(mesh);
    this._recentlyHiddenMeshes.delete(mesh);
    const colorMesh = this.colorMeshes.get(mesh.uuid);
    const code = this._meshIDColorCodeMap.get(mesh.uuid);
    if (!colorMesh || !code) {
      this.preventUpdate = false;
      return;
    }
    this._colorCodeMeshMap.delete(code);
    this._meshIDColorCodeMap.delete(mesh.uuid);
    this.colorMeshes.delete(mesh.uuid);
    colorMesh.geometry = void 0;
    colorMesh.material = [];
    disposer.destroy(colorMesh, true);
    this._recentlyHiddenMeshes.delete(mesh);
    this._currentVisibleMeshes.delete(mesh);
    this.preventUpdate = false;
  }
  /**
   * Updates the given instanced meshes inside the culler. You should use this if you change the count property, e.g. when changing the visibility of fragments.
   *
   * @param meshes - The meshes to update.
   *
   * @returns {void}
   */
  updateInstanced(meshes) {
    for (const mesh of meshes) {
      const colorMesh = this.colorMeshes.get(mesh.uuid);
      if (!colorMesh) {
        continue;
      }
      colorMesh.count = mesh.count;
    }
  }
  getAvailableMaterial() {
    const { r, g, b, code } = this.getAvailableColor();
    const colorEnabled = ColorManagement.enabled;
    ColorManagement.enabled = false;
    const color = new Color(`rgb(${r}, ${g}, ${b})`);
    if (!this.world.renderer) {
      throw new Error("Renderer not found in the world!");
    }
    const clippingPlanes = this.world.renderer.clippingPlanes;
    const colorMaterial = new MeshBasicMaterial({
      color,
      clippingPlanes,
      side: DoubleSide
    });
    ColorManagement.enabled = colorEnabled;
    return { colorMaterial, code };
  }
};
var _Cullers = class _Cullers2 extends Component {
  constructor(components) {
    super(components);
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "_enabled", true);
    __publicField2(this, "list", /* @__PURE__ */ new Map());
    components.add(_Cullers2.uuid, this);
  }
  /** {@link Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link Component.enabled} */
  set enabled(value) {
    this._enabled = value;
    for (const [_id, renderer] of this.list) {
      renderer.enabled = value;
    }
  }
  /**
   * Creates a new MeshCullerRenderer for the given world.
   * If a MeshCullerRenderer already exists for the world, it will return the existing one.
   *
   * @param world - The world for which to create the MeshCullerRenderer.
   *
   * @returns The newly created or existing MeshCullerRenderer for the given world.
   */
  create(world) {
    if (this.list.has(world.uuid)) {
      return this.list.get(world.uuid);
    }
    const culler = new MeshCullerRenderer(this.components, world);
    this.list.set(world.uuid, culler);
    return culler;
  }
  /**
   * Deletes the MeshCullerRenderer associated with the given world.
   * If a MeshCullerRenderer exists for the given world, it will be disposed and removed from the list.
   *
   * @param world - The world for which to delete the MeshCullerRenderer.
   *
   * @returns {void}
   */
  delete(world) {
    const culler = this.list.get(world.uuid);
    if (culler) {
      culler.dispose();
    }
    this.list.delete(world.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false;
    this.onDisposed.trigger(_Cullers2.uuid);
    this.onDisposed.reset();
    for (const [_id, culler] of this.list) {
      culler.dispose();
    }
    this.list.clear();
  }
  /**
   * Updates the given instanced meshes inside the all the cullers. You should use this if you change the count property, e.g. when changing the visibility of fragments.
   *
   * @param meshes - The meshes to update.
   *
   */
  updateInstanced(meshes) {
    for (const [, culler] of this.list) {
      culler.updateInstanced(meshes);
    }
  }
};
__publicField2(_Cullers, "uuid", "69f2a50d-c266-44fc-b1bd-fa4d34be89e6");
var Cullers = _Cullers;
var DistanceRenderer = class {
  constructor(components, world) {
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "onDistanceComputed", new Event());
    __publicField2(this, "excludedObjects", /* @__PURE__ */ new Set());
    __publicField2(this, "enabled", true);
    __publicField2(this, "renderDebugFrame", false);
    __publicField2(this, "components");
    __publicField2(this, "scene", new Scene());
    __publicField2(this, "camera", new OrthographicCamera(-1, 1, 1, -1, 0, 1));
    __publicField2(this, "depthMaterial");
    __publicField2(this, "world");
    __publicField2(this, "renderer");
    __publicField2(this, "worker");
    __publicField2(this, "_width", 512);
    __publicField2(this, "_height", 512);
    __publicField2(this, "_postQuad");
    __publicField2(this, "tempRT");
    __publicField2(this, "resultRT");
    __publicField2(this, "bufferSize");
    __publicField2(this, "_buffer");
    __publicField2(this, "_isWorkerBusy", false);
    __publicField2(this, "compute", async () => {
      if (!this.enabled || this.world.isDisposing) {
        return;
      }
      if (this._isWorkerBusy) {
        return;
      }
      this._isWorkerBusy = true;
      this.world.camera.three.updateMatrix();
      this.renderer.setSize(this._width, this._height);
      this.renderer.setRenderTarget(this.tempRT);
      const tempVariableName = "visibilityBeforeDistanceCheck";
      for (const object of this.excludedObjects) {
        object.userData[tempVariableName] = object.visible;
        object.visible = false;
      }
      this.renderer.render(this.world.scene.three, this.world.camera.three);
      for (const object of this.excludedObjects) {
        if (object.userData[tempVariableName] !== void 0) {
          object.visible = object.userData[tempVariableName];
        }
      }
      this.depthMaterial.uniforms.tDiffuse.value = this.tempRT.texture;
      this.depthMaterial.uniforms.tDepth.value = this.tempRT.depthTexture;
      this.renderer.setRenderTarget(this.resultRT);
      this.renderer.render(this.scene, this.camera);
      const context = this.renderer.getContext();
      try {
        await readPixelsAsync(
          context,
          0,
          0,
          this._width,
          this._height,
          context.RGBA,
          context.UNSIGNED_BYTE,
          this._buffer
        );
      } catch (e) {
        this.renderer.setRenderTarget(null);
        this._isWorkerBusy = false;
        return;
      }
      this.renderer.setRenderTarget(null);
      if (this.renderDebugFrame) {
        this.renderer.render(this.scene, this.camera);
      }
      this.worker.postMessage({
        buffer: this._buffer
      });
    });
    __publicField2(this, "handleWorkerMessage", (event) => {
      if (!this.enabled || this.world.isDisposing) {
        return;
      }
      const colors = event.data.colors;
      let min = Number.MAX_VALUE;
      for (const value of colors) {
        if (value === 0) {
          continue;
        }
        if (value < min) {
          min = value;
        }
      }
      const camera2 = this.world.camera.three || OrthographicCamera;
      const normalized = min / 255;
      const maxFoundDistance = (normalized - 1) * -1 * (camera2.far - camera2.near);
      const maxValidDistance = Math.min(maxFoundDistance, camera2.far);
      this.onDistanceComputed.trigger(maxValidDistance);
      this._isWorkerBusy = false;
    });
    if (!world.renderer) {
      throw new Error("The given world must have a renderer!");
    }
    this.components = components;
    this.world = world;
    const camera = world.camera.three;
    this.renderer = new WebGLRenderer();
    this.tempRT = new WebGLRenderTarget(this._width, this._height);
    this.bufferSize = this._width * this._height * 4;
    this._buffer = new Uint8Array(this.bufferSize);
    this.tempRT.texture.minFilter = NearestFilter;
    this.tempRT.texture.magFilter = NearestFilter;
    this.tempRT.stencilBuffer = false;
    this.tempRT.samples = 0;
    this.tempRT.depthTexture = new DepthTexture(
      this._width,
      this._height
    );
    this.tempRT.depthTexture.format = DepthFormat;
    this.tempRT.depthTexture.type = UnsignedShortType;
    this.resultRT = new WebGLRenderTarget(this._width, this._height);
    this.depthMaterial = new ShaderMaterial({
      vertexShader: `
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
    `,
      fragmentShader: `
#include <packing>

varying vec2 vUv;
uniform sampler2D tDiffuse;
uniform sampler2D tDepth;
uniform float cameraNear;
uniform float cameraFar;


float readDepth( sampler2D depthSampler, vec2 coord ) {
  float fragCoordZ = texture2D( depthSampler, coord ).x;
  float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
  return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );
}

void main() {
  //vec3 diffuse = texture2D( tDiffuse, vUv ).rgb;
  float depth = readDepth( tDepth, vUv );

  gl_FragColor.rgb = 1.0 - vec3( depth );
  gl_FragColor.a = 1.0;
}
    `,
      uniforms: {
        cameraNear: { value: camera.near },
        cameraFar: { value: camera.far },
        tDiffuse: { value: null },
        tDepth: { value: null }
      }
    });
    const postPlane = new PlaneGeometry(2, 2);
    this._postQuad = new Mesh(postPlane, this.depthMaterial);
    this.scene.add(this._postQuad);
    this.renderer.clippingPlanes = world.renderer.clippingPlanes;
    const code = `
      addEventListener("message", (event) => {
        const { buffer } = event.data;
        const colors = new Set();
        for (let i = 0; i < buffer.length; i += 4) {
          const r = buffer[i];
          colors.add(r);
        }
        postMessage({ colors });
      });
    `;
    const blob = new Blob([code], { type: "application/javascript" });
    this.worker = new Worker(URL.createObjectURL(blob));
    this.worker.addEventListener("message", this.handleWorkerMessage);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false;
    this.onDistanceComputed.reset();
    this.worker.terminate();
    this.renderer.forceContextLoss();
    this.renderer.dispose();
    this.tempRT.dispose();
    this.resultRT.dispose();
    const children = [...this.scene.children];
    this.excludedObjects.clear();
    for (const child of children) {
      child.removeFromParent();
    }
    this._postQuad.geometry.dispose();
    this._postQuad.removeFromParent();
    this._buffer = null;
    this.onDisposed.reset();
  }
};
var ShadowedScene = class extends SimpleScene {
  constructor() {
    super(...arguments);
    __publicField2(this, "_distanceRenderer");
    __publicField2(this, "autoBias", true);
    __publicField2(this, "_defaultShadowConfig", {
      cascade: 1,
      resolution: 512
    });
    __publicField2(this, "_lightsWithShadow", /* @__PURE__ */ new Map());
    __publicField2(this, "_isComputingShadows", false);
    __publicField2(this, "_shadowsEnabled", true);
    __publicField2(this, "_bias", 0);
    __publicField2(this, "recomputeShadows", (farthestDistance) => {
      if (!this._shadowsEnabled) {
        return;
      }
      if (this.autoBias) {
        this.bias = farthestDistance / -1e5;
      }
      const factor = 1.5;
      farthestDistance *= factor;
      if (!this.currentWorld) {
        throw new Error(
          "A world needs to be assigned to the scene before computing shadows!"
        );
      }
      if (!this._lightsWithShadow.size) {
        throw new Error("No shadows found!");
      }
      const camera = this.currentWorld.camera.three;
      if (!(camera instanceof PerspectiveCamera) && !(camera instanceof OrthographicCamera)) {
        throw new Error("Invalid camera type!");
      }
      const camDirection = new Vector3();
      camera.getWorldDirection(camDirection);
      let currentDistance = farthestDistance;
      const lightDirection = new Vector3();
      lightDirection.copy(this.config.directionalLight.position);
      lightDirection.normalize();
      for (const [index, id] of this._lightsWithShadow) {
        const light = this.directionalLights.get(id);
        if (!light) {
          throw new Error("Light not found.");
        }
        const shadowCenter = new Vector3();
        shadowCenter.copy(camDirection);
        const isLastShadow = index === this._lightsWithShadow.size - 1;
        const shadowOffset = isLastShadow ? currentDistance / 2 : currentDistance * 2 / 3;
        shadowCenter.multiplyScalar(shadowOffset);
        shadowCenter.add(camera.position);
        const shadowRadius = currentDistance - shadowOffset;
        const lightOffset = new Vector3();
        lightOffset.copy(lightDirection);
        lightOffset.multiplyScalar(shadowRadius);
        light.target.position.copy(shadowCenter);
        light.position.copy(shadowCenter);
        light.position.add(lightOffset);
        light.shadow.camera.right = shadowRadius;
        light.shadow.camera.left = -shadowRadius;
        light.shadow.camera.top = shadowRadius;
        light.shadow.camera.bottom = -shadowRadius;
        light.shadow.camera.far = shadowRadius * 2;
        light.shadow.camera.updateProjectionMatrix();
        light.shadow.camera.updateMatrix();
        if (!isLastShadow) {
          currentDistance /= 3;
        }
      }
      this._isComputingShadows = false;
    });
  }
  /**
   * The getter for the bias to prevent artifacts (stripes). It usually ranges between 0 and -0.005.
   */
  get bias() {
    return this._bias;
  }
  /**
   * The setter for the bias to prevent artifacts (stripes). It usually ranges between 0 and -0.005.
   */
  set bias(value) {
    this._bias = value;
    for (const [, id] of this._lightsWithShadow) {
      const light = this.directionalLights.get(id);
      if (light) {
        light.shadow.bias = value;
      }
    }
  }
  /**
   * Getter to see whether the shadows are enabled or not in this scene instance.
   */
  get shadowsEnabled() {
    return this._shadowsEnabled;
  }
  /**
   * Setter to control whether the shadows are enabled or not in this scene instance.
   */
  set shadowsEnabled(value) {
    this._shadowsEnabled = value;
    for (const [, light] of this.directionalLights) {
      light.castShadow = value;
    }
  }
  /**
   * Getter to get the renderer used to determine the farthest distance from the camera.
   */
  get distanceRenderer() {
    if (!this._distanceRenderer) {
      throw new Error(
        "You must set up this component before accessing the distance renderer!"
      );
    }
    return this._distanceRenderer;
  }
  /** {@link Configurable.setup} */
  setup(config) {
    super.setup(config);
    const fullConfig = {
      ...this._defaultConfig,
      ...this._defaultShadowConfig,
      ...config
    };
    if (fullConfig.cascade <= 0) {
      throw new Error(
        "Config.shadows.cascade must be a natural number greater than 0!"
      );
    }
    if (fullConfig.cascade > 1) {
      throw new Error("Multiple shadows not supported yet!");
    }
    if (!this.currentWorld) {
      throw new Error(
        "A world needs to be assigned to the scene before setting it up!"
      );
    }
    for (const [, light] of this.directionalLights) {
      light.target.removeFromParent();
      light.removeFromParent();
      light.dispose();
    }
    this.directionalLights.clear();
    if (!this._distanceRenderer) {
      this._distanceRenderer = new DistanceRenderer(
        this.components,
        this.currentWorld
      );
      this._distanceRenderer.onDistanceComputed.add(this.recomputeShadows);
    }
    this._lightsWithShadow.clear();
    for (let i = 0; i < fullConfig.cascade; i++) {
      const light = new DirectionalLight();
      light.intensity = this.config.directionalLight.intensity;
      light.color = this.config.directionalLight.color;
      light.position.copy(this.config.directionalLight.position);
      light.shadow.mapSize.width = fullConfig.resolution;
      light.shadow.mapSize.height = fullConfig.resolution;
      this.three.add(light, light.target);
      this.directionalLights.set(light.uuid, light);
      this._lightsWithShadow.set(i, light.uuid);
      light.castShadow = true;
      light.shadow.bias = this._bias;
    }
  }
  /** {@link Disposable.dispose} */
  dispose() {
    super.dispose();
    if (this._distanceRenderer) {
      this._distanceRenderer.dispose();
    }
    this._lightsWithShadow.clear();
  }
  /** Update all the shadows of the scene. */
  async updateShadows() {
    if (this._isComputingShadows || !this._shadowsEnabled) {
      return;
    }
    this._isComputingShadows = true;
    await this.distanceRenderer.compute();
  }
};
var Mouse = class {
  constructor(dom) {
    __publicField2(this, "_event");
    __publicField2(this, "_position", new Vector2());
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "updateMouseInfo", (event) => {
      this._event = event;
    });
    this.dom = dom;
    this.setupEvents(true);
  }
  /**
   * The real position of the mouse of the Three.js canvas.
   */
  get position() {
    if (this._event) {
      const bounds = this.dom.getBoundingClientRect();
      this._position.x = this.getPositionX(bounds, this._event);
      this._position.y = this.getPositionY(bounds, this._event);
    }
    return this._position;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false);
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  getPositionY(bound, event) {
    const data = this.getDataObject(event);
    return -((data.clientY - bound.top) / (bound.bottom - bound.top)) * 2 + 1;
  }
  getPositionX(bound, event) {
    const data = this.getDataObject(event);
    return (data.clientX - bound.left) / (bound.right - bound.left) * 2 - 1;
  }
  getDataObject(event) {
    return event instanceof MouseEvent ? event : event.touches[0];
  }
  setupEvents(active) {
    if (active) {
      this.dom.addEventListener("pointermove", this.updateMouseInfo);
      this.dom.addEventListener("touchstart", this.updateMouseInfo);
    } else {
      this.dom.removeEventListener("pointermove", this.updateMouseInfo);
      this.dom.removeEventListener("touchstart", this.updateMouseInfo);
    }
  }
};
var SimpleRaycaster = class {
  constructor(components, world) {
    __publicField2(this, "enabled", true);
    __publicField2(this, "components");
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "mouse");
    __publicField2(this, "three", new Raycaster());
    __publicField2(this, "world");
    const renderer = world.renderer;
    if (!renderer) {
      throw new Error("A renderer is needed for the raycaster to work!");
    }
    this.world = world;
    this.mouse = new Mouse(renderer.three.domElement);
    this.components = components;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.mouse.dispose();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  /**
   * Throws a ray from the camera to the mouse or touch event point and returns
   * the first item found. This also takes into account the clipping planes
   * used by the renderer.
   *
   * @param items - the [meshes](https://threejs.org/docs/#api/en/objects/Mesh)
   * to query. If not provided, it will query all the meshes stored in
   * {@link Components.meshes}.
   * @param position - the screen position to use for raycasting. If not provided,
   * the last pointer (mouse/touch) position will be used.
   */
  castRay(items = Array.from(this.world.meshes), position = this.mouse.position) {
    if (!this.world) {
      throw new Error("A world is needed to cast rays!");
    }
    const camera = this.world.camera.three;
    this.three.setFromCamera(position, camera);
    return this.intersect(items);
  }
  /**
   * Casts a ray from a given origin in a given direction and returns the first item found.
   * This method also takes into account the clipping planes used by the renderer.
   *
   * @param origin - The origin of the ray.
   * @param direction - The direction of the ray.
   * @param items - The meshes to query. If not provided, it will query all the meshes stored in {@link World.meshes}.
   * @returns The first intersection found or `null` if no intersection was found.
   */
  castRayFromVector(origin, direction, items = Array.from(this.world.meshes)) {
    this.three.set(origin, direction);
    return this.intersect(items);
  }
  intersect(items = Array.from(this.world.meshes)) {
    const result = this.three.intersectObjects(items);
    const filtered = this.filterClippingPlanes(result);
    return filtered.length > 0 ? filtered[0] : null;
  }
  filterClippingPlanes(objs) {
    if (!this.world.renderer) {
      throw new Error("Renderer not found!");
    }
    const renderer = this.world.renderer.three;
    if (!renderer.clippingPlanes) {
      return objs;
    }
    const planes = renderer.clippingPlanes;
    if (objs.length <= 0 || !planes || (planes == null ? void 0 : planes.length) <= 0)
      return objs;
    return objs.filter(
      (elem) => planes.every((elem2) => elem2.distanceToPoint(elem.point) > 0)
    );
  }
};
var _Raycasters = class _Raycasters2 extends Component {
  constructor(components) {
    super(components);
    __publicField2(this, "enabled", true);
    __publicField2(this, "list", /* @__PURE__ */ new Map());
    __publicField2(this, "onDisposed", new Event());
    components.add(_Raycasters2.uuid, this);
  }
  /**
   * Retrieves a SimpleRaycaster instance for the given world.
   * If a SimpleRaycaster instance already exists for the world, it will be returned.
   * Otherwise, a new SimpleRaycaster instance will be created and added to the list.
   *
   * @param world - The world for which to retrieve or create a SimpleRaycaster instance.
   * @returns The SimpleRaycaster instance for the given world.
   */
  get(world) {
    if (this.list.has(world.uuid)) {
      return this.list.get(world.uuid);
    }
    const raycaster = new SimpleRaycaster(this.components, world);
    this.list.set(world.uuid, raycaster);
    world.onDisposed.add(() => {
      this.delete(world);
    });
    return raycaster;
  }
  /**
   * Deletes the SimpleRaycaster instance associated with the given world.
   * If a SimpleRaycaster instance exists for the given world, it will be disposed and removed from the list.
   *
   * @param world - The world for which to delete the SimpleRaycaster instance.
   * @returns {void}
   */
  delete(world) {
    const raycaster = this.list.get(world.uuid);
    if (raycaster) {
      raycaster.dispose();
    }
    this.list.delete(world.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [_id, raycaster] of this.list) {
      raycaster.dispose();
    }
    this.list.clear();
    this.onDisposed.trigger();
  }
};
__publicField2(_Raycasters, "uuid", "d5d8bdf0-db25-4952-b951-b643af207ace");
var Raycasters = _Raycasters;
var SimpleGridConfigManager = class extends Configurator {
  constructor() {
    super(...arguments);
    __publicField2(this, "_config", {
      visible: {
        value: true,
        type: "Boolean"
      },
      color: {
        value: new Color(),
        type: "Color"
      },
      primarySize: {
        type: "Number",
        interpolable: true,
        value: 1,
        min: 0,
        max: 1e3
      },
      secondarySize: {
        type: "Number",
        interpolable: true,
        value: 10,
        min: 0,
        max: 1e3
      },
      distance: {
        type: "Number",
        interpolable: true,
        value: 500,
        min: 0,
        max: 500
      }
    });
  }
  /**
   * Whether the grid is visible or not.
   */
  get visible() {
    return this._config.visible.value;
  }
  /**
   * Whether the grid is visible or not.
   */
  set visible(value) {
    this._config.visible.value = value;
    this._component.visible = value;
  }
  /**
   * The color of the grid lines.
   */
  get color() {
    return this._config.color.value;
  }
  /**
   * The color of the grid lines.
   */
  set color(value) {
    this._config.color.value = value;
    this._component.material.uniforms.uColor.value = value;
    this._component.material.uniformsNeedUpdate = true;
  }
  /**
   * The size of the primary grid lines.
   */
  get primarySize() {
    return this._config.primarySize.value;
  }
  /**
   * The size of the primary grid lines.
   */
  set primarySize(value) {
    this._config.primarySize.value = value;
    this._component.material.uniforms.uSize1.value = value;
    this._component.material.uniformsNeedUpdate = true;
  }
  /**
   * The size of the secondary grid lines.
   */
  get secondarySize() {
    return this._config.secondarySize.value;
  }
  /**
   * The size of the secondary grid lines.
   */
  set secondarySize(value) {
    this._config.secondarySize.value = value;
    this._component.material.uniforms.uSize2.value = value;
    this._component.material.uniformsNeedUpdate = true;
  }
  /**
   * The distance at which the grid lines start to fade away.
   */
  get distance() {
    return this._config.distance.value;
  }
  /**
   * The distance at which the grid lines start to fade away.
   */
  set distance(value) {
    this._config.distance.value = value;
    this._component.material.uniforms.uDistance.value = value;
    this._component.material.uniformsNeedUpdate = true;
  }
};
var SimpleGrid = class {
  constructor(components, world) {
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "onSetup", new Event());
    __publicField2(this, "isSetup", false);
    __publicField2(this, "world");
    __publicField2(this, "components");
    __publicField2(this, "config");
    __publicField2(this, "_defaultConfig", {
      visible: true,
      color: new Color(12303291),
      primarySize: 1,
      secondarySize: 10,
      distance: 500
    });
    __publicField2(this, "three");
    __publicField2(this, "_fade", 3);
    __publicField2(this, "updateZoom", () => {
      if (!(this.world.camera instanceof SimpleCamera)) {
        return;
      }
      this.material.uniforms.uZoom.value = this.world.camera.three.zoom;
    });
    this.world = world;
    const { color, primarySize, secondarySize, distance } = this._defaultConfig;
    this.components = components;
    this.config = new SimpleGridConfigManager(this, this.components, "Grid");
    const geometry = new PlaneGeometry(2, 2, 1, 1);
    const material = new ShaderMaterial({
      side: DoubleSide,
      uniforms: {
        uSize1: {
          value: primarySize
        },
        uSize2: {
          value: secondarySize
        },
        uColor: {
          value: color
        },
        uDistance: {
          value: distance
        },
        uFade: {
          value: this._fade
        },
        uZoom: {
          value: 1
        }
      },
      transparent: true,
      vertexShader: `
            
            varying vec3 worldPosition;
            
            uniform float uDistance;
            
            void main() {
            
                    vec3 pos = position.xzy * uDistance;
                    pos.xz += cameraPosition.xz;
                    
                    worldPosition = pos;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            
            }
            `,
      fragmentShader: `
            
            varying vec3 worldPosition;
            
            uniform float uZoom;
            uniform float uFade;
            uniform float uSize1;
            uniform float uSize2;
            uniform vec3 uColor;
            uniform float uDistance;
                
                
                
                float getGrid(float size) {
                
                    vec2 r = worldPosition.xz / size;
                    
                    
                    vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);
                    float line = min(grid.x, grid.y);
                    
                
                    return 1.0 - min(line, 1.0);
                }
                
            void main() {
            
                    
                    float d = 1.0 - min(distance(cameraPosition.xz, worldPosition.xz) / uDistance, 1.0);
                    
                    float g1 = getGrid(uSize1);
                    float g2 = getGrid(uSize2);
                    
                    // Ortho camera fades the grid away when zooming out
                    float minZoom = step(0.2, uZoom);
                    float zoomFactor = pow(min(uZoom, 1.), 2.) * minZoom;
                    
                    gl_FragColor = vec4(uColor.rgb, mix(g2, g1, g1) * pow(d, uFade));
                    gl_FragColor.a = mix(0.5 * gl_FragColor.a, gl_FragColor.a, g2) * zoomFactor;
                    
                    if ( gl_FragColor.a <= 0.0 ) discard;
                    
            
            }
            
            `,
      extensions: {
        derivatives: true
      }
    });
    this.three = new Mesh(geometry, material);
    this.three.frustumCulled = false;
    world.scene.three.add(this.three);
    this.setupEvents(true);
  }
  /** {@link Hideable.visible} */
  get visible() {
    return this.three.visible;
  }
  /** {@link Hideable.visible} */
  set visible(visible) {
    if (visible) {
      const scene = this.world.scene.three;
      scene.add(this.three);
    } else {
      this.three.removeFromParent();
    }
  }
  /** The material of the grid. */
  get material() {
    return this.three.material;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  get fade() {
    return this._fade === 3;
  }
  /**
   * Whether the grid should fade away with distance. Recommended to be true for
   * perspective cameras and false for orthographic cameras.
   */
  set fade(active) {
    this._fade = active ? 3 : 0;
    this.material.uniforms.uFade.value = this._fade;
  }
  /** {@link Configurable.setup} */
  setup(config) {
    const fullConfig = { ...this._defaultConfig, ...config };
    this.config.visible = true;
    this.config.color = fullConfig.color;
    this.config.primarySize = fullConfig.primarySize;
    this.config.secondarySize = fullConfig.secondarySize;
    this.config.distance = fullConfig.distance;
    this.isSetup = true;
    this.onSetup.trigger();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.setupEvents(false);
    const configs = this.components.get(ConfigManager);
    configs.list.delete(this.config.uuid);
    const disposer = this.components.get(Disposer);
    disposer.destroy(this.three);
    this.onDisposed.trigger();
    this.onDisposed.reset();
    this.world = null;
    this.components = null;
  }
  setupEvents(active) {
    if (this.world.isDisposing) {
      return;
    }
    if (!(this.world.camera instanceof SimpleCamera)) {
      return;
    }
    const controls = this.world.camera.controls;
    if (active) {
      controls.addEventListener("update", this.updateZoom);
    } else {
      controls.removeEventListener("update", this.updateZoom);
    }
  }
};
var _Grids = class _Grids2 extends Component {
  constructor(components) {
    super(components);
    __publicField2(this, "list", /* @__PURE__ */ new Map());
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "enabled", true);
    components.add(_Grids2.uuid, this);
  }
  /**
   * Creates a new grid for the given world.
   * Throws an error if a grid already exists for the world.
   *
   * @param world - The world to create the grid for.
   * @returns The newly created grid.
   *
   * @throws Will throw an error if a grid already exists for the given world.
   */
  create(world) {
    if (this.list.has(world.uuid)) {
      throw new Error("This world already has a grid!");
    }
    const grid = new SimpleGrid(this.components, world);
    this.list.set(world.uuid, grid);
    world.onDisposed.add(() => {
      this.delete(world);
    });
    return grid;
  }
  /**
   * Deletes the grid associated with the given world.
   * If a grid does not exist for the given world, this method does nothing.
   *
   * @param world - The world for which to delete the grid.
   *
   * @remarks
   * This method will dispose of the grid and remove it from the internal list.
   * If the world is disposed before calling this method, the grid will be automatically deleted.
   */
  delete(world) {
    const grid = this.list.get(world.uuid);
    if (grid) {
      grid.dispose();
    }
    this.list.delete(world.uuid);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [_id, grid] of this.list) {
      grid.dispose();
    }
    this.list.clear();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
};
__publicField2(_Grids, "uuid", "d1e814d5-b81c-4452-87a2-f039375e0489");
var Grids = _Grids;
var _raycaster = new Raycaster();
var _tempVector = new Vector3();
var _tempVector2 = new Vector3();
var _tempQuaternion = new Quaternion();
var _unit = {
  X: new Vector3(1, 0, 0),
  Y: new Vector3(0, 1, 0),
  Z: new Vector3(0, 0, 1)
};
var _changeEvent = { type: "change" };
var _mouseDownEvent = { type: "mouseDown" };
var _mouseUpEvent = { type: "mouseUp", mode: null };
var _objectChangeEvent = { type: "objectChange" };
var TransformControls = class extends Object3D {
  constructor(camera, domElement) {
    super();
    if (domElement === void 0) {
      console.warn('THREE.TransformControls: The second parameter "domElement" is now mandatory.');
      domElement = document;
    }
    this.isTransformControls = true;
    this.visible = false;
    this.domElement = domElement;
    this.domElement.style.touchAction = "none";
    const _gizmo = new TransformControlsGizmo();
    this._gizmo = _gizmo;
    this.add(_gizmo);
    const _plane2 = new TransformControlsPlane();
    this._plane = _plane2;
    this.add(_plane2);
    const scope = this;
    function defineProperty(propName2, defaultValue) {
      let propValue = defaultValue;
      Object.defineProperty(scope, propName2, {
        get: function() {
          return propValue !== void 0 ? propValue : defaultValue;
        },
        set: function(value) {
          if (propValue !== value) {
            propValue = value;
            _plane2[propName2] = value;
            _gizmo[propName2] = value;
            scope.dispatchEvent({ type: propName2 + "-changed", value });
            scope.dispatchEvent(_changeEvent);
          }
        }
      });
      scope[propName2] = defaultValue;
      _plane2[propName2] = defaultValue;
      _gizmo[propName2] = defaultValue;
    }
    defineProperty("camera", camera);
    defineProperty("object", void 0);
    defineProperty("enabled", true);
    defineProperty("axis", null);
    defineProperty("mode", "translate");
    defineProperty("translationSnap", null);
    defineProperty("rotationSnap", null);
    defineProperty("scaleSnap", null);
    defineProperty("space", "world");
    defineProperty("size", 1);
    defineProperty("dragging", false);
    defineProperty("showX", true);
    defineProperty("showY", true);
    defineProperty("showZ", true);
    const worldPosition = new Vector3();
    const worldPositionStart = new Vector3();
    const worldQuaternion = new Quaternion();
    const worldQuaternionStart = new Quaternion();
    const cameraPosition = new Vector3();
    const cameraQuaternion = new Quaternion();
    const pointStart = new Vector3();
    const pointEnd = new Vector3();
    const rotationAxis = new Vector3();
    const rotationAngle = 0;
    const eye = new Vector3();
    defineProperty("worldPosition", worldPosition);
    defineProperty("worldPositionStart", worldPositionStart);
    defineProperty("worldQuaternion", worldQuaternion);
    defineProperty("worldQuaternionStart", worldQuaternionStart);
    defineProperty("cameraPosition", cameraPosition);
    defineProperty("cameraQuaternion", cameraQuaternion);
    defineProperty("pointStart", pointStart);
    defineProperty("pointEnd", pointEnd);
    defineProperty("rotationAxis", rotationAxis);
    defineProperty("rotationAngle", rotationAngle);
    defineProperty("eye", eye);
    this._offset = new Vector3();
    this._startNorm = new Vector3();
    this._endNorm = new Vector3();
    this._cameraScale = new Vector3();
    this._parentPosition = new Vector3();
    this._parentQuaternion = new Quaternion();
    this._parentQuaternionInv = new Quaternion();
    this._parentScale = new Vector3();
    this._worldScaleStart = new Vector3();
    this._worldQuaternionInv = new Quaternion();
    this._worldScale = new Vector3();
    this._positionStart = new Vector3();
    this._quaternionStart = new Quaternion();
    this._scaleStart = new Vector3();
    this._getPointer = getPointer.bind(this);
    this._onPointerDown = onPointerDown.bind(this);
    this._onPointerHover = onPointerHover.bind(this);
    this._onPointerMove = onPointerMove.bind(this);
    this._onPointerUp = onPointerUp.bind(this);
    this.domElement.addEventListener("pointerdown", this._onPointerDown);
    this.domElement.addEventListener("pointermove", this._onPointerHover);
    this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  // updateMatrixWorld  updates key transformation variables
  updateMatrixWorld() {
    if (this.object !== void 0) {
      this.object.updateMatrixWorld();
      if (this.object.parent === null) {
        console.error("TransformControls: The attached 3D object must be a part of the scene graph.");
      } else {
        this.object.parent.matrixWorld.decompose(this._parentPosition, this._parentQuaternion, this._parentScale);
      }
      this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this._worldScale);
      this._parentQuaternionInv.copy(this._parentQuaternion).invert();
      this._worldQuaternionInv.copy(this.worldQuaternion).invert();
    }
    this.camera.updateMatrixWorld();
    this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this._cameraScale);
    if (this.camera.isOrthographicCamera) {
      this.camera.getWorldDirection(this.eye).negate();
    } else {
      this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize();
    }
    super.updateMatrixWorld(this);
  }
  pointerHover(pointer) {
    if (this.object === void 0 || this.dragging === true)
      return;
    _raycaster.setFromCamera(pointer, this.camera);
    const intersect = intersectObjectWithRay(this._gizmo.picker[this.mode], _raycaster);
    if (intersect) {
      this.axis = intersect.object.name;
    } else {
      this.axis = null;
    }
  }
  pointerDown(pointer) {
    if (this.object === void 0 || this.dragging === true || pointer.button !== 0)
      return;
    if (this.axis !== null) {
      _raycaster.setFromCamera(pointer, this.camera);
      const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);
      if (planeIntersect) {
        this.object.updateMatrixWorld();
        this.object.parent.updateMatrixWorld();
        this._positionStart.copy(this.object.position);
        this._quaternionStart.copy(this.object.quaternion);
        this._scaleStart.copy(this.object.scale);
        this.object.matrixWorld.decompose(this.worldPositionStart, this.worldQuaternionStart, this._worldScaleStart);
        this.pointStart.copy(planeIntersect.point).sub(this.worldPositionStart);
      }
      this.dragging = true;
      _mouseDownEvent.mode = this.mode;
      this.dispatchEvent(_mouseDownEvent);
    }
  }
  pointerMove(pointer) {
    const axis = this.axis;
    const mode = this.mode;
    const object = this.object;
    let space = this.space;
    if (mode === "scale") {
      space = "local";
    } else if (axis === "E" || axis === "XYZE" || axis === "XYZ") {
      space = "world";
    }
    if (object === void 0 || axis === null || this.dragging === false || pointer.button !== -1)
      return;
    _raycaster.setFromCamera(pointer, this.camera);
    const planeIntersect = intersectObjectWithRay(this._plane, _raycaster, true);
    if (!planeIntersect)
      return;
    this.pointEnd.copy(planeIntersect.point).sub(this.worldPositionStart);
    if (mode === "translate") {
      this._offset.copy(this.pointEnd).sub(this.pointStart);
      if (space === "local" && axis !== "XYZ") {
        this._offset.applyQuaternion(this._worldQuaternionInv);
      }
      if (axis.indexOf("X") === -1)
        this._offset.x = 0;
      if (axis.indexOf("Y") === -1)
        this._offset.y = 0;
      if (axis.indexOf("Z") === -1)
        this._offset.z = 0;
      if (space === "local" && axis !== "XYZ") {
        this._offset.applyQuaternion(this._quaternionStart).divide(this._parentScale);
      } else {
        this._offset.applyQuaternion(this._parentQuaternionInv).divide(this._parentScale);
      }
      object.position.copy(this._offset).add(this._positionStart);
      if (this.translationSnap) {
        if (space === "local") {
          object.position.applyQuaternion(_tempQuaternion.copy(this._quaternionStart).invert());
          if (axis.search("X") !== -1) {
            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Y") !== -1) {
            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Z") !== -1) {
            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
          }
          object.position.applyQuaternion(this._quaternionStart);
        }
        if (space === "world") {
          if (object.parent) {
            object.position.add(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
          }
          if (axis.search("X") !== -1) {
            object.position.x = Math.round(object.position.x / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Y") !== -1) {
            object.position.y = Math.round(object.position.y / this.translationSnap) * this.translationSnap;
          }
          if (axis.search("Z") !== -1) {
            object.position.z = Math.round(object.position.z / this.translationSnap) * this.translationSnap;
          }
          if (object.parent) {
            object.position.sub(_tempVector.setFromMatrixPosition(object.parent.matrixWorld));
          }
        }
      }
    } else if (mode === "scale") {
      if (axis.search("XYZ") !== -1) {
        let d = this.pointEnd.length() / this.pointStart.length();
        if (this.pointEnd.dot(this.pointStart) < 0)
          d *= -1;
        _tempVector2.set(d, d, d);
      } else {
        _tempVector.copy(this.pointStart);
        _tempVector2.copy(this.pointEnd);
        _tempVector.applyQuaternion(this._worldQuaternionInv);
        _tempVector2.applyQuaternion(this._worldQuaternionInv);
        _tempVector2.divide(_tempVector);
        if (axis.search("X") === -1) {
          _tempVector2.x = 1;
        }
        if (axis.search("Y") === -1) {
          _tempVector2.y = 1;
        }
        if (axis.search("Z") === -1) {
          _tempVector2.z = 1;
        }
      }
      object.scale.copy(this._scaleStart).multiply(_tempVector2);
      if (this.scaleSnap) {
        if (axis.search("X") !== -1) {
          object.scale.x = Math.round(object.scale.x / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
        if (axis.search("Y") !== -1) {
          object.scale.y = Math.round(object.scale.y / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
        if (axis.search("Z") !== -1) {
          object.scale.z = Math.round(object.scale.z / this.scaleSnap) * this.scaleSnap || this.scaleSnap;
        }
      }
    } else if (mode === "rotate") {
      this._offset.copy(this.pointEnd).sub(this.pointStart);
      const ROTATION_SPEED = 20 / this.worldPosition.distanceTo(_tempVector.setFromMatrixPosition(this.camera.matrixWorld));
      let _inPlaneRotation = false;
      if (axis === "XYZE") {
        this.rotationAxis.copy(this._offset).cross(this.eye).normalize();
        this.rotationAngle = this._offset.dot(_tempVector.copy(this.rotationAxis).cross(this.eye)) * ROTATION_SPEED;
      } else if (axis === "X" || axis === "Y" || axis === "Z") {
        this.rotationAxis.copy(_unit[axis]);
        _tempVector.copy(_unit[axis]);
        if (space === "local") {
          _tempVector.applyQuaternion(this.worldQuaternion);
        }
        _tempVector.cross(this.eye);
        if (_tempVector.length() === 0) {
          _inPlaneRotation = true;
        } else {
          this.rotationAngle = this._offset.dot(_tempVector.normalize()) * ROTATION_SPEED;
        }
      }
      if (axis === "E" || _inPlaneRotation) {
        this.rotationAxis.copy(this.eye);
        this.rotationAngle = this.pointEnd.angleTo(this.pointStart);
        this._startNorm.copy(this.pointStart).normalize();
        this._endNorm.copy(this.pointEnd).normalize();
        this.rotationAngle *= this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1;
      }
      if (this.rotationSnap)
        this.rotationAngle = Math.round(this.rotationAngle / this.rotationSnap) * this.rotationSnap;
      if (space === "local" && axis !== "E" && axis !== "XYZE") {
        object.quaternion.copy(this._quaternionStart);
        object.quaternion.multiply(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle)).normalize();
      } else {
        this.rotationAxis.applyQuaternion(this._parentQuaternionInv);
        object.quaternion.copy(_tempQuaternion.setFromAxisAngle(this.rotationAxis, this.rotationAngle));
        object.quaternion.multiply(this._quaternionStart).normalize();
      }
    }
    this.dispatchEvent(_changeEvent);
    this.dispatchEvent(_objectChangeEvent);
  }
  pointerUp(pointer) {
    if (pointer.button !== 0)
      return;
    if (this.dragging && this.axis !== null) {
      _mouseUpEvent.mode = this.mode;
      this.dispatchEvent(_mouseUpEvent);
    }
    this.dragging = false;
    this.axis = null;
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown);
    this.domElement.removeEventListener("pointermove", this._onPointerHover);
    this.domElement.removeEventListener("pointermove", this._onPointerMove);
    this.domElement.removeEventListener("pointerup", this._onPointerUp);
    this.traverse(function(child) {
      if (child.geometry)
        child.geometry.dispose();
      if (child.material)
        child.material.dispose();
    });
  }
  // Set current object
  attach(object) {
    this.object = object;
    this.visible = true;
    return this;
  }
  // Detach from object
  detach() {
    this.object = void 0;
    this.visible = false;
    this.axis = null;
    return this;
  }
  reset() {
    if (!this.enabled)
      return;
    if (this.dragging) {
      this.object.position.copy(this._positionStart);
      this.object.quaternion.copy(this._quaternionStart);
      this.object.scale.copy(this._scaleStart);
      this.dispatchEvent(_changeEvent);
      this.dispatchEvent(_objectChangeEvent);
      this.pointStart.copy(this.pointEnd);
    }
  }
  getRaycaster() {
    return _raycaster;
  }
  // TODO: deprecate
  getMode() {
    return this.mode;
  }
  setMode(mode) {
    this.mode = mode;
  }
  setTranslationSnap(translationSnap) {
    this.translationSnap = translationSnap;
  }
  setRotationSnap(rotationSnap) {
    this.rotationSnap = rotationSnap;
  }
  setScaleSnap(scaleSnap) {
    this.scaleSnap = scaleSnap;
  }
  setSize(size) {
    this.size = size;
  }
  setSpace(space) {
    this.space = space;
  }
};
function getPointer(event) {
  if (this.domElement.ownerDocument.pointerLockElement) {
    return {
      x: 0,
      y: 0,
      button: event.button
    };
  } else {
    const rect = this.domElement.getBoundingClientRect();
    return {
      x: (event.clientX - rect.left) / rect.width * 2 - 1,
      y: -(event.clientY - rect.top) / rect.height * 2 + 1,
      button: event.button
    };
  }
}
function onPointerHover(event) {
  if (!this.enabled)
    return;
  switch (event.pointerType) {
    case "mouse":
    case "pen":
      this.pointerHover(this._getPointer(event));
      break;
  }
}
function onPointerDown(event) {
  if (!this.enabled)
    return;
  if (!document.pointerLockElement) {
    this.domElement.setPointerCapture(event.pointerId);
  }
  this.domElement.addEventListener("pointermove", this._onPointerMove);
  this.pointerHover(this._getPointer(event));
  this.pointerDown(this._getPointer(event));
}
function onPointerMove(event) {
  if (!this.enabled)
    return;
  this.pointerMove(this._getPointer(event));
}
function onPointerUp(event) {
  if (!this.enabled)
    return;
  this.domElement.releasePointerCapture(event.pointerId);
  this.domElement.removeEventListener("pointermove", this._onPointerMove);
  this.pointerUp(this._getPointer(event));
}
function intersectObjectWithRay(object, raycaster, includeInvisible) {
  const allIntersections = raycaster.intersectObject(object, true);
  for (let i = 0; i < allIntersections.length; i++) {
    if (allIntersections[i].object.visible || includeInvisible) {
      return allIntersections[i];
    }
  }
  return false;
}
var _tempEuler = new Euler();
var _alignVector = new Vector3(0, 1, 0);
var _zeroVector = new Vector3(0, 0, 0);
var _lookAtMatrix = new Matrix4();
var _tempQuaternion2 = new Quaternion();
var _identityQuaternion = new Quaternion();
var _dirVector = new Vector3();
var _tempMatrix = new Matrix4();
var _unitX = new Vector3(1, 0, 0);
var _unitY = new Vector3(0, 1, 0);
var _unitZ = new Vector3(0, 0, 1);
var _v1 = new Vector3();
var _v2 = new Vector3();
var _v3 = new Vector3();
var TransformControlsGizmo = class extends Object3D {
  constructor() {
    super();
    this.isTransformControlsGizmo = true;
    this.type = "TransformControlsGizmo";
    const gizmoMaterial = new MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    });
    const gizmoLineMaterial = new LineBasicMaterial({
      depthTest: false,
      depthWrite: false,
      fog: false,
      toneMapped: false,
      transparent: true
    });
    const matInvisible = gizmoMaterial.clone();
    matInvisible.opacity = 0.15;
    const matHelper = gizmoLineMaterial.clone();
    matHelper.opacity = 0.5;
    const matRed = gizmoMaterial.clone();
    matRed.color.setHex(16711680);
    const matGreen = gizmoMaterial.clone();
    matGreen.color.setHex(65280);
    const matBlue = gizmoMaterial.clone();
    matBlue.color.setHex(255);
    const matRedTransparent = gizmoMaterial.clone();
    matRedTransparent.color.setHex(16711680);
    matRedTransparent.opacity = 0.5;
    const matGreenTransparent = gizmoMaterial.clone();
    matGreenTransparent.color.setHex(65280);
    matGreenTransparent.opacity = 0.5;
    const matBlueTransparent = gizmoMaterial.clone();
    matBlueTransparent.color.setHex(255);
    matBlueTransparent.opacity = 0.5;
    const matWhiteTransparent = gizmoMaterial.clone();
    matWhiteTransparent.opacity = 0.25;
    const matYellowTransparent = gizmoMaterial.clone();
    matYellowTransparent.color.setHex(16776960);
    matYellowTransparent.opacity = 0.25;
    const matYellow = gizmoMaterial.clone();
    matYellow.color.setHex(16776960);
    const matGray = gizmoMaterial.clone();
    matGray.color.setHex(7895160);
    const arrowGeometry = new CylinderGeometry(0, 0.04, 0.1, 12);
    arrowGeometry.translate(0, 0.05, 0);
    const scaleHandleGeometry = new BoxGeometry(0.08, 0.08, 0.08);
    scaleHandleGeometry.translate(0, 0.04, 0);
    const lineGeometry = new BufferGeometry();
    lineGeometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3));
    const lineGeometry2 = new CylinderGeometry(75e-4, 75e-4, 0.5, 3);
    lineGeometry2.translate(0, 0.25, 0);
    function CircleGeometry(radius, arc) {
      const geometry = new TorusGeometry(radius, 75e-4, 3, 64, arc * Math.PI * 2);
      geometry.rotateY(Math.PI / 2);
      geometry.rotateX(Math.PI / 2);
      return geometry;
    }
    function TranslateHelperGeometry() {
      const geometry = new BufferGeometry();
      geometry.setAttribute("position", new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3));
      return geometry;
    }
    const gizmoTranslate = {
      X: [
        [new Mesh(arrowGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(arrowGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(arrowGeometry, matGreen), [0, 0.5, 0]],
        [new Mesh(arrowGeometry, matGreen), [0, -0.5, 0], [Math.PI, 0, 0]],
        [new Mesh(lineGeometry2, matGreen)]
      ],
      Z: [
        [new Mesh(arrowGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(arrowGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        [new Mesh(lineGeometry2, matBlue), null, [Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.1, 0), matWhiteTransparent.clone()), [0, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent.clone()), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent.clone()), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent.clone()), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    };
    const pickerTranslate = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new OctahedronGeometry(0.2, 0), matInvisible)]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ]
    };
    const helperTranslate = {
      START: [
        [new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]
      ],
      END: [
        [new Mesh(new OctahedronGeometry(0.01, 2), matHelper), null, null, null, "helper"]
      ],
      DELTA: [
        [new Line(TranslateHelperGeometry(), matHelper), null, null, null, "helper"]
      ],
      X: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    const gizmoRotate = {
      XYZE: [
        [new Mesh(CircleGeometry(0.5, 1), matGray), null, [0, Math.PI / 2, 0]]
      ],
      X: [
        [new Mesh(CircleGeometry(0.5, 0.5), matRed)]
      ],
      Y: [
        [new Mesh(CircleGeometry(0.5, 0.5), matGreen), null, [0, 0, -Math.PI / 2]]
      ],
      Z: [
        [new Mesh(CircleGeometry(0.5, 0.5), matBlue), null, [0, Math.PI / 2, 0]]
      ],
      E: [
        [new Mesh(CircleGeometry(0.75, 1), matYellowTransparent), null, [0, Math.PI / 2, 0]]
      ]
    };
    const helperRotate = {
      AXIS: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ]
    };
    const pickerRotate = {
      XYZE: [
        [new Mesh(new SphereGeometry(0.25, 10, 8), matInvisible)]
      ],
      X: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [Math.PI / 2, 0, 0]]
      ],
      Z: [
        [new Mesh(new TorusGeometry(0.5, 0.1, 4, 24), matInvisible), [0, 0, 0], [0, 0, -Math.PI / 2]]
      ],
      E: [
        [new Mesh(new TorusGeometry(0.75, 0.1, 2, 24), matInvisible)]
      ]
    };
    const gizmoScale = {
      X: [
        [new Mesh(scaleHandleGeometry, matRed), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(lineGeometry2, matRed), [0, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(scaleHandleGeometry, matRed), [-0.5, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(scaleHandleGeometry, matGreen), [0, 0.5, 0]],
        [new Mesh(lineGeometry2, matGreen)],
        [new Mesh(scaleHandleGeometry, matGreen), [0, -0.5, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(scaleHandleGeometry, matBlue), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
        [new Mesh(lineGeometry2, matBlue), [0, 0, 0], [Math.PI / 2, 0, 0]],
        [new Mesh(scaleHandleGeometry, matBlue), [0, 0, -0.5], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matBlueTransparent), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matRedTransparent), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.15, 0.15, 0.01), matGreenTransparent), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.1, 0.1, 0.1), matWhiteTransparent.clone())]
      ]
    };
    const pickerScale = {
      X: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0.3, 0, 0], [0, 0, -Math.PI / 2]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [-0.3, 0, 0], [0, 0, Math.PI / 2]]
      ],
      Y: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0.3, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, -0.3, 0], [0, 0, Math.PI]]
      ],
      Z: [
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
        [new Mesh(new CylinderGeometry(0.2, 0, 0.6, 4), matInvisible), [0, 0, -0.3], [-Math.PI / 2, 0, 0]]
      ],
      XY: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0.15, 0]]
      ],
      YZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0, 0.15, 0.15], [0, Math.PI / 2, 0]]
      ],
      XZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.01), matInvisible), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]]
      ],
      XYZ: [
        [new Mesh(new BoxGeometry(0.2, 0.2, 0.2), matInvisible), [0, 0, 0]]
      ]
    };
    const helperScale = {
      X: [
        [new Line(lineGeometry, matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]
      ],
      Y: [
        [new Line(lineGeometry, matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], "helper"]
      ],
      Z: [
        [new Line(lineGeometry, matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], "helper"]
      ]
    };
    function setupGizmo(gizmoMap) {
      const gizmo = new Object3D();
      for (const name in gizmoMap) {
        for (let i = gizmoMap[name].length; i--; ) {
          const object = gizmoMap[name][i][0].clone();
          const position = gizmoMap[name][i][1];
          const rotation = gizmoMap[name][i][2];
          const scale = gizmoMap[name][i][3];
          const tag = gizmoMap[name][i][4];
          object.name = name;
          object.tag = tag;
          if (position) {
            object.position.set(position[0], position[1], position[2]);
          }
          if (rotation) {
            object.rotation.set(rotation[0], rotation[1], rotation[2]);
          }
          if (scale) {
            object.scale.set(scale[0], scale[1], scale[2]);
          }
          object.updateMatrix();
          const tempGeometry = object.geometry.clone();
          tempGeometry.applyMatrix4(object.matrix);
          object.geometry = tempGeometry;
          object.renderOrder = Infinity;
          object.position.set(0, 0, 0);
          object.rotation.set(0, 0, 0);
          object.scale.set(1, 1, 1);
          gizmo.add(object);
        }
      }
      return gizmo;
    }
    this.gizmo = {};
    this.picker = {};
    this.helper = {};
    this.add(this.gizmo["translate"] = setupGizmo(gizmoTranslate));
    this.add(this.gizmo["rotate"] = setupGizmo(gizmoRotate));
    this.add(this.gizmo["scale"] = setupGizmo(gizmoScale));
    this.add(this.picker["translate"] = setupGizmo(pickerTranslate));
    this.add(this.picker["rotate"] = setupGizmo(pickerRotate));
    this.add(this.picker["scale"] = setupGizmo(pickerScale));
    this.add(this.helper["translate"] = setupGizmo(helperTranslate));
    this.add(this.helper["rotate"] = setupGizmo(helperRotate));
    this.add(this.helper["scale"] = setupGizmo(helperScale));
    this.picker["translate"].visible = false;
    this.picker["rotate"].visible = false;
    this.picker["scale"].visible = false;
  }
  // updateMatrixWorld will update transformations and appearance of individual handles
  updateMatrixWorld(force) {
    const space = this.mode === "scale" ? "local" : this.space;
    const quaternion = space === "local" ? this.worldQuaternion : _identityQuaternion;
    this.gizmo["translate"].visible = this.mode === "translate";
    this.gizmo["rotate"].visible = this.mode === "rotate";
    this.gizmo["scale"].visible = this.mode === "scale";
    this.helper["translate"].visible = this.mode === "translate";
    this.helper["rotate"].visible = this.mode === "rotate";
    this.helper["scale"].visible = this.mode === "scale";
    let handles = [];
    handles = handles.concat(this.picker[this.mode].children);
    handles = handles.concat(this.gizmo[this.mode].children);
    handles = handles.concat(this.helper[this.mode].children);
    for (let i = 0; i < handles.length; i++) {
      const handle = handles[i];
      handle.visible = true;
      handle.rotation.set(0, 0, 0);
      handle.position.copy(this.worldPosition);
      let factor;
      if (this.camera.isOrthographicCamera) {
        factor = (this.camera.top - this.camera.bottom) / this.camera.zoom;
      } else {
        factor = this.worldPosition.distanceTo(this.cameraPosition) * Math.min(1.9 * Math.tan(Math.PI * this.camera.fov / 360) / this.camera.zoom, 7);
      }
      handle.scale.set(1, 1, 1).multiplyScalar(factor * this.size / 4);
      if (handle.tag === "helper") {
        handle.visible = false;
        if (handle.name === "AXIS") {
          handle.visible = !!this.axis;
          if (this.axis === "X") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, 0));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "Y") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, 0, Math.PI / 2));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "Z") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
            handle.quaternion.copy(quaternion).multiply(_tempQuaternion);
            if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > 0.9) {
              handle.visible = false;
            }
          }
          if (this.axis === "XYZE") {
            _tempQuaternion.setFromEuler(_tempEuler.set(0, Math.PI / 2, 0));
            _alignVector.copy(this.rotationAxis);
            handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(_zeroVector, _alignVector, _unitY));
            handle.quaternion.multiply(_tempQuaternion);
            handle.visible = this.dragging;
          }
          if (this.axis === "E") {
            handle.visible = false;
          }
        } else if (handle.name === "START") {
          handle.position.copy(this.worldPositionStart);
          handle.visible = this.dragging;
        } else if (handle.name === "END") {
          handle.position.copy(this.worldPosition);
          handle.visible = this.dragging;
        } else if (handle.name === "DELTA") {
          handle.position.copy(this.worldPositionStart);
          handle.quaternion.copy(this.worldQuaternionStart);
          _tempVector.set(1e-10, 1e-10, 1e-10).add(this.worldPositionStart).sub(this.worldPosition).multiplyScalar(-1);
          _tempVector.applyQuaternion(this.worldQuaternionStart.clone().invert());
          handle.scale.copy(_tempVector);
          handle.visible = this.dragging;
        } else {
          handle.quaternion.copy(quaternion);
          if (this.dragging) {
            handle.position.copy(this.worldPositionStart);
          } else {
            handle.position.copy(this.worldPosition);
          }
          if (this.axis) {
            handle.visible = this.axis.search(handle.name) !== -1;
          }
        }
        continue;
      }
      handle.quaternion.copy(quaternion);
      if (this.mode === "translate" || this.mode === "scale") {
        const AXIS_HIDE_THRESHOLD = 0.99;
        const PLANE_HIDE_THRESHOLD = 0.2;
        if (handle.name === "X") {
          if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "Y") {
          if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "Z") {
          if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) > AXIS_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "XY") {
          if (Math.abs(_alignVector.copy(_unitZ).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "YZ") {
          if (Math.abs(_alignVector.copy(_unitX).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
        if (handle.name === "XZ") {
          if (Math.abs(_alignVector.copy(_unitY).applyQuaternion(quaternion).dot(this.eye)) < PLANE_HIDE_THRESHOLD) {
            handle.scale.set(1e-10, 1e-10, 1e-10);
            handle.visible = false;
          }
        }
      } else if (this.mode === "rotate") {
        _tempQuaternion2.copy(quaternion);
        _alignVector.copy(this.eye).applyQuaternion(_tempQuaternion.copy(quaternion).invert());
        if (handle.name.search("E") !== -1) {
          handle.quaternion.setFromRotationMatrix(_lookAtMatrix.lookAt(this.eye, _zeroVector, _unitY));
        }
        if (handle.name === "X") {
          _tempQuaternion.setFromAxisAngle(_unitX, Math.atan2(-_alignVector.y, _alignVector.z));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
        if (handle.name === "Y") {
          _tempQuaternion.setFromAxisAngle(_unitY, Math.atan2(_alignVector.x, _alignVector.z));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
        if (handle.name === "Z") {
          _tempQuaternion.setFromAxisAngle(_unitZ, Math.atan2(_alignVector.y, _alignVector.x));
          _tempQuaternion.multiplyQuaternions(_tempQuaternion2, _tempQuaternion);
          handle.quaternion.copy(_tempQuaternion);
        }
      }
      handle.visible = handle.visible && (handle.name.indexOf("X") === -1 || this.showX);
      handle.visible = handle.visible && (handle.name.indexOf("Y") === -1 || this.showY);
      handle.visible = handle.visible && (handle.name.indexOf("Z") === -1 || this.showZ);
      handle.visible = handle.visible && (handle.name.indexOf("E") === -1 || this.showX && this.showY && this.showZ);
      handle.material._color = handle.material._color || handle.material.color.clone();
      handle.material._opacity = handle.material._opacity || handle.material.opacity;
      handle.material.color.copy(handle.material._color);
      handle.material.opacity = handle.material._opacity;
      if (this.enabled && this.axis) {
        if (handle.name === this.axis) {
          handle.material.color.setHex(16776960);
          handle.material.opacity = 1;
        } else if (this.axis.split("").some(function(a) {
          return handle.name === a;
        })) {
          handle.material.color.setHex(16776960);
          handle.material.opacity = 1;
        }
      }
    }
    super.updateMatrixWorld(force);
  }
};
var TransformControlsPlane = class extends Mesh {
  constructor() {
    super(
      new PlaneGeometry(1e5, 1e5, 2, 2),
      new MeshBasicMaterial({ visible: false, wireframe: true, side: DoubleSide, transparent: true, opacity: 0.1, toneMapped: false })
    );
    this.isTransformControlsPlane = true;
    this.type = "TransformControlsPlane";
  }
  updateMatrixWorld(force) {
    let space = this.space;
    this.position.copy(this.worldPosition);
    if (this.mode === "scale")
      space = "local";
    _v1.copy(_unitX).applyQuaternion(space === "local" ? this.worldQuaternion : _identityQuaternion);
    _v2.copy(_unitY).applyQuaternion(space === "local" ? this.worldQuaternion : _identityQuaternion);
    _v3.copy(_unitZ).applyQuaternion(space === "local" ? this.worldQuaternion : _identityQuaternion);
    _alignVector.copy(_v2);
    switch (this.mode) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            _alignVector.copy(this.eye).cross(_v1);
            _dirVector.copy(_v1).cross(_alignVector);
            break;
          case "Y":
            _alignVector.copy(this.eye).cross(_v2);
            _dirVector.copy(_v2).cross(_alignVector);
            break;
          case "Z":
            _alignVector.copy(this.eye).cross(_v3);
            _dirVector.copy(_v3).cross(_alignVector);
            break;
          case "XY":
            _dirVector.copy(_v3);
            break;
          case "YZ":
            _dirVector.copy(_v1);
            break;
          case "XZ":
            _alignVector.copy(_v3);
            _dirVector.copy(_v2);
            break;
          case "XYZ":
          case "E":
            _dirVector.set(0, 0, 0);
            break;
        }
        break;
      case "rotate":
      default:
        _dirVector.set(0, 0, 0);
    }
    if (_dirVector.length() === 0) {
      this.quaternion.copy(this.cameraQuaternion);
    } else {
      _tempMatrix.lookAt(_tempVector.set(0, 0, 0), _dirVector, _alignVector);
      this.quaternion.setFromRotationMatrix(_tempMatrix);
    }
    super.updateMatrixWorld(force);
  }
};
var SimplePlane = class _SimplePlane {
  constructor(components, world, origin, normal, material, size = 5, activateControls = true) {
    __publicField2(this, "onDraggingStarted", new Event());
    __publicField2(this, "onDraggingEnded", new Event());
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "normal");
    __publicField2(this, "origin");
    __publicField2(this, "three", new Plane());
    __publicField2(this, "components");
    __publicField2(this, "world");
    __publicField2(this, "type", "default");
    __publicField2(this, "_helper");
    __publicField2(this, "_visible", true);
    __publicField2(this, "_enabled", true);
    __publicField2(this, "_controlsActive", false);
    __publicField2(this, "_arrowBoundBox", new Mesh());
    __publicField2(this, "_planeMesh");
    __publicField2(this, "_controls");
    __publicField2(this, "_hiddenMaterial", new MeshBasicMaterial({
      visible: false
    }));
    __publicField2(this, "update", () => {
      if (!this._enabled)
        return;
      this.three.setFromNormalAndCoplanarPoint(
        this.normal,
        this._helper.position
      );
    });
    __publicField2(this, "changeDrag", (event) => {
      this._visible = !event.value;
      this.preventCameraMovement();
      this.notifyDraggingChanged(event);
    });
    this.components = components;
    this.world = world;
    if (!world.renderer) {
      throw new Error("The given world must have a renderer!");
    }
    this.normal = normal;
    this.origin = origin;
    world.renderer.setPlane(true, this.three);
    this._planeMesh = _SimplePlane.newPlaneMesh(size, material);
    this._helper = this.newHelper();
    this._controls = this.newTransformControls();
    this.three.setFromNormalAndCoplanarPoint(normal, origin);
    if (activateControls) {
      this.toggleControls(true);
    }
  }
  /**
   * Getter for the enabled state of the clipping plane.
   * @returns {boolean} The current enabled state.
   */
  get enabled() {
    return this._enabled;
  }
  /**
   * Setter for the enabled state of the clipping plane.
   * Updates the clipping plane state in the renderer and throws an error if no renderer is found.
   * @param {boolean} state - The new enabled state.
   */
  set enabled(state) {
    if (this.world.isDisposing) {
      return;
    }
    if (!this.world.renderer) {
      throw new Error("No renderer found for clipping plane!");
    }
    this._enabled = state;
    this.world.renderer.setPlane(state, this.three);
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(state) {
    this._visible = state;
    this._controls.visible = state;
    this._helper.visible = state;
    this.toggleControls(state);
  }
  /** The meshes used for raycasting */
  get meshes() {
    return [this._planeMesh, this._arrowBoundBox];
  }
  /** The material of the clipping plane representation. */
  get planeMaterial() {
    return this._planeMesh.material;
  }
  /** The material of the clipping plane representation. */
  set planeMaterial(material) {
    this._planeMesh.material = material;
  }
  /** The size of the clipping plane representation. */
  get size() {
    return this._planeMesh.scale.x;
  }
  /** Sets the size of the clipping plane representation. */
  set size(size) {
    this._planeMesh.scale.set(size, size, size);
  }
  /**
   * Getter for the helper object of the clipping plane.
   * The helper object is a THREE.Object3D that contains the clipping plane mesh and other related objects.
   * It is used for positioning, rotating, and scaling the clipping plane in the 3D scene.
   *
   * @returns {THREE.Object3D} The helper object of the clipping plane.
   */
  get helper() {
    return this._helper;
  }
  /**
   * Sets the clipping plane's normal and origin from the given normal and point.
   * This method resets the clipping plane's state, updates the normal and origin,
   * and positions the helper object accordingly.
   *
   * @param normal - The new normal vector for the clipping plane.
   * @param point - The new origin point for the clipping plane.
   *
   * @returns {void}
   */
  setFromNormalAndCoplanarPoint(normal, point) {
    this.reset();
    if (!this.normal.equals(normal)) {
      this.normal.copy(normal);
      this._helper.lookAt(normal);
    }
    this.origin.copy(point);
    this._helper.position.copy(point);
    this._helper.updateMatrix();
    this.update();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this._enabled = false;
    this.onDraggingStarted.reset();
    this.onDraggingEnded.reset();
    this._helper.removeFromParent();
    if (this.world.renderer) {
      this.world.renderer.setPlane(false, this.three);
    }
    this._arrowBoundBox.removeFromParent();
    this._arrowBoundBox.geometry.dispose();
    this._planeMesh.geometry.dispose();
    this._controls.removeFromParent();
    this._controls.dispose();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  reset() {
    const normal = new Vector3(1, 0, 0);
    const point = new Vector3();
    if (!this.normal.equals(normal)) {
      this.normal.copy(normal);
      this._helper.lookAt(normal);
    }
    this.origin.copy(point);
    this._helper.position.copy(point);
    this._helper.updateMatrix();
  }
  toggleControls(state) {
    if (state) {
      if (this._controlsActive)
        return;
      this._controls.addEventListener("change", this.update);
      this._controls.addEventListener("dragging-changed", this.changeDrag);
    } else {
      this._controls.removeEventListener("change", this.update);
      this._controls.removeEventListener("dragging-changed", this.changeDrag);
    }
    this._controlsActive = state;
  }
  newTransformControls() {
    if (!this.world.renderer) {
      throw new Error("No renderer found for clipping plane!");
    }
    const camera = this.world.camera.three;
    const container = this.world.renderer.three.domElement;
    const controls = new TransformControls(camera, container);
    this.initializeControls(controls);
    this.world.scene.three.add(controls);
    return controls;
  }
  initializeControls(controls) {
    controls.attach(this._helper);
    controls.showX = false;
    controls.showY = false;
    controls.setSpace("local");
    this.createArrowBoundingBox();
    controls.children[0].children[0].add(this._arrowBoundBox);
  }
  createArrowBoundingBox() {
    this._arrowBoundBox.geometry = new CylinderGeometry(0.18, 0.18, 1.2);
    this._arrowBoundBox.material = this._hiddenMaterial;
    this._arrowBoundBox.rotateX(Math.PI / 2);
    this._arrowBoundBox.updateMatrix();
    this._arrowBoundBox.geometry.applyMatrix4(this._arrowBoundBox.matrix);
  }
  notifyDraggingChanged(event) {
    if (event.value) {
      this.onDraggingStarted.trigger();
    } else {
      this.onDraggingEnded.trigger();
    }
  }
  preventCameraMovement() {
    this.world.camera.enabled = this._visible;
  }
  newHelper() {
    const helper = new Object3D();
    helper.lookAt(this.normal);
    helper.position.copy(this.origin);
    this._planeMesh.position.z += 0.01;
    helper.add(this._planeMesh);
    this.world.scene.three.add(helper);
    return helper;
  }
  static newPlaneMesh(size, material) {
    const planeGeom = new PlaneGeometry(1);
    const mesh = new Mesh(planeGeom, material);
    mesh.scale.set(size, size, size);
    return mesh;
  }
};
var ClipperConfigManager = class extends Configurator {
  constructor() {
    super(...arguments);
    __publicField2(this, "_config", {
      enabled: {
        value: true,
        type: "Boolean"
      },
      visible: {
        value: true,
        type: "Boolean"
      },
      color: {
        value: new Color(),
        type: "Color"
      },
      opacity: {
        type: "Number",
        interpolable: true,
        value: 1,
        min: 0,
        max: 1
      },
      size: {
        type: "Number",
        interpolable: true,
        value: 2,
        min: 0,
        max: 100
      }
    });
  }
  get enabled() {
    return this._config.enabled.value;
  }
  set enabled(value) {
    this._config.enabled.value = value;
    this._component.enabled = value;
  }
  get visible() {
    return this._config.visible.value;
  }
  set visible(value) {
    this._config.visible.value = value;
    this._component.visible = value;
  }
  get color() {
    return this._config.color.value;
  }
  set color(value) {
    this._config.color.value = value;
    this._component.material.color.copy(value);
  }
  get opacity() {
    return this._config.opacity.value;
  }
  set opacity(value) {
    this._config.opacity.value = value;
    this._component.material.opacity = value;
  }
  get size() {
    return this._config.size.value;
  }
  set size(value) {
    this._config.size.value = value;
    this._component.size = value;
  }
};
var _Clipper = class _Clipper2 extends Component {
  constructor(components) {
    super(components);
    __publicField2(this, "onSetup", new Event());
    __publicField2(this, "onBeforeDrag", new Event());
    __publicField2(this, "onAfterDrag", new Event());
    __publicField2(this, "onBeforeCreate", new Event());
    __publicField2(this, "onBeforeCancel", new Event());
    __publicField2(this, "onAfterCancel", new Event());
    __publicField2(this, "onBeforeDelete", new Event());
    __publicField2(this, "onAfterCreate", new Event());
    __publicField2(this, "onAfterDelete", new Event());
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "isSetup", false);
    __publicField2(this, "orthogonalY", false);
    __publicField2(this, "toleranceOrthogonalY", 0.7);
    __publicField2(this, "Type", SimplePlane);
    __publicField2(this, "list", []);
    __publicField2(this, "config", new ClipperConfigManager(
      this,
      this.components,
      "Clipper",
      _Clipper2.uuid
    ));
    __publicField2(this, "_defaultConfig", {
      color: new Color(12255487),
      opacity: 0.2,
      size: 2
    });
    __publicField2(this, "_material", new MeshBasicMaterial({
      color: 12255487,
      side: DoubleSide,
      transparent: true,
      opacity: 0.2
    }));
    __publicField2(this, "_size", 5);
    __publicField2(this, "_enabled", false);
    __publicField2(this, "_visible", true);
    __publicField2(this, "_onStartDragging", () => {
      this.onBeforeDrag.trigger();
    });
    __publicField2(this, "_onEndDragging", () => {
      this.onAfterDrag.trigger();
    });
    this.components.add(_Clipper2.uuid, this);
  }
  /** {@link Component.enabled} */
  get enabled() {
    return this._enabled;
  }
  /** {@link Component.enabled} */
  set enabled(state) {
    this._enabled = state;
    for (const plane of this.list) {
      plane.enabled = state;
    }
    this.updateMaterialsAndPlanes();
  }
  /** {@link Hideable.visible } */
  get visible() {
    return this._visible;
  }
  /** {@link Hideable.visible } */
  set visible(state) {
    this._visible = state;
    for (const plane of this.list) {
      plane.visible = state;
    }
  }
  /** The material of the clipping plane representation. */
  get material() {
    return this._material;
  }
  /** The material of the clipping plane representation. */
  set material(material) {
    this._material = material;
    for (const plane of this.list) {
      plane.planeMaterial = material;
    }
  }
  /** The size of the geometric representation of the clippings planes. */
  get size() {
    return this._size;
  }
  /** The size of the geometric representation of the clippings planes. */
  set size(size) {
    this._size = size;
    for (const plane of this.list) {
      plane.size = size;
    }
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this._enabled = false;
    const configs = this.components.get(ConfigManager);
    configs.list.delete(this.config.uuid);
    for (const plane of this.list) {
      plane.dispose();
    }
    this.list.length = 0;
    this._material.dispose();
    this.onBeforeCreate.reset();
    this.onBeforeCancel.reset();
    this.onBeforeDelete.reset();
    this.onBeforeDrag.reset();
    this.onAfterCreate.reset();
    this.onAfterCancel.reset();
    this.onAfterDelete.reset();
    this.onAfterDrag.reset();
    this.onDisposed.trigger(_Clipper2.uuid);
    this.onDisposed.reset();
  }
  /** {@link Createable.create} */
  create(world) {
    const casters = this.components.get(Raycasters);
    const caster = casters.get(world);
    const intersects2 = caster.castRay();
    if (intersects2) {
      return this.createPlaneFromIntersection(world, intersects2);
    }
    return null;
  }
  /**
   * Creates a plane in a certain place and with a certain orientation,
   * without the need of the mouse.
   *
   * @param world - the world where this plane should be created.
   * @param normal - the orientation of the clipping plane.
   * @param point - the position of the clipping plane.
   * navigation.
   */
  createFromNormalAndCoplanarPoint(world, normal, point) {
    const plane = this.newPlane(world, point, normal);
    this.updateMaterialsAndPlanes();
    return plane;
  }
  /**
   * {@link Createable.delete}
   *
   * @param world - the world where the plane to delete is.
   * @param plane - the plane to delete. If undefined, the first plane
   * found under the cursor will be deleted.
   */
  delete(world, plane) {
    if (!plane) {
      plane = this.pickPlane(world);
    }
    if (!plane) {
      return;
    }
    this.deletePlane(plane);
  }
  /**
   * Deletes all the existing clipping planes.
   *
   * @param types - the types of planes to be deleted. If not provided, all planes will be deleted.
   */
  deleteAll(types) {
    const planes = [...this.list];
    for (const plane of planes) {
      if (!types || types.has(plane.type)) {
        this.delete(plane.world, plane);
        const index = this.list.indexOf(plane);
        if (index !== -1) {
          this.list.splice(index, 1);
        }
      }
    }
  }
  /** {@link Configurable.setup} */
  setup(config) {
    const fullConfig = { ...this._defaultConfig, ...config };
    this.config.color = fullConfig.color;
    this.config.opacity = fullConfig.opacity;
    this.config.size = fullConfig.size;
    this.isSetup = true;
    this.onSetup.trigger();
  }
  deletePlane(plane) {
    const index = this.list.indexOf(plane);
    if (index !== -1) {
      this.list.splice(index, 1);
      if (!plane.world.renderer) {
        throw new Error("Renderer not found for this plane's world!");
      }
      plane.world.renderer.setPlane(false, plane.three);
      plane.dispose();
      this.updateMaterialsAndPlanes();
      this.onAfterDelete.trigger(plane);
    }
  }
  pickPlane(world) {
    const casters = this.components.get(Raycasters);
    const caster = casters.get(world);
    const meshes = this.getAllPlaneMeshes();
    const intersects2 = caster.castRay(meshes);
    if (intersects2) {
      const found = intersects2.object;
      return this.list.find((p) => p.meshes.includes(found));
    }
    return void 0;
  }
  getAllPlaneMeshes() {
    const meshes = [];
    for (const plane of this.list) {
      meshes.push(...plane.meshes);
    }
    return meshes;
  }
  createPlaneFromIntersection(world, intersect) {
    var _a;
    if (!world.renderer) {
      throw new Error("The given world must have a renderer!");
    }
    const constant = intersect.point.distanceTo(new Vector3(0, 0, 0));
    const normal = (_a = intersect.face) == null ? void 0 : _a.normal;
    if (!constant || !normal) {
      return null;
    }
    const worldNormal = this.getWorldNormal(intersect, normal);
    const plane = this.newPlane(world, intersect.point, worldNormal.negate());
    plane.visible = this._visible;
    plane.size = this._size;
    world.renderer.setPlane(true, plane.three);
    this.updateMaterialsAndPlanes();
    return plane;
  }
  getWorldNormal(intersect, normal) {
    const object = intersect.object;
    let transform = intersect.object.matrixWorld.clone();
    const isInstance = object instanceof InstancedMesh;
    if (isInstance && intersect.instanceId !== void 0) {
      const temp52 = new Matrix4();
      object.getMatrixAt(intersect.instanceId, temp52);
      transform = temp52.multiply(transform);
    }
    const normalMatrix = new Matrix3().getNormalMatrix(transform);
    const worldNormal = normal.clone().applyMatrix3(normalMatrix).normalize();
    this.normalizePlaneDirectionY(worldNormal);
    return worldNormal;
  }
  normalizePlaneDirectionY(normal) {
    if (this.orthogonalY) {
      if (normal.y > this.toleranceOrthogonalY) {
        normal.x = 0;
        normal.y = 1;
        normal.z = 0;
      }
      if (normal.y < -this.toleranceOrthogonalY) {
        normal.x = 0;
        normal.y = -1;
        normal.z = 0;
      }
    }
  }
  newPlane(world, point, normal) {
    const plane = new this.Type(
      this.components,
      world,
      point,
      normal,
      this._material
    );
    plane.onDraggingStarted.add(this._onStartDragging);
    plane.onDraggingEnded.add(this._onEndDragging);
    this.list.push(plane);
    this.onAfterCreate.trigger(plane);
    return plane;
  }
  updateMaterialsAndPlanes() {
    const worlds = this.components.get(Worlds);
    for (const [_id, world] of worlds.list) {
      if (!world.renderer) {
        continue;
      }
      world.renderer.updateClippingPlanes();
      const { clippingPlanes } = world.renderer;
      for (const model of world.meshes) {
        if (!model.material) {
          continue;
        }
        if (Array.isArray(model.material)) {
          for (const mat of model.material) {
            mat.clippingPlanes = clippingPlanes;
          }
        } else {
          model.material.clippingPlanes = clippingPlanes;
        }
      }
    }
  }
};
__publicField2(_Clipper, "uuid", "66290bc5-18c4-4cd1-9379-2e17a0617611");
var Clipper = _Clipper;
var FirstPersonMode = class {
  constructor(camera) {
    __publicField2(this, "enabled", false);
    __publicField2(this, "id", "FirstPerson");
    this.camera = camera;
  }
  /** {@link NavigationMode.set} */
  set(active) {
    this.enabled = active;
    if (active) {
      const projection = this.camera.projection.current;
      if (projection !== "Perspective") {
        this.camera.set("Orbit");
        return;
      }
      this.setupFirstPersonCamera();
    }
  }
  setupFirstPersonCamera() {
    const controls = this.camera.controls;
    const newTargetPosition = new Vector3();
    controls.distance--;
    controls.getPosition(newTargetPosition);
    controls.minDistance = 1;
    controls.maxDistance = 1;
    controls.distance = 1;
    controls.moveTo(
      newTargetPosition.x,
      newTargetPosition.y,
      newTargetPosition.z
    );
    controls.truckSpeed = 50;
    controls.mouseButtons.wheel = CameraControls.ACTION.DOLLY;
    controls.touches.two = CameraControls.ACTION.TOUCH_ZOOM_TRUCK;
  }
};
var OrbitMode = class {
  constructor(camera) {
    __publicField2(this, "enabled", true);
    __publicField2(this, "id", "Orbit");
    this.camera = camera;
    this.activateOrbitControls();
  }
  /** {@link NavigationMode.set} */
  set(active) {
    this.enabled = active;
    if (active) {
      this.activateOrbitControls();
    }
  }
  activateOrbitControls() {
    const controls = this.camera.controls;
    controls.minDistance = 1;
    controls.maxDistance = 300;
    const position = new Vector3();
    controls.getPosition(position);
    const distance = position.length();
    controls.distance = distance;
    controls.truckSpeed = 2;
    const { rotation } = this.camera.three;
    const direction = new Vector3(0, 0, -1).applyEuler(rotation);
    const target = position.addScaledVector(direction, distance);
    controls.moveTo(target.x, target.y, target.z);
  }
};
var PlanMode = class {
  constructor(camera) {
    __publicField2(this, "enabled", false);
    __publicField2(this, "id", "Plan");
    __publicField2(this, "mouseAction1");
    __publicField2(this, "mouseAction2");
    __publicField2(this, "mouseInitialized", false);
    __publicField2(this, "defaultAzimuthSpeed");
    __publicField2(this, "defaultPolarSpeed");
    this.camera = camera;
    this.defaultAzimuthSpeed = camera.controls.azimuthRotateSpeed;
    this.defaultPolarSpeed = camera.controls.polarRotateSpeed;
  }
  /** {@link NavigationMode.set} */
  set(active) {
    this.enabled = active;
    const controls = this.camera.controls;
    controls.azimuthRotateSpeed = active ? 0 : this.defaultAzimuthSpeed;
    controls.polarRotateSpeed = active ? 0 : this.defaultPolarSpeed;
    if (!this.mouseInitialized) {
      this.mouseAction1 = controls.touches.one;
      this.mouseAction2 = controls.touches.two;
      this.mouseInitialized = true;
    }
    if (active) {
      controls.mouseButtons.left = CameraControls.ACTION.TRUCK;
      controls.touches.one = CameraControls.ACTION.TOUCH_TRUCK;
      controls.touches.two = CameraControls.ACTION.TOUCH_ZOOM;
    } else {
      controls.mouseButtons.left = CameraControls.ACTION.ROTATE;
      controls.touches.one = this.mouseAction1;
      controls.touches.two = this.mouseAction2;
    }
  }
};
var ProjectionManager = class {
  constructor(camera) {
    __publicField2(this, "onChanged", new Event());
    __publicField2(this, "current", "Perspective");
    __publicField2(this, "camera");
    __publicField2(this, "matchOrthoDistanceEnabled", false);
    __publicField2(this, "_component");
    __publicField2(this, "_previousDistance", -1);
    this._component = camera;
    this.camera = camera.three;
  }
  /**
   * Sets the {@link CameraProjection} of the {@link OrthoPerspectiveCamera}.
   *
   * @param projection - the new projection to set. If it is the current projection,
   * it will have no effect.
   */
  async set(projection) {
    if (this.current === projection)
      return;
    if (projection === "Orthographic") {
      this.setOrthoCamera();
    } else {
      await this.setPerspectiveCamera();
    }
    this.onChanged.trigger(this.camera);
  }
  /**
   * Changes the current {@link CameraProjection} from Ortographic to Perspective
   * and vice versa.
   */
  async toggle() {
    const isPerspective = this.current === "Perspective";
    const target = isPerspective ? "Orthographic" : "Perspective";
    await this.set(target);
  }
  setOrthoCamera() {
    if (this._component.mode === null)
      return;
    if (this._component.mode.id === "FirstPerson") {
      return;
    }
    this._previousDistance = this._component.controls.distance;
    this._component.controls.distance = 200;
    const dims = this.getPerspectiveDims();
    if (!dims) {
      return;
    }
    const { width, height } = dims;
    this.setupOrthoCamera(height, width);
    this.camera = this._component.threeOrtho;
    this.current = "Orthographic";
  }
  getPerspectiveDims() {
    const world = this._component.currentWorld;
    if (!world || !world.renderer) {
      return null;
    }
    const lineOfSight = new Vector3();
    this._component.threePersp.getWorldDirection(lineOfSight);
    const target = new Vector3();
    this._component.controls.getTarget(target);
    const distance = target.clone().sub(this._component.threePersp.position);
    const depth = distance.dot(lineOfSight);
    const dims = world.renderer.getSize();
    const aspect = dims.x / dims.y;
    const camera = this._component.threePersp;
    const height = depth * 2 * Math.atan(camera.fov * (Math.PI / 180) / 2);
    const width = height * aspect;
    return { width, height };
  }
  setupOrthoCamera(height, width) {
    this._component.controls.mouseButtons.wheel = CameraControls.ACTION.ZOOM;
    this._component.controls.mouseButtons.middle = CameraControls.ACTION.ZOOM;
    this._component.controls.touches.two = CameraControls.ACTION.TOUCH_ZOOM_TRUCK;
    this._component.controls.touches.three = CameraControls.ACTION.TOUCH_ZOOM_TRUCK;
    this._component.controls.dollySpeed = 5;
    const pCamera = this._component.threePersp;
    const oCamera = this._component.threeOrtho;
    oCamera.zoom = 1;
    oCamera.left = width / -2;
    oCamera.right = width / 2;
    oCamera.top = height / 2;
    oCamera.bottom = height / -2;
    oCamera.updateProjectionMatrix();
    oCamera.position.copy(pCamera.position);
    oCamera.quaternion.copy(pCamera.quaternion);
    this._component.controls.camera = oCamera;
  }
  getDistance() {
    const pCamera = this._component.threePersp;
    const oCamera = this._component.threeOrtho;
    const depth = (oCamera.top - oCamera.bottom) / oCamera.zoom / (2 * Math.atan(pCamera.fov * (Math.PI / 180) / 2));
    return depth;
  }
  async setPerspectiveCamera() {
    this._component.controls.mouseButtons.wheel = CameraControls.ACTION.DOLLY;
    this._component.controls.mouseButtons.middle = CameraControls.ACTION.DOLLY;
    const pCamera = this._component.threePersp;
    const oCamera = this._component.threeOrtho;
    pCamera.position.copy(oCamera.position);
    pCamera.quaternion.copy(oCamera.quaternion);
    this._component.controls.mouseButtons.wheel = CameraControls.ACTION.DOLLY;
    this._component.controls.touches.two = CameraControls.ACTION.TOUCH_DOLLY_TRUCK;
    this._component.controls.touches.three = CameraControls.ACTION.TOUCH_DOLLY_TRUCK;
    this._component.controls.dollySpeed = 5;
    if (this.matchOrthoDistanceEnabled) {
      this._component.controls.distance = this.getDistance();
    } else {
      this._component.controls.distance = this._previousDistance;
    }
    await this._component.controls.zoomTo(1);
    pCamera.updateProjectionMatrix();
    this._component.controls.camera = pCamera;
    this.camera = pCamera;
    this.current = "Perspective";
  }
};
var OrthoPerspectiveCamera = class extends SimpleCamera {
  constructor(components) {
    super(components);
    __publicField2(this, "projection");
    __publicField2(this, "threeOrtho");
    __publicField2(this, "threePersp");
    __publicField2(this, "_userInputButtons", {});
    __publicField2(this, "_frustumSize", 50);
    __publicField2(this, "_navigationModes", /* @__PURE__ */ new Map());
    __publicField2(this, "_mode", null);
    __publicField2(this, "previousSize", null);
    this.threePersp = this.three;
    this.threeOrtho = this.newOrthoCamera();
    this.projection = new ProjectionManager(this);
    this.onAspectUpdated.add(() => {
      this.setOrthoPerspCameraAspect();
    });
    this.projection.onChanged.add(
      (camera) => {
        this.three = camera;
        this.updateAspect();
      }
    );
    this.onWorldChanged.add(({ action }) => {
      if (action === "added") {
        this._navigationModes.clear();
        this._navigationModes.set("Orbit", new OrbitMode(this));
        this._navigationModes.set("FirstPerson", new FirstPersonMode(this));
        this._navigationModes.set("Plan", new PlanMode(this));
        this._mode = this._navigationModes.get("Orbit");
        this.mode.set(true, { preventTargetAdjustment: true });
        if (this.currentWorld && this.currentWorld.renderer) {
          this.previousSize = this.currentWorld.renderer.getSize().clone();
        }
      }
    });
  }
  /**
   * Getter for the current navigation mode.
   * Throws an error if the mode is not found or the camera is not initialized.
   *
   * @returns {NavigationMode} The current navigation mode.
   *
   * @throws {Error} Throws an error if the mode is not found or the camera is not initialized.
   */
  get mode() {
    if (!this._mode) {
      throw new Error("Mode not found, camera not initialized");
    }
    return this._mode;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    super.dispose();
    this.threeOrtho.removeFromParent();
  }
  /**
   * Sets a new {@link NavigationMode} and disables the previous one.
   *
   * @param mode - The {@link NavigationMode} to set.
   */
  set(mode) {
    if (this.mode === null)
      return;
    if (this.mode.id === mode)
      return;
    this.mode.set(false);
    if (!this._navigationModes.has(mode)) {
      throw new Error("The specified mode does not exist!");
    }
    this._mode = this._navigationModes.get(mode);
    this.mode.set(true);
  }
  /**
   * Make the camera view fit all the specified meshes.
   *
   * @param meshes the meshes to fit. If it is not defined, it will
   * evaluate {@link Components.meshes}.
   * @param offset the distance to the fit object
   */
  async fit(meshes, offset = 1.5) {
    if (!this.enabled)
      return;
    const maxNum = Number.MAX_VALUE;
    const minNum = Number.MIN_VALUE;
    const min = new Vector3(maxNum, maxNum, maxNum);
    const max = new Vector3(minNum, minNum, minNum);
    for (const mesh of meshes) {
      const box2 = new Box3().setFromObject(mesh);
      if (box2.min.x < min.x)
        min.x = box2.min.x;
      if (box2.min.y < min.y)
        min.y = box2.min.y;
      if (box2.min.z < min.z)
        min.z = box2.min.z;
      if (box2.max.x > max.x)
        max.x = box2.max.x;
      if (box2.max.y > max.y)
        max.y = box2.max.y;
      if (box2.max.z > max.z)
        max.z = box2.max.z;
    }
    const box = new Box3(min, max);
    const sceneSize = new Vector3();
    box.getSize(sceneSize);
    const sceneCenter = new Vector3();
    box.getCenter(sceneCenter);
    const radius = Math.max(sceneSize.x, sceneSize.y, sceneSize.z) * offset;
    const sphere = new Sphere(sceneCenter, radius);
    await this.controls.fitToSphere(sphere, true);
  }
  /**
   * Allows or prevents all user input.
   *
   * @param active - whether to enable or disable user inputs.
   */
  setUserInput(active) {
    if (active) {
      this.enableUserInput();
    } else {
      this.disableUserInput();
    }
  }
  disableUserInput() {
    this._userInputButtons.left = this.controls.mouseButtons.left;
    this._userInputButtons.right = this.controls.mouseButtons.right;
    this._userInputButtons.middle = this.controls.mouseButtons.middle;
    this._userInputButtons.wheel = this.controls.mouseButtons.wheel;
    this.controls.mouseButtons.left = 0;
    this.controls.mouseButtons.right = 0;
    this.controls.mouseButtons.middle = 0;
    this.controls.mouseButtons.wheel = 0;
  }
  enableUserInput() {
    if (Object.keys(this._userInputButtons).length === 0)
      return;
    this.controls.mouseButtons.left = this._userInputButtons.left;
    this.controls.mouseButtons.right = this._userInputButtons.right;
    this.controls.mouseButtons.middle = this._userInputButtons.middle;
    this.controls.mouseButtons.wheel = this._userInputButtons.wheel;
  }
  newOrthoCamera() {
    const aspect = window.innerWidth / window.innerHeight;
    return new OrthographicCamera(
      this._frustumSize * aspect / -2,
      this._frustumSize * aspect / 2,
      this._frustumSize / 2,
      this._frustumSize / -2,
      0.1,
      1e3
    );
  }
  setOrthoPerspCameraAspect() {
    if (!this.currentWorld || !this.currentWorld.renderer) {
      return;
    }
    if (!this.previousSize)
      return;
    const size = this.currentWorld.renderer.getSize();
    const previousHeight = this.threeOrtho.top;
    const previousWidth = this.threeOrtho.right;
    const heightSizeFactor = size.y / this.previousSize.y;
    const widthSizeFactor = size.x / this.previousSize.x;
    const newHeight = previousHeight * heightSizeFactor;
    const newWidth = previousWidth * widthSizeFactor;
    this.threeOrtho.left = -newWidth;
    this.threeOrtho.right = newWidth;
    this.threeOrtho.top = newHeight;
    this.threeOrtho.bottom = -newHeight;
    this.threeOrtho.updateProjectionMatrix();
    this.previousSize.copy(size);
  }
};
var relToAttributesMap = /* @__PURE__ */ new Map([
  [
    IFCRELAGGREGATES,
    {
      forRelated: "Decomposes",
      forRelating: "IsDecomposedBy"
    }
  ],
  [
    IFCRELASSOCIATESMATERIAL,
    {
      forRelated: "HasAssociations",
      forRelating: "AssociatedTo"
    }
  ],
  [
    IFCRELASSOCIATESCLASSIFICATION,
    {
      forRelated: "HasAssociations",
      forRelating: "ClassificationForObjects"
    }
  ],
  [
    IFCRELASSIGNSTOGROUP,
    {
      forRelated: "HasAssignments",
      forRelating: "IsGroupedBy"
    }
  ],
  [
    IFCRELDEFINESBYPROPERTIES,
    {
      forRelated: "IsDefinedBy",
      forRelating: "DefinesOcurrence"
    }
  ],
  [
    IFCRELDEFINESBYTYPE,
    {
      forRelated: "IsTypedBy",
      forRelating: "Types"
    }
  ],
  [
    IFCRELDEFINESBYTEMPLATE,
    {
      forRelated: "IsDefinedBy",
      forRelating: "Defines"
    }
  ],
  [
    IFCRELCONTAINEDINSPATIALSTRUCTURE,
    {
      forRelated: "ContainedInStructure",
      forRelating: "ContainsElements"
    }
  ],
  [
    IFCRELFLOWCONTROLELEMENTS,
    {
      forRelated: "AssignedToFlowElement",
      forRelating: "HasControlElements"
    }
  ],
  [
    IFCRELCONNECTSELEMENTS,
    {
      forRelated: "ConnectedFrom",
      forRelating: "ConnectedTo"
    }
  ],
  [
    IFCRELASSIGNSTOPRODUCT,
    {
      forRelated: "HasAssignments",
      forRelating: "ReferencedBy"
    }
  ],
  [
    IFCRELDECLARES,
    {
      forRelated: "HasContext",
      forRelating: "Declares"
    }
  ],
  [
    IFCRELASSIGNSTOCONTROL,
    {
      forRelated: "HasAssignments",
      forRelating: "Controls"
    }
  ],
  [
    IFCRELNESTS,
    {
      forRelated: "Nests",
      forRelating: "IsNestedBy"
    }
  ],
  [
    IFCRELASSOCIATESDOCUMENT,
    {
      forRelated: "HasAssociations",
      forRelating: "DocumentRefForObjects"
    }
  ]
]);
var IfcElements = {
  103090709: "IFCPROJECT",
  4097777520: "IFCSITE",
  4031249490: "IFCBUILDING",
  3124254112: "IFCBUILDINGSTOREY",
  3856911033: "IFCSPACE",
  1674181508: "IFCANNOTATION",
  25142252: "IFCCONTROLLER",
  32344328: "IFCBOILER",
  76236018: "IFCLAMP",
  90941305: "IFCPUMP",
  177149247: "IFCAIRTERMINALBOX",
  182646315: "IFCFLOWINSTRUMENT",
  263784265: "IFCFURNISHINGELEMENT",
  264262732: "IFCELECTRICGENERATOR",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  310824031: "IFCPIPEFITTING",
  331165859: "IFCSTAIR",
  342316401: "IFCDUCTFITTING",
  377706215: "IFCMECHANICALFASTENER",
  395920057: "IFCDOOR",
  402227799: "IFCELECTRICMOTOR",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  484807127: "IFCEVAPORATOR",
  486154966: "IFCWINDOWSTANDARDCASE",
  629592764: "IFCLIGHTFIXTURE",
  630975310: "IFCUNITARYCONTROLELEMENT",
  635142910: "IFCCABLECARRIERFITTING",
  639361253: "IFCCOIL",
  647756555: "IFCFASTENER",
  707683696: "IFCFLOWSTORAGEDEVICE",
  738039164: "IFCPROTECTIVEDEVICE",
  753842376: "IFCBEAM",
  812556717: "IFCTANK",
  819412036: "IFCFILTER",
  843113511: "IFCCOLUMN",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  900683007: "IFCFOOTING",
  905975707: "IFCCOLUMNSTANDARDCASE",
  926996030: "IFCVOIDINGFEATURE",
  979691226: "IFCREINFORCINGBAR",
  987401354: "IFCFLOWSEGMENT",
  1003880860: "IFCELECTRICTIMECONTROL",
  1051757585: "IFCCABLEFITTING",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  1073191201: "IFCMEMBER",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  1156407060: "IFCPLATESTANDARDCASE",
  1162798199: "IFCSWITCHINGDEVICE",
  1329646415: "IFCSHADINGDEVICE",
  1335981549: "IFCDISCRETEACCESSORY",
  1360408905: "IFCDUCTSILENCER",
  1404847402: "IFCSTACKTERMINAL",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  1437502449: "IFCMEDICALDEVICE",
  1509553395: "IFCFURNITURE",
  1529196076: "IFCSLAB",
  1620046519: "IFCTRANSPORTELEMENT",
  1634111441: "IFCAIRTERMINAL",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  1677625105: "IFCCIVILELEMENT",
  1687234759: "IFCPILE",
  1904799276: "IFCELECTRICAPPLIANCE",
  1911478936: "IFCMEMBERSTANDARDCASE",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  1973544240: "IFCCOVERING",
  1999602285: "IFCSPACEHEATER",
  2016517767: "IFCROOF",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  2058353004: "IFCFLOWCONTROLLER",
  2068733104: "IFCHUMIDIFIER",
  2176052936: "IFCJUNCTIONBOX",
  2188021234: "IFCFLOWMETER",
  2223149337: "IFCFLOWTERMINAL",
  2262370178: "IFCRAILING",
  2272882330: "IFCCONDENSER",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  2320036040: "IFCREINFORCINGMESH",
  2347447852: "IFCTENDONANCHOR",
  2391383451: "IFCVIBRATIONISOLATOR",
  2391406946: "IFCWALL",
  2474470126: "IFCMOTORCONNECTION",
  2769231204: "IFCVIRTUALELEMENT",
  2814081492: "IFCENGINE",
  2906023776: "IFCBEAMSTANDARDCASE",
  2938176219: "IFCBURNER",
  2979338954: "IFCBUILDINGELEMENTPART",
  3024970846: "IFCRAMP",
  3026737570: "IFCTUBEBUNDLE",
  3027962421: "IFCSLABSTANDARDCASE",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  3053780830: "IFCSANITARYTERMINAL",
  3079942009: "IFCOPENINGSTANDARDCASE",
  3087945054: "IFCALARM",
  3101698114: "IFCSURFACEFEATURE",
  3127900445: "IFCSLABELEMENTEDCASE",
  3132237377: "IFCFLOWMOVINGDEVICE",
  3171933400: "IFCPLATE",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  3242481149: "IFCDOORSTANDARDCASE",
  3283111854: "IFCRAMPFLIGHT",
  3296154744: "IFCCHIMNEY",
  3304561284: "IFCWINDOW",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  3319311131: "IFCHEATEXCHANGER",
  3415622556: "IFCFAN",
  3420628829: "IFCSOLARDEVICE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  3495092785: "IFCCURTAINWALL",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  3512223829: "IFCWALLSTANDARDCASE",
  3518393246: "IFCDUCTSEGMENT",
  3571504051: "IFCCOMPRESSOR",
  3588315303: "IFCOPENINGELEMENT",
  3612865200: "IFCPIPESEGMENT",
  3640358203: "IFCCOOLINGTOWER",
  3651124850: "IFCPROJECTIONELEMENT",
  3694346114: "IFCOUTLET",
  3747195512: "IFCEVAPORATIVECOOLER",
  3758799889: "IFCCABLECARRIERSEGMENT",
  3824725483: "IFCTENDON",
  3825984169: "IFCTRANSFORMER",
  3902619387: "IFCCHILLER",
  4074379575: "IFCDAMPER",
  4086658281: "IFCSENSOR",
  4123344466: "IFCELEMENTASSEMBLY",
  4136498852: "IFCCOOLEDBEAM",
  4156078855: "IFCWALLELEMENTEDCASE",
  4175244083: "IFCINTERCEPTOR",
  4207607924: "IFCVALVE",
  4217484030: "IFCCABLESEGMENT",
  4237592921: "IFCWASTETERMINAL",
  4252922144: "IFCSTAIRFLIGHT",
  4278956645: "IFCFLOWFITTING",
  4288193352: "IFCACTUATOR",
  4292641817: "IFCUNITARYEQUIPMENT",
  3009204131: "IFCGRID"
};
var IfcCategories = class {
  getAll(webIfc, modelID) {
    const elementsCategories = {};
    const categoriesIDs = Object.keys(IfcElements).map((e) => parseInt(e, 10));
    for (let i = 0; i < categoriesIDs.length; i++) {
      const element = categoriesIDs[i];
      const lines = webIfc.GetLineIDsWithType(modelID, element);
      const size = lines.size();
      for (let i2 = 0; i2 < size; i2++) {
        elementsCategories[lines.get(i2)] = element;
      }
    }
    return elementsCategories;
  }
};
var IfcCategoryMap = {
  950732822: "IFCURIREFERENCE",
  4075327185: "IFCTIME",
  1209108979: "IFCTEMPERATURERATEOFCHANGEMEASURE",
  3457685358: "IFCSOUNDPRESSURELEVELMEASURE",
  4157543285: "IFCSOUNDPOWERLEVELMEASURE",
  2798247006: "IFCPROPERTYSETDEFINITIONSET",
  1790229001: "IFCPOSITIVEINTEGER",
  525895558: "IFCNONNEGATIVELENGTHMEASURE",
  1774176899: "IFCLINEINDEX",
  1275358634: "IFCLANGUAGEID",
  2541165894: "IFCDURATION",
  3701338814: "IFCDAYINWEEKNUMBER",
  2195413836: "IFCDATETIME",
  937566702: "IFCDATE",
  1683019596: "IFCCARDINALPOINTREFERENCE",
  2314439260: "IFCBINARY",
  1500781891: "IFCAREADENSITYMEASURE",
  3683503648: "IFCARCINDEX",
  4065007721: "IFCYEARNUMBER",
  1718600412: "IFCWARPINGMOMENTMEASURE",
  51269191: "IFCWARPINGCONSTANTMEASURE",
  2593997549: "IFCVOLUMETRICFLOWRATEMEASURE",
  3458127941: "IFCVOLUMEMEASURE",
  3345633955: "IFCVAPORPERMEABILITYMEASURE",
  1278329552: "IFCTORQUEMEASURE",
  2591213694: "IFCTIMESTAMP",
  2726807636: "IFCTIMEMEASURE",
  743184107: "IFCTHERMODYNAMICTEMPERATUREMEASURE",
  2016195849: "IFCTHERMALTRANSMITTANCEMEASURE",
  857959152: "IFCTHERMALRESISTANCEMEASURE",
  2281867870: "IFCTHERMALEXPANSIONCOEFFICIENTMEASURE",
  2645777649: "IFCTHERMALCONDUCTIVITYMEASURE",
  232962298: "IFCTHERMALADMITTANCEMEASURE",
  296282323: "IFCTEXTTRANSFORMATION",
  603696268: "IFCTEXTFONTNAME",
  3490877962: "IFCTEXTDECORATION",
  1460886941: "IFCTEXTALIGNMENT",
  2801250643: "IFCTEXT",
  58845555: "IFCTEMPERATUREGRADIENTMEASURE",
  361837227: "IFCSPECULARROUGHNESS",
  2757832317: "IFCSPECULAREXPONENT",
  3477203348: "IFCSPECIFICHEATCAPACITYMEASURE",
  993287707: "IFCSOUNDPRESSUREMEASURE",
  846465480: "IFCSOUNDPOWERMEASURE",
  3471399674: "IFCSOLIDANGLEMEASURE",
  408310005: "IFCSHEARMODULUSMEASURE",
  2190458107: "IFCSECTIONALAREAINTEGRALMEASURE",
  3467162246: "IFCSECTIONMODULUSMEASURE",
  2766185779: "IFCSECONDINMINUTE",
  3211557302: "IFCROTATIONALSTIFFNESSMEASURE",
  1755127002: "IFCROTATIONALMASSMEASURE",
  2133746277: "IFCROTATIONALFREQUENCYMEASURE",
  200335297: "IFCREAL",
  96294661: "IFCRATIOMEASURE",
  3972513137: "IFCRADIOACTIVITYMEASURE",
  3665567075: "IFCPRESSUREMEASURE",
  2169031380: "IFCPRESENTABLETEXT",
  1364037233: "IFCPOWERMEASURE",
  1245737093: "IFCPOSITIVERATIOMEASURE",
  3054510233: "IFCPOSITIVEPLANEANGLEMEASURE",
  2815919920: "IFCPOSITIVELENGTHMEASURE",
  4042175685: "IFCPLANEANGLEMEASURE",
  2642773653: "IFCPLANARFORCEMEASURE",
  2260317790: "IFCPARAMETERVALUE",
  929793134: "IFCPHMEASURE",
  2395907400: "IFCNUMERICMEASURE",
  2095195183: "IFCNORMALISEDRATIOMEASURE",
  765770214: "IFCMONTHINYEARNUMBER",
  2615040989: "IFCMONETARYMEASURE",
  3114022597: "IFCMOMENTOFINERTIAMEASURE",
  1648970520: "IFCMOLECULARWEIGHTMEASURE",
  3177669450: "IFCMOISTUREDIFFUSIVITYMEASURE",
  1753493141: "IFCMODULUSOFSUBGRADEREACTIONMEASURE",
  1052454078: "IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE",
  2173214787: "IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE",
  3341486342: "IFCMODULUSOFELASTICITYMEASURE",
  102610177: "IFCMINUTEINHOUR",
  3531705166: "IFCMASSPERLENGTHMEASURE",
  3124614049: "IFCMASSMEASURE",
  4017473158: "IFCMASSFLOWRATEMEASURE",
  1477762836: "IFCMASSDENSITYMEASURE",
  2486716878: "IFCMAGNETICFLUXMEASURE",
  286949696: "IFCMAGNETICFLUXDENSITYMEASURE",
  151039812: "IFCLUMINOUSINTENSITYMEASURE",
  2755797622: "IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE",
  2095003142: "IFCLUMINOUSFLUXMEASURE",
  503418787: "IFCLOGICAL",
  3086160713: "IFCLINEARVELOCITYMEASURE",
  1307019551: "IFCLINEARSTIFFNESSMEASURE",
  2128979029: "IFCLINEARMOMENTMEASURE",
  191860431: "IFCLINEARFORCEMEASURE",
  1243674935: "IFCLENGTHMEASURE",
  3258342251: "IFCLABEL",
  2054016361: "IFCKINEMATICVISCOSITYMEASURE",
  3192672207: "IFCISOTHERMALMOISTURECAPACITYMEASURE",
  3686016028: "IFCIONCONCENTRATIONMEASURE",
  3809634241: "IFCINTEGERCOUNTRATEMEASURE",
  1939436016: "IFCINTEGER",
  2679005408: "IFCINDUCTANCEMEASURE",
  3358199106: "IFCILLUMINANCEMEASURE",
  983778844: "IFCIDENTIFIER",
  2589826445: "IFCHOURINDAY",
  1158859006: "IFCHEATINGVALUEMEASURE",
  3113092358: "IFCHEATFLUXDENSITYMEASURE",
  3064340077: "IFCGLOBALLYUNIQUEID",
  3044325142: "IFCFREQUENCYMEASURE",
  1361398929: "IFCFORCEMEASURE",
  2590844177: "IFCFONTWEIGHT",
  2715512545: "IFCFONTVARIANT",
  1102727119: "IFCFONTSTYLE",
  2078135608: "IFCENERGYMEASURE",
  2506197118: "IFCELECTRICVOLTAGEMEASURE",
  2951915441: "IFCELECTRICRESISTANCEMEASURE",
  3790457270: "IFCELECTRICCURRENTMEASURE",
  2093906313: "IFCELECTRICCONDUCTANCEMEASURE",
  3818826038: "IFCELECTRICCHARGEMEASURE",
  1827137117: "IFCELECTRICCAPACITANCEMEASURE",
  69416015: "IFCDYNAMICVISCOSITYMEASURE",
  524656162: "IFCDOSEEQUIVALENTMEASURE",
  4134073009: "IFCDIMENSIONCOUNT",
  1514641115: "IFCDESCRIPTIVEMEASURE",
  300323983: "IFCDAYLIGHTSAVINGHOUR",
  86635668: "IFCDAYINMONTHNUMBER",
  94842927: "IFCCURVATUREMEASURE",
  1778710042: "IFCCOUNTMEASURE",
  3238673880: "IFCCONTEXTDEPENDENTMEASURE",
  3812528620: "IFCCOMPOUNDPLANEANGLEMEASURE",
  2991860651: "IFCCOMPLEXNUMBER",
  1867003952: "IFCBOXALIGNMENT",
  2735952531: "IFCBOOLEAN",
  2650437152: "IFCAREAMEASURE",
  632304761: "IFCANGULARVELOCITYMEASURE",
  360377573: "IFCAMOUNTOFSUBSTANCEMEASURE",
  4182062534: "IFCACCELERATIONMEASURE",
  3699917729: "IFCABSORBEDDOSEMEASURE",
  1971632696: "IFCGEOSLICE",
  2680139844: "IFCGEOMODEL",
  24726584: "IFCELECTRICFLOWTREATMENTDEVICE",
  3693000487: "IFCDISTRIBUTIONBOARD",
  3460952963: "IFCCONVEYORSEGMENT",
  3999819293: "IFCCAISSONFOUNDATION",
  3314249567: "IFCBOREHOLE",
  4196446775: "IFCBEARING",
  325726236: "IFCALIGNMENT",
  3425753595: "IFCTRACKELEMENT",
  991950508: "IFCSIGNAL",
  3798194928: "IFCREINFORCEDSOIL",
  3290496277: "IFCRAIL",
  1383356374: "IFCPAVEMENT",
  2182337498: "IFCNAVIGATIONELEMENT",
  234836483: "IFCMOORINGDEVICE",
  2078563270: "IFCMOBILETELECOMMUNICATIONSAPPLIANCE",
  1638804497: "IFCLIQUIDTERMINAL",
  1154579445: "IFCLINEARPOSITIONINGELEMENT",
  2696325953: "IFCKERB",
  2713699986: "IFCGEOTECHNICALASSEMBLY",
  2142170206: "IFCELECTRICFLOWTREATMENTDEVICETYPE",
  3376911765: "IFCEARTHWORKSFILL",
  1077100507: "IFCEARTHWORKSELEMENT",
  3071239417: "IFCEARTHWORKSCUT",
  479945903: "IFCDISTRIBUTIONBOARDTYPE",
  3426335179: "IFCDEEPFOUNDATION",
  1502416096: "IFCCOURSE",
  2940368186: "IFCCONVEYORSEGMENTTYPE",
  3203706013: "IFCCAISSONFOUNDATIONTYPE",
  3862327254: "IFCBUILTSYSTEM",
  1876633798: "IFCBUILTELEMENT",
  963979645: "IFCBRIDGEPART",
  644574406: "IFCBRIDGE",
  3649138523: "IFCBEARINGTYPE",
  1662888072: "IFCALIGNMENTVERTICAL",
  317615605: "IFCALIGNMENTSEGMENT",
  1545765605: "IFCALIGNMENTHORIZONTAL",
  4266260250: "IFCALIGNMENTCANT",
  3956297820: "IFCVIBRATIONDAMPERTYPE",
  1530820697: "IFCVIBRATIONDAMPER",
  840318589: "IFCVEHICLE",
  1953115116: "IFCTRANSPORTATIONDEVICE",
  618700268: "IFCTRACKELEMENTTYPE",
  2281632017: "IFCTENDONCONDUITTYPE",
  3663046924: "IFCTENDONCONDUIT",
  42703149: "IFCSINESPIRAL",
  1894708472: "IFCSIGNALTYPE",
  3599934289: "IFCSIGNTYPE",
  33720170: "IFCSIGN",
  1027922057: "IFCSEVENTHORDERPOLYNOMIALSPIRAL",
  544395925: "IFCSEGMENTEDREFERENCECURVE",
  3649235739: "IFCSECONDORDERPOLYNOMIALSPIRAL",
  550521510: "IFCROADPART",
  146592293: "IFCROAD",
  3818125796: "IFCRELADHERESTOELEMENT",
  4021432810: "IFCREFERENT",
  1891881377: "IFCRAILWAYPART",
  3992365140: "IFCRAILWAY",
  1763565496: "IFCRAILTYPE",
  1946335990: "IFCPOSITIONINGELEMENT",
  514975943: "IFCPAVEMENTTYPE",
  506776471: "IFCNAVIGATIONELEMENTTYPE",
  710110818: "IFCMOORINGDEVICETYPE",
  1950438474: "IFCMOBILETELECOMMUNICATIONSAPPLIANCETYPE",
  976884017: "IFCMARINEPART",
  525669439: "IFCMARINEFACILITY",
  1770583370: "IFCLIQUIDTERMINALTYPE",
  2176059722: "IFCLINEARELEMENT",
  679976338: "IFCKERBTYPE",
  3948183225: "IFCIMPACTPROTECTIONDEVICETYPE",
  2568555532: "IFCIMPACTPROTECTIONDEVICE",
  2898700619: "IFCGRADIENTCURVE",
  1594536857: "IFCGEOTECHNICALSTRATUM",
  4230923436: "IFCGEOTECHNICALELEMENT",
  4228831410: "IFCFACILITYPARTCOMMON",
  1310830890: "IFCFACILITYPART",
  24185140: "IFCFACILITY",
  4234616927: "IFCDIRECTRIXDERIVEDREFERENCESWEPTAREASOLID",
  1306400036: "IFCDEEPFOUNDATIONTYPE",
  4189326743: "IFCCOURSETYPE",
  2000195564: "IFCCOSINESPIRAL",
  3497074424: "IFCCLOTHOID",
  1626504194: "IFCBUILTELEMENTTYPE",
  3651464721: "IFCVEHICLETYPE",
  1229763772: "IFCTRIANGULATEDIRREGULARNETWORK",
  3665877780: "IFCTRANSPORTATIONDEVICETYPE",
  782932809: "IFCTHIRDORDERPOLYNOMIALSPIRAL",
  2735484536: "IFCSPIRAL",
  1356537516: "IFCSECTIONEDSURFACE",
  1290935644: "IFCSECTIONEDSOLIDHORIZONTAL",
  1862484736: "IFCSECTIONEDSOLID",
  1441486842: "IFCRELPOSITIONS",
  1033248425: "IFCRELASSOCIATESPROFILEDEF",
  3381221214: "IFCPOLYNOMIALCURVE",
  2485787929: "IFCOFFSETCURVEBYDISTANCES",
  590820931: "IFCOFFSETCURVE",
  3465909080: "IFCINDEXEDPOLYGONALTEXTUREMAP",
  593015953: "IFCDIRECTRIXCURVESWEPTAREASOLID",
  4212018352: "IFCCURVESEGMENT",
  3425423356: "IFCAXIS2PLACEMENTLINEAR",
  823603102: "IFCSEGMENT",
  2165702409: "IFCPOINTBYDISTANCEEXPRESSION",
  182550632: "IFCOPENCROSSPROFILEDEF",
  388784114: "IFCLINEARPLACEMENT",
  536804194: "IFCALIGNMENTHORIZONTALSEGMENT",
  3752311538: "IFCALIGNMENTCANTSEGMENT",
  1010789467: "IFCTEXTURECOORDINATEINDICESWITHVOIDS",
  222769930: "IFCTEXTURECOORDINATEINDICES",
  2691318326: "IFCQUANTITYNUMBER",
  3633395639: "IFCALIGNMENTVERTICALSEGMENT",
  2879124712: "IFCALIGNMENTPARAMETERSEGMENT",
  25142252: "IFCCONTROLLER",
  3087945054: "IFCALARM",
  4288193352: "IFCACTUATOR",
  630975310: "IFCUNITARYCONTROLELEMENT",
  4086658281: "IFCSENSOR",
  2295281155: "IFCPROTECTIVEDEVICETRIPPINGUNIT",
  182646315: "IFCFLOWINSTRUMENT",
  1426591983: "IFCFIRESUPPRESSIONTERMINAL",
  819412036: "IFCFILTER",
  3415622556: "IFCFAN",
  1003880860: "IFCELECTRICTIMECONTROL",
  402227799: "IFCELECTRICMOTOR",
  264262732: "IFCELECTRICGENERATOR",
  3310460725: "IFCELECTRICFLOWSTORAGEDEVICE",
  862014818: "IFCELECTRICDISTRIBUTIONBOARD",
  1904799276: "IFCELECTRICAPPLIANCE",
  1360408905: "IFCDUCTSILENCER",
  3518393246: "IFCDUCTSEGMENT",
  342316401: "IFCDUCTFITTING",
  562808652: "IFCDISTRIBUTIONCIRCUIT",
  4074379575: "IFCDAMPER",
  3640358203: "IFCCOOLINGTOWER",
  4136498852: "IFCCOOLEDBEAM",
  2272882330: "IFCCONDENSER",
  3571504051: "IFCCOMPRESSOR",
  3221913625: "IFCCOMMUNICATIONSAPPLIANCE",
  639361253: "IFCCOIL",
  3902619387: "IFCCHILLER",
  4217484030: "IFCCABLESEGMENT",
  1051757585: "IFCCABLEFITTING",
  3758799889: "IFCCABLECARRIERSEGMENT",
  635142910: "IFCCABLECARRIERFITTING",
  2938176219: "IFCBURNER",
  32344328: "IFCBOILER",
  2906023776: "IFCBEAMSTANDARDCASE",
  277319702: "IFCAUDIOVISUALAPPLIANCE",
  2056796094: "IFCAIRTOAIRHEATRECOVERY",
  177149247: "IFCAIRTERMINALBOX",
  1634111441: "IFCAIRTERMINAL",
  486154966: "IFCWINDOWSTANDARDCASE",
  4237592921: "IFCWASTETERMINAL",
  4156078855: "IFCWALLELEMENTEDCASE",
  4207607924: "IFCVALVE",
  4292641817: "IFCUNITARYEQUIPMENT",
  3179687236: "IFCUNITARYCONTROLELEMENTTYPE",
  3026737570: "IFCTUBEBUNDLE",
  3825984169: "IFCTRANSFORMER",
  812556717: "IFCTANK",
  1162798199: "IFCSWITCHINGDEVICE",
  385403989: "IFCSTRUCTURALLOADCASE",
  1404847402: "IFCSTACKTERMINAL",
  1999602285: "IFCSPACEHEATER",
  3420628829: "IFCSOLARDEVICE",
  3027962421: "IFCSLABSTANDARDCASE",
  3127900445: "IFCSLABELEMENTEDCASE",
  1329646415: "IFCSHADINGDEVICE",
  3053780830: "IFCSANITARYTERMINAL",
  2572171363: "IFCREINFORCINGBARTYPE",
  1232101972: "IFCRATIONALBSPLINECURVEWITHKNOTS",
  90941305: "IFCPUMP",
  655969474: "IFCPROTECTIVEDEVICETRIPPINGUNITTYPE",
  738039164: "IFCPROTECTIVEDEVICE",
  1156407060: "IFCPLATESTANDARDCASE",
  3612865200: "IFCPIPESEGMENT",
  310824031: "IFCPIPEFITTING",
  3694346114: "IFCOUTLET",
  144952367: "IFCOUTERBOUNDARYCURVE",
  2474470126: "IFCMOTORCONNECTION",
  1911478936: "IFCMEMBERSTANDARDCASE",
  1437502449: "IFCMEDICALDEVICE",
  629592764: "IFCLIGHTFIXTURE",
  76236018: "IFCLAMP",
  2176052936: "IFCJUNCTIONBOX",
  4175244083: "IFCINTERCEPTOR",
  2068733104: "IFCHUMIDIFIER",
  3319311131: "IFCHEATEXCHANGER",
  2188021234: "IFCFLOWMETER",
  1209101575: "IFCEXTERNALSPATIALELEMENT",
  484807127: "IFCEVAPORATOR",
  3747195512: "IFCEVAPORATIVECOOLER",
  2814081492: "IFCENGINE",
  2417008758: "IFCELECTRICDISTRIBUTIONBOARDTYPE",
  3242481149: "IFCDOORSTANDARDCASE",
  3205830791: "IFCDISTRIBUTIONSYSTEM",
  400855858: "IFCCOMMUNICATIONSAPPLIANCETYPE",
  905975707: "IFCCOLUMNSTANDARDCASE",
  1677625105: "IFCCIVILELEMENT",
  3296154744: "IFCCHIMNEY",
  2674252688: "IFCCABLEFITTINGTYPE",
  2188180465: "IFCBURNERTYPE",
  1177604601: "IFCBUILDINGSYSTEM",
  39481116: "IFCBUILDINGELEMENTPARTTYPE",
  1136057603: "IFCBOUNDARYCURVE",
  2461110595: "IFCBSPLINECURVEWITHKNOTS",
  1532957894: "IFCAUDIOVISUALAPPLIANCETYPE",
  4088093105: "IFCWORKCALENDAR",
  4009809668: "IFCWINDOWTYPE",
  926996030: "IFCVOIDINGFEATURE",
  2391383451: "IFCVIBRATIONISOLATOR",
  2415094496: "IFCTENDONTYPE",
  3081323446: "IFCTENDONANCHORTYPE",
  413509423: "IFCSYSTEMFURNITUREELEMENT",
  3101698114: "IFCSURFACEFEATURE",
  3657597509: "IFCSTRUCTURALSURFACEACTION",
  2757150158: "IFCSTRUCTURALCURVEREACTION",
  1004757350: "IFCSTRUCTURALCURVEACTION",
  338393293: "IFCSTAIRTYPE",
  1072016465: "IFCSOLARDEVICETYPE",
  4074543187: "IFCSHADINGDEVICETYPE",
  2157484638: "IFCSEAMCURVE",
  2781568857: "IFCROOFTYPE",
  2310774935: "IFCREINFORCINGMESHTYPE",
  964333572: "IFCREINFORCINGELEMENTTYPE",
  683857671: "IFCRATIONALBSPLINESURFACEWITHKNOTS",
  1469900589: "IFCRAMPTYPE",
  2839578677: "IFCPOLYGONALFACESET",
  1158309216: "IFCPILETYPE",
  3079942009: "IFCOPENINGSTANDARDCASE",
  1114901282: "IFCMEDICALDEVICETYPE",
  3113134337: "IFCINTERSECTIONCURVE",
  3946677679: "IFCINTERCEPTORTYPE",
  2571569899: "IFCINDEXEDPOLYCURVE",
  3493046030: "IFCGEOGRAPHICELEMENT",
  1509553395: "IFCFURNITURE",
  1893162501: "IFCFOOTINGTYPE",
  2853485674: "IFCEXTERNALSPATIALSTRUCTUREELEMENT",
  4148101412: "IFCEVENT",
  132023988: "IFCENGINETYPE",
  2397081782: "IFCELEMENTASSEMBLYTYPE",
  2323601079: "IFCDOORTYPE",
  1213902940: "IFCCYLINDRICALSURFACE",
  1525564444: "IFCCONSTRUCTIONPRODUCTRESOURCETYPE",
  4105962743: "IFCCONSTRUCTIONMATERIALRESOURCETYPE",
  2185764099: "IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE",
  15328376: "IFCCOMPOSITECURVEONSURFACE",
  3875453745: "IFCCOMPLEXPROPERTYTEMPLATE",
  3893394355: "IFCCIVILELEMENTTYPE",
  2197970202: "IFCCHIMNEYTYPE",
  167062518: "IFCBSPLINESURFACEWITHKNOTS",
  2887950389: "IFCBSPLINESURFACE",
  2603310189: "IFCADVANCEDBREPWITHVOIDS",
  1635779807: "IFCADVANCEDBREP",
  2916149573: "IFCTRIANGULATEDFACESET",
  1935646853: "IFCTOROIDALSURFACE",
  2387106220: "IFCTESSELLATEDFACESET",
  3206491090: "IFCTASKTYPE",
  699246055: "IFCSURFACECURVE",
  4095615324: "IFCSUBCONTRACTRESOURCETYPE",
  603775116: "IFCSTRUCTURALSURFACEREACTION",
  4015995234: "IFCSPHERICALSURFACE",
  2481509218: "IFCSPATIALZONETYPE",
  463610769: "IFCSPATIALZONE",
  710998568: "IFCSPATIALELEMENTTYPE",
  1412071761: "IFCSPATIALELEMENT",
  3663146110: "IFCSIMPLEPROPERTYTEMPLATE",
  3243963512: "IFCREVOLVEDAREASOLIDTAPERED",
  816062949: "IFCREPARAMETRISEDCOMPOSITECURVESEGMENT",
  1521410863: "IFCRELSPACEBOUNDARY2NDLEVEL",
  3523091289: "IFCRELSPACEBOUNDARY1STLEVEL",
  427948657: "IFCRELINTERFERESELEMENTS",
  307848117: "IFCRELDEFINESBYTEMPLATE",
  1462361463: "IFCRELDEFINESBYOBJECT",
  2565941209: "IFCRELDECLARES",
  1027710054: "IFCRELASSIGNSTOGROUPBYFACTOR",
  3521284610: "IFCPROPERTYTEMPLATE",
  492091185: "IFCPROPERTYSETTEMPLATE",
  653396225: "IFCPROJECTLIBRARY",
  569719735: "IFCPROCEDURETYPE",
  3967405729: "IFCPREDEFINEDPROPERTYSET",
  1682466193: "IFCPCURVE",
  428585644: "IFCLABORRESOURCETYPE",
  2294589976: "IFCINDEXEDPOLYGONALFACEWITHVOIDS",
  178912537: "IFCINDEXEDPOLYGONALFACE",
  4095422895: "IFCGEOGRAPHICELEMENTTYPE",
  2652556860: "IFCFIXEDREFERENCESWEPTAREASOLID",
  2804161546: "IFCEXTRUDEDAREASOLIDTAPERED",
  4024345920: "IFCEVENTTYPE",
  2629017746: "IFCCURVEBOUNDEDSURFACE",
  1815067380: "IFCCREWRESOURCETYPE",
  3419103109: "IFCCONTEXT",
  2574617495: "IFCCONSTRUCTIONRESOURCETYPE",
  2059837836: "IFCCARTESIANPOINTLIST3D",
  1675464909: "IFCCARTESIANPOINTLIST2D",
  574549367: "IFCCARTESIANPOINTLIST",
  3406155212: "IFCADVANCEDFACE",
  3698973494: "IFCTYPERESOURCE",
  3736923433: "IFCTYPEPROCESS",
  901063453: "IFCTESSELLATEDITEM",
  1096409881: "IFCSWEPTDISKSOLIDPOLYGONAL",
  1042787934: "IFCRESOURCETIME",
  1608871552: "IFCRESOURCECONSTRAINTRELATIONSHIP",
  2943643501: "IFCRESOURCEAPPROVALRELATIONSHIP",
  2090586900: "IFCQUANTITYSET",
  1482703590: "IFCPROPERTYTEMPLATEDEFINITION",
  3778827333: "IFCPREDEFINEDPROPERTIES",
  2998442950: "IFCMIRROREDPROFILEDEF",
  853536259: "IFCMATERIALRELATIONSHIP",
  3404854881: "IFCMATERIALPROFILESETUSAGETAPERING",
  3079605661: "IFCMATERIALPROFILESETUSAGE",
  2852063980: "IFCMATERIALCONSTITUENTSET",
  3708119e3: "IFCMATERIALCONSTITUENT",
  1585845231: "IFCLAGTIME",
  2133299955: "IFCINDEXEDTRIANGLETEXTUREMAP",
  1437953363: "IFCINDEXEDTEXTUREMAP",
  3570813810: "IFCINDEXEDCOLOURMAP",
  1437805879: "IFCEXTERNALREFERENCERELATIONSHIP",
  297599258: "IFCEXTENDEDPROPERTIES",
  211053100: "IFCEVENTTIME",
  2713554722: "IFCCONVERSIONBASEDUNITWITHOFFSET",
  3285139300: "IFCCOLOURRGBLIST",
  1236880293: "IFCWORKTIME",
  1199560280: "IFCTIMEPERIOD",
  3611470254: "IFCTEXTUREVERTEXLIST",
  2771591690: "IFCTASKTIMERECURRING",
  1549132990: "IFCTASKTIME",
  2043862942: "IFCTABLECOLUMN",
  2934153892: "IFCSURFACEREINFORCEMENTAREA",
  609421318: "IFCSTRUCTURALLOADORRESULT",
  3478079324: "IFCSTRUCTURALLOADCONFIGURATION",
  1054537805: "IFCSCHEDULINGTIME",
  2439245199: "IFCRESOURCELEVELRELATIONSHIP",
  2433181523: "IFCREFERENCE",
  3915482550: "IFCRECURRENCEPATTERN",
  986844984: "IFCPROPERTYABSTRACTION",
  3843373140: "IFCPROJECTEDCRS",
  677532197: "IFCPRESENTATIONITEM",
  1507914824: "IFCMATERIALUSAGEDEFINITION",
  552965576: "IFCMATERIALPROFILEWITHOFFSETS",
  164193824: "IFCMATERIALPROFILESET",
  2235152071: "IFCMATERIALPROFILE",
  1847252529: "IFCMATERIALLAYERWITHOFFSETS",
  760658860: "IFCMATERIALDEFINITION",
  3057273783: "IFCMAPCONVERSION",
  4294318154: "IFCEXTERNALINFORMATION",
  1466758467: "IFCCOORDINATEREFERENCESYSTEM",
  1785450214: "IFCCOORDINATEOPERATION",
  775493141: "IFCCONNECTIONVOLUMEGEOMETRY",
  979691226: "IFCREINFORCINGBAR",
  3700593921: "IFCELECTRICDISTRIBUTIONPOINT",
  1062813311: "IFCDISTRIBUTIONCONTROLELEMENT",
  1052013943: "IFCDISTRIBUTIONCHAMBERELEMENT",
  578613899: "IFCCONTROLLERTYPE",
  2454782716: "IFCCHAMFEREDGEFEATURE",
  753842376: "IFCBEAM",
  3001207471: "IFCALARMTYPE",
  2874132201: "IFCACTUATORTYPE",
  3304561284: "IFCWINDOW",
  3512223829: "IFCWALLSTANDARDCASE",
  2391406946: "IFCWALL",
  3313531582: "IFCVIBRATIONISOLATORTYPE",
  2347447852: "IFCTENDONANCHOR",
  3824725483: "IFCTENDON",
  2515109513: "IFCSTRUCTURALANALYSISMODEL",
  4252922144: "IFCSTAIRFLIGHT",
  331165859: "IFCSTAIR",
  1529196076: "IFCSLAB",
  1783015770: "IFCSENSORTYPE",
  1376911519: "IFCROUNDEDEDGEFEATURE",
  2016517767: "IFCROOF",
  2320036040: "IFCREINFORCINGMESH",
  3027567501: "IFCREINFORCINGELEMENT",
  3055160366: "IFCRATIONALBEZIERCURVE",
  3283111854: "IFCRAMPFLIGHT",
  3024970846: "IFCRAMP",
  2262370178: "IFCRAILING",
  3171933400: "IFCPLATE",
  1687234759: "IFCPILE",
  1073191201: "IFCMEMBER",
  900683007: "IFCFOOTING",
  3508470533: "IFCFLOWTREATMENTDEVICE",
  2223149337: "IFCFLOWTERMINAL",
  707683696: "IFCFLOWSTORAGEDEVICE",
  987401354: "IFCFLOWSEGMENT",
  3132237377: "IFCFLOWMOVINGDEVICE",
  4037862832: "IFCFLOWINSTRUMENTTYPE",
  4278956645: "IFCFLOWFITTING",
  2058353004: "IFCFLOWCONTROLLER",
  4222183408: "IFCFIRESUPPRESSIONTERMINALTYPE",
  1810631287: "IFCFILTERTYPE",
  346874300: "IFCFANTYPE",
  1658829314: "IFCENERGYCONVERSIONDEVICE",
  857184966: "IFCELECTRICALELEMENT",
  1634875225: "IFCELECTRICALCIRCUIT",
  712377611: "IFCELECTRICTIMECONTROLTYPE",
  1217240411: "IFCELECTRICMOTORTYPE",
  1365060375: "IFCELECTRICHEATERTYPE",
  1534661035: "IFCELECTRICGENERATORTYPE",
  3277789161: "IFCELECTRICFLOWSTORAGEDEVICETYPE",
  663422040: "IFCELECTRICAPPLIANCETYPE",
  855621170: "IFCEDGEFEATURE",
  2030761528: "IFCDUCTSILENCERTYPE",
  3760055223: "IFCDUCTSEGMENTTYPE",
  869906466: "IFCDUCTFITTINGTYPE",
  395920057: "IFCDOOR",
  3041715199: "IFCDISTRIBUTIONPORT",
  3040386961: "IFCDISTRIBUTIONFLOWELEMENT",
  1945004755: "IFCDISTRIBUTIONELEMENT",
  2063403501: "IFCDISTRIBUTIONCONTROLELEMENTTYPE",
  1599208980: "IFCDISTRIBUTIONCHAMBERELEMENTTYPE",
  2635815018: "IFCDISCRETEACCESSORYTYPE",
  1335981549: "IFCDISCRETEACCESSORY",
  4147604152: "IFCDIAMETERDIMENSION",
  3961806047: "IFCDAMPERTYPE",
  3495092785: "IFCCURTAINWALL",
  1973544240: "IFCCOVERING",
  2954562838: "IFCCOOLINGTOWERTYPE",
  335055490: "IFCCOOLEDBEAMTYPE",
  488727124: "IFCCONSTRUCTIONPRODUCTRESOURCE",
  1060000209: "IFCCONSTRUCTIONMATERIALRESOURCE",
  3898045240: "IFCCONSTRUCTIONEQUIPMENTRESOURCE",
  1163958913: "IFCCONDITIONCRITERION",
  2188551683: "IFCCONDITION",
  2816379211: "IFCCONDENSERTYPE",
  3850581409: "IFCCOMPRESSORTYPE",
  843113511: "IFCCOLUMN",
  2301859152: "IFCCOILTYPE",
  2611217952: "IFCCIRCLE",
  2951183804: "IFCCHILLERTYPE",
  1285652485: "IFCCABLESEGMENTTYPE",
  3293546465: "IFCCABLECARRIERSEGMENTTYPE",
  395041908: "IFCCABLECARRIERFITTINGTYPE",
  1909888760: "IFCBUILDINGELEMENTPROXYTYPE",
  1095909175: "IFCBUILDINGELEMENTPROXY",
  2979338954: "IFCBUILDINGELEMENTPART",
  52481810: "IFCBUILDINGELEMENTCOMPONENT",
  3299480353: "IFCBUILDINGELEMENT",
  231477066: "IFCBOILERTYPE",
  1916977116: "IFCBEZIERCURVE",
  819618141: "IFCBEAMTYPE",
  1967976161: "IFCBSPLINECURVE",
  3460190687: "IFCASSET",
  2470393545: "IFCANGULARDIMENSION",
  1871374353: "IFCAIRTOAIRHEATRECOVERYTYPE",
  3352864051: "IFCAIRTERMINALTYPE",
  1411407467: "IFCAIRTERMINALBOXTYPE",
  3821786052: "IFCACTIONREQUEST",
  1213861670: "IFC2DCOMPOSITECURVE",
  1033361043: "IFCZONE",
  3342526732: "IFCWORKSCHEDULE",
  4218914973: "IFCWORKPLAN",
  1028945134: "IFCWORKCONTROL",
  1133259667: "IFCWASTETERMINALTYPE",
  1898987631: "IFCWALLTYPE",
  2769231204: "IFCVIRTUALELEMENT",
  728799441: "IFCVALVETYPE",
  1911125066: "IFCUNITARYEQUIPMENTTYPE",
  1600972822: "IFCTUBEBUNDLETYPE",
  3593883385: "IFCTRIMMEDCURVE",
  1620046519: "IFCTRANSPORTELEMENT",
  1692211062: "IFCTRANSFORMERTYPE",
  1637806684: "IFCTIMESERIESSCHEDULE",
  5716631: "IFCTANKTYPE",
  2254336722: "IFCSYSTEM",
  2315554128: "IFCSWITCHINGDEVICETYPE",
  148013059: "IFCSUBCONTRACTRESOURCE",
  1975003073: "IFCSTRUCTURALSURFACECONNECTION",
  2986769608: "IFCSTRUCTURALRESULTGROUP",
  1235345126: "IFCSTRUCTURALPOINTREACTION",
  734778138: "IFCSTRUCTURALPOINTCONNECTION",
  2082059205: "IFCSTRUCTURALPOINTACTION",
  3987759626: "IFCSTRUCTURALPLANARACTIONVARYING",
  1621171031: "IFCSTRUCTURALPLANARACTION",
  1252848954: "IFCSTRUCTURALLOADGROUP",
  1721250024: "IFCSTRUCTURALLINEARACTIONVARYING",
  1807405624: "IFCSTRUCTURALLINEARACTION",
  2445595289: "IFCSTRUCTURALCURVEMEMBERVARYING",
  214636428: "IFCSTRUCTURALCURVEMEMBER",
  4243806635: "IFCSTRUCTURALCURVECONNECTION",
  1179482911: "IFCSTRUCTURALCONNECTION",
  682877961: "IFCSTRUCTURALACTION",
  1039846685: "IFCSTAIRFLIGHTTYPE",
  3112655638: "IFCSTACKTERMINALTYPE",
  3812236995: "IFCSPACETYPE",
  652456506: "IFCSPACEPROGRAM",
  1305183839: "IFCSPACEHEATERTYPE",
  3856911033: "IFCSPACE",
  2533589738: "IFCSLABTYPE",
  4097777520: "IFCSITE",
  4105383287: "IFCSERVICELIFE",
  3517283431: "IFCSCHEDULETIMECONTROL",
  1768891740: "IFCSANITARYTERMINALTYPE",
  2863920197: "IFCRELASSIGNSTASKS",
  160246688: "IFCRELAGGREGATES",
  2324767716: "IFCRAMPFLIGHTTYPE",
  2893384427: "IFCRAILINGTYPE",
  3248260540: "IFCRADIUSDIMENSION",
  2250791053: "IFCPUMPTYPE",
  1842657554: "IFCPROTECTIVEDEVICETYPE",
  3651124850: "IFCPROJECTIONELEMENT",
  3642467123: "IFCPROJECTORDERRECORD",
  2904328755: "IFCPROJECTORDER",
  2744685151: "IFCPROCEDURE",
  3740093272: "IFCPORT",
  3724593414: "IFCPOLYLINE",
  4017108033: "IFCPLATETYPE",
  4231323485: "IFCPIPESEGMENTTYPE",
  804291784: "IFCPIPEFITTINGTYPE",
  3327091369: "IFCPERMIT",
  2382730787: "IFCPERFORMANCEHISTORY",
  2837617999: "IFCOUTLETTYPE",
  3425660407: "IFCORDERACTION",
  3588315303: "IFCOPENINGELEMENT",
  4143007308: "IFCOCCUPANT",
  1916936684: "IFCMOVE",
  977012517: "IFCMOTORCONNECTIONTYPE",
  3181161470: "IFCMEMBERTYPE",
  2108223431: "IFCMECHANICALFASTENERTYPE",
  377706215: "IFCMECHANICALFASTENER",
  2506943328: "IFCLINEARDIMENSION",
  1161773419: "IFCLIGHTFIXTURETYPE",
  1051575348: "IFCLAMPTYPE",
  3827777499: "IFCLABORRESOURCE",
  4288270099: "IFCJUNCTIONBOXTYPE",
  2391368822: "IFCINVENTORY",
  1806887404: "IFCHUMIDIFIERTYPE",
  1251058090: "IFCHEATEXCHANGERTYPE",
  2706460486: "IFCGROUP",
  3009204131: "IFCGRID",
  200128114: "IFCGASTERMINALTYPE",
  814719939: "IFCFURNITURESTANDARD",
  263784265: "IFCFURNISHINGELEMENT",
  3009222698: "IFCFLOWTREATMENTDEVICETYPE",
  2297155007: "IFCFLOWTERMINALTYPE",
  1339347760: "IFCFLOWSTORAGEDEVICETYPE",
  1834744321: "IFCFLOWSEGMENTTYPE",
  1482959167: "IFCFLOWMOVINGDEVICETYPE",
  3815607619: "IFCFLOWMETERTYPE",
  3198132628: "IFCFLOWFITTINGTYPE",
  3907093117: "IFCFLOWCONTROLLERTYPE",
  1287392070: "IFCFEATUREELEMENTSUBTRACTION",
  2143335405: "IFCFEATUREELEMENTADDITION",
  2827207264: "IFCFEATUREELEMENT",
  2489546625: "IFCFASTENERTYPE",
  647756555: "IFCFASTENER",
  3737207727: "IFCFACETEDBREPWITHVOIDS",
  807026263: "IFCFACETEDBREP",
  3390157468: "IFCEVAPORATORTYPE",
  3174744832: "IFCEVAPORATIVECOOLERTYPE",
  3272907226: "IFCEQUIPMENTSTANDARD",
  1962604670: "IFCEQUIPMENTELEMENT",
  2107101300: "IFCENERGYCONVERSIONDEVICETYPE",
  1704287377: "IFCELLIPSE",
  2590856083: "IFCELEMENTCOMPONENTTYPE",
  1623761950: "IFCELEMENTCOMPONENT",
  4123344466: "IFCELEMENTASSEMBLY",
  1758889154: "IFCELEMENT",
  360485395: "IFCELECTRICALBASEPROPERTIES",
  3849074793: "IFCDISTRIBUTIONFLOWELEMENTTYPE",
  3256556792: "IFCDISTRIBUTIONELEMENTTYPE",
  681481545: "IFCDIMENSIONCURVEDIRECTEDCALLOUT",
  1457835157: "IFCCURTAINWALLTYPE",
  3295246426: "IFCCREWRESOURCE",
  1916426348: "IFCCOVERINGTYPE",
  1419761937: "IFCCOSTSCHEDULE",
  3895139033: "IFCCOSTITEM",
  3293443760: "IFCCONTROL",
  2559216714: "IFCCONSTRUCTIONRESOURCE",
  2510884976: "IFCCONIC",
  3732776249: "IFCCOMPOSITECURVE",
  300633059: "IFCCOLUMNTYPE",
  2937912522: "IFCCIRCLEHOLLOWPROFILEDEF",
  3124254112: "IFCBUILDINGSTOREY",
  1950629157: "IFCBUILDINGELEMENTTYPE",
  4031249490: "IFCBUILDING",
  1260505505: "IFCBOUNDEDCURVE",
  3649129432: "IFCBOOLEANCLIPPINGRESULT",
  1334484129: "IFCBLOCK",
  3207858831: "IFCASYMMETRICISHAPEPROFILEDEF",
  1674181508: "IFCANNOTATION",
  2296667514: "IFCACTOR",
  2097647324: "IFCTRANSPORTELEMENTTYPE",
  3473067441: "IFCTASK",
  1580310250: "IFCSYSTEMFURNITUREELEMENTTYPE",
  4124788165: "IFCSURFACEOFREVOLUTION",
  2809605785: "IFCSURFACEOFLINEAREXTRUSION",
  2028607225: "IFCSURFACECURVESWEPTAREASOLID",
  4070609034: "IFCSTRUCTUREDDIMENSIONCALLOUT",
  2218152070: "IFCSTRUCTURALSURFACEMEMBERVARYING",
  3979015343: "IFCSTRUCTURALSURFACEMEMBER",
  3689010777: "IFCSTRUCTURALREACTION",
  530289379: "IFCSTRUCTURALMEMBER",
  3136571912: "IFCSTRUCTURALITEM",
  3544373492: "IFCSTRUCTURALACTIVITY",
  451544542: "IFCSPHERE",
  3893378262: "IFCSPATIALSTRUCTUREELEMENTTYPE",
  2706606064: "IFCSPATIALSTRUCTUREELEMENT",
  3626867408: "IFCRIGHTCIRCULARCYLINDER",
  4158566097: "IFCRIGHTCIRCULARCONE",
  1856042241: "IFCREVOLVEDAREASOLID",
  2914609552: "IFCRESOURCE",
  1401173127: "IFCRELVOIDSELEMENT",
  3451746338: "IFCRELSPACEBOUNDARY",
  366585022: "IFCRELSERVICESBUILDINGS",
  4122056220: "IFCRELSEQUENCE",
  1058617721: "IFCRELSCHEDULESCOSTITEMS",
  1245217292: "IFCRELREFERENCEDINSPATIALSTRUCTURE",
  750771296: "IFCRELPROJECTSELEMENT",
  202636808: "IFCRELOVERRIDESPROPERTIES",
  2051452291: "IFCRELOCCUPIESSPACES",
  3268803585: "IFCRELNESTS",
  4189434867: "IFCRELINTERACTIONREQUIREMENTS",
  279856033: "IFCRELFLOWCONTROLELEMENTS",
  3940055652: "IFCRELFILLSELEMENT",
  781010003: "IFCRELDEFINESBYTYPE",
  4186316022: "IFCRELDEFINESBYPROPERTIES",
  693640335: "IFCRELDEFINES",
  2551354335: "IFCRELDECOMPOSES",
  2802773753: "IFCRELCOVERSSPACES",
  886880790: "IFCRELCOVERSBLDGELEMENTS",
  3242617779: "IFCRELCONTAINEDINSPATIALSTRUCTURE",
  3678494232: "IFCRELCONNECTSWITHREALIZINGELEMENTS",
  504942748: "IFCRELCONNECTSWITHECCENTRICITY",
  1638771189: "IFCRELCONNECTSSTRUCTURALMEMBER",
  3912681535: "IFCRELCONNECTSSTRUCTURALELEMENT",
  2127690289: "IFCRELCONNECTSSTRUCTURALACTIVITY",
  3190031847: "IFCRELCONNECTSPORTS",
  4201705270: "IFCRELCONNECTSPORTTOELEMENT",
  3945020480: "IFCRELCONNECTSPATHELEMENTS",
  1204542856: "IFCRELCONNECTSELEMENTS",
  826625072: "IFCRELCONNECTS",
  2851387026: "IFCRELASSOCIATESPROFILEPROPERTIES",
  2655215786: "IFCRELASSOCIATESMATERIAL",
  3840914261: "IFCRELASSOCIATESLIBRARY",
  982818633: "IFCRELASSOCIATESDOCUMENT",
  2728634034: "IFCRELASSOCIATESCONSTRAINT",
  919958153: "IFCRELASSOCIATESCLASSIFICATION",
  4095574036: "IFCRELASSOCIATESAPPROVAL",
  1327628568: "IFCRELASSOCIATESAPPLIEDVALUE",
  1865459582: "IFCRELASSOCIATES",
  205026976: "IFCRELASSIGNSTORESOURCE",
  3372526763: "IFCRELASSIGNSTOPROJECTORDER",
  2857406711: "IFCRELASSIGNSTOPRODUCT",
  4278684876: "IFCRELASSIGNSTOPROCESS",
  1307041759: "IFCRELASSIGNSTOGROUP",
  2495723537: "IFCRELASSIGNSTOCONTROL",
  1683148259: "IFCRELASSIGNSTOACTOR",
  3939117080: "IFCRELASSIGNS",
  3454111270: "IFCRECTANGULARTRIMMEDSURFACE",
  2798486643: "IFCRECTANGULARPYRAMID",
  2770003689: "IFCRECTANGLEHOLLOWPROFILEDEF",
  3219374653: "IFCPROXY",
  1451395588: "IFCPROPERTYSET",
  4194566429: "IFCPROJECTIONCURVE",
  103090709: "IFCPROJECT",
  4208778838: "IFCPRODUCT",
  2945172077: "IFCPROCESS",
  220341763: "IFCPLANE",
  603570806: "IFCPLANARBOX",
  3566463478: "IFCPERMEABLECOVERINGPROPERTIES",
  3505215534: "IFCOFFSETCURVE3D",
  3388369263: "IFCOFFSETCURVE2D",
  3888040117: "IFCOBJECT",
  1425443689: "IFCMANIFOLDSOLIDBREP",
  1281925730: "IFCLINE",
  572779678: "IFCLSHAPEPROFILEDEF",
  1484403080: "IFCISHAPEPROFILEDEF",
  987898635: "IFCGEOMETRICCURVESET",
  1268542332: "IFCFURNITURETYPE",
  4238390223: "IFCFURNISHINGELEMENTTYPE",
  3455213021: "IFCFLUIDFLOWPROPERTIES",
  315944413: "IFCFILLAREASTYLETILES",
  4203026998: "IFCFILLAREASTYLETILESYMBOLWITHSTYLE",
  374418227: "IFCFILLAREASTYLEHATCHING",
  2047409740: "IFCFACEBASEDSURFACEMODEL",
  477187591: "IFCEXTRUDEDAREASOLID",
  80994333: "IFCENERGYPROPERTIES",
  2835456948: "IFCELLIPSEPROFILEDEF",
  2777663545: "IFCELEMENTARYSURFACE",
  339256511: "IFCELEMENTTYPE",
  1883228015: "IFCELEMENTQUANTITY",
  1472233963: "IFCEDGELOOP",
  4006246654: "IFCDRAUGHTINGPREDEFINEDCURVEFONT",
  445594917: "IFCDRAUGHTINGPREDEFINEDCOLOUR",
  3073041342: "IFCDRAUGHTINGCALLOUT",
  526551008: "IFCDOORSTYLE",
  1714330368: "IFCDOORPANELPROPERTIES",
  2963535650: "IFCDOORLININGPROPERTIES",
  32440307: "IFCDIRECTION",
  4054601972: "IFCDIMENSIONCURVETERMINATOR",
  606661476: "IFCDIMENSIONCURVE",
  693772133: "IFCDEFINEDSYMBOL",
  2827736869: "IFCCURVEBOUNDEDPLANE",
  2601014836: "IFCCURVE",
  2147822146: "IFCCSGSOLID",
  2506170314: "IFCCSGPRIMITIVE3D",
  194851669: "IFCCRANERAILFSHAPEPROFILEDEF",
  4133800736: "IFCCRANERAILASHAPEPROFILEDEF",
  2485617015: "IFCCOMPOSITECURVESEGMENT",
  2205249479: "IFCCLOSEDSHELL",
  1383045692: "IFCCIRCLEPROFILEDEF",
  1416205885: "IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM",
  3331915920: "IFCCARTESIANTRANSFORMATIONOPERATOR3D",
  3486308946: "IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM",
  3749851601: "IFCCARTESIANTRANSFORMATIONOPERATOR2D",
  59481748: "IFCCARTESIANTRANSFORMATIONOPERATOR",
  1123145078: "IFCCARTESIANPOINT",
  2898889636: "IFCCSHAPEPROFILEDEF",
  2713105998: "IFCBOXEDHALFSPACE",
  2581212453: "IFCBOUNDINGBOX",
  4182860854: "IFCBOUNDEDSURFACE",
  2736907675: "IFCBOOLEANRESULT",
  2740243338: "IFCAXIS2PLACEMENT3D",
  3125803723: "IFCAXIS2PLACEMENT2D",
  4261334040: "IFCAXIS1PLACEMENT",
  1302238472: "IFCANNOTATIONSURFACE",
  2265737646: "IFCANNOTATIONFILLAREAOCCURRENCE",
  669184980: "IFCANNOTATIONFILLAREA",
  3288037868: "IFCANNOTATIONCURVEOCCURRENCE",
  2543172580: "IFCZSHAPEPROFILEDEF",
  1299126871: "IFCWINDOWSTYLE",
  512836454: "IFCWINDOWPANELPROPERTIES",
  336235671: "IFCWINDOWLININGPROPERTIES",
  2759199220: "IFCVERTEXLOOP",
  1417489154: "IFCVECTOR",
  427810014: "IFCUSHAPEPROFILEDEF",
  2347495698: "IFCTYPEPRODUCT",
  1628702193: "IFCTYPEOBJECT",
  1345879162: "IFCTWODIRECTIONREPEATFACTOR",
  2715220739: "IFCTRAPEZIUMPROFILEDEF",
  3124975700: "IFCTEXTLITERALWITHEXTENT",
  4282788508: "IFCTEXTLITERAL",
  3028897424: "IFCTERMINATORSYMBOL",
  3071757647: "IFCTSHAPEPROFILEDEF",
  230924584: "IFCSWEPTSURFACE",
  1260650574: "IFCSWEPTDISKSOLID",
  2247615214: "IFCSWEPTAREASOLID",
  1878645084: "IFCSURFACESTYLERENDERING",
  2513912981: "IFCSURFACE",
  2233826070: "IFCSUBEDGE",
  3653947884: "IFCSTRUCTURALSTEELPROFILEPROPERTIES",
  3843319758: "IFCSTRUCTURALPROFILEPROPERTIES",
  1190533807: "IFCSTRUCTURALLOADSINGLEFORCEWARPING",
  1597423693: "IFCSTRUCTURALLOADSINGLEFORCE",
  1973038258: "IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION",
  2473145415: "IFCSTRUCTURALLOADSINGLEDISPLACEMENT",
  2668620305: "IFCSTRUCTURALLOADPLANARFORCE",
  1595516126: "IFCSTRUCTURALLOADLINEARFORCE",
  390701378: "IFCSPACETHERMALLOADPROPERTIES",
  1202362311: "IFCSOUNDVALUE",
  2485662743: "IFCSOUNDPROPERTIES",
  723233188: "IFCSOLIDMODEL",
  2609359061: "IFCSLIPPAGECONNECTIONCONDITION",
  4124623270: "IFCSHELLBASEDSURFACEMODEL",
  2411513650: "IFCSERVICELIFEFACTOR",
  1509187699: "IFCSECTIONEDSPINE",
  2778083089: "IFCROUNDEDRECTANGLEPROFILEDEF",
  478536968: "IFCRELATIONSHIP",
  3765753017: "IFCREINFORCEMENTDEFINITIONPROPERTIES",
  3413951693: "IFCREGULARTIMESERIES",
  3615266464: "IFCRECTANGLEPROFILEDEF",
  110355661: "IFCPROPERTYTABLEVALUE",
  3650150729: "IFCPROPERTYSINGLEVALUE",
  3357820518: "IFCPROPERTYSETDEFINITION",
  941946838: "IFCPROPERTYREFERENCEVALUE",
  2752243245: "IFCPROPERTYLISTVALUE",
  4166981789: "IFCPROPERTYENUMERATEDVALUE",
  1680319473: "IFCPROPERTYDEFINITION",
  871118103: "IFCPROPERTYBOUNDEDVALUE",
  673634403: "IFCPRODUCTDEFINITIONSHAPE",
  179317114: "IFCPREDEFINEDPOINTMARKERSYMBOL",
  433424934: "IFCPREDEFINEDDIMENSIONSYMBOL",
  2559016684: "IFCPREDEFINEDCURVEFONT",
  759155922: "IFCPREDEFINEDCOLOUR",
  2775532180: "IFCPOLYGONALBOUNDEDHALFSPACE",
  2924175390: "IFCPOLYLOOP",
  1423911732: "IFCPOINTONSURFACE",
  4022376103: "IFCPOINTONCURVE",
  2067069095: "IFCPOINT",
  1663979128: "IFCPLANAREXTENT",
  2004835150: "IFCPLACEMENT",
  597895409: "IFCPIXELTEXTURE",
  3021840470: "IFCPHYSICALCOMPLEXQUANTITY",
  2519244187: "IFCPATH",
  2529465313: "IFCPARAMETERIZEDPROFILEDEF",
  1029017970: "IFCORIENTEDEDGE",
  2665983363: "IFCOPENSHELL",
  2833995503: "IFCONEDIRECTIONREPEATFACTOR",
  219451334: "IFCOBJECTDEFINITION",
  1430189142: "IFCMECHANICALCONCRETEMATERIALPROPERTIES",
  2022407955: "IFCMATERIALDEFINITIONREPRESENTATION",
  2347385850: "IFCMAPPEDITEM",
  1008929658: "IFCLOOP",
  2624227202: "IFCLOCALPLACEMENT",
  3422422726: "IFCLIGHTSOURCESPOT",
  1520743889: "IFCLIGHTSOURCEPOSITIONAL",
  4266656042: "IFCLIGHTSOURCEGONIOMETRIC",
  2604431987: "IFCLIGHTSOURCEDIRECTIONAL",
  125510826: "IFCLIGHTSOURCEAMBIENT",
  1402838566: "IFCLIGHTSOURCE",
  3741457305: "IFCIRREGULARTIMESERIES",
  3905492369: "IFCIMAGETEXTURE",
  2445078500: "IFCHYGROSCOPICMATERIALPROPERTIES",
  812098782: "IFCHALFSPACESOLID",
  178086475: "IFCGRIDPLACEMENT",
  3590301190: "IFCGEOMETRICSET",
  4142052618: "IFCGEOMETRICREPRESENTATIONSUBCONTEXT",
  2453401579: "IFCGEOMETRICREPRESENTATIONITEM",
  3448662350: "IFCGEOMETRICREPRESENTATIONCONTEXT",
  1446786286: "IFCGENERALPROFILEPROPERTIES",
  803998398: "IFCGENERALMATERIALPROPERTIES",
  3857492461: "IFCFUELPROPERTIES",
  738692330: "IFCFILLAREASTYLE",
  4219587988: "IFCFAILURECONNECTIONCONDITION",
  3008276851: "IFCFACESURFACE",
  803316827: "IFCFACEOUTERBOUND",
  1809719519: "IFCFACEBOUND",
  2556980723: "IFCFACE",
  1860660968: "IFCEXTENDEDMATERIALPROPERTIES",
  476780140: "IFCEDGECURVE",
  3900360178: "IFCEDGE",
  4170525392: "IFCDRAUGHTINGPREDEFINEDTEXTFONT",
  3732053477: "IFCDOCUMENTREFERENCE",
  1694125774: "IFCDIMENSIONPAIR",
  2273265877: "IFCDIMENSIONCALLOUTRELATIONSHIP",
  3632507154: "IFCDERIVEDPROFILEDEF",
  3800577675: "IFCCURVESTYLE",
  2889183280: "IFCCONVERSIONBASEDUNIT",
  3050246964: "IFCCONTEXTDEPENDENTUNIT",
  45288368: "IFCCONNECTIONPOINTECCENTRICITY",
  1981873012: "IFCCONNECTIONCURVEGEOMETRY",
  370225590: "IFCCONNECTEDFACESET",
  1485152156: "IFCCOMPOSITEPROFILEDEF",
  2542286263: "IFCCOMPLEXPROPERTY",
  776857604: "IFCCOLOURRGB",
  647927063: "IFCCLASSIFICATIONREFERENCE",
  3150382593: "IFCCENTERLINEPROFILEDEF",
  616511568: "IFCBLOBTEXTURE",
  2705031697: "IFCARBITRARYPROFILEDEFWITHVOIDS",
  1310608509: "IFCARBITRARYOPENPROFILEDEF",
  3798115385: "IFCARBITRARYCLOSEDPROFILEDEF",
  2297822566: "IFCANNOTATIONTEXTOCCURRENCE",
  3612888222: "IFCANNOTATIONSYMBOLOCCURRENCE",
  962685235: "IFCANNOTATIONSURFACEOCCURRENCE",
  2442683028: "IFCANNOTATIONOCCURRENCE",
  1065908215: "IFCWATERPROPERTIES",
  891718957: "IFCVIRTUALGRIDINTERSECTION",
  1907098498: "IFCVERTEXPOINT",
  3304826586: "IFCVERTEXBASEDTEXTUREMAP",
  2799835756: "IFCVERTEX",
  180925521: "IFCUNITASSIGNMENT",
  1735638870: "IFCTOPOLOGYREPRESENTATION",
  1377556343: "IFCTOPOLOGICALREPRESENTATIONITEM",
  581633288: "IFCTIMESERIESVALUE",
  1718945513: "IFCTIMESERIESREFERENCERELATIONSHIP",
  3101149627: "IFCTIMESERIES",
  3317419933: "IFCTHERMALMATERIALPROPERTIES",
  1210645708: "IFCTEXTUREVERTEX",
  2552916305: "IFCTEXTUREMAP",
  1742049831: "IFCTEXTURECOORDINATEGENERATOR",
  280115917: "IFCTEXTURECOORDINATE",
  1484833681: "IFCTEXTSTYLEWITHBOXCHARACTERISTICS",
  1640371178: "IFCTEXTSTYLETEXTMODEL",
  2636378356: "IFCTEXTSTYLEFORDEFINEDFONT",
  1983826977: "IFCTEXTSTYLEFONTMODEL",
  1447204868: "IFCTEXTSTYLE",
  912023232: "IFCTELECOMADDRESS",
  531007025: "IFCTABLEROW",
  985171141: "IFCTABLE",
  1290481447: "IFCSYMBOLSTYLE",
  626085974: "IFCSURFACETEXTURE",
  1351298697: "IFCSURFACESTYLEWITHTEXTURES",
  846575682: "IFCSURFACESTYLESHADING",
  1607154358: "IFCSURFACESTYLEREFRACTION",
  3303107099: "IFCSURFACESTYLELIGHTING",
  1300840506: "IFCSURFACESTYLE",
  3049322572: "IFCSTYLEDREPRESENTATION",
  3958052878: "IFCSTYLEDITEM",
  2830218821: "IFCSTYLEMODEL",
  3408363356: "IFCSTRUCTURALLOADTEMPERATURE",
  2525727697: "IFCSTRUCTURALLOADSTATIC",
  2162789131: "IFCSTRUCTURALLOAD",
  2273995522: "IFCSTRUCTURALCONNECTIONCONDITION",
  3692461612: "IFCSIMPLEPROPERTY",
  4240577450: "IFCSHAPEREPRESENTATION",
  3982875396: "IFCSHAPEMODEL",
  867548509: "IFCSHAPEASPECT",
  4165799628: "IFCSECTIONREINFORCEMENTPROPERTIES",
  2042790032: "IFCSECTIONPROPERTIES",
  448429030: "IFCSIUNIT",
  2341007311: "IFCROOT",
  3679540991: "IFCRIBPLATEPROFILEPROPERTIES",
  1660063152: "IFCREPRESENTATIONMAP",
  3008791417: "IFCREPRESENTATIONITEM",
  3377609919: "IFCREPRESENTATIONCONTEXT",
  1076942058: "IFCREPRESENTATION",
  1222501353: "IFCRELAXATION",
  1580146022: "IFCREINFORCEMENTBARPROPERTIES",
  2692823254: "IFCREFERENCESVALUEDOCUMENT",
  825690147: "IFCQUANTITYWEIGHT",
  2405470396: "IFCQUANTITYVOLUME",
  3252649465: "IFCQUANTITYTIME",
  931644368: "IFCQUANTITYLENGTH",
  2093928680: "IFCQUANTITYCOUNT",
  2044713172: "IFCQUANTITYAREA",
  3710013099: "IFCPROPERTYENUMERATION",
  148025276: "IFCPROPERTYDEPENDENCYRELATIONSHIP",
  3896028662: "IFCPROPERTYCONSTRAINTRELATIONSHIP",
  2598011224: "IFCPROPERTY",
  2802850158: "IFCPROFILEPROPERTIES",
  3958567839: "IFCPROFILEDEF",
  2267347899: "IFCPRODUCTSOFCOMBUSTIONPROPERTIES",
  2095639259: "IFCPRODUCTREPRESENTATION",
  2417041796: "IFCPRESENTATIONSTYLEASSIGNMENT",
  3119450353: "IFCPRESENTATIONSTYLE",
  1304840413: "IFCPRESENTATIONLAYERWITHSTYLE",
  2022622350: "IFCPRESENTATIONLAYERASSIGNMENT",
  1775413392: "IFCPREDEFINEDTEXTFONT",
  3213052703: "IFCPREDEFINEDTERMINATORSYMBOL",
  990879717: "IFCPREDEFINEDSYMBOL",
  3727388367: "IFCPREDEFINEDITEM",
  3355820592: "IFCPOSTALADDRESS",
  2226359599: "IFCPHYSICALSIMPLEQUANTITY",
  2483315170: "IFCPHYSICALQUANTITY",
  101040310: "IFCPERSONANDORGANIZATION",
  2077209135: "IFCPERSON",
  1207048766: "IFCOWNERHISTORY",
  1411181986: "IFCORGANIZATIONRELATIONSHIP",
  4251960020: "IFCORGANIZATION",
  1227763645: "IFCOPTICALMATERIALPROPERTIES",
  2251480897: "IFCOBJECTIVE",
  3701648758: "IFCOBJECTPLACEMENT",
  1918398963: "IFCNAMEDUNIT",
  2706619895: "IFCMONETARYUNIT",
  3368373690: "IFCMETRIC",
  677618848: "IFCMECHANICALSTEELMATERIALPROPERTIES",
  4256014907: "IFCMECHANICALMATERIALPROPERTIES",
  2597039031: "IFCMEASUREWITHUNIT",
  3265635763: "IFCMATERIALPROPERTIES",
  2199411900: "IFCMATERIALLIST",
  1303795690: "IFCMATERIALLAYERSETUSAGE",
  3303938423: "IFCMATERIALLAYERSET",
  248100487: "IFCMATERIALLAYER",
  1847130766: "IFCMATERIALCLASSIFICATIONRELATIONSHIP",
  1838606355: "IFCMATERIAL",
  30780891: "IFCLOCALTIME",
  1566485204: "IFCLIGHTINTENSITYDISTRIBUTION",
  4162380809: "IFCLIGHTDISTRIBUTIONDATA",
  3452421091: "IFCLIBRARYREFERENCE",
  2655187982: "IFCLIBRARYINFORMATION",
  3020489413: "IFCIRREGULARTIMESERIESVALUE",
  852622518: "IFCGRIDAXIS",
  3548104201: "IFCEXTERNALLYDEFINEDTEXTFONT",
  3207319532: "IFCEXTERNALLYDEFINEDSYMBOL",
  1040185647: "IFCEXTERNALLYDEFINEDSURFACESTYLE",
  2242383968: "IFCEXTERNALLYDEFINEDHATCHSTYLE",
  3200245327: "IFCEXTERNALREFERENCE",
  1648886627: "IFCENVIRONMENTALIMPACTVALUE",
  3796139169: "IFCDRAUGHTINGCALLOUTRELATIONSHIP",
  770865208: "IFCDOCUMENTINFORMATIONRELATIONSHIP",
  1154170062: "IFCDOCUMENTINFORMATION",
  1376555844: "IFCDOCUMENTELECTRONICFORMAT",
  2949456006: "IFCDIMENSIONALEXPONENTS",
  1045800335: "IFCDERIVEDUNITELEMENT",
  1765591967: "IFCDERIVEDUNIT",
  1072939445: "IFCDATEANDTIME",
  3510044353: "IFCCURVESTYLEFONTPATTERN",
  2367409068: "IFCCURVESTYLEFONTANDSCALING",
  1105321065: "IFCCURVESTYLEFONT",
  539742890: "IFCCURRENCYRELATIONSHIP",
  602808272: "IFCCOSTVALUE",
  1065062679: "IFCCOORDINATEDUNIVERSALTIMEOFFSET",
  347226245: "IFCCONSTRAINTRELATIONSHIP",
  613356794: "IFCCONSTRAINTCLASSIFICATIONRELATIONSHIP",
  1658513725: "IFCCONSTRAINTAGGREGATIONRELATIONSHIP",
  1959218052: "IFCCONSTRAINT",
  2732653382: "IFCCONNECTIONSURFACEGEOMETRY",
  4257277454: "IFCCONNECTIONPORTGEOMETRY",
  2614616156: "IFCCONNECTIONPOINTGEOMETRY",
  2859738748: "IFCCONNECTIONGEOMETRY",
  3264961684: "IFCCOLOURSPECIFICATION",
  3639012971: "IFCCLASSIFICATIONNOTATIONFACET",
  938368621: "IFCCLASSIFICATIONNOTATION",
  1098599126: "IFCCLASSIFICATIONITEMRELATIONSHIP",
  1767535486: "IFCCLASSIFICATIONITEM",
  747523909: "IFCCLASSIFICATION",
  622194075: "IFCCALENDARDATE",
  2069777674: "IFCBOUNDARYNODECONDITIONWARPING",
  1387855156: "IFCBOUNDARYNODECONDITION",
  3367102660: "IFCBOUNDARYFACECONDITION",
  1560379544: "IFCBOUNDARYEDGECONDITION",
  4037036970: "IFCBOUNDARYCONDITION",
  3869604511: "IFCAPPROVALRELATIONSHIP",
  390851274: "IFCAPPROVALPROPERTYRELATIONSHIP",
  2080292479: "IFCAPPROVALACTORRELATIONSHIP",
  130549933: "IFCAPPROVAL",
  1110488051: "IFCAPPLIEDVALUERELATIONSHIP",
  411424972: "IFCAPPLIEDVALUE",
  639542469: "IFCAPPLICATION",
  618182010: "IFCADDRESS",
  3630933823: "IFCACTORROLE",
  599546466: "FILE_DESCRIPTION",
  1390159747: "FILE_NAME",
  1109904537: "FILE_SCHEMA"
};
var IfcPropertiesUtils = class _IfcPropertiesUtils {
  static async getUnits(group) {
    var _a, _b, _c;
    const { IFCUNITASSIGNMENT: IFCUNITASSIGNMENT2 } = web_ifc_api_exports;
    const allUnitsSets = await group.getAllPropertiesOfType(IFCUNITASSIGNMENT2);
    if (!allUnitsSets) {
      return 1;
    }
    const unitIDs = Object.keys(allUnitsSets);
    const allUnits = allUnitsSets[parseInt(unitIDs[0], 10)];
    for (const unitRef of allUnits.Units) {
      if (unitRef.value === void 0 || unitRef.value === null)
        continue;
      const unit = await group.getProperties(unitRef.value);
      if (!unit || !unit.UnitType || !unit.UnitType.value) {
        continue;
      }
      const value = unit.UnitType.value;
      if (value !== "LENGTHUNIT")
        continue;
      let factor = 1;
      let unitValue = 1;
      if (unit.Name.value === "METRE") {
        unitValue = 1;
      }
      if (unit.Name.value === "FOOT") {
        unitValue = 0.3048;
      }
      if (((_a = unit.Prefix) == null ? void 0 : _a.value) === "MILLI") {
        factor = 1e-3;
      } else if (((_b = unit.Prefix) == null ? void 0 : _b.value) === "CENTI") {
        factor = 0.01;
      } else if (((_c = unit.Prefix) == null ? void 0 : _c.value) === "DECI") {
        factor = 0.1;
      }
      return unitValue * factor;
    }
    return 1;
  }
  static async findItemByGuid(model, guid) {
    var _a;
    const ids = model.getAllPropertiesIDs();
    for (const id of ids) {
      const property = await model.getProperties(id);
      if (property && ((_a = property.GlobalId) == null ? void 0 : _a.value) === guid) {
        return property;
      }
    }
    return null;
  }
  static async getRelationMap(model, relationType, onElementsFound) {
    var _a;
    const defaultCallback = async () => {
    };
    const _onElementsFound = onElementsFound ?? defaultCallback;
    const result = {};
    const ids = model.getAllPropertiesIDs();
    for (const expressID of ids) {
      const prop = await model.getProperties(expressID);
      if (!prop) {
        continue;
      }
      const isRelation = prop.type === relationType;
      const relatingKey = Object.keys(prop).find(
        (key) => key.startsWith("Relating")
      );
      const relatedKey = Object.keys(prop).find(
        (key) => key.startsWith("Related")
      );
      if (!(isRelation && relatingKey && relatedKey))
        continue;
      const relating = await model.getProperties((_a = prop[relatingKey]) == null ? void 0 : _a.value);
      const related = prop[relatedKey];
      if (!relating || !related) {
        continue;
      }
      if (!(related && Array.isArray(related)))
        continue;
      const elements = related.map((el) => {
        return el.value;
      });
      await _onElementsFound(relating.expressID, elements);
      result[relating.expressID] = elements;
    }
    return result;
  }
  static async getQsetQuantities(model, expressID, onQuantityFound) {
    const defaultCallback = () => {
    };
    const _onQuantityFound = onQuantityFound ?? defaultCallback;
    const pset = await model.getProperties(expressID);
    if (!pset || pset.type !== IFCELEMENTQUANTITY) {
      return null;
    }
    const quantities = pset.Quantities ?? [{}];
    const qtos = quantities.map((prop) => {
      if (prop.value)
        _onQuantityFound(prop.value);
      return prop.value;
    });
    return qtos.filter((prop) => prop !== null);
  }
  static async getPsetProps(model, expressID, onPropFound) {
    const defaultCallback = () => {
    };
    const _onPropFound = onPropFound ?? defaultCallback;
    const pset = await model.getProperties(expressID);
    if (!pset || pset.type !== IFCPROPERTYSET) {
      return null;
    }
    const hasProperties = pset.HasProperties ?? [{}];
    const props = hasProperties.map((prop) => {
      if (prop.value)
        _onPropFound(prop.value);
      return prop.value;
    });
    return props.filter((prop) => prop !== null);
  }
  static async getPsetRel(model, psetID) {
    var _a;
    const prop = await model.getProperties(psetID);
    if (!prop) {
      return null;
    }
    const allPropsRels = await model.getAllPropertiesOfType(
      IFCRELDEFINESBYPROPERTIES
    );
    if (!allPropsRels) {
      return null;
    }
    const allRels = Object.values(allPropsRels);
    let found = null;
    for (const rel of allRels) {
      if (((_a = rel.RelatingPropertyDefinition) == null ? void 0 : _a.value) === psetID) {
        found = rel.expressID;
      }
    }
    return found;
  }
  static async getQsetRel(model, qsetID) {
    return _IfcPropertiesUtils.getPsetRel(model, qsetID);
  }
  static async getEntityName(model, entityID) {
    var _a;
    const entity = await model.getProperties(entityID);
    if (!entity) {
      return { key: null, name: null };
    }
    const key = Object.keys(entity).find((key2) => key2.endsWith("Name")) ?? null;
    const name = key ? (_a = entity[key]) == null ? void 0 : _a.value : null;
    return { key, name };
  }
  static async getQuantityValue(model, quantityID) {
    const quantity = await model.getProperties(quantityID);
    if (!quantity) {
      return { key: null, value: null };
    }
    const key = Object.keys(quantity).find((key2) => key2.endsWith("Value")) ?? null;
    let value;
    if (key === null) {
      value = null;
    } else if (quantity[key] === void 0 || quantity[key] === null) {
      value = null;
    } else {
      value = quantity[key].value;
    }
    return { key, value };
  }
  static isRel(expressID) {
    const entityName2 = IfcCategoryMap[expressID];
    return entityName2.startsWith("IFCREL");
  }
  static async attributeExists(model, expressID, attribute) {
    const entity = await model.getProperties(expressID);
    if (!entity) {
      return false;
    }
    return Object.keys(entity).includes(attribute);
  }
  static async groupEntitiesByType(model, expressIDs) {
    var _a;
    const categoriesMap = /* @__PURE__ */ new Map();
    for (const expressID of expressIDs) {
      const entity = await model.getProperties(expressID);
      if (!entity) {
        continue;
      }
      const key = entity.type;
      const set = categoriesMap.get(key);
      if (!set)
        categoriesMap.set(key, /* @__PURE__ */ new Set());
      (_a = categoriesMap.get(key)) == null ? void 0 : _a.add(expressID);
    }
    return categoriesMap;
  }
  // static getPropertyUnits(properties: IfcProperties, expressID: number) {
  //   const entity = properties[expressID];
  //   if (!entity) return null;
  //   const propertyInstance =
  //     entity instanceof WEBIFC.IFC2X3.IfcProperty ||
  //     entity instanceof WEBIFC.IFC4.IfcProperty ||
  //     entity instanceof WEBIFC.IFC4X3.IfcProperty;
  //   if (!propertyInstance) return null;
  //   const { key: valueKey } = IfcPropertiesUtils.getQuantityValue(
  //     properties,
  //     expressID
  //   );
  //   if (!valueKey) return null;
  //   // @ts-ignore
  //   const measureName = entity[valueKey].constructor.name as string;
  //   const isMeasureAttribute = measureName.endsWith("Measure");
  //   if (!isMeasureAttribute) return null;
  //   const measureType = measureName.slice(3, measureName.length - 7);
  //   return propertyInstance;
  // }
};
var ifcCategoryCase = {
  IFCURIREFERENCE: "IfcUriReference",
  IFCTIME: "IfcTime",
  IFCTEMPERATURERATEOFCHANGEMEASURE: "IfcTemperatureRateOfChangeMeasure",
  IFCSOUNDPRESSURELEVELMEASURE: "IfcSoundPressureLevelMeasure",
  IFCSOUNDPOWERLEVELMEASURE: "IfcSoundPowerLevelMeasure",
  IFCPROPERTYSETDEFINITIONSET: "IfcPropertySetDefinitionSet",
  IFCPOSITIVEINTEGER: "IfcPositiveInteger",
  IFCNONNEGATIVELENGTHMEASURE: "IfcNonNegativeLengthMeasure",
  IFCLINEINDEX: "IfcLineIndex",
  IFCLANGUAGEID: "IfcLanguageId",
  IFCDURATION: "IfcDuration",
  IFCDAYINWEEKNUMBER: "IfcDayInWeekNumber",
  IFCDATETIME: "IfcDateTime",
  IFCDATE: "IfcDate",
  IFCCARDINALPOINTREFERENCE: "IfcCardinalPointReference",
  IFCBINARY: "IfcBinary",
  IFCAREADENSITYMEASURE: "IfcAreaDensityMeasure",
  IFCARCINDEX: "IfcArcIndex",
  IFCYEARNUMBER: "IfcYearNumber",
  IFCWARPINGMOMENTMEASURE: "IfcWarpingMomentMeasure",
  IFCWARPINGCONSTANTMEASURE: "IfcWarpingConstantMeasure",
  IFCVOLUMETRICFLOWRATEMEASURE: "IfcVolumetricFlowRateMeasure",
  IFCVOLUMEMEASURE: "IfcVolumeMeasure",
  IFCVAPORPERMEABILITYMEASURE: "IfcVaporPermeabilityMeasure",
  IFCTORQUEMEASURE: "IfcTorqueMeasure",
  IFCTIMESTAMP: "IfcTimestamp",
  IFCTIMEMEASURE: "IfcTimeMeasure",
  IFCTHERMODYNAMICTEMPERATUREMEASURE: "IfcThermodynamicTemperatureMeasure",
  IFCTHERMALTRANSMITTANCEMEASURE: "IfcThermalTransmittanceMeasure",
  IFCTHERMALRESISTANCEMEASURE: "IfcThermalResistanceMeasure",
  IFCTHERMALEXPANSIONCOEFFICIENTMEASURE: "IfcThermalExpansionCoefficientMeasure",
  IFCTHERMALCONDUCTIVITYMEASURE: "IfcThermalConductivityMeasure",
  IFCTHERMALADMITTANCEMEASURE: "IfcThermalAdmittanceMeasure",
  IFCTEXTTRANSFORMATION: "IfcTextTransformation",
  IFCTEXTFONTNAME: "IfcTextFontName",
  IFCTEXTDECORATION: "IfcTextDecoration",
  IFCTEXTALIGNMENT: "IfcTextAlignment",
  IFCTEXT: "IfcText",
  IFCTEMPERATUREGRADIENTMEASURE: "IfcTemperatureGradientMeasure",
  IFCSPECULARROUGHNESS: "IfcSpecularRoughness",
  IFCSPECULAREXPONENT: "IfcSpecularExponent",
  IFCSPECIFICHEATCAPACITYMEASURE: "IfcSpecificHeatCapacityMeasure",
  IFCSOUNDPRESSUREMEASURE: "IfcSoundPressureMeasure",
  IFCSOUNDPOWERMEASURE: "IfcSoundPowerMeasure",
  IFCSOLIDANGLEMEASURE: "IfcSolidAngleMeasure",
  IFCSHEARMODULUSMEASURE: "IfcShearModulusMeasure",
  IFCSECTIONALAREAINTEGRALMEASURE: "IfcSectionalAreaIntegralMeasure",
  IFCSECTIONMODULUSMEASURE: "IfcSectionModulusMeasure",
  IFCSECONDINMINUTE: "IfcSecondInMinute",
  IFCROTATIONALSTIFFNESSMEASURE: "IfcRotationalStiffnessMeasure",
  IFCROTATIONALMASSMEASURE: "IfcRotationalMassMeasure",
  IFCROTATIONALFREQUENCYMEASURE: "IfcRotationalFrequencyMeasure",
  IFCREAL: "IfcReal",
  IFCRATIOMEASURE: "IfcRatioMeasure",
  IFCRADIOACTIVITYMEASURE: "IfcRadioactivityMeasure",
  IFCPRESSUREMEASURE: "IfcPressureMeasure",
  IFCPRESENTABLETEXT: "IfcPresentableText",
  IFCPOWERMEASURE: "IfcPowerMeasure",
  IFCPOSITIVERATIOMEASURE: "IfcPositiveRatioMeasure",
  IFCPOSITIVEPLANEANGLEMEASURE: "IfcPositivePlaneAngleMeasure",
  IFCPOSITIVELENGTHMEASURE: "IfcPositiveLengthMeasure",
  IFCPLANEANGLEMEASURE: "IfcPlaneAngleMeasure",
  IFCPLANARFORCEMEASURE: "IfcPlanarForceMeasure",
  IFCPARAMETERVALUE: "IfcParameterValue",
  IFCPHMEASURE: "IfcPhMeasure",
  IFCNUMERICMEASURE: "IfcNumericMeasure",
  IFCNORMALISEDRATIOMEASURE: "IfcNormalisedRatioMeasure",
  IFCMONTHINYEARNUMBER: "IfcMonthInYearNumber",
  IFCMONETARYMEASURE: "IfcMonetaryMeasure",
  IFCMOMENTOFINERTIAMEASURE: "IfcMomentOfInertiaMeasure",
  IFCMOLECULARWEIGHTMEASURE: "IfcMolecularWeightMeasure",
  IFCMOISTUREDIFFUSIVITYMEASURE: "IfcMoistureDiffusivityMeasure",
  IFCMODULUSOFSUBGRADEREACTIONMEASURE: "IfcModulusOfSubgradeReactionMeasure",
  IFCMODULUSOFROTATIONALSUBGRADEREACTIONMEASURE: "IfcModulusOfRotationalSubgradeReactionMeasure",
  IFCMODULUSOFLINEARSUBGRADEREACTIONMEASURE: "IfcModulusOfLinearSubgradeReactionMeasure",
  IFCMODULUSOFELASTICITYMEASURE: "IfcModulusOfElasticityMeasure",
  IFCMINUTEINHOUR: "IfcMinuteInHour",
  IFCMASSPERLENGTHMEASURE: "IfcMassPerLengthMeasure",
  IFCMASSMEASURE: "IfcMassMeasure",
  IFCMASSFLOWRATEMEASURE: "IfcMassFlowRateMeasure",
  IFCMASSDENSITYMEASURE: "IfcMassDensityMeasure",
  IFCMAGNETICFLUXMEASURE: "IfcMagneticFluxMeasure",
  IFCMAGNETICFLUXDENSITYMEASURE: "IfcMagneticFluxDensityMeasure",
  IFCLUMINOUSINTENSITYMEASURE: "IfcLuminousIntensityMeasure",
  IFCLUMINOUSINTENSITYDISTRIBUTIONMEASURE: "IfcLuminousIntensityDistributionMeasure",
  IFCLUMINOUSFLUXMEASURE: "IfcLuminousFluxMeasure",
  IFCLOGICAL: "IfcLogical",
  IFCLINEARVELOCITYMEASURE: "IfcLinearVelocityMeasure",
  IFCLINEARSTIFFNESSMEASURE: "IfcLinearStiffnessMeasure",
  IFCLINEARMOMENTMEASURE: "IfcLinearMomentMeasure",
  IFCLINEARFORCEMEASURE: "IfcLinearForceMeasure",
  IFCLENGTHMEASURE: "IfcLengthMeasure",
  IFCLABEL: "IfcLabel",
  IFCKINEMATICVISCOSITYMEASURE: "IfcKinematicViscosityMeasure",
  IFCISOTHERMALMOISTURECAPACITYMEASURE: "IfcIsothermalMoistureCapacityMeasure",
  IFCIONCONCENTRATIONMEASURE: "IfcIonConcentrationMeasure",
  IFCINTEGERCOUNTRATEMEASURE: "IfcIntegerCountRateMeasure",
  IFCINTEGER: "IfcInteger",
  IFCINDUCTANCEMEASURE: "IfcInductanceMeasure",
  IFCILLUMINANCEMEASURE: "IfcIlluminanceMeasure",
  IFCIDENTIFIER: "IfcIdentifier",
  IFCHOURINDAY: "IfcHourInDay",
  IFCHEATINGVALUEMEASURE: "IfcHeatingValueMeasure",
  IFCHEATFLUXDENSITYMEASURE: "IfcHeatFluxDensityMeasure",
  IFCGLOBALLYUNIQUEID: "IfcGloballyUniqueId",
  IFCFREQUENCYMEASURE: "IfcFrequencyMeasure",
  IFCFORCEMEASURE: "IfcForceMeasure",
  IFCFONTWEIGHT: "IfcFontWeight",
  IFCFONTVARIANT: "IfcFontVariant",
  IFCFONTSTYLE: "IfcFontStyle",
  IFCENERGYMEASURE: "IfcEnergyMeasure",
  IFCELECTRICVOLTAGEMEASURE: "IfcElectricVoltageMeasure",
  IFCELECTRICRESISTANCEMEASURE: "IfcElectricResistanceMeasure",
  IFCELECTRICCURRENTMEASURE: "IfcElectricCurrentMeasure",
  IFCELECTRICCONDUCTANCEMEASURE: "IfcElectricConductanceMeasure",
  IFCELECTRICCHARGEMEASURE: "IfcElectricChargeMeasure",
  IFCELECTRICCAPACITANCEMEASURE: "IfcElectricCapacitanceMeasure",
  IFCDYNAMICVISCOSITYMEASURE: "IfcDynamicViscosityMeasure",
  IFCDOSEEQUIVALENTMEASURE: "IfcDoseEquivalentMeasure",
  IFCDIMENSIONCOUNT: "IfcDimensionCount",
  IFCDESCRIPTIVEMEASURE: "IfcDescriptiveMeasure",
  IFCDAYLIGHTSAVINGHOUR: "IfcDaylightSavingHour",
  IFCDAYINMONTHNUMBER: "IfcDayInMonthNumber",
  IFCCURVATUREMEASURE: "IfcCurvatureMeasure",
  IFCCOUNTMEASURE: "IfcCountMeasure",
  IFCCONTEXTDEPENDENTMEASURE: "IfcContextDependentMeasure",
  IFCCOMPOUNDPLANEANGLEMEASURE: "IfcCompoundPlaneAngleMeasure",
  IFCCOMPLEXNUMBER: "IfcComplexNumber",
  IFCBOXALIGNMENT: "IfcBoxAlignment",
  IFCBOOLEAN: "IfcBoolean",
  IFCAREAMEASURE: "IfcAreaMeasure",
  IFCANGULARVELOCITYMEASURE: "IfcAngularVelocityMeasure",
  IFCAMOUNTOFSUBSTANCEMEASURE: "IfcAmountOfSubstanceMeasure",
  IFCACCELERATIONMEASURE: "IfcAccelerationMeasure",
  IFCABSORBEDDOSEMEASURE: "IfcAbsorbedDoseMeasure",
  IFCGEOSLICE: "IfcGeoSlice",
  IFCGEOMODEL: "IfcGeoModel",
  IFCELECTRICFLOWTREATMENTDEVICE: "IfcElectricFlowTreatmentDevice",
  IFCDISTRIBUTIONBOARD: "IfcDistributionBoard",
  IFCCONVEYORSEGMENT: "IfcConveyorSegment",
  IFCCAISSONFOUNDATION: "IfcCaissonFoundation",
  IFCBOREHOLE: "IfcBorehole",
  IFCBEARING: "IfcBearing",
  IFCALIGNMENT: "IfcAlignment",
  IFCTRACKELEMENT: "IfcTrackElement",
  IFCSIGNAL: "IfcSignal",
  IFCREINFORCEDSOIL: "IfcReinforcedSoil",
  IFCRAIL: "IfcRail",
  IFCPAVEMENT: "IfcPavement",
  IFCNAVIGATIONELEMENT: "IfcNavigationElement",
  IFCMOORINGDEVICE: "IfcMooringDevice",
  IFCMOBILETELECOMMUNICATIONSAPPLIANCE: "IfcMobileTelecommunicationsAppliance",
  IFCLIQUIDTERMINAL: "IfcLiquidTerminal",
  IFCLINEARPOSITIONINGELEMENT: "IfcLinearPositioningElement",
  IFCKERB: "IfcKerb",
  IFCGEOTECHNICALASSEMBLY: "IfcGeotechnicalAssembly",
  IFCELECTRICFLOWTREATMENTDEVICETYPE: "IfcElectricFlowTreatmentDeviceType",
  IFCEARTHWORKSFILL: "IfcEarthworksFill",
  IFCEARTHWORKSELEMENT: "IfcEarthworksElement",
  IFCEARTHWORKSCUT: "IfcEarthworksCut",
  IFCDISTRIBUTIONBOARDTYPE: "IfcDistributionBoardType",
  IFCDEEPFOUNDATION: "IfcDeepFoundation",
  IFCCOURSE: "IfcCourse",
  IFCCONVEYORSEGMENTTYPE: "IfcConveyorSegmentType",
  IFCCAISSONFOUNDATIONTYPE: "IfcCaissonFoundationType",
  IFCBUILTSYSTEM: "IfcBuiltSystem",
  IFCBUILTELEMENT: "IfcBuiltElement",
  IFCBRIDGEPART: "IfcBridgePart",
  IFCBRIDGE: "IfcBridge",
  IFCBEARINGTYPE: "IfcBearingType",
  IFCALIGNMENTVERTICAL: "IfcAlignmentVertical",
  IFCALIGNMENTSEGMENT: "IfcAlignmentSegment",
  IFCALIGNMENTHORIZONTAL: "IfcAlignmentHorizontal",
  IFCALIGNMENTCANT: "IfcAlignmentCant",
  IFCVIBRATIONDAMPERTYPE: "IfcVibrationDamperType",
  IFCVIBRATIONDAMPER: "IfcVibrationDamper",
  IFCVEHICLE: "IfcVehicle",
  IFCTRANSPORTATIONDEVICE: "IfcTransportationDevice",
  IFCTRACKELEMENTTYPE: "IfcTrackElementType",
  IFCTENDONCONDUITTYPE: "IfcTendonConduitType",
  IFCTENDONCONDUIT: "IfcTendonConduit",
  IFCSINESPIRAL: "IfcSineSpiral",
  IFCSIGNALTYPE: "IfcSignalType",
  IFCSIGNTYPE: "IfcSignType",
  IFCSIGN: "IfcSign",
  IFCSEVENTHORDERPOLYNOMIALSPIRAL: "IfcSeventhOrderPolynomialSpiral",
  IFCSEGMENTEDREFERENCECURVE: "IfcSegmentedReferenceCurve",
  IFCSECONDORDERPOLYNOMIALSPIRAL: "IfcSecondOrderPolynomialSpiral",
  IFCROADPART: "IfcRoadPart",
  IFCROAD: "IfcRoad",
  IFCRELADHERESTOELEMENT: "IfcRelAdheresToElement",
  IFCREFERENT: "IfcReferent",
  IFCRAILWAYPART: "IfcRailwayPart",
  IFCRAILWAY: "IfcRailway",
  IFCRAILTYPE: "IfcRailType",
  IFCPOSITIONINGELEMENT: "IfcPositioningElement",
  IFCPAVEMENTTYPE: "IfcPavementType",
  IFCNAVIGATIONELEMENTTYPE: "IfcNavigationElementType",
  IFCMOORINGDEVICETYPE: "IfcMooringDeviceType",
  IFCMOBILETELECOMMUNICATIONSAPPLIANCETYPE: "IfcMobileTelecommunicationsApplianceType",
  IFCMARINEPART: "IfcMarinePart",
  IFCMARINEFACILITY: "IfcMarineFacility",
  IFCLIQUIDTERMINALTYPE: "IfcLiquidTerminalType",
  IFCLINEARELEMENT: "IfcLinearElement",
  IFCKERBTYPE: "IfcKerbType",
  IFCIMPACTPROTECTIONDEVICETYPE: "IfcImpactProtectionDeviceType",
  IFCIMPACTPROTECTIONDEVICE: "IfcImpactProtectionDevice",
  IFCGRADIENTCURVE: "IfcGradientCurve",
  IFCGEOTECHNICALSTRATUM: "IfcGeotechnicalStratum",
  IFCGEOTECHNICALELEMENT: "IfcGeotechnicalElement",
  IFCFACILITYPARTCOMMON: "IfcFacilityPartCommon",
  IFCFACILITYPART: "IfcFacilityPart",
  IFCFACILITY: "IfcFacility",
  IFCDIRECTRIXDERIVEDREFERENCESWEPTAREASOLID: "IfcDirectrixDerivedReferenceSweptAreaSolid",
  IFCDEEPFOUNDATIONTYPE: "IfcDeepFoundationType",
  IFCCOURSETYPE: "IfcCourseType",
  IFCCOSINESPIRAL: "IfcCosineSpiral",
  IFCCLOTHOID: "IfcClothoid",
  IFCBUILTELEMENTTYPE: "IfcBuiltElementType",
  IFCVEHICLETYPE: "IfcVehicleType",
  IFCTRIANGULATEDIRREGULARNETWORK: "IfcTriangulatedIrregularNetwork",
  IFCTRANSPORTATIONDEVICETYPE: "IfcTransportationDeviceType",
  IFCTHIRDORDERPOLYNOMIALSPIRAL: "IfcThirdOrderPolynomialSpiral",
  IFCSPIRAL: "IfcSpiral",
  IFCSECTIONEDSURFACE: "IfcSectionedSurface",
  IFCSECTIONEDSOLIDHORIZONTAL: "IfcSectionedSolidHorizontal",
  IFCSECTIONEDSOLID: "IfcSectionedSolid",
  IFCRELPOSITIONS: "IfcRelPositions",
  IFCRELASSOCIATESPROFILEDEF: "IfcRelAssociatesProfileDef",
  IFCPOLYNOMIALCURVE: "IfcPolynomialCurve",
  IFCOFFSETCURVEBYDISTANCES: "IfcOffsetCurveByDistances",
  IFCOFFSETCURVE: "IfcOffsetCurve",
  IFCINDEXEDPOLYGONALTEXTUREMAP: "IfcIndexedPolygonalTextureMap",
  IFCDIRECTRIXCURVESWEPTAREASOLID: "IfcDirectrixCurveSweptAreaSolid",
  IFCCURVESEGMENT: "IfcCurveSegment",
  IFCAXIS2PLACEMENTLINEAR: "IfcAxis2PlacementLinear",
  IFCSEGMENT: "IfcSegment",
  IFCPOINTBYDISTANCEEXPRESSION: "IfcPointByDistanceExpression",
  IFCOPENCROSSPROFILEDEF: "IfcOpenCrossProfileDef",
  IFCLINEARPLACEMENT: "IfcLinearPlacement",
  IFCALIGNMENTHORIZONTALSEGMENT: "IfcAlignmentHorizontalSegment",
  IFCALIGNMENTCANTSEGMENT: "IfcAlignmentCantSegment",
  IFCTEXTURECOORDINATEINDICESWITHVOIDS: "IfcTextureCoordinateIndicesWithVoids",
  IFCTEXTURECOORDINATEINDICES: "IfcTextureCoordinateIndices",
  IFCQUANTITYNUMBER: "IfcQuantityNumber",
  IFCALIGNMENTVERTICALSEGMENT: "IfcAlignmentVerticalSegment",
  IFCALIGNMENTPARAMETERSEGMENT: "IfcAlignmentParameterSegment",
  IFCCONTROLLER: "IfcController",
  IFCALARM: "IfcAlarm",
  IFCACTUATOR: "IfcActuator",
  IFCUNITARYCONTROLELEMENT: "IfcUnitaryControlElement",
  IFCSENSOR: "IfcSensor",
  IFCPROTECTIVEDEVICETRIPPINGUNIT: "IfcProtectiveDeviceTrippingUnit",
  IFCFLOWINSTRUMENT: "IfcFlowInstrument",
  IFCFIRESUPPRESSIONTERMINAL: "IfcFireSuppressionTerminal",
  IFCFILTER: "IfcFilter",
  IFCFAN: "IfcFan",
  IFCELECTRICTIMECONTROL: "IfcElectricTimeControl",
  IFCELECTRICMOTOR: "IfcElectricMotor",
  IFCELECTRICGENERATOR: "IfcElectricGenerator",
  IFCELECTRICFLOWSTORAGEDEVICE: "IfcElectricFlowStorageDevice",
  IFCELECTRICDISTRIBUTIONBOARD: "IfcElectricDistributionBoard",
  IFCELECTRICAPPLIANCE: "IfcElectricAppliance",
  IFCDUCTSILENCER: "IfcDuctSilencer",
  IFCDUCTSEGMENT: "IfcDuctSegment",
  IFCDUCTFITTING: "IfcDuctFitting",
  IFCDISTRIBUTIONCIRCUIT: "IfcDistributionCircuit",
  IFCDAMPER: "IfcDamper",
  IFCCOOLINGTOWER: "IfcCoolingTower",
  IFCCOOLEDBEAM: "IfcCooledBeam",
  IFCCONDENSER: "IfcCondenser",
  IFCCOMPRESSOR: "IfcCompressor",
  IFCCOMMUNICATIONSAPPLIANCE: "IfcCommunicationsAppliance",
  IFCCOIL: "IfcCoil",
  IFCCHILLER: "IfcChiller",
  IFCCABLESEGMENT: "IfcCableSegment",
  IFCCABLEFITTING: "IfcCableFitting",
  IFCCABLECARRIERSEGMENT: "IfcCableCarrierSegment",
  IFCCABLECARRIERFITTING: "IfcCableCarrierFitting",
  IFCBURNER: "IfcBurner",
  IFCBOILER: "IfcBoiler",
  IFCBEAMSTANDARDCASE: "IfcBeamStandardCase",
  IFCAUDIOVISUALAPPLIANCE: "IfcAudioVisualAppliance",
  IFCAIRTOAIRHEATRECOVERY: "IfcAirToAirHeatRecovery",
  IFCAIRTERMINALBOX: "IfcAirTerminalBox",
  IFCAIRTERMINAL: "IfcAirTerminal",
  IFCWINDOWSTANDARDCASE: "IfcWindowStandardCase",
  IFCWASTETERMINAL: "IfcWasteTerminal",
  IFCWALLELEMENTEDCASE: "IfcWallElementedCase",
  IFCVALVE: "IfcValve",
  IFCUNITARYEQUIPMENT: "IfcUnitaryEquipment",
  IFCUNITARYCONTROLELEMENTTYPE: "IfcUnitaryControlElementType",
  IFCTUBEBUNDLE: "IfcTubeBundle",
  IFCTRANSFORMER: "IfcTransformer",
  IFCTANK: "IfcTank",
  IFCSWITCHINGDEVICE: "IfcSwitchingDevice",
  IFCSTRUCTURALLOADCASE: "IfcStructuralLoadCase",
  IFCSTACKTERMINAL: "IfcStackTerminal",
  IFCSPACEHEATER: "IfcSpaceHeater",
  IFCSOLARDEVICE: "IfcSolarDevice",
  IFCSLABSTANDARDCASE: "IfcSlabStandardCase",
  IFCSLABELEMENTEDCASE: "IfcSlabElementedCase",
  IFCSHADINGDEVICE: "IfcShadingDevice",
  IFCSANITARYTERMINAL: "IfcSanitaryTerminal",
  IFCREINFORCINGBARTYPE: "IfcReinforcingBarType",
  IFCRATIONALBSPLINECURVEWITHKNOTS: "IfcRationalBSplineCurveWithKnots",
  IFCPUMP: "IfcPump",
  IFCPROTECTIVEDEVICETRIPPINGUNITTYPE: "IfcProtectiveDeviceTrippingUnitType",
  IFCPROTECTIVEDEVICE: "IfcProtectiveDevice",
  IFCPLATESTANDARDCASE: "IfcPlateStandardCase",
  IFCPIPESEGMENT: "IfcPipeSegment",
  IFCPIPEFITTING: "IfcPipeFitting",
  IFCOUTLET: "IfcOutlet",
  IFCOUTERBOUNDARYCURVE: "IfcOuterBoundaryCurve",
  IFCMOTORCONNECTION: "IfcMotorConnection",
  IFCMEMBERSTANDARDCASE: "IfcMemberStandardCase",
  IFCMEDICALDEVICE: "IfcMedicalDevice",
  IFCLIGHTFIXTURE: "IfcLightFixture",
  IFCLAMP: "IfcLamp",
  IFCJUNCTIONBOX: "IfcJunctionBox",
  IFCINTERCEPTOR: "IfcInterceptor",
  IFCHUMIDIFIER: "IfcHumidifier",
  IFCHEATEXCHANGER: "IfcHeatExchanger",
  IFCFLOWMETER: "IfcFlowMeter",
  IFCEXTERNALSPATIALELEMENT: "IfcExternalSpatialElement",
  IFCEVAPORATOR: "IfcEvaporator",
  IFCEVAPORATIVECOOLER: "IfcEvaporativeCooler",
  IFCENGINE: "IfcEngine",
  IFCELECTRICDISTRIBUTIONBOARDTYPE: "IfcElectricDistributionBoardType",
  IFCDOORSTANDARDCASE: "IfcDoorStandardCase",
  IFCDISTRIBUTIONSYSTEM: "IfcDistributionSystem",
  IFCCOMMUNICATIONSAPPLIANCETYPE: "IfcCommunicationsApplianceType",
  IFCCOLUMNSTANDARDCASE: "IfcColumnStandardCase",
  IFCCIVILELEMENT: "IfcCivilElement",
  IFCCHIMNEY: "IfcChimney",
  IFCCABLEFITTINGTYPE: "IfcCableFittingType",
  IFCBURNERTYPE: "IfcBurnerType",
  IFCBUILDINGSYSTEM: "IfcBuildingSystem",
  IFCBUILDINGELEMENTPARTTYPE: "IfcBuildingElementPartType",
  IFCBOUNDARYCURVE: "IfcBoundaryCurve",
  IFCBSPLINECURVEWITHKNOTS: "IfcBSplineCurveWithKnots",
  IFCAUDIOVISUALAPPLIANCETYPE: "IfcAudioVisualApplianceType",
  IFCWORKCALENDAR: "IfcWorkCalendar",
  IFCWINDOWTYPE: "IfcWindowType",
  IFCVOIDINGFEATURE: "IfcVoidingFeature",
  IFCVIBRATIONISOLATOR: "IfcVibrationIsolator",
  IFCTENDONTYPE: "IfcTendonType",
  IFCTENDONANCHORTYPE: "IfcTendonAnchorType",
  IFCSYSTEMFURNITUREELEMENT: "IfcSystemFurnitureElement",
  IFCSURFACEFEATURE: "IfcSurfaceFeature",
  IFCSTRUCTURALSURFACEACTION: "IfcStructuralSurfaceAction",
  IFCSTRUCTURALCURVEREACTION: "IfcStructuralCurveReaction",
  IFCSTRUCTURALCURVEACTION: "IfcStructuralCurveAction",
  IFCSTAIRTYPE: "IfcStairType",
  IFCSOLARDEVICETYPE: "IfcSolarDeviceType",
  IFCSHADINGDEVICETYPE: "IfcShadingDeviceType",
  IFCSEAMCURVE: "IfcSeamCurve",
  IFCROOFTYPE: "IfcRoofType",
  IFCREINFORCINGMESHTYPE: "IfcReinforcingMeshType",
  IFCREINFORCINGELEMENTTYPE: "IfcReinforcingElementType",
  IFCRATIONALBSPLINESURFACEWITHKNOTS: "IfcRationalBSplineSurfaceWithKnots",
  IFCRAMPTYPE: "IfcRampType",
  IFCPOLYGONALFACESET: "IfcPolygonalFaceSet",
  IFCPILETYPE: "IfcPileType",
  IFCOPENINGSTANDARDCASE: "IfcOpeningStandardCase",
  IFCMEDICALDEVICETYPE: "IfcMedicalDeviceType",
  IFCINTERSECTIONCURVE: "IfcIntersectionCurve",
  IFCINTERCEPTORTYPE: "IfcInterceptorType",
  IFCINDEXEDPOLYCURVE: "IfcIndexedPolyCurve",
  IFCGEOGRAPHICELEMENT: "IfcGeographicElement",
  IFCFURNITURE: "IfcFurniture",
  IFCFOOTINGTYPE: "IfcFootingType",
  IFCEXTERNALSPATIALSTRUCTUREELEMENT: "IfcExternalSpatialStructureElement",
  IFCEVENT: "IfcEvent",
  IFCENGINETYPE: "IfcEngineType",
  IFCELEMENTASSEMBLYTYPE: "IfcElementAssemblyType",
  IFCDOORTYPE: "IfcDoorType",
  IFCCYLINDRICALSURFACE: "IfcCylindricalSurface",
  IFCCONSTRUCTIONPRODUCTRESOURCETYPE: "IfcConstructionProductResourceType",
  IFCCONSTRUCTIONMATERIALRESOURCETYPE: "IfcConstructionMaterialResourceType",
  IFCCONSTRUCTIONEQUIPMENTRESOURCETYPE: "IfcConstructionEquipmentResourceType",
  IFCCOMPOSITECURVEONSURFACE: "IfcCompositeCurveOnSurface",
  IFCCOMPLEXPROPERTYTEMPLATE: "IfcComplexPropertyTemplate",
  IFCCIVILELEMENTTYPE: "IfcCivilElementType",
  IFCCHIMNEYTYPE: "IfcChimneyType",
  IFCBSPLINESURFACEWITHKNOTS: "IfcBSplineSurfaceWithKnots",
  IFCBSPLINESURFACE: "IfcBSplineSurface",
  IFCADVANCEDBREPWITHVOIDS: "IfcAdvancedBrepWithVoids",
  IFCADVANCEDBREP: "IfcAdvancedBrep",
  IFCTRIANGULATEDFACESET: "IfcTriangulatedFaceSet",
  IFCTOROIDALSURFACE: "IfcToroidalSurface",
  IFCTESSELLATEDFACESET: "IfcTessellatedFaceSet",
  IFCTASKTYPE: "IfcTaskType",
  IFCSURFACECURVE: "IfcSurfaceCurve",
  IFCSUBCONTRACTRESOURCETYPE: "IfcSubContractResourceType",
  IFCSTRUCTURALSURFACEREACTION: "IfcStructuralSurfaceReaction",
  IFCSPHERICALSURFACE: "IfcSphericalSurface",
  IFCSPATIALZONETYPE: "IfcSpatialZoneType",
  IFCSPATIALZONE: "IfcSpatialZone",
  IFCSPATIALELEMENTTYPE: "IfcSpatialElementType",
  IFCSPATIALELEMENT: "IfcSpatialElement",
  IFCSIMPLEPROPERTYTEMPLATE: "IfcSimplePropertyTemplate",
  IFCREVOLVEDAREASOLIDTAPERED: "IfcRevolvedAreaSolidTapered",
  IFCREPARAMETRISEDCOMPOSITECURVESEGMENT: "IfcReparametrisedCompositeCurveSegment",
  IFCRELSPACEBOUNDARY2NDLEVEL: "IfcRelSpaceBoundary2ndLevel",
  IFCRELSPACEBOUNDARY1STLEVEL: "IfcRelSpaceBoundary1stLevel",
  IFCRELINTERFERESELEMENTS: "IfcRelInterferesElements",
  IFCRELDEFINESBYTEMPLATE: "IfcRelDefinesByTemplate",
  IFCRELDEFINESBYOBJECT: "IfcRelDefinesByObject",
  IFCRELDECLARES: "IfcRelDeclares",
  IFCRELASSIGNSTOGROUPBYFACTOR: "IfcRelAssignsToGroupByFactor",
  IFCPROPERTYTEMPLATE: "IfcPropertyTemplate",
  IFCPROPERTYSETTEMPLATE: "IfcPropertySetTemplate",
  IFCPROJECTLIBRARY: "IfcProjectLibrary",
  IFCPROCEDURETYPE: "IfcProcedureType",
  IFCPREDEFINEDPROPERTYSET: "IfcPredefinedPropertySet",
  IFCPCURVE: "IfcPCurve",
  IFCLABORRESOURCETYPE: "IfcLaborResourceType",
  IFCINDEXEDPOLYGONALFACEWITHVOIDS: "IfcIndexedPolygonalFaceWithVoids",
  IFCINDEXEDPOLYGONALFACE: "IfcIndexedPolygonalFace",
  IFCGEOGRAPHICELEMENTTYPE: "IfcGeographicElementType",
  IFCFIXEDREFERENCESWEPTAREASOLID: "IfcFixedReferenceSweptAreaSolid",
  IFCEXTRUDEDAREASOLIDTAPERED: "IfcExtrudedAreaSolidTapered",
  IFCEVENTTYPE: "IfcEventType",
  IFCCURVEBOUNDEDSURFACE: "IfcCurveBoundedSurface",
  IFCCREWRESOURCETYPE: "IfcCrewResourceType",
  IFCCONTEXT: "IfcContext",
  IFCCONSTRUCTIONRESOURCETYPE: "IfcConstructionResourceType",
  IFCCARTESIANPOINTLIST3D: "IfcCartesianPointList3D",
  IFCCARTESIANPOINTLIST2D: "IfcCartesianPointList2D",
  IFCCARTESIANPOINTLIST: "IfcCartesianPointList",
  IFCADVANCEDFACE: "IfcAdvancedFace",
  IFCTYPERESOURCE: "IfcTypeResource",
  IFCTYPEPROCESS: "IfcTypeProcess",
  IFCTESSELLATEDITEM: "IfcTessellatedItem",
  IFCSWEPTDISKSOLIDPOLYGONAL: "IfcSweptDiskSolidPolygonal",
  IFCRESOURCETIME: "IfcResourceTime",
  IFCRESOURCECONSTRAINTRELATIONSHIP: "IfcResourceConstraintRelationship",
  IFCRESOURCEAPPROVALRELATIONSHIP: "IfcResourceApprovalRelationship",
  IFCQUANTITYSET: "IfcQuantitySet",
  IFCPROPERTYTEMPLATEDEFINITION: "IfcPropertyTemplateDefinition",
  IFCPREDEFINEDPROPERTIES: "IfcPredefinedProperties",
  IFCMIRROREDPROFILEDEF: "IfcMirroredProfileDef",
  IFCMATERIALRELATIONSHIP: "IfcMaterialRelationship",
  IFCMATERIALPROFILESETUSAGETAPERING: "IfcMaterialProfileSetUsageTapering",
  IFCMATERIALPROFILESETUSAGE: "IfcMaterialProfileSetUsage",
  IFCMATERIALCONSTITUENTSET: "IfcMaterialConstituentSet",
  IFCMATERIALCONSTITUENT: "IfcMaterialConstituent",
  IFCLAGTIME: "IfcLagTime",
  IFCINDEXEDTRIANGLETEXTUREMAP: "IfcIndexedTriangleTextureMap",
  IFCINDEXEDTEXTUREMAP: "IfcIndexedTextureMap",
  IFCINDEXEDCOLOURMAP: "IfcIndexedColourMap",
  IFCEXTERNALREFERENCERELATIONSHIP: "IfcExternalReferenceRelationship",
  IFCEXTENDEDPROPERTIES: "IfcExtendedProperties",
  IFCEVENTTIME: "IfcEventTime",
  IFCCONVERSIONBASEDUNITWITHOFFSET: "IfcConversionBasedUnitWithOffset",
  IFCCOLOURRGBLIST: "IfcColourRgbList",
  IFCWORKTIME: "IfcWorkTime",
  IFCTIMEPERIOD: "IfcTimePeriod",
  IFCTEXTUREVERTEXLIST: "IfcTextureVertexList",
  IFCTASKTIMERECURRING: "IfcTaskTimeRecurring",
  IFCTASKTIME: "IfcTaskTime",
  IFCTABLECOLUMN: "IfcTableColumn",
  IFCSURFACEREINFORCEMENTAREA: "IfcSurfaceReinforcementArea",
  IFCSTRUCTURALLOADORRESULT: "IfcStructuralLoadOrResult",
  IFCSTRUCTURALLOADCONFIGURATION: "IfcStructuralLoadConfiguration",
  IFCSCHEDULINGTIME: "IfcSchedulingTime",
  IFCRESOURCELEVELRELATIONSHIP: "IfcResourceLevelRelationship",
  IFCREFERENCE: "IfcReference",
  IFCRECURRENCEPATTERN: "IfcRecurrencePattern",
  IFCPROPERTYABSTRACTION: "IfcPropertyAbstraction",
  IFCPROJECTEDCRS: "IfcProjectedCrs",
  IFCPRESENTATIONITEM: "IfcPresentationItem",
  IFCMATERIALUSAGEDEFINITION: "IfcMaterialUsageDefinition",
  IFCMATERIALPROFILEWITHOFFSETS: "IfcMaterialProfileWithOffsets",
  IFCMATERIALPROFILESET: "IfcMaterialProfileSet",
  IFCMATERIALPROFILE: "IfcMaterialProfile",
  IFCMATERIALLAYERWITHOFFSETS: "IfcMaterialLayerWithOffsets",
  IFCMATERIALDEFINITION: "IfcMaterialDefinition",
  IFCMAPCONVERSION: "IfcMapConversion",
  IFCEXTERNALINFORMATION: "IfcExternalInformation",
  IFCCOORDINATEREFERENCESYSTEM: "IfcCoordinateReferenceSystem",
  IFCCOORDINATEOPERATION: "IfcCoordinateOperation",
  IFCCONNECTIONVOLUMEGEOMETRY: "IfcConnectionVolumeGeometry",
  IFCREINFORCINGBAR: "IfcReinforcingBar",
  IFCELECTRICDISTRIBUTIONPOINT: "IfcElectricDistributionPoint",
  IFCDISTRIBUTIONCONTROLELEMENT: "IfcDistributionControlElement",
  IFCDISTRIBUTIONCHAMBERELEMENT: "IfcDistributionChamberElement",
  IFCCONTROLLERTYPE: "IfcControllerType",
  IFCCHAMFEREDGEFEATURE: "IfcChamferEdgeFeature",
  IFCBEAM: "IfcBeam",
  IFCALARMTYPE: "IfcAlarmType",
  IFCACTUATORTYPE: "IfcActuatorType",
  IFCWINDOW: "IfcWindow",
  IFCWALLSTANDARDCASE: "IfcWallStandardCase",
  IFCWALL: "IfcWall",
  IFCVIBRATIONISOLATORTYPE: "IfcVibrationIsolatorType",
  IFCTENDONANCHOR: "IfcTendonAnchor",
  IFCTENDON: "IfcTendon",
  IFCSTRUCTURALANALYSISMODEL: "IfcStructuralAnalysisModel",
  IFCSTAIRFLIGHT: "IfcStairFlight",
  IFCSTAIR: "IfcStair",
  IFCSLAB: "IfcSlab",
  IFCSENSORTYPE: "IfcSensorType",
  IFCROUNDEDEDGEFEATURE: "IfcRoundedEdgeFeature",
  IFCROOF: "IfcRoof",
  IFCREINFORCINGMESH: "IfcReinforcingMesh",
  IFCREINFORCINGELEMENT: "IfcReinforcingElement",
  IFCRATIONALBEZIERCURVE: "IfcRationalBezierCurve",
  IFCRAMPFLIGHT: "IfcRampFlight",
  IFCRAMP: "IfcRamp",
  IFCRAILING: "IfcRailing",
  IFCPLATE: "IfcPlate",
  IFCPILE: "IfcPile",
  IFCMEMBER: "IfcMember",
  IFCFOOTING: "IfcFooting",
  IFCFLOWTREATMENTDEVICE: "IfcFlowTreatmentDevice",
  IFCFLOWTERMINAL: "IfcFlowTerminal",
  IFCFLOWSTORAGEDEVICE: "IfcFlowStorageDevice",
  IFCFLOWSEGMENT: "IfcFlowSegment",
  IFCFLOWMOVINGDEVICE: "IfcFlowMovingDevice",
  IFCFLOWINSTRUMENTTYPE: "IfcFlowInstrumentType",
  IFCFLOWFITTING: "IfcFlowFitting",
  IFCFLOWCONTROLLER: "IfcFlowController",
  IFCFIRESUPPRESSIONTERMINALTYPE: "IfcFireSuppressionTerminalType",
  IFCFILTERTYPE: "IfcFilterType",
  IFCFANTYPE: "IfcFanType",
  IFCENERGYCONVERSIONDEVICE: "IfcEnergyConversionDevice",
  IFCELECTRICALELEMENT: "IfcElectricalElement",
  IFCELECTRICALCIRCUIT: "IfcElectricalCircuit",
  IFCELECTRICTIMECONTROLTYPE: "IfcElectricTimeControlType",
  IFCELECTRICMOTORTYPE: "IfcElectricMotorType",
  IFCELECTRICHEATERTYPE: "IfcElectricHeaterType",
  IFCELECTRICGENERATORTYPE: "IfcElectricGeneratorType",
  IFCELECTRICFLOWSTORAGEDEVICETYPE: "IfcElectricFlowStorageDeviceType",
  IFCELECTRICAPPLIANCETYPE: "IfcElectricApplianceType",
  IFCEDGEFEATURE: "IfcEdgeFeature",
  IFCDUCTSILENCERTYPE: "IfcDuctSilencerType",
  IFCDUCTSEGMENTTYPE: "IfcDuctSegmentType",
  IFCDUCTFITTINGTYPE: "IfcDuctFittingType",
  IFCDOOR: "IfcDoor",
  IFCDISTRIBUTIONPORT: "IfcDistributionPort",
  IFCDISTRIBUTIONFLOWELEMENT: "IfcDistributionFlowElement",
  IFCDISTRIBUTIONELEMENT: "IfcDistributionElement",
  IFCDISTRIBUTIONCONTROLELEMENTTYPE: "IfcDistributionControlElementType",
  IFCDISTRIBUTIONCHAMBERELEMENTTYPE: "IfcDistributionChamberElementType",
  IFCDISCRETEACCESSORYTYPE: "IfcDiscreteAccessoryType",
  IFCDISCRETEACCESSORY: "IfcDiscreteAccessory",
  IFCDIAMETERDIMENSION: "IfcDiameterDimension",
  IFCDAMPERTYPE: "IfcDamperType",
  IFCCURTAINWALL: "IfcCurtainWall",
  IFCCOVERING: "IfcCovering",
  IFCCOOLINGTOWERTYPE: "IfcCoolingTowerType",
  IFCCOOLEDBEAMTYPE: "IfcCooledBeamType",
  IFCCONSTRUCTIONPRODUCTRESOURCE: "IfcConstructionProductResource",
  IFCCONSTRUCTIONMATERIALRESOURCE: "IfcConstructionMaterialResource",
  IFCCONSTRUCTIONEQUIPMENTRESOURCE: "IfcConstructionEquipmentResource",
  IFCCONDITIONCRITERION: "IfcConditionCriterion",
  IFCCONDITION: "IfcCondition",
  IFCCONDENSERTYPE: "IfcCondenserType",
  IFCCOMPRESSORTYPE: "IfcCompressorType",
  IFCCOLUMN: "IfcColumn",
  IFCCOILTYPE: "IfcCoilType",
  IFCCIRCLE: "IfcCircle",
  IFCCHILLERTYPE: "IfcChillerType",
  IFCCABLESEGMENTTYPE: "IfcCableSegmentType",
  IFCCABLECARRIERSEGMENTTYPE: "IfcCableCarrierSegmentType",
  IFCCABLECARRIERFITTINGTYPE: "IfcCableCarrierFittingType",
  IFCBUILDINGELEMENTPROXYTYPE: "IfcBuildingElementProxyType",
  IFCBUILDINGELEMENTPROXY: "IfcBuildingElementProxy",
  IFCBUILDINGELEMENTPART: "IfcBuildingElementPart",
  IFCBUILDINGELEMENTCOMPONENT: "IfcBuildingElementComponent",
  IFCBUILDINGELEMENT: "IfcBuildingElement",
  IFCBOILERTYPE: "IfcBoilerType",
  IFCBEZIERCURVE: "IfcBezierCurve",
  IFCBEAMTYPE: "IfcBeamType",
  IFCBSPLINECURVE: "IfcBSplineCurve",
  IFCASSET: "IfcAsset",
  IFCANGULARDIMENSION: "IfcAngularDimension",
  IFCAIRTOAIRHEATRECOVERYTYPE: "IfcAirToAirHeatRecoveryType",
  IFCAIRTERMINALTYPE: "IfcAirTerminalType",
  IFCAIRTERMINALBOXTYPE: "IfcAirTerminalBoxType",
  IFCACTIONREQUEST: "IfcActionRequest",
  IFC2DCOMPOSITECURVE: "Ifc2DCompositeCurve",
  IFCZONE: "IfcZone",
  IFCWORKSCHEDULE: "IfcWorkSchedule",
  IFCWORKPLAN: "IfcWorkPlan",
  IFCWORKCONTROL: "IfcWorkControl",
  IFCWASTETERMINALTYPE: "IfcWasteTerminalType",
  IFCWALLTYPE: "IfcWallType",
  IFCVIRTUALELEMENT: "IfcVirtualElement",
  IFCVALVETYPE: "IfcValveType",
  IFCUNITARYEQUIPMENTTYPE: "IfcUnitaryEquipmentType",
  IFCTUBEBUNDLETYPE: "IfcTubeBundleType",
  IFCTRIMMEDCURVE: "IfcTrimmedCurve",
  IFCTRANSPORTELEMENT: "IfcTransportElement",
  IFCTRANSFORMERTYPE: "IfcTransformerType",
  IFCTIMESERIESSCHEDULE: "IfcTimeSeriesSchedule",
  IFCTANKTYPE: "IfcTankType",
  IFCSYSTEM: "IfcSystem",
  IFCSWITCHINGDEVICETYPE: "IfcSwitchingDeviceType",
  IFCSUBCONTRACTRESOURCE: "IfcSubContractResource",
  IFCSTRUCTURALSURFACECONNECTION: "IfcStructuralSurfaceConnection",
  IFCSTRUCTURALRESULTGROUP: "IfcStructuralResultGroup",
  IFCSTRUCTURALPOINTREACTION: "IfcStructuralPointReaction",
  IFCSTRUCTURALPOINTCONNECTION: "IfcStructuralPointConnection",
  IFCSTRUCTURALPOINTACTION: "IfcStructuralPointAction",
  IFCSTRUCTURALPLANARACTIONVARYING: "IfcStructuralPlanarActionVarying",
  IFCSTRUCTURALPLANARACTION: "IfcStructuralPlanarAction",
  IFCSTRUCTURALLOADGROUP: "IfcStructuralLoadGroup",
  IFCSTRUCTURALLINEARACTIONVARYING: "IfcStructuralLinearActionVarying",
  IFCSTRUCTURALLINEARACTION: "IfcStructuralLinearAction",
  IFCSTRUCTURALCURVEMEMBERVARYING: "IfcStructuralCurveMemberVarying",
  IFCSTRUCTURALCURVEMEMBER: "IfcStructuralCurveMember",
  IFCSTRUCTURALCURVECONNECTION: "IfcStructuralCurveConnection",
  IFCSTRUCTURALCONNECTION: "IfcStructuralConnection",
  IFCSTRUCTURALACTION: "IfcStructuralAction",
  IFCSTAIRFLIGHTTYPE: "IfcStairFlightType",
  IFCSTACKTERMINALTYPE: "IfcStackTerminalType",
  IFCSPACETYPE: "IfcSpaceType",
  IFCSPACEPROGRAM: "IfcSpaceProgram",
  IFCSPACEHEATERTYPE: "IfcSpaceHeaterType",
  IFCSPACE: "IfcSpace",
  IFCSLABTYPE: "IfcSlabType",
  IFCSITE: "IfcSite",
  IFCSERVICELIFE: "IfcServiceLife",
  IFCSCHEDULETIMECONTROL: "IfcScheduleTimeControl",
  IFCSANITARYTERMINALTYPE: "IfcSanitaryTerminalType",
  IFCRELASSIGNSTASKS: "IfcRelAssignsTasks",
  IFCRELAGGREGATES: "IfcRelAggregates",
  IFCRAMPFLIGHTTYPE: "IfcRampFlightType",
  IFCRAILINGTYPE: "IfcRailingType",
  IFCRADIUSDIMENSION: "IfcRadiusDimension",
  IFCPUMPTYPE: "IfcPumpType",
  IFCPROTECTIVEDEVICETYPE: "IfcProtectiveDeviceType",
  IFCPROJECTIONELEMENT: "IfcProjectionElement",
  IFCPROJECTORDERRECORD: "IfcProjectOrderRecord",
  IFCPROJECTORDER: "IfcProjectOrder",
  IFCPROCEDURE: "IfcProcedure",
  IFCPORT: "IfcPort",
  IFCPOLYLINE: "IfcPolyline",
  IFCPLATETYPE: "IfcPlateType",
  IFCPIPESEGMENTTYPE: "IfcPipeSegmentType",
  IFCPIPEFITTINGTYPE: "IfcPipeFittingType",
  IFCPERMIT: "IfcPermit",
  IFCPERFORMANCEHISTORY: "IfcPerformanceHistory",
  IFCOUTLETTYPE: "IfcOutletType",
  IFCORDERACTION: "IfcOrderAction",
  IFCOPENINGELEMENT: "IfcOpeningElement",
  IFCOCCUPANT: "IfcOccupant",
  IFCMOVE: "IfcMove",
  IFCMOTORCONNECTIONTYPE: "IfcMotorConnectionType",
  IFCMEMBERTYPE: "IfcMemberType",
  IFCMECHANICALFASTENERTYPE: "IfcMechanicalFastenerType",
  IFCMECHANICALFASTENER: "IfcMechanicalFastener",
  IFCLINEARDIMENSION: "IfcLinearDimension",
  IFCLIGHTFIXTURETYPE: "IfcLightFixtureType",
  IFCLAMPTYPE: "IfcLampType",
  IFCLABORRESOURCE: "IfcLaborResource",
  IFCJUNCTIONBOXTYPE: "IfcJunctionBoxType",
  IFCINVENTORY: "IfcInventory",
  IFCHUMIDIFIERTYPE: "IfcHumidifierType",
  IFCHEATEXCHANGERTYPE: "IfcHeatExchangerType",
  IFCGROUP: "IfcGroup",
  IFCGRID: "IfcGrid",
  IFCGASTERMINALTYPE: "IfcGasTerminalType",
  IFCFURNITURESTANDARD: "IfcFurnitureStandard",
  IFCFURNISHINGELEMENT: "IfcFurnishingElement",
  IFCFLOWTREATMENTDEVICETYPE: "IfcFlowTreatmentDeviceType",
  IFCFLOWTERMINALTYPE: "IfcFlowTerminalType",
  IFCFLOWSTORAGEDEVICETYPE: "IfcFlowStorageDeviceType",
  IFCFLOWSEGMENTTYPE: "IfcFlowSegmentType",
  IFCFLOWMOVINGDEVICETYPE: "IfcFlowMovingDeviceType",
  IFCFLOWMETERTYPE: "IfcFlowMeterType",
  IFCFLOWFITTINGTYPE: "IfcFlowFittingType",
  IFCFLOWCONTROLLERTYPE: "IfcFlowControllerType",
  IFCFEATUREELEMENTSUBTRACTION: "IfcFeatureElementSubtraction",
  IFCFEATUREELEMENTADDITION: "IfcFeatureElementAddition",
  IFCFEATUREELEMENT: "IfcFeatureElement",
  IFCFASTENERTYPE: "IfcFastenerType",
  IFCFASTENER: "IfcFastener",
  IFCFACETEDBREPWITHVOIDS: "IfcFacetedBrepWithVoids",
  IFCFACETEDBREP: "IfcFacetedBrep",
  IFCEVAPORATORTYPE: "IfcEvaporatorType",
  IFCEVAPORATIVECOOLERTYPE: "IfcEvaporativeCoolerType",
  IFCEQUIPMENTSTANDARD: "IfcEquipmentStandard",
  IFCEQUIPMENTELEMENT: "IfcEquipmentElement",
  IFCENERGYCONVERSIONDEVICETYPE: "IfcEnergyConversionDeviceType",
  IFCELLIPSE: "IfcEllipse",
  IFCELEMENTCOMPONENTTYPE: "IfcElementComponentType",
  IFCELEMENTCOMPONENT: "IfcElementComponent",
  IFCELEMENTASSEMBLY: "IfcElementAssembly",
  IFCELEMENT: "IfcElement",
  IFCELECTRICALBASEPROPERTIES: "IfcElectricalBaseProperties",
  IFCDISTRIBUTIONFLOWELEMENTTYPE: "IfcDistributionFlowElementType",
  IFCDISTRIBUTIONELEMENTTYPE: "IfcDistributionElementType",
  IFCDIMENSIONCURVEDIRECTEDCALLOUT: "IfcDimensionCurveDirectedCallout",
  IFCCURTAINWALLTYPE: "IfcCurtainWallType",
  IFCCREWRESOURCE: "IfcCrewResource",
  IFCCOVERINGTYPE: "IfcCoveringType",
  IFCCOSTSCHEDULE: "IfcCostSchedule",
  IFCCOSTITEM: "IfcCostItem",
  IFCCONTROL: "IfcControl",
  IFCCONSTRUCTIONRESOURCE: "IfcConstructionResource",
  IFCCONIC: "IfcConic",
  IFCCOMPOSITECURVE: "IfcCompositeCurve",
  IFCCOLUMNTYPE: "IfcColumnType",
  IFCCIRCLEHOLLOWPROFILEDEF: "IfcCircleHollowProfileDef",
  IFCBUILDINGSTOREY: "IfcBuildingStorey",
  IFCBUILDINGELEMENTTYPE: "IfcBuildingElementType",
  IFCBUILDING: "IfcBuilding",
  IFCBOUNDEDCURVE: "IfcBoundedCurve",
  IFCBOOLEANCLIPPINGRESULT: "IfcBooleanClippingResult",
  IFCBLOCK: "IfcBlock",
  IFCASYMMETRICISHAPEPROFILEDEF: "IfcAsymmetricIShapeProfileDef",
  IFCANNOTATION: "IfcAnnotation",
  IFCACTOR: "IfcActor",
  IFCTRANSPORTELEMENTTYPE: "IfcTransportElementType",
  IFCTASK: "IfcTask",
  IFCSYSTEMFURNITUREELEMENTTYPE: "IfcSystemFurnitureElementType",
  IFCSURFACEOFREVOLUTION: "IfcSurfaceOfRevolution",
  IFCSURFACEOFLINEAREXTRUSION: "IfcSurfaceOfLinearExtrusion",
  IFCSURFACECURVESWEPTAREASOLID: "IfcSurfaceCurveSweptAreaSolid",
  IFCSTRUCTUREDDIMENSIONCALLOUT: "IfcStructuredDimensionCallout",
  IFCSTRUCTURALSURFACEMEMBERVARYING: "IfcStructuralSurfaceMemberVarying",
  IFCSTRUCTURALSURFACEMEMBER: "IfcStructuralSurfaceMember",
  IFCSTRUCTURALREACTION: "IfcStructuralReaction",
  IFCSTRUCTURALMEMBER: "IfcStructuralMember",
  IFCSTRUCTURALITEM: "IfcStructuralItem",
  IFCSTRUCTURALACTIVITY: "IfcStructuralActivity",
  IFCSPHERE: "IfcSphere",
  IFCSPATIALSTRUCTUREELEMENTTYPE: "IfcSpatialStructureElementType",
  IFCSPATIALSTRUCTUREELEMENT: "IfcSpatialStructureElement",
  IFCRIGHTCIRCULARCYLINDER: "IfcRightCircularCylinder",
  IFCRIGHTCIRCULARCONE: "IfcRightCircularCone",
  IFCREVOLVEDAREASOLID: "IfcRevolvedAreaSolid",
  IFCRESOURCE: "IfcResource",
  IFCRELVOIDSELEMENT: "IfcRelVoidsElement",
  IFCRELSPACEBOUNDARY: "IfcRelSpaceBoundary",
  IFCRELSERVICESBUILDINGS: "IfcRelServicesBuildings",
  IFCRELSEQUENCE: "IfcRelSequence",
  IFCRELSCHEDULESCOSTITEMS: "IfcRelSchedulesCostItems",
  IFCRELREFERENCEDINSPATIALSTRUCTURE: "IfcRelReferencedInSpatialStructure",
  IFCRELPROJECTSELEMENT: "IfcRelProjectsElement",
  IFCRELOVERRIDESPROPERTIES: "IfcRelOverridesProperties",
  IFCRELOCCUPIESSPACES: "IfcRelOccupiesSpaces",
  IFCRELNESTS: "IfcRelNests",
  IFCRELINTERACTIONREQUIREMENTS: "IfcRelInteractionRequirements",
  IFCRELFLOWCONTROLELEMENTS: "IfcRelFlowControlElements",
  IFCRELFILLSELEMENT: "IfcRelFillsElement",
  IFCRELDEFINESBYTYPE: "IfcRelDefinesByType",
  IFCRELDEFINESBYPROPERTIES: "IfcRelDefinesByProperties",
  IFCRELDEFINES: "IfcRelDefines",
  IFCRELDECOMPOSES: "IfcRelDecomposes",
  IFCRELCOVERSSPACES: "IfcRelCoversSpaces",
  IFCRELCOVERSBLDGELEMENTS: "IfcRelCoversBldgElements",
  IFCRELCONTAINEDINSPATIALSTRUCTURE: "IfcRelContainedInSpatialStructure",
  IFCRELCONNECTSWITHREALIZINGELEMENTS: "IfcRelConnectsWithRealizingElements",
  IFCRELCONNECTSWITHECCENTRICITY: "IfcRelConnectsWithEccentricity",
  IFCRELCONNECTSSTRUCTURALMEMBER: "IfcRelConnectsStructuralMember",
  IFCRELCONNECTSSTRUCTURALELEMENT: "IfcRelConnectsStructuralElement",
  IFCRELCONNECTSSTRUCTURALACTIVITY: "IfcRelConnectsStructuralActivity",
  IFCRELCONNECTSPORTS: "IfcRelConnectsPorts",
  IFCRELCONNECTSPORTTOELEMENT: "IfcRelConnectsPortToElement",
  IFCRELCONNECTSPATHELEMENTS: "IfcRelConnectsPathElements",
  IFCRELCONNECTSELEMENTS: "IfcRelConnectsElements",
  IFCRELCONNECTS: "IfcRelConnects",
  IFCRELASSOCIATESPROFILEPROPERTIES: "IfcRelAssociatesProfileProperties",
  IFCRELASSOCIATESMATERIAL: "IfcRelAssociatesMaterial",
  IFCRELASSOCIATESLIBRARY: "IfcRelAssociatesLibrary",
  IFCRELASSOCIATESDOCUMENT: "IfcRelAssociatesDocument",
  IFCRELASSOCIATESCONSTRAINT: "IfcRelAssociatesConstraint",
  IFCRELASSOCIATESCLASSIFICATION: "IfcRelAssociatesClassification",
  IFCRELASSOCIATESAPPROVAL: "IfcRelAssociatesApproval",
  IFCRELASSOCIATESAPPLIEDVALUE: "IfcRelAssociatesAppliedValue",
  IFCRELASSOCIATES: "IfcRelAssociates",
  IFCRELASSIGNSTORESOURCE: "IfcRelAssignsToResource",
  IFCRELASSIGNSTOPROJECTORDER: "IfcRelAssignsToProjectOrder",
  IFCRELASSIGNSTOPRODUCT: "IfcRelAssignsToProduct",
  IFCRELASSIGNSTOPROCESS: "IfcRelAssignsToProcess",
  IFCRELASSIGNSTOGROUP: "IfcRelAssignsToGroup",
  IFCRELASSIGNSTOCONTROL: "IfcRelAssignsToControl",
  IFCRELASSIGNSTOACTOR: "IfcRelAssignsToActor",
  IFCRELASSIGNS: "IfcRelAssigns",
  IFCRECTANGULARTRIMMEDSURFACE: "IfcRectangularTrimmedSurface",
  IFCRECTANGULARPYRAMID: "IfcRectangularPyramid",
  IFCRECTANGLEHOLLOWPROFILEDEF: "IfcRectangleHollowProfileDef",
  IFCPROXY: "IfcProxy",
  IFCPROPERTYSET: "IfcPropertySet",
  IFCPROJECTIONCURVE: "IfcProjectionCurve",
  IFCPROJECT: "IfcProject",
  IFCPRODUCT: "IfcProduct",
  IFCPROCESS: "IfcProcess",
  IFCPLANE: "IfcPlane",
  IFCPLANARBOX: "IfcPlanarBox",
  IFCPERMEABLECOVERINGPROPERTIES: "IfcPermeableCoveringProperties",
  IFCOFFSETCURVE3D: "IfcOffsetCurve3D",
  IFCOFFSETCURVE2D: "IfcOffsetCurve2D",
  IFCOBJECT: "IfcObject",
  IFCMANIFOLDSOLIDBREP: "IfcManifoldSolidBrep",
  IFCLINE: "IfcLine",
  IFCLSHAPEPROFILEDEF: "IfcLShapeProfileDef",
  IFCISHAPEPROFILEDEF: "IfcIShapeProfileDef",
  IFCGEOMETRICCURVESET: "IfcGeometricCurveSet",
  IFCFURNITURETYPE: "IfcFurnitureType",
  IFCFURNISHINGELEMENTTYPE: "IfcFurnishingElementType",
  IFCFLUIDFLOWPROPERTIES: "IfcFluidFlowProperties",
  IFCFILLAREASTYLETILES: "IfcFillAreaStyleTiles",
  IFCFILLAREASTYLETILESYMBOLWITHSTYLE: "IfcFillAreaStyleTileSymbolWithStyle",
  IFCFILLAREASTYLEHATCHING: "IfcFillAreaStyleHatching",
  IFCFACEBASEDSURFACEMODEL: "IfcFaceBasedSurfaceModel",
  IFCEXTRUDEDAREASOLID: "IfcExtrudedAreaSolid",
  IFCENERGYPROPERTIES: "IfcEnergyProperties",
  IFCELLIPSEPROFILEDEF: "IfcEllipseProfileDef",
  IFCELEMENTARYSURFACE: "IfcElementarySurface",
  IFCELEMENTTYPE: "IfcElementType",
  IFCELEMENTQUANTITY: "IfcElementQuantity",
  IFCEDGELOOP: "IfcEdgeLoop",
  IFCDRAUGHTINGPREDEFINEDCURVEFONT: "IfcDraughtingPredefinedCurveFont",
  IFCDRAUGHTINGPREDEFINEDCOLOUR: "IfcDraughtingPredefinedColour",
  IFCDRAUGHTINGCALLOUT: "IfcDraughtingCallout",
  IFCDOORSTYLE: "IfcDoorStyle",
  IFCDOORPANELPROPERTIES: "IfcDoorPanelProperties",
  IFCDOORLININGPROPERTIES: "IfcDoorLiningProperties",
  IFCDIRECTION: "IfcDirection",
  IFCDIMENSIONCURVETERMINATOR: "IfcDimensionCurveTerminator",
  IFCDIMENSIONCURVE: "IfcDimensionCurve",
  IFCDEFINEDSYMBOL: "IfcDefinedSymbol",
  IFCCURVEBOUNDEDPLANE: "IfcCurveBoundedPlane",
  IFCCURVE: "IfcCurve",
  IFCCSGSOLID: "IfcCsgSolid",
  IFCCSGPRIMITIVE3D: "IfcCsgPrimitive3D",
  IFCCRANERAILFSHAPEPROFILEDEF: "IfcCraneRailFShapeProfileDef",
  IFCCRANERAILASHAPEPROFILEDEF: "IfcCraneRailAShapeProfileDef",
  IFCCOMPOSITECURVESEGMENT: "IfcCompositeCurveSegment",
  IFCCLOSEDSHELL: "IfcClosedShell",
  IFCCIRCLEPROFILEDEF: "IfcCircleProfileDef",
  IFCCARTESIANTRANSFORMATIONOPERATOR3DNONUNIFORM: "IfcCartesianTransformationOperator3DNonUniform",
  IFCCARTESIANTRANSFORMATIONOPERATOR3D: "IfcCartesianTransformationOperator3D",
  IFCCARTESIANTRANSFORMATIONOPERATOR2DNONUNIFORM: "IfcCartesianTransformationOperator2DNonUniform",
  IFCCARTESIANTRANSFORMATIONOPERATOR2D: "IfcCartesianTransformationOperator2D",
  IFCCARTESIANTRANSFORMATIONOPERATOR: "IfcCartesianTransformationOperator",
  IFCCARTESIANPOINT: "IfcCartesianPoint",
  IFCCSHAPEPROFILEDEF: "IfcCShapeProfileDef",
  IFCBOXEDHALFSPACE: "IfcBoxedHalfSpace",
  IFCBOUNDINGBOX: "IfcBoundingBox",
  IFCBOUNDEDSURFACE: "IfcBoundedSurface",
  IFCBOOLEANRESULT: "IfcBooleanResult",
  IFCAXIS2PLACEMENT3D: "IfcAxis2Placement3D",
  IFCAXIS2PLACEMENT2D: "IfcAxis2Placement2D",
  IFCAXIS1PLACEMENT: "IfcAxis1Placement",
  IFCANNOTATIONSURFACE: "IfcAnnotationSurface",
  IFCANNOTATIONFILLAREAOCCURRENCE: "IfcAnnotationFillAreaOccurrence",
  IFCANNOTATIONFILLAREA: "IfcAnnotationFillArea",
  IFCANNOTATIONCURVEOCCURRENCE: "IfcAnnotationCurveOccurrence",
  IFCZSHAPEPROFILEDEF: "IfcZShapeProfileDef",
  IFCWINDOWSTYLE: "IfcWindowStyle",
  IFCWINDOWPANELPROPERTIES: "IfcWindowPanelProperties",
  IFCWINDOWLININGPROPERTIES: "IfcWindowLiningProperties",
  IFCVERTEXLOOP: "IfcVertexLoop",
  IFCVECTOR: "IfcVector",
  IFCUSHAPEPROFILEDEF: "IfcUShapeProfileDef",
  IFCTYPEPRODUCT: "IfcTypeProduct",
  IFCTYPEOBJECT: "IfcTypeObject",
  IFCTWODIRECTIONREPEATFACTOR: "IfcTwoDirectionRepeatFactor",
  IFCTRAPEZIUMPROFILEDEF: "IfcTrapeziumProfileDef",
  IFCTEXTLITERALWITHEXTENT: "IfcTextLiteralWithExtent",
  IFCTEXTLITERAL: "IfcTextLiteral",
  IFCTERMINATORSYMBOL: "IfcTerminatorSymbol",
  IFCTSHAPEPROFILEDEF: "IfcTShapeProfileDef",
  IFCSWEPTSURFACE: "IfcSweptSurface",
  IFCSWEPTDISKSOLID: "IfcSweptDiskSolid",
  IFCSWEPTAREASOLID: "IfcSweptAreaSolid",
  IFCSURFACESTYLERENDERING: "IfcSurfaceStyleRendering",
  IFCSURFACE: "IfcSurface",
  IFCSUBEDGE: "IfcSubedge",
  IFCSTRUCTURALSTEELPROFILEPROPERTIES: "IfcStructuralSteelProfileProperties",
  IFCSTRUCTURALPROFILEPROPERTIES: "IfcStructuralProfileProperties",
  IFCSTRUCTURALLOADSINGLEFORCEWARPING: "IfcStructuralLoadSingleForceWarping",
  IFCSTRUCTURALLOADSINGLEFORCE: "IfcStructuralLoadSingleForce",
  IFCSTRUCTURALLOADSINGLEDISPLACEMENTDISTORTION: "IfcStructuralLoadSingleDisplacementDistortion",
  IFCSTRUCTURALLOADSINGLEDISPLACEMENT: "IfcStructuralLoadSingleDisplacement",
  IFCSTRUCTURALLOADPLANARFORCE: "IfcStructuralLoadPlanarForce",
  IFCSTRUCTURALLOADLINEARFORCE: "IfcStructuralLoadLinearForce",
  IFCSPACETHERMALLOADPROPERTIES: "IfcSpaceThermalLoadProperties",
  IFCSOUNDVALUE: "IfcSoundValue",
  IFCSOUNDPROPERTIES: "IfcSoundProperties",
  IFCSOLIDMODEL: "IfcSolidModel",
  IFCSLIPPAGECONNECTIONCONDITION: "IfcSlippageConnectionCondition",
  IFCSHELLBASEDSURFACEMODEL: "IfcShellBasedSurfaceModel",
  IFCSERVICELIFEFACTOR: "IfcServiceLifeFactor",
  IFCSECTIONEDSPINE: "IfcSectionedSpine",
  IFCROUNDEDRECTANGLEPROFILEDEF: "IfcRoundedRectangleProfileDef",
  IFCRELATIONSHIP: "IfcRelationship",
  IFCREINFORCEMENTDEFINITIONPROPERTIES: "IfcReinforcementDefinitionProperties",
  IFCREGULARTIMESERIES: "IfcRegularTimeSeries",
  IFCRECTANGLEPROFILEDEF: "IfcRectangleProfileDef",
  IFCPROPERTYTABLEVALUE: "IfcPropertyTableValue",
  IFCPROPERTYSINGLEVALUE: "IfcPropertySingleValue",
  IFCPROPERTYSETDEFINITION: "IfcPropertySetDefinition",
  IFCPROPERTYREFERENCEVALUE: "IfcPropertyReferenceValue",
  IFCPROPERTYLISTVALUE: "IfcPropertyListValue",
  IFCPROPERTYENUMERATEDVALUE: "IfcPropertyEnumeratedValue",
  IFCPROPERTYDEFINITION: "IfcPropertyDefinition",
  IFCPROPERTYBOUNDEDVALUE: "IfcPropertyBoundedValue",
  IFCPRODUCTDEFINITIONSHAPE: "IfcProductDefinitionShape",
  IFCPREDEFINEDPOINTMARKERSYMBOL: "IfcPredefinedPointMarkerSymbol",
  IFCPREDEFINEDDIMENSIONSYMBOL: "IfcPredefinedDimensionSymbol",
  IFCPREDEFINEDCURVEFONT: "IfcPredefinedCurveFont",
  IFCPREDEFINEDCOLOUR: "IfcPredefinedColour",
  IFCPOLYGONALBOUNDEDHALFSPACE: "IfcPolygonalBoundedHalfSpace",
  IFCPOLYLOOP: "IfcPolyLoop",
  IFCPOINTONSURFACE: "IfcPointOnSurface",
  IFCPOINTONCURVE: "IfcPointOnCurve",
  IFCPOINT: "IfcPoint",
  IFCPLANAREXTENT: "IfcPlanarExtent",
  IFCPLACEMENT: "IfcPlacement",
  IFCPIXELTEXTURE: "IfcPixelTexture",
  IFCPHYSICALCOMPLEXQUANTITY: "IfcPhysicalComplexQuantity",
  IFCPATH: "IfcPath",
  IFCPARAMETERIZEDPROFILEDEF: "IfcParameterizedProfileDef",
  IFCORIENTEDEDGE: "IfcOrientedEdge",
  IFCOPENSHELL: "IfcOpenShell",
  IFCONEDIRECTIONREPEATFACTOR: "IfcOneDirectionRepeatFactor",
  IFCOBJECTDEFINITION: "IfcObjectDefinition",
  IFCMECHANICALCONCRETEMATERIALPROPERTIES: "IfcMechanicalConcreteMaterialProperties",
  IFCMATERIALDEFINITIONREPRESENTATION: "IfcMaterialDefinitionRepresentation",
  IFCMAPPEDITEM: "IfcMappedItem",
  IFCLOOP: "IfcLoop",
  IFCLOCALPLACEMENT: "IfcLocalPlacement",
  IFCLIGHTSOURCESPOT: "IfcLightSourceSpot",
  IFCLIGHTSOURCEPOSITIONAL: "IfcLightSourcePositional",
  IFCLIGHTSOURCEGONIOMETRIC: "IfcLightSourceGoniometric",
  IFCLIGHTSOURCEDIRECTIONAL: "IfcLightSourceDirectional",
  IFCLIGHTSOURCEAMBIENT: "IfcLightSourceAmbient",
  IFCLIGHTSOURCE: "IfcLightSource",
  IFCIRREGULARTIMESERIES: "IfcIrregularTimeSeries",
  IFCIMAGETEXTURE: "IfcImageTexture",
  IFCHYGROSCOPICMATERIALPROPERTIES: "IfcHygroscopicMaterialProperties",
  IFCHALFSPACESOLID: "IfcHalfSpaceSolid",
  IFCGRIDPLACEMENT: "IfcGridPlacement",
  IFCGEOMETRICSET: "IfcGeometricSet",
  IFCGEOMETRICREPRESENTATIONSUBCONTEXT: "IfcGeometricRepresentationSubContext",
  IFCGEOMETRICREPRESENTATIONITEM: "IfcGeometricRepresentationItem",
  IFCGEOMETRICREPRESENTATIONCONTEXT: "IfcGeometricRepresentationContext",
  IFCGENERALPROFILEPROPERTIES: "IfcGeneralProfileProperties",
  IFCGENERALMATERIALPROPERTIES: "IfcGeneralMaterialProperties",
  IFCFUELPROPERTIES: "IfcFuelProperties",
  IFCFILLAREASTYLE: "IfcFillAreaStyle",
  IFCFAILURECONNECTIONCONDITION: "IfcFailureConnectionCondition",
  IFCFACESURFACE: "IfcFaceSurface",
  IFCFACEOUTERBOUND: "IfcFaceOuterBound",
  IFCFACEBOUND: "IfcFaceBound",
  IFCFACE: "IfcFace",
  IFCEXTENDEDMATERIALPROPERTIES: "IfcExtendedMaterialProperties",
  IFCEDGECURVE: "IfcEdgeCurve",
  IFCEDGE: "IfcEdge",
  IFCDRAUGHTINGPREDEFINEDTEXTFONT: "IfcDraughtingPredefinedTextFont",
  IFCDOCUMENTREFERENCE: "IfcDocumentReference",
  IFCDIMENSIONPAIR: "IfcDimensionPair",
  IFCDIMENSIONCALLOUTRELATIONSHIP: "IfcDimensionCalloutRelationship",
  IFCDERIVEDPROFILEDEF: "IfcDerivedProfileDef",
  IFCCURVESTYLE: "IfcCurveStyle",
  IFCCONVERSIONBASEDUNIT: "IfcConversionBasedUnit",
  IFCCONTEXTDEPENDENTUNIT: "IfcContextDependentUnit",
  IFCCONNECTIONPOINTECCENTRICITY: "IfcConnectionPointEccentricity",
  IFCCONNECTIONCURVEGEOMETRY: "IfcConnectionCurveGeometry",
  IFCCONNECTEDFACESET: "IfcConnectedFaceSet",
  IFCCOMPOSITEPROFILEDEF: "IfcCompositeProfileDef",
  IFCCOMPLEXPROPERTY: "IfcComplexProperty",
  IFCCOLOURRGB: "IfcColourRgb",
  IFCCLASSIFICATIONREFERENCE: "IfcClassificationReference",
  IFCCENTERLINEPROFILEDEF: "IfcCenterLineProfileDef",
  IFCBLOBTEXTURE: "IfcBlobTexture",
  IFCARBITRARYPROFILEDEFWITHVOIDS: "IfcArbitraryProfileDefWithVoids",
  IFCARBITRARYOPENPROFILEDEF: "IfcArbitraryOpenProfileDef",
  IFCARBITRARYCLOSEDPROFILEDEF: "IfcArbitraryClosedProfileDef",
  IFCANNOTATIONTEXTOCCURRENCE: "IfcAnnotationTextOccurrence",
  IFCANNOTATIONSYMBOLOCCURRENCE: "IfcAnnotationSymbolOccurrence",
  IFCANNOTATIONSURFACEOCCURRENCE: "IfcAnnotationSurfaceOccurrence",
  IFCANNOTATIONOCCURRENCE: "IfcAnnotationOccurrence",
  IFCWATERPROPERTIES: "IfcWaterProperties",
  IFCVIRTUALGRIDINTERSECTION: "IfcVirtualGridIntersection",
  IFCVERTEXPOINT: "IfcVertexPoint",
  IFCVERTEXBASEDTEXTUREMAP: "IfcVertexBasedTextureMap",
  IFCVERTEX: "IfcVertex",
  IFCUNITASSIGNMENT: "IfcUnitAssignment",
  IFCTOPOLOGYREPRESENTATION: "IfcTopologyRepresentation",
  IFCTOPOLOGICALREPRESENTATIONITEM: "IfcTopologicalRepresentationItem",
  IFCTIMESERIESVALUE: "IfcTimeSeriesValue",
  IFCTIMESERIESREFERENCERELATIONSHIP: "IfcTimeSeriesReferenceRelationship",
  IFCTIMESERIES: "IfcTimeSeries",
  IFCTHERMALMATERIALPROPERTIES: "IfcThermalMaterialProperties",
  IFCTEXTUREVERTEX: "IfcTextureVertex",
  IFCTEXTUREMAP: "IfcTextureMap",
  IFCTEXTURECOORDINATEGENERATOR: "IfcTextureCoordinateGenerator",
  IFCTEXTURECOORDINATE: "IfcTextureCoordinate",
  IFCTEXTSTYLEWITHBOXCHARACTERISTICS: "IfcTextStyleWithBoxCharacteristics",
  IFCTEXTSTYLETEXTMODEL: "IfcTextStyleTextModel",
  IFCTEXTSTYLEFORDEFINEDFONT: "IfcTextStyleForDefinedFont",
  IFCTEXTSTYLEFONTMODEL: "IfcTextStyleFontModel",
  IFCTEXTSTYLE: "IfcTextStyle",
  IFCTELECOMADDRESS: "IfcTelecomAddress",
  IFCTABLEROW: "IfcTableRow",
  IFCTABLE: "IfcTable",
  IFCSYMBOLSTYLE: "IfcSymbolStyle",
  IFCSURFACETEXTURE: "IfcSurfaceTexture",
  IFCSURFACESTYLEWITHTEXTURES: "IfcSurfaceStyleWithTextures",
  IFCSURFACESTYLESHADING: "IfcSurfaceStyleShading",
  IFCSURFACESTYLEREFRACTION: "IfcSurfaceStyleRefraction",
  IFCSURFACESTYLELIGHTING: "IfcSurfaceStyleLighting",
  IFCSURFACESTYLE: "IfcSurfaceStyle",
  IFCSTYLEDREPRESENTATION: "IfcStyledRepresentation",
  IFCSTYLEDITEM: "IfcStyledItem",
  IFCSTYLEMODEL: "IfcStyleModel",
  IFCSTRUCTURALLOADTEMPERATURE: "IfcStructuralLoadTemperature",
  IFCSTRUCTURALLOADSTATIC: "IfcStructuralLoadStatic",
  IFCSTRUCTURALLOAD: "IfcStructuralLoad",
  IFCSTRUCTURALCONNECTIONCONDITION: "IfcStructuralConnectionCondition",
  IFCSIMPLEPROPERTY: "IfcSimpleProperty",
  IFCSHAPEREPRESENTATION: "IfcShapeRepresentation",
  IFCSHAPEMODEL: "IfcShapeModel",
  IFCSHAPEASPECT: "IfcShapeAspect",
  IFCSECTIONREINFORCEMENTPROPERTIES: "IfcSectionReinforcementProperties",
  IFCSECTIONPROPERTIES: "IfcSectionProperties",
  IFCSIUNIT: "IfcSIUnit",
  IFCROOT: "IfcRoot",
  IFCRIBPLATEPROFILEPROPERTIES: "IfcRibPlateProfileProperties",
  IFCREPRESENTATIONMAP: "IfcRepresentationMap",
  IFCREPRESENTATIONITEM: "IfcRepresentationItem",
  IFCREPRESENTATIONCONTEXT: "IfcRepresentationContext",
  IFCREPRESENTATION: "IfcRepresentation",
  IFCRELAXATION: "IfcRelaxation",
  IFCREINFORCEMENTBARPROPERTIES: "IfcReinforcementBarProperties",
  IFCREFERENCESVALUEDOCUMENT: "IfcReferencesValueDocument",
  IFCQUANTITYWEIGHT: "IfcQuantityWeight",
  IFCQUANTITYVOLUME: "IfcQuantityVolume",
  IFCQUANTITYTIME: "IfcQuantityTime",
  IFCQUANTITYLENGTH: "IfcQuantityLength",
  IFCQUANTITYCOUNT: "IfcQuantityCount",
  IFCQUANTITYAREA: "IfcQuantityArea",
  IFCPROPERTYENUMERATION: "IfcPropertyEnumeration",
  IFCPROPERTYDEPENDENCYRELATIONSHIP: "IfcPropertyDependencyRelationship",
  IFCPROPERTYCONSTRAINTRELATIONSHIP: "IfcPropertyConstraintRelationship",
  IFCPROPERTY: "IfcProperty",
  IFCPROFILEPROPERTIES: "IfcProfileProperties",
  IFCPROFILEDEF: "IfcProfileDef",
  IFCPRODUCTSOFCOMBUSTIONPROPERTIES: "IfcProductsOfCombustionProperties",
  IFCPRODUCTREPRESENTATION: "IfcProductRepresentation",
  IFCPRESENTATIONSTYLEASSIGNMENT: "IfcPresentationStyleAssignment",
  IFCPRESENTATIONSTYLE: "IfcPresentationStyle",
  IFCPRESENTATIONLAYERWITHSTYLE: "IfcPresentationLayerWithStyle",
  IFCPRESENTATIONLAYERASSIGNMENT: "IfcPresentationLayerAssignment",
  IFCPREDEFINEDTEXTFONT: "IfcPredefinedTextFont",
  IFCPREDEFINEDTERMINATORSYMBOL: "IfcPredefinedTerminatorSymbol",
  IFCPREDEFINEDSYMBOL: "IfcPredefinedSymbol",
  IFCPREDEFINEDITEM: "IfcPredefinedItem",
  IFCPOSTALADDRESS: "IfcPostalAddress",
  IFCPHYSICALSIMPLEQUANTITY: "IfcPhysicalSimpleQuantity",
  IFCPHYSICALQUANTITY: "IfcPhysicalQuantity",
  IFCPERSONANDORGANIZATION: "IfcPersonAndOrganization",
  IFCPERSON: "IfcPerson",
  IFCOWNERHISTORY: "IfcOwnerHistory",
  IFCORGANIZATIONRELATIONSHIP: "IfcOrganizationRelationship",
  IFCORGANIZATION: "IfcOrganization",
  IFCOPTICALMATERIALPROPERTIES: "IfcOpticalMaterialProperties",
  IFCOBJECTIVE: "IfcObjective",
  IFCOBJECTPLACEMENT: "IfcObjectPlacement",
  IFCNAMEDUNIT: "IfcNamedUnit",
  IFCMONETARYUNIT: "IfcMonetaryUnit",
  IFCMETRIC: "IfcMetric",
  IFCMECHANICALSTEELMATERIALPROPERTIES: "IfcMechanicalSteelMaterialProperties",
  IFCMECHANICALMATERIALPROPERTIES: "IfcMechanicalMaterialProperties",
  IFCMEASUREWITHUNIT: "IfcMeasureWithUnit",
  IFCMATERIALPROPERTIES: "IfcMaterialProperties",
  IFCMATERIALLIST: "IfcMaterialList",
  IFCMATERIALLAYERSETUSAGE: "IfcMaterialLayerSetUsage",
  IFCMATERIALLAYERSET: "IfcMaterialLayerSet",
  IFCMATERIALLAYER: "IfcMaterialLayer",
  IFCMATERIALCLASSIFICATIONRELATIONSHIP: "IfcMaterialClassificationRelationship",
  IFCMATERIAL: "IfcMaterial",
  IFCLOCALTIME: "IfcLocalTime",
  IFCLIGHTINTENSITYDISTRIBUTION: "IfcLightIntensityDistribution",
  IFCLIGHTDISTRIBUTIONDATA: "IfcLightDistributionData",
  IFCLIBRARYREFERENCE: "IfcLibraryReference",
  IFCLIBRARYINFORMATION: "IfcLibraryInformation",
  IFCIRREGULARTIMESERIESVALUE: "IfcIrregularTimeSeriesValue",
  IFCGRIDAXIS: "IfcGridAxis",
  IFCEXTERNALLYDEFINEDTEXTFONT: "IfcExternallyDefinedTextFont",
  IFCEXTERNALLYDEFINEDSYMBOL: "IfcExternallyDefinedSymbol",
  IFCEXTERNALLYDEFINEDSURFACESTYLE: "IfcExternallyDefinedSurfaceStyle",
  IFCEXTERNALLYDEFINEDHATCHSTYLE: "IfcExternallyDefinedHatchStyle",
  IFCEXTERNALREFERENCE: "IfcExternalReference",
  IFCENVIRONMENTALIMPACTVALUE: "IfcEnvironmentalImpactValue",
  IFCDRAUGHTINGCALLOUTRELATIONSHIP: "IfcDraughtingCalloutRelationship",
  IFCDOCUMENTINFORMATIONRELATIONSHIP: "IfcDocumentInformationRelationship",
  IFCDOCUMENTINFORMATION: "IfcDocumentInformation",
  IFCDOCUMENTELECTRONICFORMAT: "IfcDocumentElectronicFormat",
  IFCDIMENSIONALEXPONENTS: "IfcDimensionalExponents",
  IFCDERIVEDUNITELEMENT: "IfcDerivedUnitElement",
  IFCDERIVEDUNIT: "IfcDerivedUnit",
  IFCDATEANDTIME: "IfcDateAndTime",
  IFCCURVESTYLEFONTPATTERN: "IfcCurveStyleFontPattern",
  IFCCURVESTYLEFONTANDSCALING: "IfcCurveStyleFontAndScaling",
  IFCCURVESTYLEFONT: "IfcCurveStyleFont",
  IFCCURRENCYRELATIONSHIP: "IfcCurrencyRelationship",
  IFCCOSTVALUE: "IfcCostValue",
  IFCCOORDINATEDUNIVERSALTIMEOFFSET: "IfcCoordinatedUniversalTimeOffset",
  IFCCONSTRAINTRELATIONSHIP: "IfcConstraintRelationship",
  IFCCONSTRAINTCLASSIFICATIONRELATIONSHIP: "IfcConstraintClassificationRelationship",
  IFCCONSTRAINTAGGREGATIONRELATIONSHIP: "IfcConstraintAggregationRelationship",
  IFCCONSTRAINT: "IfcConstraint",
  IFCCONNECTIONSURFACEGEOMETRY: "IfcConnectionSurfaceGeometry",
  IFCCONNECTIONPORTGEOMETRY: "IfcConnectionPortGeometry",
  IFCCONNECTIONPOINTGEOMETRY: "IfcConnectionPointGeometry",
  IFCCONNECTIONGEOMETRY: "IfcConnectionGeometry",
  IFCCOLOURSPECIFICATION: "IfcColourSpecification",
  IFCCLASSIFICATIONNOTATIONFACET: "IfcClassificationNotationFacet",
  IFCCLASSIFICATIONNOTATION: "IfcClassificationNotation",
  IFCCLASSIFICATIONITEMRELATIONSHIP: "IfcClassificationItemRelationship",
  IFCCLASSIFICATIONITEM: "IfcClassificationItem",
  IFCCLASSIFICATION: "IfcClassification",
  IFCCALENDARDATE: "IfcCalendarDate",
  IFCBOUNDARYNODECONDITIONWARPING: "IfcBoundaryNodeConditionWarping",
  IFCBOUNDARYNODECONDITION: "IfcBoundaryNodeCondition",
  IFCBOUNDARYFACECONDITION: "IfcBoundaryFaceCondition",
  IFCBOUNDARYEDGECONDITION: "IfcBoundaryEdgeCondition",
  IFCBOUNDARYCONDITION: "IfcBoundaryCondition",
  IFCAPPROVALRELATIONSHIP: "IfcApprovalRelationship",
  IFCAPPROVALPROPERTYRELATIONSHIP: "IfcApprovalPropertyRelationship",
  IFCAPPROVALACTORRELATIONSHIP: "IfcApprovalActorRelationship",
  IFCAPPROVAL: "IfcApproval",
  IFCAPPLIEDVALUERELATIONSHIP: "IfcAppliedValueRelationship",
  IFCAPPLIEDVALUE: "IfcAppliedValue",
  IFCAPPLICATION: "IfcApplication",
  IFCADDRESS: "IfcAddress",
  IFCACTORROLE: "IfcActorRole"
};
var Units = class {
  constructor() {
    __publicField2(this, "factor", 1);
    __publicField2(this, "complement", 1);
  }
  apply(matrix) {
    const scale = this.getScaleMatrix();
    const result = scale.multiply(matrix);
    matrix.copy(result);
  }
  setUp(webIfc) {
    var _a, _b, _c;
    this.factor = 1;
    const length = this.getLengthUnits(webIfc);
    if (!length) {
      return;
    }
    const isLengthNull = length === void 0 || length === null;
    const isValueNull = length.Name === void 0 || length.Name === null;
    if (isLengthNull || isValueNull) {
      return;
    }
    if (length.Name.value === "FOOT") {
      this.factor = 0.3048;
    }
    if (((_a = length.Prefix) == null ? void 0 : _a.value) === "MILLI") {
      this.complement = 1e-3;
    } else if (((_b = length.Prefix) == null ? void 0 : _b.value) === "CENTI") {
      this.complement = 0.01;
    } else if (((_c = length.Prefix) == null ? void 0 : _c.value) === "DECI") {
      this.complement = 0.01;
    }
  }
  getLengthUnits(webIfc) {
    try {
      const allUnitsAssigns = webIfc.GetLineIDsWithType(
        0,
        IFCUNITASSIGNMENT
      );
      const unitsAssign = allUnitsAssigns.get(0);
      const unitsAssignProps = webIfc.GetLine(0, unitsAssign);
      for (const units of unitsAssignProps.Units) {
        if (!units || units.value === null || units.value === void 0) {
          continue;
        }
        const unitsProps = webIfc.GetLine(0, units.value);
        if (unitsProps.UnitType && unitsProps.UnitType.value === "LENGTHUNIT") {
          return unitsProps;
        }
      }
      return null;
    } catch (e) {
      console.log("Could not get units");
      return null;
    }
  }
  getScaleMatrix() {
    const f = this.factor;
    return new Matrix4().fromArray([
      f,
      0,
      0,
      0,
      0,
      f,
      0,
      0,
      0,
      0,
      f,
      0,
      0,
      0,
      0,
      1
    ]);
  }
};
var SpatialStructure = class {
  constructor() {
    __publicField2(this, "itemsByFloor", {});
    __publicField2(this, "_units", new Units());
  }
  // TODO: Maybe make this more flexible so that it also support more exotic spatial structures?
  setUp(webIfc) {
    this._units.setUp(webIfc);
    this.cleanUp();
    try {
      const spatialRels = webIfc.GetLineIDsWithType(
        0,
        IFCRELCONTAINEDINSPATIALSTRUCTURE
      );
      const allRooms = /* @__PURE__ */ new Set();
      const rooms = webIfc.GetLineIDsWithType(0, IFCSPACE);
      for (let i = 0; i < rooms.size(); i++) {
        allRooms.add(rooms.get(i));
      }
      const aggregates = webIfc.GetLineIDsWithType(0, IFCRELAGGREGATES);
      const aggregatesSize = aggregates.size();
      for (let i = 0; i < aggregatesSize; i++) {
        const id = aggregates.get(i);
        const properties = webIfc.GetLine(0, id);
        if (!properties || !properties.RelatingObject || !properties.RelatedObjects) {
          continue;
        }
        const parentID = properties.RelatingObject.value;
        const childsIDs = properties.RelatedObjects;
        for (const child of childsIDs) {
          const childID = child.value;
          if (allRooms.has(childID)) {
            this.itemsByFloor[childID] = parentID;
          }
        }
      }
      const itemsContainedInRooms = {};
      const spatialRelsSize = spatialRels.size();
      for (let i = 0; i < spatialRelsSize; i++) {
        const id = spatialRels.get(i);
        const properties = webIfc.GetLine(0, id);
        if (!properties || !properties.RelatingStructure || !properties.RelatedElements) {
          continue;
        }
        const structureID = properties.RelatingStructure.value;
        const relatedItems = properties.RelatedElements;
        if (allRooms.has(structureID)) {
          for (const related of relatedItems) {
            if (!itemsContainedInRooms[structureID]) {
              itemsContainedInRooms[structureID] = [];
            }
            const id2 = related.value;
            itemsContainedInRooms[structureID].push(id2);
          }
        } else {
          for (const related of relatedItems) {
            const id2 = related.value;
            this.itemsByFloor[id2] = structureID;
          }
        }
      }
      for (const roomID in itemsContainedInRooms) {
        const roomFloor = this.itemsByFloor[roomID];
        if (roomFloor !== void 0) {
          const items = itemsContainedInRooms[roomID];
          for (const item of items) {
            this.itemsByFloor[item] = roomFloor;
          }
        }
      }
      for (let i = 0; i < aggregatesSize; i++) {
        const id = aggregates.get(i);
        const properties = webIfc.GetLine(0, id);
        if (!properties || !properties.RelatingObject || !properties.RelatedObjects) {
          continue;
        }
        const parentID = properties.RelatingObject.value;
        const childsIDs = properties.RelatedObjects;
        for (const child of childsIDs) {
          const childID = child.value;
          const parentStructure = this.itemsByFloor[parentID];
          if (parentStructure !== void 0) {
            this.itemsByFloor[childID] = parentStructure;
          }
        }
      }
    } catch (e) {
      console.log("Could not get floors.");
    }
  }
  cleanUp() {
    this.itemsByFloor = {};
  }
};
var IfcFragmentSettings = class {
  constructor() {
    __publicField2(this, "includeProperties", true);
    __publicField2(this, "optionalCategories", [IFCSPACE]);
    __publicField2(this, "wasm", {
      path: "",
      absolute: false,
      logLevel: LogLevel.LOG_LEVEL_OFF
    });
    __publicField2(this, "excludedCategories", /* @__PURE__ */ new Set());
    __publicField2(this, "includedCategories", /* @__PURE__ */ new Set());
    __publicField2(this, "saveLocations", false);
    __publicField2(this, "webIfc", {
      COORDINATE_TO_ORIGIN: true
      // OPTIMIZE_PROFILES: true,
    });
    __publicField2(this, "autoSetWasm", true);
    __publicField2(this, "customLocateFileHandler", null);
  }
};
var CivilReader = class {
  constructor() {
    __publicField2(this, "defLineMat", new LineBasicMaterial({ color: 16777215 }));
  }
  read(webIfc) {
    const IfcAlignment = webIfc.GetAllAlignments(0);
    const IfcCrossSection2D = webIfc.GetAllCrossSections2D(0);
    const IfcCrossSection3D = webIfc.GetAllCrossSections3D(0);
    const civilItems = {
      IfcAlignment,
      IfcCrossSection2D,
      IfcCrossSection3D
    };
    return this.get(civilItems);
  }
  get(civilItems) {
    if (civilItems.IfcAlignment) {
      const alignments = /* @__PURE__ */ new Map();
      for (const ifcAlign of civilItems.IfcAlignment) {
        const alignment = new Alignment3();
        alignment.absolute = this.getCurves(ifcAlign.curve3D, alignment);
        alignment.horizontal = this.getCurves(ifcAlign.horizontal, alignment);
        alignment.vertical = this.getCurves(ifcAlign.vertical, alignment);
        alignments.set(alignments.size, alignment);
      }
      return { alignments, coordinationMatrix: new Matrix4() };
    }
    return void 0;
  }
  getCurves(ifcAlignData, alignment) {
    const curves = [];
    let index = 0;
    for (const curve of ifcAlignData) {
      const data = {};
      if (curve.data) {
        for (const entry of curve.data) {
          const [key, value] = entry.split(": ");
          const numValue = parseFloat(value);
          data[key] = numValue || value;
        }
      }
      const { points } = curve;
      const array = new Float32Array(points.length * 3);
      for (let i = 0; i < points.length; i++) {
        const { x, y, z } = points[i];
        array[i * 3] = x;
        array[i * 3 + 1] = y;
        array[i * 3 + 2] = z || 0;
      }
      const attr = new BufferAttribute(array, 3);
      const geometry = new EdgesGeometry();
      geometry.setAttribute("position", attr);
      const mesh = new CurveMesh(
        index,
        data,
        alignment,
        geometry,
        this.defLineMat
      );
      curves.push(mesh.curve);
      index++;
    }
    return curves;
  }
};
var IfcMetadataReader = class {
  getNameInfo(webIfc) {
    var _a;
    const data = {};
    const { arguments: dataArguments } = webIfc.GetHeaderLine(0, FILE_NAME) || {};
    if (!dataArguments)
      return data;
    const [
      name,
      timeStamp,
      author,
      organization,
      preprocessorVersion,
      originatingSystem,
      authorization
    ] = dataArguments;
    if (name == null ? void 0 : name.value)
      data.name = name.value;
    if (timeStamp == null ? void 0 : timeStamp.value)
      data.creationDate = new Date(timeStamp.value);
    if (author) {
      data.author = {};
      const [authorName, authorEmail] = author;
      if (authorName == null ? void 0 : authorName.value)
        data.author.name = authorName.value;
      if (authorEmail == null ? void 0 : authorEmail.value)
        data.author.email = authorEmail.value;
    }
    if (organization && ((_a = organization[0]) == null ? void 0 : _a.value)) {
      data.organization = organization[0].value;
    }
    if (preprocessorVersion == null ? void 0 : preprocessorVersion.value) {
      data.preprocessorVersion = preprocessorVersion == null ? void 0 : preprocessorVersion.value;
    }
    if (originatingSystem == null ? void 0 : originatingSystem.value) {
      data.originatingSystem = originatingSystem == null ? void 0 : originatingSystem.value;
    }
    if (authorization == null ? void 0 : authorization.value) {
      data.authorization = authorization == null ? void 0 : authorization.value;
    }
    return data;
  }
  getDescriptionInfo(webIfc) {
    var _a;
    const data = {};
    const { arguments: dataArguments } = webIfc.GetHeaderLine(0, FILE_DESCRIPTION) || {};
    if (!dataArguments)
      return data;
    const [description, implementationLevel] = dataArguments;
    if (Array.isArray(description) && ((_a = description[0]) == null ? void 0 : _a.value)) {
      const viewDefinition = description[0].value.match(/\[([^\]]+)\]/);
      if (viewDefinition && viewDefinition[1]) {
        data.viewDefinition = viewDefinition[1];
      }
    }
    if (implementationLevel == null ? void 0 : implementationLevel.value)
      data.implementationLevel = implementationLevel.value;
    return data;
  }
};
var SpatialIdsFinder = class {
  static get(model, webIfc) {
    const spatialTypes = [
      IFCPROJECT,
      IFCSITE,
      IFCBUILDING,
      IFCBUILDINGSTOREY,
      IFCSPACE,
      IFCROAD,
      IFCFACILITY,
      IFCFACILITYPART,
      IFCBRIDGE
    ];
    const data = model.data;
    for (const category of spatialTypes) {
      const ids = webIfc.GetLineIDsWithType(0, category);
      const size = ids.size();
      for (let i = 0; i < size; i++) {
        const id = ids.get(i);
        if (!data.has(id)) {
          data.set(id, [[], [0, category]]);
        }
      }
    }
  }
};
var GeometryTypes = /* @__PURE__ */ new Set([
  1123145078,
  574549367,
  1675464909,
  2059837836,
  3798115385,
  32440307,
  3125803723,
  3207858831,
  2740243338,
  2624227202,
  4240577450,
  3615266464,
  3724593414,
  220341763,
  477187591,
  1878645084,
  1300840506,
  3303107099,
  1607154358,
  1878645084,
  846575682,
  1351298697,
  2417041796,
  3049322572,
  3331915920,
  1416205885,
  776857604,
  3285139300,
  3958052878,
  2827736869,
  2732653382,
  673634403,
  3448662350,
  4142052618,
  2924175390,
  803316827,
  2556980723,
  1809719519,
  2205249479,
  807026263,
  3737207727,
  1660063152,
  2347385850,
  2705031697,
  3732776249,
  2485617015,
  2611217952,
  1704287377,
  2937912522,
  2770003689,
  1281925730,
  1484403080,
  3448662350,
  4142052618,
  3800577675,
  4006246654,
  3590301190,
  1383045692,
  2775532180,
  2047409740,
  370225590,
  3593883385,
  2665983363,
  4124623270,
  812098782,
  3649129432,
  987898635,
  1105321065,
  3510044353,
  1635779807,
  2603310189,
  3406155212,
  1310608509,
  4261334040,
  2736907675,
  3649129432,
  1136057603,
  1260505505,
  4182860854,
  2713105998,
  2898889636,
  59481748,
  3749851601,
  3486308946,
  3150382593,
  1062206242,
  3264961684,
  15328376,
  1485152156,
  370225590,
  1981873012,
  2859738748,
  45288368,
  2614616156,
  2732653382,
  775493141,
  2147822146,
  2601014836,
  2629017746,
  1186437898,
  2367409068,
  1213902940,
  3632507154,
  3900360178,
  476780140,
  1472233963,
  2804161546,
  3008276851,
  738692330,
  374418227,
  315944413,
  3905492369,
  3570813810,
  2571569899,
  178912537,
  2294589976,
  1437953363,
  2133299955,
  572779678,
  3092502836,
  388784114,
  2624227202,
  1425443689,
  3057273783,
  2347385850,
  1682466193,
  2519244187,
  2839578677,
  3958567839,
  2513912981,
  2830218821,
  427810014,
  2916149573
]);
var _IfcJsonExporter = class _IfcJsonExporter2 extends Component {
  constructor(components) {
    super(components);
    __publicField2(this, "enabled", true);
    components.add(_IfcJsonExporter2.uuid, this);
  }
  /**
   * Exports all the properties of an IFC into an array of JS objects.
   * @param webIfc The instance of [web-ifc](https://github.com/ThatOpen/engine_web-ifc) to use.
   * @param modelID ID of the IFC model whose properties to extract.
   * @param indirect whether to get the indirect relationships as well.
   * @param recursiveSpatial whether to get the properties of spatial items recursively
   * to make the location data available (e.g. absolute position of building).
   */
  async export(webIfc, modelID, indirect = false, recursiveSpatial = true) {
    const properties = {};
    const allIfcEntities = new Set(webIfc.GetIfcEntityList(modelID));
    const spatialStructure = /* @__PURE__ */ new Set([
      IFCPROJECT,
      IFCSITE,
      IFCBUILDING,
      IFCBUILDINGSTOREY,
      IFCSPACE
    ]);
    for (const type of spatialStructure) {
      allIfcEntities.add(type);
    }
    for (const type of allIfcEntities) {
      if (GeometryTypes.has(type)) {
        continue;
      }
      const recursive = spatialStructure.has(type) && recursiveSpatial;
      const ids = webIfc.GetLineIDsWithType(modelID, type);
      for (const id of ids) {
        try {
          const property = webIfc.GetLine(0, id, recursive, indirect);
          properties[property.expressID] = property;
        } catch (e) {
          console.log(
            `Could not get property ${id}, with recursive ${recursive} and indirect ${indirect}.`
          );
        }
      }
    }
    return properties;
  }
};
__publicField2(_IfcJsonExporter, "uuid", "b32c4332-cd67-436e-ba7f-196646c7a635");
var IfcJsonExporter = _IfcJsonExporter;
var _IfcLoader = class _IfcLoader2 extends Component {
  constructor(components) {
    super(components);
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "onIfcStartedLoading", new Event());
    __publicField2(this, "onSetup", new Event());
    __publicField2(this, "settings", new IfcFragmentSettings());
    __publicField2(this, "webIfc", new IfcAPI2());
    __publicField2(this, "enabled", true);
    __publicField2(this, "_material", new MeshLambertMaterial());
    __publicField2(this, "_spatialTree", new SpatialStructure());
    __publicField2(this, "_metaData", new IfcMetadataReader());
    __publicField2(this, "_fragmentInstances", /* @__PURE__ */ new Map());
    __publicField2(this, "_civil", new CivilReader());
    __publicField2(this, "_visitedFragments", /* @__PURE__ */ new Map());
    __publicField2(this, "_materialT", new MeshLambertMaterial({
      transparent: true,
      opacity: 0.5
    }));
    this.components.add(_IfcLoader2.uuid, this);
    this.settings.excludedCategories.add(IFCOPENINGELEMENT);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.webIfc = null;
    this.onDisposed.trigger(_IfcLoader2.uuid);
    this.onDisposed.reset();
  }
  /**
   * Sets up the IfcLoader component with the provided configuration.
   *
   * @param config - Optional configuration settings for the IfcLoader.
   * If not provided, the existing settings will be used.
   *
   * @returns A Promise that resolves when the setup process is completed.
   *
   * @remarks
   * If the `autoSetWasm` option is enabled in the configuration,
   * the method will automatically set the WASM paths for the Web-IFC library.
   *
   * @example
   * ```typescript
   * const ifcLoader = new IfcLoader(components);
   * await ifcLoader.setup({ autoSetWasm: true });
   * ```
   */
  async setup(config) {
    this.settings = { ...this.settings, ...config };
    if (this.settings.autoSetWasm) {
      await this.autoSetWasm();
    }
    this.onSetup.trigger();
  }
  /**
   * Loads an IFC file and processes it for 3D visualization.
   *
   * @param data - The Uint8Array containing the IFC file data.
   * @param coordinate - Optional boolean indicating whether to coordinate the loaded IFC data. Default is true.
   *
   * @returns A Promise that resolves to the FragmentsGroup containing the loaded and processed IFC data.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * const group = await ifcLoader.load(ifcData);
   * ```
   */
  async load(data, coordinate = true, name = "") {
    const before = performance.now();
    this.onIfcStartedLoading.trigger();
    await this.readIfcFile(data);
    const group = await this.getAllGeometries();
    group.name = name;
    const jsonExporter = this.components.get(IfcJsonExporter);
    const properties = await jsonExporter.export(this.webIfc, 0);
    group.setLocalProperties(properties);
    const fragments = this.components.get(FragmentsManager);
    fragments.groups.set(group.uuid, group);
    for (const frag of group.items) {
      fragments.list.set(frag.id, frag);
      frag.mesh.uuid = frag.id;
      frag.group = group;
    }
    fragments.onFragmentsLoaded.trigger(group);
    if (coordinate) {
      fragments.coordinate([group]);
    }
    for (const [expressID] of group.data) {
      const props = properties[expressID];
      if (!props || !props.GlobalId)
        continue;
      const globalID = props.GlobalId.value || props.GlobalId;
      group.globalToExpressIDs.set(globalID, expressID);
    }
    SpatialIdsFinder.get(group, this.webIfc);
    this.cleanUp();
    console.log(`Streaming the IFC took ${performance.now() - before} ms!`);
    return group;
  }
  /**
   * Reads an IFC file and initializes the Web-IFC library.
   *
   * @param data - The Uint8Array containing the IFC file data.
   *
   * @returns A Promise that resolves when the IFC file is opened and initialized.
   *
   * @remarks
   * This method sets the WASM path and initializes the Web-IFC library based on the provided settings.
   * It also opens the IFC model using the provided data and settings.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * await ifcLoader.readIfcFile(ifcData);
   * ```
   */
  async readIfcFile(data) {
    const { path, absolute, logLevel } = this.settings.wasm;
    this.webIfc.SetWasmPath(path, absolute);
    await this.webIfc.Init(this.settings.customLocateFileHandler || void 0);
    if (logLevel) {
      this.webIfc.SetLogLevel(logLevel);
    }
    return this.webIfc.OpenModel(data, this.settings.webIfc);
  }
  /**
   * Cleans up the IfcLoader component by resetting the Web-IFC library,
   * clearing the visited fragments and fragment instances maps, and creating a new instance of the Web-IFC library.
   *
   * @remarks
   * This method is called automatically after using the .load() method, so usually you don't need to use it manually.
   *
   * @example
   * ```typescript
   * const ifcLoader = components.get(IfcLoader);
   * ifcLoader.cleanUp();
   * ```
   */
  cleanUp() {
    try {
      this.webIfc.Dispose();
    } catch (e) {
      console.log("Web-ifc wasn't disposed.");
    }
    this.webIfc = null;
    this.webIfc = new IfcAPI2();
    this._visitedFragments.clear();
    this._fragmentInstances.clear();
  }
  async getAllGeometries() {
    this._spatialTree.setUp(this.webIfc);
    const allIfcEntities = this.webIfc.GetIfcEntityList(0);
    const group = new FragmentsGroup3();
    group.ifcMetadata = {
      name: "",
      description: "",
      ...this._metaData.getNameInfo(this.webIfc),
      ...this._metaData.getDescriptionInfo(this.webIfc),
      schema: this.webIfc.GetModelSchema(0) || "IFC2X3",
      maxExpressID: this.webIfc.GetMaxExpressID(0)
    };
    const ids = [];
    for (const type of allIfcEntities) {
      if (!this.webIfc.IsIfcElement(type) && type !== IFCSPACE) {
        continue;
      }
      const included = this.settings.includedCategories;
      if (included.size > 0 && !included.has(type)) {
        continue;
      } else if (this.settings.excludedCategories.has(type)) {
        continue;
      }
      const result = this.webIfc.GetLineIDsWithType(0, type);
      const size = result.size();
      for (let i = 0; i < size; i++) {
        const itemID = result.get(i);
        ids.push(itemID);
        const level = this._spatialTree.itemsByFloor[itemID] || 0;
        group.data.set(itemID, [[], [level, type]]);
      }
    }
    this._spatialTree.cleanUp();
    this.webIfc.StreamMeshes(0, ids, (mesh) => {
      this.getMesh(mesh, group);
    });
    for (const entry of this._visitedFragments) {
      const { index, fragment } = entry[1];
      group.keyFragments.set(index, fragment.id);
    }
    for (const fragment of group.items) {
      const fragmentData = this._fragmentInstances.get(fragment.id);
      if (!fragmentData) {
        throw new Error("Fragment not found!");
      }
      const items = [];
      for (const [_geomID, item] of fragmentData) {
        items.push(item);
      }
      fragment.add(items);
    }
    const matrix = this.webIfc.GetCoordinationMatrix(0);
    group.coordinationMatrix.fromArray(matrix);
    group.civilData = this._civil.read(this.webIfc);
    return group;
  }
  getMesh(mesh, group) {
    const size = mesh.geometries.size();
    const id = mesh.expressID;
    for (let i = 0; i < size; i++) {
      const geometry = mesh.geometries.get(i);
      const { x, y, z, w } = geometry.color;
      const transparent = w !== 1;
      const { geometryExpressID } = geometry;
      const geometryID = `${geometryExpressID}-${transparent}`;
      if (!this._visitedFragments.has(geometryID)) {
        const bufferGeometry = this.getGeometry(this.webIfc, geometryExpressID);
        const material = transparent ? this._materialT : this._material;
        const fragment2 = new Fragment$2(bufferGeometry, material, 1);
        group.add(fragment2.mesh);
        group.items.push(fragment2);
        const index = this._visitedFragments.size;
        this._visitedFragments.set(geometryID, { index, fragment: fragment2 });
      }
      const color = new Color().setRGB(x, y, z, "srgb");
      const transform = new Matrix4();
      transform.fromArray(geometry.flatTransformation);
      const fragmentData = this._visitedFragments.get(geometryID);
      if (fragmentData === void 0) {
        throw new Error("Error getting geometry data for streaming!");
      }
      const data = group.data.get(id);
      if (!data) {
        throw new Error("Data not found!");
      }
      data[0].push(fragmentData.index);
      const { fragment } = fragmentData;
      if (!this._fragmentInstances.has(fragment.id)) {
        this._fragmentInstances.set(fragment.id, /* @__PURE__ */ new Map());
      }
      const instances = this._fragmentInstances.get(fragment.id);
      if (!instances) {
        throw new Error("Instances not found!");
      }
      if (instances.has(id)) {
        const instance = instances.get(id);
        if (!instance) {
          throw new Error("Instance not found!");
        }
        instance.transforms.push(transform);
        if (instance.colors) {
          instance.colors.push(color);
        }
      } else {
        instances.set(id, { id, transforms: [transform], colors: [color] });
      }
    }
  }
  getGeometry(webIfc, id) {
    const geometry = webIfc.GetGeometry(0, id);
    const index = webIfc.GetIndexArray(
      geometry.GetIndexData(),
      geometry.GetIndexDataSize()
    );
    const vertexData = webIfc.GetVertexArray(
      geometry.GetVertexData(),
      geometry.GetVertexDataSize()
    );
    const position = new Float32Array(vertexData.length / 2);
    const normal = new Float32Array(vertexData.length / 2);
    for (let i = 0; i < vertexData.length; i += 6) {
      position[i / 2] = vertexData[i];
      position[i / 2 + 1] = vertexData[i + 1];
      position[i / 2 + 2] = vertexData[i + 2];
      normal[i / 2] = vertexData[i + 3];
      normal[i / 2 + 1] = vertexData[i + 4];
      normal[i / 2 + 2] = vertexData[i + 5];
    }
    const bufferGeometry = new BufferGeometry();
    const posAttr = new BufferAttribute(position, 3);
    const norAttr = new BufferAttribute(normal, 3);
    bufferGeometry.setAttribute("position", posAttr);
    bufferGeometry.setAttribute("normal", norAttr);
    bufferGeometry.setIndex(Array.from(index));
    geometry.delete();
    return bufferGeometry;
  }
  async autoSetWasm() {
    const componentsPackage = await fetch(
      `https://unpkg.com/@thatopen/components@${Components.release}/package.json`
    );
    if (!componentsPackage.ok) {
      console.warn(
        "Couldn't get openbim-components package.json. Set wasm settings manually."
      );
      return;
    }
    const componentsPackageJSON = await componentsPackage.json();
    if (!("web-ifc" in componentsPackageJSON.peerDependencies)) {
      console.warn(
        "Couldn't get web-ifc from peer dependencies in openbim-components. Set wasm settings manually."
      );
    } else {
      const webIfcVer = componentsPackageJSON.peerDependencies["web-ifc"];
      this.settings.wasm.path = `https://unpkg.com/web-ifc@${webIfcVer}/`;
      this.settings.wasm.absolute = true;
    }
  }
};
__publicField2(_IfcLoader, "uuid", "a659add7-1418-4771-a0d6-7d4d438e4624");
var IfcLoader = _IfcLoader;
var ifcRelAttrsPosition = {
  // IfcRelAssigns
  IfcRelAssignsToControl: { related: 5, relating: 7 },
  IfcRelAssignsToGroup: { related: 5, relating: 7 },
  IfcRelAssignsToProduct: { related: 5, relating: 7 },
  // IfcRelAssociates
  IfcRelAssociatesClassification: { related: 5, relating: 6 },
  IfcRelAssociatesMaterial: { related: 5, relating: 6 },
  IfcRelAssociatesDocument: { related: 5, relating: 6 },
  // IfcRelConnects
  IfcRelContainedInSpatialStructure: { related: 5, relating: 6 },
  IfcRelFlowControlElements: { related: 5, relating: 6 },
  IfcRelConnectsElements: { related: 7, relating: 6 },
  // IfcRelDeclares
  IfcRelDeclares: { related: 6, relating: 5 },
  // IfcRelDecomposes
  IfcRelAggregates: { related: 6, relating: 5 },
  IfcRelNests: { related: 6, relating: 5 },
  // IfcRelDefines
  IfcRelDefinesByProperties: { related: 5, relating: 6 },
  IfcRelDefinesByType: { related: 5, relating: 6 },
  IfcRelDefinesByTemplate: { related: 5, relating: 6 }
};
var ifcRelClassNames = {
  // IfcRelAssigns
  [IFCRELASSIGNSTOCONTROL]: "IfcRelAssignsToControl",
  [IFCRELASSIGNSTOGROUP]: "IfcRelAssignsToGroup",
  [IFCRELASSIGNSTOPRODUCT]: "IfcRelAssignsToProduct",
  // IfcRelAssociates
  [IFCRELASSOCIATESCLASSIFICATION]: "IfcRelAssociatesClassification",
  [IFCRELASSOCIATESMATERIAL]: "IfcRelAssociatesMaterial",
  [IFCRELASSOCIATESDOCUMENT]: "IfcRelAssociatesDocument",
  // IfcRelConnects
  [IFCRELCONTAINEDINSPATIALSTRUCTURE]: "IfcRelContainedInSpatialStructure",
  [IFCRELCONNECTSELEMENTS]: "IfcRelConnectsElements",
  [IFCRELFLOWCONTROLELEMENTS]: "IfcRelFlowControlElements",
  // IfcRelDeclares
  [IFCRELDECLARES]: "IfcRelDeclares",
  // IfcRelDecomposes
  [IFCRELAGGREGATES]: "IfcRelAggregates",
  [IFCRELNESTS]: "IfcRelNests",
  // IfcRelDefines
  [IFCRELDEFINESBYPROPERTIES]: "IfcRelDefinesByProperties",
  [IFCRELDEFINESBYTYPE]: "IfcRelDefinesByType",
  [IFCRELDEFINESBYTEMPLATE]: "IfcRelDefinesByTemplate"
};
var _IfcPropertiesManager = class _IfcPropertiesManager2 extends Component {
  constructor(components) {
    super(components);
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "onRequestFile", new Event());
    __publicField2(this, "ifcToExport", null);
    __publicField2(this, "onElementToPset", new Event());
    __publicField2(this, "onPropToPset", new Event());
    __publicField2(this, "onPsetRemoved", new Event());
    __publicField2(this, "onDataChanged", new Event());
    __publicField2(this, "wasm", {
      path: "/",
      absolute: false
    });
    __publicField2(this, "enabled", true);
    __publicField2(this, "attributeListeners", {});
    __publicField2(this, "selectedModel");
    __publicField2(this, "changeMap", {});
    this.components.add(_IfcPropertiesManager2.uuid, this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.selectedModel = void 0;
    this.attributeListeners = {};
    this.changeMap = {};
    this.onElementToPset.reset();
    this.onPropToPset.reset();
    this.onPsetRemoved.reset();
    this.onDataChanged.reset();
    this.onDisposed.trigger(_IfcPropertiesManager2.uuid);
    this.onDisposed.reset();
  }
  /**
   * Static method to retrieve the IFC schema from a given model.
   *
   * @param model - The FragmentsGroup model from which to retrieve the IFC schema.
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @returns The IFC schema associated with the given model.
   */
  static getIFCSchema(model) {
    const schema = model.ifcMetadata.schema;
    if (!schema) {
      throw new Error("IFC Schema not found");
    }
    if (schema.startsWith("IFC2X3")) {
      return "IFC2X3";
    }
    if (schema.startsWith("IFC4") && schema.replace("IFC4", "") === "") {
      return "IFC4";
    }
    if (schema.startsWith("IFC4X3")) {
      return "IFC4X3";
    }
    return schema;
  }
  /**
   * Method to add or update entity attributes in the model.
   *
   * @param model - The FragmentsGroup model in which to set the properties.
   * @param dataToSave - An array of objects representing the properties to be saved.
   * Each object must have an `expressID` property, which is the express ID of the entity in the model.
   * The rest of the properties will be set as the properties of the entity.
   *
   * @returns A promise that resolves when all the properties have been set.
   *
   * @throws Will throw an error if any of the `expressID` properties are missing in the `dataToSave` array.
   */
  async setData(model, ...dataToSave) {
    for (const data of dataToSave) {
      const { expressID } = data;
      if (!expressID || expressID === -1) {
        data.expressID = this.getNewExpressID(model);
      }
      await model.setProperties(data.expressID, data);
      this.registerChange(model, data.expressID);
    }
  }
  /**
   * Creates a new Property Set (Pset) in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the Pset.
   * @param name - The name of the Pset.
   * @param description - (Optional) The description of the Pset.
   *
   * @returns A promise that resolves with an object containing the newly created Pset and its relation.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  async newPset(model, name, description) {
    const schema = _IfcPropertiesManager2.getIFCSchema(model);
    const { handle: ownerHistoryHandle } = await this.getOwnerHistory(model);
    const psetGlobalId = this.newGUID(model);
    const psetName = new web_ifc_api_exports[schema].IfcLabel(name);
    const psetDescription = description ? new web_ifc_api_exports[schema].IfcText(description) : null;
    const pset = new web_ifc_api_exports[schema].IfcPropertySet(
      psetGlobalId,
      ownerHistoryHandle,
      psetName,
      psetDescription,
      []
    );
    pset.expressID = this.getNewExpressID(model);
    await this.setData(model, pset);
    return { pset };
  }
  /**
   * Removes a Property Set (Pset) from the given model.
   *
   * @param model - The FragmentsGroup model from which to remove the Pset.
   * @param psetID - The express IDs of the Psets to be removed.
   *
   * @returns A promise that resolves when all the Psets have been removed.
   *
   * @throws Will throw an error if any of the `expressID` properties are missing in the `psetID` array.
   * @throws Will throw an error if the Pset to be removed is not of type `IFCPROPERTYSET`.
   * @throws Will throw an error if no relation is found between the Pset and the model.
   */
  async removePset(model, ...psetID) {
    for (const expressID of psetID) {
      const pset = await model.getProperties(expressID);
      if ((pset == null ? void 0 : pset.type) !== IFCPROPERTYSET)
        continue;
      const relID = await IfcPropertiesUtils.getPsetRel(model, expressID);
      if (relID) {
        await model.setProperties(relID, null);
        this.registerChange(model, relID);
      }
      if (pset) {
        for (const propHandle of pset.HasProperties) {
          await model.setProperties(propHandle.value, null);
        }
        await model.setProperties(expressID, null);
        this.onPsetRemoved.trigger({ model, psetID: expressID });
        this.registerChange(model, expressID);
      }
    }
  }
  /**
   * Creates a new single-value property of type string in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the property.
   * @param type - The type of the property value. Must be a string property type.
   * @param name - The name of the property.
   * @param value - The value of the property. Must be a string.
   *
   * @returns The newly created single-value property.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  newSingleStringProperty(model, type, name, value) {
    return this.newSingleProperty(model, type, name, value);
  }
  /**
   * Creates a new single-value property of type numeric in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the property.
   * @param type - The type of the property value. Must be a numeric property type.
   * @param name - The name of the property.
   * @param value - The value of the property. Must be a number.
   *
   * @returns The newly created single-value property.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  newSingleNumericProperty(model, type, name, value) {
    return this.newSingleProperty(model, type, name, value);
  }
  /**
   * Creates a new single-value property of type boolean in the given model.
   *
   * @param model - The FragmentsGroup model in which to create the property.
   * @param type - The type of the property value. Must be a boolean property type.
   * @param name - The name of the property.
   * @param value - The value of the property. Must be a boolean.
   *
   * @returns The newly created single-value property.
   *
   * @throws Will throw an error if the IFC schema is not found in the model.
   * @throws Will throw an error if no OwnerHistory is found in the model.
   */
  newSingleBooleanProperty(model, type, name, value) {
    return this.newSingleProperty(model, type, name, value);
  }
  /**
   * Removes a property from a Property Set (Pset) in the given model.
   *
   * @param model - The FragmentsGroup model from which to remove the property.
   * @param psetID - The express ID of the Pset from which to remove the property.
   * @param propID - The express ID of the property to be removed.
   *
   * @returns A promise that resolves when the property has been removed.
   *
   * @throws Will throw an error if the Pset or the property to be removed are not found in the model.
   * @throws Will throw an error if the Pset to be removed is not of type `IFCPROPERTYSET`.
   */
  async removePsetProp(model, psetID, propID) {
    const pset = await model.getProperties(psetID);
    const prop = await model.getProperties(propID);
    if (!pset || !prop)
      return;
    if (!(pset.type === IFCPROPERTYSET && prop))
      return;
    pset.HasProperties = pset.HasProperties.filter((handle) => {
      return handle.value !== propID;
    });
    await model.setProperties(propID, null);
    this.registerChange(model, psetID, propID);
  }
  /**
   * @deprecated Use indexer.addEntitiesRelation instead. This will be removed in future releases.
   */
  addElementToPset(model, psetID, ...expressIDs) {
    const indexer = this.components.get(IfcRelationsIndexer);
    indexer.addEntitiesRelation(
      model,
      psetID,
      { type: IFCRELDEFINESBYPROPERTIES, inv: "DefinesOcurrence" },
      ...expressIDs
    );
  }
  /**
   * Adds elements to a Property Set (Pset) in the given model.
   *
   * @param model - The FragmentsGroup model in which to add the elements.
   * @param psetID - The express ID of the Pset to which to add the elements.
   * @param elementID - The express IDs of the elements to be added.
   *
   * @returns A promise that resolves when all the elements have been added.
   *
   * @throws Will throw an error if the Pset or the elements to be added are not found in the model.
   * @throws Will throw an error if the Pset to be added to is not of type `IFCPROPERTYSET`.
   * @throws Will throw an error if no relation is found between the Pset and the model.
   */
  async addPropToPset(model, psetID, ...propID) {
    const pset = await model.getProperties(psetID);
    if (!pset)
      return;
    for (const expressID of propID) {
      if (pset.HasProperties.includes(expressID)) {
        continue;
      }
      const elementHandle = new Handle(expressID);
      pset.HasProperties.push(elementHandle);
      this.onPropToPset.trigger({ model, psetID, propID: expressID });
    }
    this.registerChange(model, psetID);
  }
  /**
   * Creates a new instance of a relationship between entities in the IFC model.
   *
   * @param model - The FragmentsGroup model in which to create the relationship.
   * @param type - The type of the relationship to create.
   * @param relatingID - The express ID of the entity that is related to the other entities.
   * @param relatedIDs - The express IDs of the entities that are related to the relating entity.
   *
   * @returns A promise that resolves with the newly created relationship.
   *
   * @throws Will throw an error if the relationship type is unsupported.
   */
  async createIfcRel(model, type, relatingID, relatedIDs) {
    const relName = ifcRelClassNames[type];
    if (!relName) {
      throw new Error(`IfcPropertiesManager: ${relName} is unsoported.`);
    }
    const schema = _IfcPropertiesManager2.getIFCSchema(model);
    const attributePositions = ifcRelAttrsPosition[relName];
    const RelClass = web_ifc_api_exports[schema][relName];
    if (!(attributePositions && RelClass)) {
      throw new Error(`IfcPropertiesManager: ${relName} is unsoported.`);
    }
    const args = [new web_ifc_api_exports[schema].IfcGloballyUniqueId(UUID.create())];
    const { related, relating } = attributePositions;
    const relatedIDsSet = new Set(relatedIDs);
    const relatingHandles = [...relatedIDsSet].map(
      (expressID) => new Handle(expressID)
    );
    const addNulls = (start, end) => {
      for (let i = start; i < end - 1; i++)
        args.push(null);
    };
    if (related < relating) {
      addNulls(1, related);
      args.push(relatingHandles);
      addNulls(related, relating);
      args.push(new Handle(relatingID));
    } else {
      addNulls(1, relating);
      addNulls(relating, related);
      args.push(new Handle(relatingID));
      args.push(relatingHandles);
    }
    const ifcRel = new RelClass(...args);
    await this.setData(model, ifcRel);
    return ifcRel;
  }
  /**
   * Saves the changes made to the model to a new IFC file.
   *
   * @param model - The FragmentsGroup model from which to save the changes.
   * @param ifcToSaveOn - The Uint8Array representing the original IFC file.
   *
   * @returns A promise that resolves with the modified IFC data as a Uint8Array.
   *
   * @throws Will throw an error if any issues occur during the saving process.
   */
  async saveToIfc(model, ifcToSaveOn) {
    const ifcLoader = this.components.get(IfcLoader);
    const ifcApi = ifcLoader.webIfc;
    const modelID = await ifcLoader.readIfcFile(ifcToSaveOn);
    const indexer = this.components.get(IfcRelationsIndexer);
    await indexer.applyRelationChanges();
    const changes = this.changeMap[model.uuid] ?? [];
    for (const expressID of changes) {
      const data = await model.getProperties(expressID);
      if (!data) {
        const existed = ifcApi.GetLine(modelID, expressID);
        if (existed)
          ifcApi.DeleteLine(modelID, expressID);
      } else {
        ifcApi.WriteLine(modelID, data);
      }
    }
    const modifiedIFC = ifcApi.SaveModel(modelID);
    ifcLoader.webIfc.CloseModel(modelID);
    ifcLoader.cleanUp();
    return modifiedIFC;
  }
  /**
   * Retrieves all the entities of a specific type from the model and returns their express IDs wrapped in Handles.
   * This is used to make references of an entity inside another entity attributes.
   *
   * @param model - The FragmentsGroup model from which to retrieve the entities.
   * @param type - The type of the entities to retrieve. This should be the express ID of the IFC type.
   *
   * @returns A promise that resolves with an array of Handles, each containing the express ID of an entity of the specified type.
   * @returns null if the model doesn't have any entity of that type
   */
  async getEntityRef(model, type) {
    const entities = await model.getAllPropertiesOfType(type);
    if (!entities)
      return null;
    const handles = [];
    for (const id in entities) {
      const handle = new Handle(Number(id));
      handles.push(handle);
    }
    return handles;
  }
  /**
   * Sets an attribute listener for a specific attribute of an entity in the model.
   * The listener will trigger an event whenever the attribute's value changes.
   *
   * @param model - The FragmentsGroup model in which to set the attribute listener.
   * @param expressID - The express ID of the entity for which to set the listener.
   * @param attributeName - The name of the attribute for which to set the listener.
   *
   * @returns The event that will be triggered when the attribute's value changes.
   *
   * @throws Will throw an error if the entity with the given expressID doesn't exist.
   * @throws Will throw an error if the attribute is an array or null, and it can't have a listener.
   * @throws Will throw an error if the attribute has a badly defined handle.
   */
  async setAttributeListener(model, expressID, attributeName) {
    if (!this.attributeListeners[model.uuid])
      this.attributeListeners[model.uuid] = {};
    const existingListener = this.attributeListeners[model.uuid][expressID] ? this.attributeListeners[model.uuid][expressID][attributeName] : null;
    if (existingListener)
      return existingListener;
    const entity = await model.getProperties(expressID);
    if (!entity) {
      throw new Error(`Entity with expressID ${expressID} doesn't exists.`);
    }
    const attribute = entity[attributeName];
    if (Array.isArray(attribute) || !attribute) {
      throw new Error(
        `Attribute ${attributeName} is array or null, and it can't have a listener.`
      );
    }
    const value = attribute.value;
    if (value === void 0 || value == null) {
      throw new Error(`Attribute ${attributeName} has a badly defined handle.`);
    }
    const event = new Event();
    Object.defineProperty(entity[attributeName], "value", {
      get() {
        return this._value;
      },
      async set(value2) {
        this._value = value2;
        event.trigger(value2);
      }
    });
    entity[attributeName].value = value;
    if (!this.attributeListeners[model.uuid][expressID])
      this.attributeListeners[model.uuid][expressID] = {};
    this.attributeListeners[model.uuid][expressID][attributeName] = event;
    return event;
  }
  getNewExpressID(model) {
    model.ifcMetadata.maxExpressID++;
    return model.ifcMetadata.maxExpressID;
  }
  newGUID(model) {
    const schema = _IfcPropertiesManager2.getIFCSchema(model);
    return new web_ifc_api_exports[schema].IfcGloballyUniqueId(UUID.create());
  }
  async getOwnerHistory(model) {
    const ownerHistories = await model.getAllPropertiesOfType(
      IFCOWNERHISTORY
    );
    if (!ownerHistories) {
      throw new Error("No OwnerHistory was found.");
    }
    const keys = Object.keys(ownerHistories).map((key) => parseInt(key, 10));
    const entity = ownerHistories[keys[0]];
    const handle = new Handle(entity.expressID);
    return { entity, handle };
  }
  registerChange(model, ...expressID) {
    if (!this.changeMap[model.uuid]) {
      this.changeMap[model.uuid] = /* @__PURE__ */ new Set();
    }
    for (const id of expressID) {
      this.changeMap[model.uuid].add(id);
      this.onDataChanged.trigger({ model, expressID: id });
    }
  }
  async newSingleProperty(model, type, name, value) {
    const schema = _IfcPropertiesManager2.getIFCSchema(model);
    const propName2 = new web_ifc_api_exports[schema].IfcIdentifier(name);
    const propValue = new web_ifc_api_exports[schema][type](value);
    const prop = new web_ifc_api_exports[schema].IfcPropertySingleValue(
      propName2,
      null,
      propValue,
      null
    );
    prop.expressID = this.getNewExpressID(model);
    await this.setData(model, prop);
    return prop;
  }
};
__publicField2(_IfcPropertiesManager, "uuid", "58c2d9f0-183c-48d6-a402-dfcf5b9a34df");
var IfcPropertiesManager = _IfcPropertiesManager;
var _IfcRelationsIndexer = class _IfcRelationsIndexer2 extends Component {
  constructor(components) {
    super(components);
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "onRelationsIndexed", new Event());
    __publicField2(this, "relationMaps", {});
    __publicField2(this, "enabled", true);
    __publicField2(this, "_relToAttributesMap", relToAttributesMap);
    __publicField2(this, "_inverseAttributes", [
      "IsDecomposedBy",
      "Decomposes",
      "AssociatedTo",
      "HasAssociations",
      "ClassificationForObjects",
      "IsGroupedBy",
      "HasAssignments",
      "IsDefinedBy",
      "DefinesOcurrence",
      "IsTypedBy",
      "Types",
      "Defines",
      "ContainedInStructure",
      "ContainsElements",
      "HasControlElements",
      "AssignedToFlowElement",
      "ConnectedTo",
      "ConnectedFrom",
      "ReferencedBy",
      "Declares",
      "HasContext",
      "Controls",
      "IsNestedBy",
      "Nests",
      "DocumentRefForObjects"
    ]);
    __publicField2(this, "_ifcRels", [
      IFCRELAGGREGATES,
      IFCRELASSOCIATESMATERIAL,
      IFCRELASSOCIATESCLASSIFICATION,
      IFCRELASSIGNSTOGROUP,
      IFCRELDEFINESBYPROPERTIES,
      IFCRELDEFINESBYTYPE,
      IFCRELDEFINESBYTEMPLATE,
      IFCRELCONTAINEDINSPATIALSTRUCTURE,
      IFCRELFLOWCONTROLELEMENTS,
      IFCRELCONNECTSELEMENTS,
      IFCRELASSIGNSTOPRODUCT,
      IFCRELDECLARES,
      IFCRELASSIGNSTOCONTROL,
      IFCRELNESTS,
      IFCRELASSOCIATESDOCUMENT
    ]);
    __publicField2(this, "onFragmentsDisposed", (data) => {
      delete this.relationMaps[data.groupID];
    });
    __publicField2(this, "_changeMap", {});
    __publicField2(this, "onEntitiesRelated", new Event());
    this.components.add(_IfcRelationsIndexer2.uuid, this);
    const fragmentManager = components.get(FragmentsManager);
    fragmentManager.onFragmentsDisposed.add(this.onFragmentsDisposed);
  }
  indexRelations(relationsMap, relAttrs, related, relating) {
    const relatingKey = Object.keys(relAttrs).find(
      (key) => key.startsWith("Relating")
    );
    const relatedKey = Object.keys(relAttrs).find(
      (key) => key.startsWith("Related")
    );
    if (!(relatingKey && relatedKey))
      return;
    const relatingID = relAttrs[relatingKey].value;
    const relatedIDs = relAttrs[relatedKey].map((el) => el.value);
    const indexMap = this.getEntityRelations(
      relationsMap,
      relatingID,
      relating
    );
    for (const id of relatedIDs) {
      indexMap.push(id);
    }
    for (const id of relatedIDs) {
      const relations = this.getEntityRelations(relationsMap, id, related);
      relations.push(relatingID);
    }
  }
  getAttributeIndex(inverseAttribute) {
    const index = this._inverseAttributes.indexOf(inverseAttribute);
    if (index === -1) {
      throw new Error(
        `IfcRelationsIndexer: ${inverseAttribute} is not a valid IFC Inverse Attribute name or its not supported yet by this component.`
      );
    }
    return index;
  }
  /**
   * Adds a relation map to the model's relations map.
   *
   * @param model - The `FragmentsGroup` model to which the relation map will be added.
   * @param relationMap - The `RelationsMap` to be added to the model's relations map.
   *
   * @fires onRelationsIndexed - Triggers an event with the model's UUID and the added relation map.
   */
  setRelationMap(model, relationMap) {
    this.relationMaps[model.uuid] = relationMap;
    this.onRelationsIndexed.trigger({
      modelID: model.uuid,
      relationsMap: relationMap
    });
  }
  /**
   * Processes a given model to index its IFC entities relations based on predefined inverse attributes.
   * This method iterates through each specified inverse attribute, retrieves the corresponding relations,
   * and maps them in a structured way to facilitate quick access to related entities.
   *
   * The process involves querying the model for each relation type associated with the inverse attributes
   * and updating the internal relationMaps with the relationships found. This map is keyed by the model's UUID
   * and contains a nested map where each key is an entity's expressID and its value is another map.
   * This inner map's keys are the indices of the inverse attributes, and its values are arrays of expressIDs
   * of entities that are related through that attribute.
   *
   * @param model The `FragmentsGroup` model to be processed. It must have properties loaded.
   * @returns A promise that resolves to the relations map for the processed model. This map is a detailed
   * representation of the relations indexed by entity expressIDs and relation types.
   * @throws An error if the model does not have properties loaded.
   */
  async process(model, config) {
    if (!model.hasProperties)
      throw new Error("FragmentsGroup properties not found");
    let relationsMap = this.relationMaps[model.uuid];
    if (!relationsMap) {
      relationsMap = /* @__PURE__ */ new Map();
      this.relationMaps[model.uuid] = relationsMap;
    }
    const entities = model.getLocalProperties();
    if (!entities)
      return relationsMap;
    const relationsToProcess = (config == null ? void 0 : config.relationsToProcess) ?? this._ifcRels;
    for (const [_, entity] of Object.entries(entities)) {
      if (!relationsToProcess.includes(entity.type))
        continue;
      const relInverseAttributes = this._relToAttributesMap.get(entity.type);
      if (!relInverseAttributes) {
        continue;
      }
      const { forRelated: related, forRelating: relating } = relInverseAttributes;
      this.indexRelations(relationsMap, entity, related, relating);
    }
    this.setRelationMap(model, relationsMap);
    return relationsMap;
  }
  /**
   * Processes a given model from a WebIfc API to index its IFC entities relations.
   *
   * @param ifcApi - The WebIfc API instance from which to retrieve the model's properties.
   * @param modelID - The unique identifier of the model within the WebIfc API.
   * @returns A promise that resolves to the relations map for the processed model.
   *          This map is a detailed representation of the relations indexed by entity expressIDs and relation types.
   */
  async processFromWebIfc(ifcApi, modelID) {
    const relationsMap = /* @__PURE__ */ new Map();
    for (const relType of this._ifcRels) {
      const relInverseAttributes = this._relToAttributesMap.get(relType);
      if (!relInverseAttributes)
        continue;
      const { forRelated: related, forRelating: relating } = relInverseAttributes;
      const relExpressIDs = ifcApi.GetLineIDsWithType(modelID, relType);
      for (let i = 0; i < relExpressIDs.size(); i++) {
        const relAttrs = await ifcApi.properties.getItemProperties(
          modelID,
          relExpressIDs.get(i)
        );
        this.indexRelations(relationsMap, relAttrs, related, relating);
      }
    }
    this.onRelationsIndexed.trigger({
      modelID: modelID.toString(),
      relationsMap
    });
    return relationsMap;
  }
  /**
   * Retrieves the relations of a specific entity within a model based on the given relation name.
   * This method searches the indexed relation maps for the specified model and entity,
   * returning the IDs of related entities if a match is found.
   *
   * @param model The `FragmentsGroup` model containing the entity, or its UUID.
   * @param expressID The unique identifier of the entity within the model.
   * @param attribute The IFC schema inverse attribute of the relation to search for (e.g., "IsDefinedBy", "ContainsElements").
   * @returns An array of express IDs representing the related entities. If the array is empty, no relations were found.
   */
  getEntityRelations(model, expressID, attribute) {
    const index = this.getAttributeIndex(attribute);
    let relationsMap;
    if (model instanceof FragmentsGroup3) {
      relationsMap = this.relationMaps[model.uuid];
    } else if (typeof model === "string") {
      relationsMap = this.relationMaps[model];
    } else {
      relationsMap = model;
    }
    if (!relationsMap && (model instanceof FragmentsGroup3 || typeof model === "string")) {
      relationsMap = /* @__PURE__ */ new Map();
      const id = model instanceof FragmentsGroup3 ? model.uuid : model;
      this.relationMaps[id] = relationsMap;
    }
    let entityRelations = relationsMap.get(expressID);
    if (!entityRelations) {
      entityRelations = /* @__PURE__ */ new Map();
      relationsMap.set(expressID, entityRelations);
    }
    let relations = entityRelations.get(index);
    if (!relations) {
      relations = [];
      entityRelations.set(index, relations);
    }
    return relations;
  }
  /**
   * Serializes the relations of a given relation map into a JSON string.
   * This method iterates through the relations in the given map, organizing them into a structured object where each key is an expressID of an entity,
   * and its value is another object mapping relation indices to arrays of related entity expressIDs.
   * The resulting object is then serialized into a JSON string.
   *
   * @param relationMap - The map of relations to be serialized. The map keys are expressIDs of entities, and the values are maps where each key is a relation type ID and its value is an array of expressIDs of entities related through that relation type.
   * @returns A JSON string representing the serialized relations of the given relation map.
   */
  serializeRelations(relationMap) {
    const object = {};
    for (const [expressID, relations] of relationMap.entries()) {
      if (!object[expressID])
        object[expressID] = {};
      for (const [relationID, relationEntities] of relations.entries()) {
        object[expressID][relationID] = relationEntities;
      }
    }
    return JSON.stringify(object);
  }
  /**
   * Serializes the relations of a specific model into a JSON string.
   * This method iterates through the relations indexed for the given model,
   * organizing them into a structured object where each key is an expressID of an entity,
   * and its value is another object mapping relation indices to arrays of related entity expressIDs.
   * The resulting object is then serialized into a JSON string.
   *
   * @param model The `FragmentsGroup` model whose relations are to be serialized.
   * @returns A JSON string representing the serialized relations of the specified model.
   * If the model has no indexed relations, `null` is returned.
   */
  serializeModelRelations(model) {
    const relationsMap = this.relationMaps[model.uuid];
    if (!relationsMap)
      return null;
    const json = this.serializeRelations(relationsMap);
    return json;
  }
  /**
   * Serializes all relations of every model processed by the indexer into a JSON string.
   * This method iterates through each model's relations indexed in `relationMaps`, organizing them
   * into a structured JSON object. Each top-level key in this object corresponds to a model's UUID,
   * and its value is another object mapping entity expressIDs to their related entities, categorized
   * by relation types. The structure facilitates easy access to any entity's relations across all models.
   *
   * @returns A JSON string representing the serialized relations of all models processed by the indexer.
   *          If no relations have been indexed, an empty object is returned as a JSON string.
   */
  serializeAllRelations() {
    const jsonObject = {};
    for (const uuid in this.relationMaps) {
      const indexMap = this.relationMaps[uuid];
      const object = {};
      for (const [expressID, relations] of indexMap.entries()) {
        if (!object[expressID])
          object[expressID] = {};
        for (const [relationID, relationEntities] of relations.entries()) {
          object[expressID][relationID] = relationEntities;
        }
      }
      jsonObject[uuid] = object;
    }
    return JSON.stringify(jsonObject);
  }
  /**
   * Converts a JSON string representing relations between entities into a structured map.
   * This method parses the JSON string to reconstruct the relations map that indexes
   * entity relations by their express IDs. The outer map keys are the express IDs of entities,
   * and the values are maps where each key is a relation type ID and its value is an array
   * of express IDs of entities related through that relation type.
   *
   * @param json The JSON string to be parsed into the relations map.
   * @returns A `Map` where the key is the express ID of an entity as a number, and the value
   * is another `Map`. This inner map's key is the relation type ID as a number, and its value
   * is an array of express IDs (as numbers) of entities related through that relation type.
   */
  getRelationsMapFromJSON(json) {
    const relations = JSON.parse(json);
    const indexMap = /* @__PURE__ */ new Map();
    for (const expressID in relations) {
      const expressIDRelations = relations[expressID];
      const relationMap = /* @__PURE__ */ new Map();
      for (const relationID in expressIDRelations) {
        relationMap.set(Number(relationID), expressIDRelations[relationID]);
      }
      indexMap.set(Number(expressID), relationMap);
    }
    return indexMap;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.relationMaps = {};
    const fragmentManager = this.components.get(FragmentsManager);
    fragmentManager.onFragmentsDisposed.remove(this.onFragmentsDisposed);
    this.onDisposed.trigger(_IfcRelationsIndexer2.uuid);
    this.onDisposed.reset();
  }
  /**
   * Retrieves the entities within a model that have a specific relation with a given entity.
   *
   * @param model - The BIM model to search for related entities.
   * @param inv - The IFC schema inverse attribute of the relation to search for (e.g., "IsDefinedBy", "ContainsElements").
   * @param expressID - The expressID of the entity within the model.
   *
   * @returns A `Set` with the expressIDs of the entities that have the specified relation with the given entity.
   *
   * @throws An error if the model relations are not indexed or if the inverse attribute name is invalid.
   */
  getEntitiesWithRelation(model, inv, expressID) {
    const relations = this.relationMaps[model.uuid];
    if (!relations)
      throw new Error(
        "IfcRelationsIndexer: the model relations are not indexed!"
      );
    const set = /* @__PURE__ */ new Set();
    for (const [id, map] of relations) {
      const index = this.getAttributeIndex(inv);
      const rels = map.get(index);
      if (rels && rels.includes(expressID))
        set.add(id);
    }
    return set;
  }
  /**
   * Adds relations between an entity and other entities in a BIM model.
   *
   * @param model - The BIM model to which the relations will be added.
   * @param expressID - The expressID of the entity within the model.
   * @param relationName - The IFC schema inverse attribute of the relation to add (e.g., "IsDefinedBy", "ContainsElements").
   * @param relIDs - The expressIDs of the related entities within the model.
   * @deprecated Use addEntitiesRelation instead. This will be removed in future versions.
   *
   * @throws An error if the relation name is not a valid relation name.
   */
  addEntityRelations(model, expressID, relationName, ...relIDs) {
    const existingRelations = this.getEntityRelations(
      model,
      expressID,
      relationName
    );
    if (!existingRelations) {
      const attributeIndex = this.getAttributeIndex(relationName);
      const entityRelations = this.relationMaps[model.uuid].get(expressID);
      entityRelations == null ? void 0 : entityRelations.set(attributeIndex, relIDs);
    } else {
      existingRelations.push(...relIDs);
    }
  }
  /**
   * Converts the relations made into actual IFC data.
   *
   * @remarks This function iterates through the changes made to the relations and applies them to the corresponding BIM model.
   * It only make sense to use it if the relations need to be write in the IFC file.
   *
   * @returns A promise that resolves when all the relation changes have been applied.
   */
  async applyRelationChanges() {
    const fragments = this.components.get(FragmentsManager);
    const propsManager = this.components.get(IfcPropertiesManager);
    for (const modelID in this._changeMap) {
      const model = fragments.groups.get(modelID);
      if (!model)
        continue;
      const relations = this._changeMap[modelID];
      for (const [relType, data] of relations) {
        for (const [relatingID, relationInfo] of data) {
          const { related, relID } = relationInfo;
          if (relID) {
            const rel = await model.getProperties(relID);
            if (!rel)
              continue;
            const keys = Object.keys(rel);
            const relatedKey = keys.find((key) => key.startsWith("Related"));
            const relatingKey = keys.find((key) => key.startsWith("Relating"));
            if (!(relatedKey && relatingKey))
              continue;
            rel[relatedKey] = [...related].map((id) => new Handle(id));
            rel[relatingKey] = new Handle(relatingID);
            await propsManager.setData(model, rel);
          } else {
            const rel = await propsManager.createIfcRel(
              model,
              relType,
              relatingID,
              [...related]
            );
            if (!rel)
              continue;
            relationInfo.relID = rel.expressID;
          }
        }
      }
    }
  }
  addEntitiesRelation(model, relatingID, rel, ...relatedIDs) {
    const { type, inv } = rel;
    let relationsMap = this.relationMaps[model.uuid];
    if (!relationsMap) {
      relationsMap = /* @__PURE__ */ new Map();
      this.relationMaps[model.uuid] = relationsMap;
    }
    if (!this._ifcRels.includes(type))
      return;
    const relInvAttrs = relToAttributesMap.get(type);
    if (!relInvAttrs)
      return;
    const { forRelated: related, forRelating: relating } = relInvAttrs;
    if (!(related === inv || relating === inv))
      return;
    let modelChangeMap = this._changeMap[model.uuid];
    if (!modelChangeMap) {
      modelChangeMap = new DataMap();
      this._changeMap[model.uuid] = modelChangeMap;
    }
    const relatingExpressID = relating === inv ? [relatingID] : relatedIDs;
    const relatedExpressID = related === inv ? [relatingID] : relatedIDs;
    let typeChangeMap = modelChangeMap.get(type);
    if (!typeChangeMap) {
      typeChangeMap = new DataMap();
      typeChangeMap.onItemSet.add(
        () => this.onEntitiesRelated.trigger({
          invAttribute: inv,
          relType: type,
          relatingIDs: relatingExpressID,
          relatedIDs: relatedExpressID
        })
      );
      typeChangeMap.onItemUpdated.add(
        () => this.onEntitiesRelated.trigger({
          invAttribute: inv,
          relType: type,
          relatingIDs: relatingExpressID,
          relatedIDs: relatedExpressID
        })
      );
      modelChangeMap.set(type, typeChangeMap);
    }
    for (const relating2 of relatingExpressID) {
      let relatingData = typeChangeMap.get(relating2);
      if (!relatingData) {
        relatingData = { related: new DataSet() };
        typeChangeMap.set(relating2, relatingData);
      }
      relatingData.related.add(...relatedExpressID);
    }
    for (const id of relatingExpressID) {
      const indexMap = this.getEntityRelations(model, id, relating);
      indexMap.push(...relatedExpressID);
    }
    for (const id of relatedExpressID) {
      const relations = this.getEntityRelations(model, id, related);
      relations.push(...relatingExpressID);
    }
  }
  /**
   * Gets the children of the given element recursively. E.g. in a model with project - site - building - storeys - rooms, passing a storey will include all its children and the children of the rooms contained in it.
   *
   * @param model The BIM model whose children to get.
   * @param expressID The expressID of the item whose children to get.
   * @param found An optional parameter that includes a set of expressIDs where the found element IDs will be added.
   *
   * @returns A `Set` with the expressIDs of the found items.
   */
  getEntityChildren(model, expressID, found = /* @__PURE__ */ new Set()) {
    found.add(expressID);
    const modelRelations = this.relationMaps[model.uuid];
    if (modelRelations === void 0) {
      throw new Error(
        "The provided model has no indices. You have to generate them first."
      );
    }
    const spatialRels = this.getEntityRelations(
      model,
      expressID,
      "IsDecomposedBy"
    );
    if (spatialRels) {
      for (const id of spatialRels) {
        this.getEntityChildren(model, id, found);
      }
    }
    const rels = this.getEntityRelations(model, expressID, "ContainsElements");
    if (rels) {
      for (const id of rels) {
        this.getEntityChildren(model, id, found);
      }
    }
    return found;
  }
};
__publicField2(_IfcRelationsIndexer, "uuid", "23a889ab-83b3-44a4-8bee-ead83438370b");
var IfcRelationsIndexer = _IfcRelationsIndexer;
var _FragmentsManager = class _FragmentsManager2 extends Component {
  constructor(components) {
    super(components);
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "onFragmentsLoaded", new Event());
    __publicField2(this, "onFragmentsDisposed", new Event());
    __publicField2(this, "list", new DataMap());
    __publicField2(this, "groups", new DataMap());
    __publicField2(this, "baseCoordinationModel", "");
    __publicField2(this, "baseCoordinationMatrix", new Matrix4());
    __publicField2(this, "enabled", true);
    __publicField2(this, "_loader", new Serializer());
    this.components.add(_FragmentsManager2.uuid, this);
  }
  /**
   * Getter for the meshes of all fragments in the FragmentsManager.
   * It iterates over the fragments in the list and pushes their meshes into an array.
   * @returns {THREE.Mesh[]} An array of THREE.Mesh objects representing the fragments.
   */
  get meshes() {
    const meshes = [];
    for (const [_id, fragment] of this.list) {
      meshes.push(fragment.mesh);
    }
    return meshes;
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [_id, group] of this.groups) {
      group.dispose(true);
    }
    this.baseCoordinationModel = "";
    this.groups.clear();
    this.list.clear();
    this.onFragmentsLoaded.reset();
    this.onFragmentsDisposed.reset();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  /**
   * Dispose of a specific fragment group.
   * This method removes the group from the groups map, deletes all fragments within the group from the list,
   * disposes of the group, and triggers the onFragmentsDisposed event.
   *
   * @param group - The fragment group to be disposed.
   */
  disposeGroup(group) {
    const { uuid: groupID } = group;
    const fragmentIDs = [];
    for (const fragment of group.items) {
      fragmentIDs.push(fragment.id);
      this.list.delete(fragment.id);
    }
    group.dispose(true);
    this.groups.delete(group.uuid);
    if (this.groups.size === 0) {
      this.baseCoordinationModel = "";
      this.baseCoordinationMatrix = new Matrix4();
    }
    this.onFragmentsDisposed.trigger({
      groupID,
      fragmentIDs
    });
  }
  /**
   * Loads a binary file that contain fragment geometry.
   * @param data - The binary data to load.
   * @param config - Optional configuration for loading.
   * @param config.isStreamed - Optional setting to determine whether this model is streamed or not.
   * @param config.coordinate - Whether to apply coordinate transformation. Default is true.
   * @param config.properties - Ifc properties to set on the loaded fragments. Not to be used when streaming.
   * @returns The loaded FragmentsGroup.
   */
  load(data, config) {
    const defaultConfig = { coordinate: true };
    const _config = { ...defaultConfig, ...config };
    const { coordinate, name, properties, relationsMap } = _config;
    const model = this._loader.import(data);
    if (config) {
      model.isStreamed = config.isStreamed || false;
    }
    if (name)
      model.name = name;
    for (const fragment of model.items) {
      fragment.group = model;
      this.list.set(fragment.id, fragment);
    }
    if (coordinate) {
      this.coordinate([model]);
    }
    this.groups.set(model.uuid, model);
    if (properties) {
      model.setLocalProperties(properties);
    }
    if (relationsMap) {
      const indexer = this.components.get(IfcRelationsIndexer);
      indexer.setRelationMap(model, relationsMap);
    }
    this.onFragmentsLoaded.trigger(model);
    return model;
  }
  /**
   * Export the specified fragmentsgroup to binary data.
   * @param group - the fragments group to be exported.
   * @returns the exported data as binary buffer.
   */
  export(group) {
    return this._loader.export(group);
  }
  /**
   * Gets a map of model IDs to sets of express IDs for the given fragment ID map.
   * @param fragmentIdMap - A map of fragment IDs to their corresponding express IDs.
   * @returns A map of model IDs to sets of express IDs.
   */
  getModelIdMap(fragmentIdMap) {
    const map = {};
    for (const fragmentID in fragmentIdMap) {
      const fragment = this.list.get(fragmentID);
      if (!(fragment && fragment.group))
        continue;
      const model = fragment.group;
      if (!(model.uuid in map))
        map[model.uuid] = /* @__PURE__ */ new Set();
      const expressIDs = fragmentIdMap[fragmentID];
      for (const expressID of expressIDs) {
        map[model.uuid].add(expressID);
      }
    }
    return map;
  }
  /**
   * Converts a map of model IDs to sets of express IDs to a fragment ID map.
   * @param modelIdMap - A map of model IDs to their corresponding express IDs.
   * @returns A fragment ID map.
   * @remarks
   * This method iterates through the provided model ID map, retrieves the corresponding model from the `groups` map,
   * and then calls the `getFragmentMap` method of the model to obtain a fragment ID map for the given express IDs.
   * The fragment ID maps are then merged into a single map and returned.
   * If a model with a given ID is not found in the `groups` map, the method skips that model and continues with the next one.
   */
  modelIdToFragmentIdMap(modelIdMap) {
    let fragmentIdMap = {};
    for (const modelID in modelIdMap) {
      const model = this.groups.get(modelID);
      if (!model)
        continue;
      const expressIDs = modelIdMap[modelID];
      const map = model.getFragmentMap(expressIDs);
      fragmentIdMap = { ...fragmentIdMap, ...map };
    }
    return fragmentIdMap;
  }
  /**
   * Converts a collection of IFC GUIDs to a fragmentIdMap.
   *
   * @param guids - An iterable collection of global IDs to be converted to a fragment ID map.
   *
   * @returns A fragment ID map, where the keys are fragment IDs and the values are the corresponding express IDs.
   */
  guidToFragmentIdMap(guids) {
    const modelIdMap = {};
    for (const [id, model] of this.groups) {
      if (!(id in modelIdMap))
        modelIdMap[id] = /* @__PURE__ */ new Set();
      for (const globalId of guids) {
        const expressID = model.globalToExpressIDs.get(globalId);
        if (expressID)
          modelIdMap[id].add(expressID);
      }
    }
    const fragmentIdMap = this.modelIdToFragmentIdMap(modelIdMap);
    return fragmentIdMap;
  }
  /**
   * Converts a fragment ID map to a collection of IFC GUIDs.
   *
   * @param fragmentIdMap - A fragment ID map to be converted to a collection of IFC GUIDs.
   *
   * @returns An array of IFC GUIDs.
   */
  fragmentIdMapToGuids(fragmentIdMap) {
    const guids = [];
    const modelIdMap = this.getModelIdMap(fragmentIdMap);
    for (const modelID in modelIdMap) {
      const model = this.groups.get(modelID);
      if (!model)
        continue;
      const expressIDs = modelIdMap[modelID];
      for (const expressID of expressIDs) {
        for (const [guid, id] of model.globalToExpressIDs.entries()) {
          if (id === expressID) {
            guids.push(guid);
            break;
          }
        }
      }
    }
    return guids;
  }
  /**
   * Applies coordinate transformation to the provided models.
   * If no models are provided, all groups are used.
   * The first model in the list becomes the base model for coordinate transformation.
   * All other models are then transformed to match the base model's coordinate system.
   *
   * @param models - The models to apply coordinate transformation to.
   * If not provided, all models are used.
   */
  coordinate(models = Array.from(this.groups.values())) {
    const isFirstModel = this.baseCoordinationModel.length === 0;
    if (isFirstModel) {
      const first = models.pop();
      if (!first) {
        return;
      }
      this.baseCoordinationModel = first.uuid;
      this.baseCoordinationMatrix = first.coordinationMatrix.clone();
    }
    if (!models.length) {
      return;
    }
    for (const model of models) {
      if (model.coordinationMatrix.equals(this.baseCoordinationMatrix)) {
        continue;
      }
      model.position.set(0, 0, 0);
      model.rotation.set(0, 0, 0);
      model.scale.set(1, 1, 1);
      model.updateMatrix();
      this.applyBaseCoordinateSystem(model, model.coordinationMatrix);
    }
  }
  /**
   * Applies the base coordinate system to the provided object.
   *
   * This function takes an object and its original coordinate system as input.
   * It then inverts the original coordinate system and applies the base coordinate system
   * to the object. This ensures that the object's position, rotation, and scale are
   * transformed to match the base coordinate system (which is taken from the first model loaded).
   *
   * @param object - The object to which the base coordinate system will be applied.
   * This should be an instance of THREE.Object3D.
   *
   * @param originalCoordinateSystem - The original coordinate system of the object.
   * This should be a THREE.Matrix4 representing the object's transformation matrix.
   */
  applyBaseCoordinateSystem(object, originalCoordinateSystem) {
    if (originalCoordinateSystem) {
      object.applyMatrix4(originalCoordinateSystem.clone().invert());
    }
    object.applyMatrix4(this.baseCoordinationMatrix);
  }
  /**
   * Creates a copy of the whole model or a part of it.
   *
   * @param model - The model to clone.
   * @param items - Optional - The part of the model to be cloned. If not given, the whole group is cloned.
   *
   */
  clone(model, items) {
    const clone = model.cloneGroup(items);
    this.groups.set(clone.uuid, clone);
    for (const frag of clone.items) {
      this.list.set(frag.id, frag);
    }
    return clone;
  }
};
__publicField2(_FragmentsManager, "uuid", "fef46874-46a3-461b-8c44-2922ab77c806");
var FragmentsManager = _FragmentsManager;
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var jszip_min = { exports: {} };
(function(module, exports) {
  !function(e) {
    module.exports = e();
  }(function() {
    return function s(a, o, h) {
      function u(r, e2) {
        if (!o[r]) {
          if (!a[r]) {
            var t = "function" == typeof commonjsRequire && commonjsRequire;
            if (!e2 && t)
              return t(r, true);
            if (l)
              return l(r, true);
            var n = new Error("Cannot find module '" + r + "'");
            throw n.code = "MODULE_NOT_FOUND", n;
          }
          var i = o[r] = { exports: {} };
          a[r][0].call(i.exports, function(e3) {
            var t2 = a[r][1][e3];
            return u(t2 || e3);
          }, i, i.exports, s, a, o, h);
        }
        return o[r].exports;
      }
      for (var l = "function" == typeof commonjsRequire && commonjsRequire, e = 0; e < h.length; e++)
        u(h[e]);
      return u;
    }({ 1: [function(e, t, r) {
      var d = e("./utils"), c = e("./support"), p = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      r.encode = function(e2) {
        for (var t2, r2, n, i, s, a, o, h = [], u = 0, l = e2.length, f = l, c2 = "string" !== d.getTypeOf(e2); u < e2.length; )
          f = l - u, n = c2 ? (t2 = e2[u++], r2 = u < l ? e2[u++] : 0, u < l ? e2[u++] : 0) : (t2 = e2.charCodeAt(u++), r2 = u < l ? e2.charCodeAt(u++) : 0, u < l ? e2.charCodeAt(u++) : 0), i = t2 >> 2, s = (3 & t2) << 4 | r2 >> 4, a = 1 < f ? (15 & r2) << 2 | n >> 6 : 64, o = 2 < f ? 63 & n : 64, h.push(p.charAt(i) + p.charAt(s) + p.charAt(a) + p.charAt(o));
        return h.join("");
      }, r.decode = function(e2) {
        var t2, r2, n, i, s, a, o = 0, h = 0, u = "data:";
        if (e2.substr(0, u.length) === u)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var l, f = 3 * (e2 = e2.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (e2.charAt(e2.length - 1) === p.charAt(64) && f--, e2.charAt(e2.length - 2) === p.charAt(64) && f--, f % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (l = c.uint8array ? new Uint8Array(0 | f) : new Array(0 | f); o < e2.length; )
          t2 = p.indexOf(e2.charAt(o++)) << 2 | (i = p.indexOf(e2.charAt(o++))) >> 4, r2 = (15 & i) << 4 | (s = p.indexOf(e2.charAt(o++))) >> 2, n = (3 & s) << 6 | (a = p.indexOf(e2.charAt(o++))), l[h++] = t2, 64 !== s && (l[h++] = r2), 64 !== a && (l[h++] = n);
        return l;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(e, t, r) {
      var n = e("./external"), i = e("./stream/DataWorker"), s = e("./stream/Crc32Probe"), a = e("./stream/DataLengthProbe");
      function o(e2, t2, r2, n2, i2) {
        this.compressedSize = e2, this.uncompressedSize = t2, this.crc32 = r2, this.compression = n2, this.compressedContent = i2;
      }
      o.prototype = { getContentWorker: function() {
        var e2 = new i(n.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new a("data_length")), t2 = this;
        return e2.on("end", function() {
          if (this.streamInfo.data_length !== t2.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), e2;
      }, getCompressedWorker: function() {
        return new i(n.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, o.createWorkerFrom = function(e2, t2, r2) {
        return e2.pipe(new s()).pipe(new a("uncompressedSize")).pipe(t2.compressWorker(r2)).pipe(new a("compressedSize")).withStreamInfo("compression", t2);
      }, t.exports = o;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, t, r) {
      var n = e("./stream/GenericWorker");
      r.STORE = { magic: "\0\0", compressWorker: function() {
        return new n("STORE compression");
      }, uncompressWorker: function() {
        return new n("STORE decompression");
      } }, r.DEFLATE = e("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, t, r) {
      var n = e("./utils");
      var o = function() {
        for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
          e2 = r2;
          for (var n2 = 0; n2 < 8; n2++)
            e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
          t2[r2] = e2;
        }
        return t2;
      }();
      t.exports = function(e2, t2) {
        return void 0 !== e2 && e2.length ? "string" !== n.getTypeOf(e2) ? function(e3, t3, r2, n2) {
          var i = o, s = n2 + r2;
          e3 ^= -1;
          for (var a = n2; a < s; a++)
            e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3[a])];
          return -1 ^ e3;
        }(0 | t2, e2, e2.length, 0) : function(e3, t3, r2, n2) {
          var i = o, s = n2 + r2;
          e3 ^= -1;
          for (var a = n2; a < s; a++)
            e3 = e3 >>> 8 ^ i[255 & (e3 ^ t3.charCodeAt(a))];
          return -1 ^ e3;
        }(0 | t2, e2, e2.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(e, t, r) {
      r.base64 = false, r.binary = false, r.dir = false, r.createFolders = true, r.date = null, r.compression = null, r.compressionOptions = null, r.comment = null, r.unixPermissions = null, r.dosPermissions = null;
    }, {}], 6: [function(e, t, r) {
      var n = null;
      n = "undefined" != typeof Promise ? Promise : e("lie"), t.exports = { Promise: n };
    }, { lie: 37 }], 7: [function(e, t, r) {
      var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array, i = e("pako"), s = e("./utils"), a = e("./stream/GenericWorker"), o = n ? "uint8array" : "array";
      function h(e2, t2) {
        a.call(this, "FlateWorker/" + e2), this._pako = null, this._pakoAction = e2, this._pakoOptions = t2, this.meta = {};
      }
      r.magic = "\b\0", s.inherits(h, a), h.prototype.processChunk = function(e2) {
        this.meta = e2.meta, null === this._pako && this._createPako(), this._pako.push(s.transformTo(o, e2.data), false);
      }, h.prototype.flush = function() {
        a.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], true);
      }, h.prototype.cleanUp = function() {
        a.prototype.cleanUp.call(this), this._pako = null;
      }, h.prototype._createPako = function() {
        this._pako = new i[this._pakoAction]({ raw: true, level: this._pakoOptions.level || -1 });
        var t2 = this;
        this._pako.onData = function(e2) {
          t2.push({ data: e2, meta: t2.meta });
        };
      }, r.compressWorker = function(e2) {
        return new h("Deflate", e2);
      }, r.uncompressWorker = function() {
        return new h("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, t, r) {
      function A(e2, t2) {
        var r2, n2 = "";
        for (r2 = 0; r2 < t2; r2++)
          n2 += String.fromCharCode(255 & e2), e2 >>>= 8;
        return n2;
      }
      function n(e2, t2, r2, n2, i2, s2) {
        var a, o, h = e2.file, u = e2.compression, l = s2 !== O.utf8encode, f = I.transformTo("string", s2(h.name)), c = I.transformTo("string", O.utf8encode(h.name)), d = h.comment, p = I.transformTo("string", s2(d)), m = I.transformTo("string", O.utf8encode(d)), _ = c.length !== h.name.length, g = m.length !== d.length, b = "", v = "", y = "", w = h.dir, k = h.date, x = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        t2 && !r2 || (x.crc32 = e2.crc32, x.compressedSize = e2.compressedSize, x.uncompressedSize = e2.uncompressedSize);
        var S = 0;
        t2 && (S |= 8), l || !_ && !g || (S |= 2048);
        var z = 0, C = 0;
        w && (z |= 16), "UNIX" === i2 ? (C = 798, z |= function(e3, t3) {
          var r3 = e3;
          return e3 || (r3 = t3 ? 16893 : 33204), (65535 & r3) << 16;
        }(h.unixPermissions, w)) : (C = 20, z |= function(e3) {
          return 63 & (e3 || 0);
        }(h.dosPermissions)), a = k.getUTCHours(), a <<= 6, a |= k.getUTCMinutes(), a <<= 5, a |= k.getUTCSeconds() / 2, o = k.getUTCFullYear() - 1980, o <<= 4, o |= k.getUTCMonth() + 1, o <<= 5, o |= k.getUTCDate(), _ && (v = A(1, 1) + A(B(f), 4) + c, b += "up" + A(v.length, 2) + v), g && (y = A(1, 1) + A(B(p), 4) + m, b += "uc" + A(y.length, 2) + y);
        var E = "";
        return E += "\n\0", E += A(S, 2), E += u.magic, E += A(a, 2), E += A(o, 2), E += A(x.crc32, 4), E += A(x.compressedSize, 4), E += A(x.uncompressedSize, 4), E += A(f.length, 2), E += A(b.length, 2), { fileRecord: R.LOCAL_FILE_HEADER + E + f + b, dirRecord: R.CENTRAL_FILE_HEADER + A(C, 2) + E + A(p.length, 2) + "\0\0\0\0" + A(z, 4) + A(n2, 4) + f + b + p };
      }
      var I = e("../utils"), i = e("../stream/GenericWorker"), O = e("../utf8"), B = e("../crc32"), R = e("../signature");
      function s(e2, t2, r2, n2) {
        i.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = t2, this.zipPlatform = r2, this.encodeFileName = n2, this.streamFiles = e2, this.accumulate = false, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      I.inherits(s, i), s.prototype.push = function(e2) {
        var t2 = e2.meta.percent || 0, r2 = this.entriesCount, n2 = this._sources.length;
        this.accumulate ? this.contentBuffer.push(e2) : (this.bytesWritten += e2.data.length, i.prototype.push.call(this, { data: e2.data, meta: { currentFile: this.currentFile, percent: r2 ? (t2 + 100 * (r2 - n2 - 1)) / r2 : 100 } }));
      }, s.prototype.openedSource = function(e2) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = e2.file.name;
        var t2 = this.streamFiles && !e2.file.dir;
        if (t2) {
          var r2 = n(e2, t2, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: r2.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = true;
      }, s.prototype.closedSource = function(e2) {
        this.accumulate = false;
        var t2 = this.streamFiles && !e2.file.dir, r2 = n(e2, t2, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(r2.dirRecord), t2)
          this.push({ data: function(e3) {
            return R.DATA_DESCRIPTOR + A(e3.crc32, 4) + A(e3.compressedSize, 4) + A(e3.uncompressedSize, 4);
          }(e2), meta: { percent: 100 } });
        else
          for (this.push({ data: r2.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, s.prototype.flush = function() {
        for (var e2 = this.bytesWritten, t2 = 0; t2 < this.dirRecords.length; t2++)
          this.push({ data: this.dirRecords[t2], meta: { percent: 100 } });
        var r2 = this.bytesWritten - e2, n2 = function(e3, t3, r3, n3, i2) {
          var s2 = I.transformTo("string", i2(n3));
          return R.CENTRAL_DIRECTORY_END + "\0\0\0\0" + A(e3, 2) + A(e3, 2) + A(t3, 4) + A(r3, 4) + A(s2.length, 2) + s2;
        }(this.dirRecords.length, r2, e2, this.zipComment, this.encodeFileName);
        this.push({ data: n2, meta: { percent: 100 } });
      }, s.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, s.prototype.registerPrevious = function(e2) {
        this._sources.push(e2);
        var t2 = this;
        return e2.on("data", function(e3) {
          t2.processChunk(e3);
        }), e2.on("end", function() {
          t2.closedSource(t2.previous.streamInfo), t2._sources.length ? t2.prepareNextSource() : t2.end();
        }), e2.on("error", function(e3) {
          t2.error(e3);
        }), this;
      }, s.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), true) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), true));
      }, s.prototype.error = function(e2) {
        var t2 = this._sources;
        if (!i.prototype.error.call(this, e2))
          return false;
        for (var r2 = 0; r2 < t2.length; r2++)
          try {
            t2[r2].error(e2);
          } catch (e3) {
          }
        return true;
      }, s.prototype.lock = function() {
        i.prototype.lock.call(this);
        for (var e2 = this._sources, t2 = 0; t2 < e2.length; t2++)
          e2[t2].lock();
      }, t.exports = s;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, t, r) {
      var u = e("../compressions"), n = e("./ZipFileWorker");
      r.generateWorker = function(e2, a, t2) {
        var o = new n(a.streamFiles, t2, a.platform, a.encodeFileName), h = 0;
        try {
          e2.forEach(function(e3, t3) {
            h++;
            var r2 = function(e4, t4) {
              var r3 = e4 || t4, n3 = u[r3];
              if (!n3)
                throw new Error(r3 + " is not a valid compression method !");
              return n3;
            }(t3.options.compression, a.compression), n2 = t3.options.compressionOptions || a.compressionOptions || {}, i = t3.dir, s = t3.date;
            t3._compressWorker(r2, n2).withStreamInfo("file", { name: e3, dir: i, date: s, comment: t3.comment || "", unixPermissions: t3.unixPermissions, dosPermissions: t3.dosPermissions }).pipe(o);
          }), o.entriesCount = h;
        } catch (e3) {
          o.error(e3);
        }
        return o;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, t, r) {
      function n() {
        if (!(this instanceof n))
          return new n();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var e2 = new n();
          for (var t2 in this)
            "function" != typeof this[t2] && (e2[t2] = this[t2]);
          return e2;
        };
      }
      (n.prototype = e("./object")).loadAsync = e("./load"), n.support = e("./support"), n.defaults = e("./defaults"), n.version = "3.10.1", n.loadAsync = function(e2, t2) {
        return new n().loadAsync(e2, t2);
      }, n.external = e("./external"), t.exports = n;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, t, r) {
      var u = e("./utils"), i = e("./external"), n = e("./utf8"), s = e("./zipEntries"), a = e("./stream/Crc32Probe"), l = e("./nodejsUtils");
      function f(n2) {
        return new i.Promise(function(e2, t2) {
          var r2 = n2.decompressed.getContentWorker().pipe(new a());
          r2.on("error", function(e3) {
            t2(e3);
          }).on("end", function() {
            r2.streamInfo.crc32 !== n2.decompressed.crc32 ? t2(new Error("Corrupted zip : CRC32 mismatch")) : e2();
          }).resume();
        });
      }
      t.exports = function(e2, o) {
        var h = this;
        return o = u.extend(o || {}, { base64: false, checkCRC32: false, optimizedBinaryString: false, createFolders: false, decodeFileName: n.utf8decode }), l.isNode && l.isStream(e2) ? i.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : u.prepareContent("the loaded zip file", e2, true, o.optimizedBinaryString, o.base64).then(function(e3) {
          var t2 = new s(o);
          return t2.load(e3), t2;
        }).then(function(e3) {
          var t2 = [i.Promise.resolve(e3)], r2 = e3.files;
          if (o.checkCRC32)
            for (var n2 = 0; n2 < r2.length; n2++)
              t2.push(f(r2[n2]));
          return i.Promise.all(t2);
        }).then(function(e3) {
          for (var t2 = e3.shift(), r2 = t2.files, n2 = 0; n2 < r2.length; n2++) {
            var i2 = r2[n2], s2 = i2.fileNameStr, a2 = u.resolve(i2.fileNameStr);
            h.file(a2, i2.decompressed, { binary: true, optimizedBinaryString: true, date: i2.date, dir: i2.dir, comment: i2.fileCommentStr.length ? i2.fileCommentStr : null, unixPermissions: i2.unixPermissions, dosPermissions: i2.dosPermissions, createFolders: o.createFolders }), i2.dir || (h.file(a2).unsafeOriginalName = s2);
          }
          return t2.zipComment.length && (h.comment = t2.zipComment), h;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, t, r) {
      var n = e("../utils"), i = e("../stream/GenericWorker");
      function s(e2, t2) {
        i.call(this, "Nodejs stream input adapter for " + e2), this._upstreamEnded = false, this._bindStream(t2);
      }
      n.inherits(s, i), s.prototype._bindStream = function(e2) {
        var t2 = this;
        (this._stream = e2).pause(), e2.on("data", function(e3) {
          t2.push({ data: e3, meta: { percent: 0 } });
        }).on("error", function(e3) {
          t2.isPaused ? this.generatedError = e3 : t2.error(e3);
        }).on("end", function() {
          t2.isPaused ? t2._upstreamEnded = true : t2.end();
        });
      }, s.prototype.pause = function() {
        return !!i.prototype.pause.call(this) && (this._stream.pause(), true);
      }, s.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), true);
      }, t.exports = s;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, t, r) {
      var i = e("readable-stream").Readable;
      function n(e2, t2, r2) {
        i.call(this, t2), this._helper = e2;
        var n2 = this;
        e2.on("data", function(e3, t3) {
          n2.push(e3) || n2._helper.pause(), r2 && r2(t3);
        }).on("error", function(e3) {
          n2.emit("error", e3);
        }).on("end", function() {
          n2.push(null);
        });
      }
      e("../utils").inherits(n, i), n.prototype._read = function() {
        this._helper.resume();
      }, t.exports = n;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, t, r) {
      t.exports = { isNode: "undefined" != typeof Buffer, newBufferFrom: function(e2, t2) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(e2, t2);
        if ("number" == typeof e2)
          throw new Error('The "data" argument must not be a number');
        return new Buffer(e2, t2);
      }, allocBuffer: function(e2) {
        if (Buffer.alloc)
          return Buffer.alloc(e2);
        var t2 = new Buffer(e2);
        return t2.fill(0), t2;
      }, isBuffer: function(e2) {
        return Buffer.isBuffer(e2);
      }, isStream: function(e2) {
        return e2 && "function" == typeof e2.on && "function" == typeof e2.pause && "function" == typeof e2.resume;
      } };
    }, {}], 15: [function(e, t, r) {
      function s(e2, t2, r2) {
        var n2, i2 = u.getTypeOf(t2), s2 = u.extend(r2 || {}, f);
        s2.date = s2.date || /* @__PURE__ */ new Date(), null !== s2.compression && (s2.compression = s2.compression.toUpperCase()), "string" == typeof s2.unixPermissions && (s2.unixPermissions = parseInt(s2.unixPermissions, 8)), s2.unixPermissions && 16384 & s2.unixPermissions && (s2.dir = true), s2.dosPermissions && 16 & s2.dosPermissions && (s2.dir = true), s2.dir && (e2 = g(e2)), s2.createFolders && (n2 = _(e2)) && b.call(this, n2, true);
        var a2 = "string" === i2 && false === s2.binary && false === s2.base64;
        r2 && void 0 !== r2.binary || (s2.binary = !a2), (t2 instanceof c && 0 === t2.uncompressedSize || s2.dir || !t2 || 0 === t2.length) && (s2.base64 = false, s2.binary = true, t2 = "", s2.compression = "STORE", i2 = "string");
        var o2 = null;
        o2 = t2 instanceof c || t2 instanceof l ? t2 : p.isNode && p.isStream(t2) ? new m(e2, t2) : u.prepareContent(e2, t2, s2.binary, s2.optimizedBinaryString, s2.base64);
        var h2 = new d(e2, o2, s2);
        this.files[e2] = h2;
      }
      var i = e("./utf8"), u = e("./utils"), l = e("./stream/GenericWorker"), a = e("./stream/StreamHelper"), f = e("./defaults"), c = e("./compressedObject"), d = e("./zipObject"), o = e("./generate"), p = e("./nodejsUtils"), m = e("./nodejs/NodejsStreamInputAdapter"), _ = function(e2) {
        "/" === e2.slice(-1) && (e2 = e2.substring(0, e2.length - 1));
        var t2 = e2.lastIndexOf("/");
        return 0 < t2 ? e2.substring(0, t2) : "";
      }, g = function(e2) {
        return "/" !== e2.slice(-1) && (e2 += "/"), e2;
      }, b = function(e2, t2) {
        return t2 = void 0 !== t2 ? t2 : f.createFolders, e2 = g(e2), this.files[e2] || s.call(this, e2, null, { dir: true, createFolders: t2 }), this.files[e2];
      };
      function h(e2) {
        return "[object RegExp]" === Object.prototype.toString.call(e2);
      }
      var n = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(e2) {
        var t2, r2, n2;
        for (t2 in this.files)
          n2 = this.files[t2], (r2 = t2.slice(this.root.length, t2.length)) && t2.slice(0, this.root.length) === this.root && e2(r2, n2);
      }, filter: function(r2) {
        var n2 = [];
        return this.forEach(function(e2, t2) {
          r2(e2, t2) && n2.push(t2);
        }), n2;
      }, file: function(e2, t2, r2) {
        if (1 !== arguments.length)
          return e2 = this.root + e2, s.call(this, e2, t2, r2), this;
        if (h(e2)) {
          var n2 = e2;
          return this.filter(function(e3, t3) {
            return !t3.dir && n2.test(e3);
          });
        }
        var i2 = this.files[this.root + e2];
        return i2 && !i2.dir ? i2 : null;
      }, folder: function(r2) {
        if (!r2)
          return this;
        if (h(r2))
          return this.filter(function(e3, t3) {
            return t3.dir && r2.test(e3);
          });
        var e2 = this.root + r2, t2 = b.call(this, e2), n2 = this.clone();
        return n2.root = t2.name, n2;
      }, remove: function(r2) {
        r2 = this.root + r2;
        var e2 = this.files[r2];
        if (e2 || ("/" !== r2.slice(-1) && (r2 += "/"), e2 = this.files[r2]), e2 && !e2.dir)
          delete this.files[r2];
        else
          for (var t2 = this.filter(function(e3, t3) {
            return t3.name.slice(0, r2.length) === r2;
          }), n2 = 0; n2 < t2.length; n2++)
            delete this.files[t2[n2].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(e2) {
        var t2, r2 = {};
        try {
          if ((r2 = u.extend(e2 || {}, { streamFiles: false, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: i.utf8encode })).type = r2.type.toLowerCase(), r2.compression = r2.compression.toUpperCase(), "binarystring" === r2.type && (r2.type = "string"), !r2.type)
            throw new Error("No output type specified.");
          u.checkSupport(r2.type), "darwin" !== r2.platform && "freebsd" !== r2.platform && "linux" !== r2.platform && "sunos" !== r2.platform || (r2.platform = "UNIX"), "win32" === r2.platform && (r2.platform = "DOS");
          var n2 = r2.comment || this.comment || "";
          t2 = o.generateWorker(this, r2, n2);
        } catch (e3) {
          (t2 = new l("error")).error(e3);
        }
        return new a(t2, r2.type || "string", r2.mimeType);
      }, generateAsync: function(e2, t2) {
        return this.generateInternalStream(e2).accumulate(t2);
      }, generateNodeStream: function(e2, t2) {
        return (e2 = e2 || {}).type || (e2.type = "nodebuffer"), this.generateInternalStream(e2).toNodejsStream(t2);
      } };
      t.exports = n;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, t, r) {
      t.exports = e("stream");
    }, { stream: void 0 }], 17: [function(e, t, r) {
      var n = e("./DataReader");
      function i(e2) {
        n.call(this, e2);
        for (var t2 = 0; t2 < this.data.length; t2++)
          e2[t2] = 255 & e2[t2];
      }
      e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
        return this.data[this.zero + e2];
      }, i.prototype.lastIndexOfSignature = function(e2) {
        for (var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.length - 4; 0 <= s; --s)
          if (this.data[s] === t2 && this.data[s + 1] === r2 && this.data[s + 2] === n2 && this.data[s + 3] === i2)
            return s - this.zero;
        return -1;
      }, i.prototype.readAndCheckSignature = function(e2) {
        var t2 = e2.charCodeAt(0), r2 = e2.charCodeAt(1), n2 = e2.charCodeAt(2), i2 = e2.charCodeAt(3), s = this.readData(4);
        return t2 === s[0] && r2 === s[1] && n2 === s[2] && i2 === s[3];
      }, i.prototype.readData = function(e2) {
        if (this.checkOffset(e2), 0 === e2)
          return [];
        var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
        return this.index += e2, t2;
      }, t.exports = i;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, t, r) {
      var n = e("../utils");
      function i(e2) {
        this.data = e2, this.length = e2.length, this.index = 0, this.zero = 0;
      }
      i.prototype = { checkOffset: function(e2) {
        this.checkIndex(this.index + e2);
      }, checkIndex: function(e2) {
        if (this.length < this.zero + e2 || e2 < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + e2 + "). Corrupted zip ?");
      }, setIndex: function(e2) {
        this.checkIndex(e2), this.index = e2;
      }, skip: function(e2) {
        this.setIndex(this.index + e2);
      }, byteAt: function() {
      }, readInt: function(e2) {
        var t2, r2 = 0;
        for (this.checkOffset(e2), t2 = this.index + e2 - 1; t2 >= this.index; t2--)
          r2 = (r2 << 8) + this.byteAt(t2);
        return this.index += e2, r2;
      }, readString: function(e2) {
        return n.transformTo("string", this.readData(e2));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var e2 = this.readInt(4);
        return new Date(Date.UTC(1980 + (e2 >> 25 & 127), (e2 >> 21 & 15) - 1, e2 >> 16 & 31, e2 >> 11 & 31, e2 >> 5 & 63, (31 & e2) << 1));
      } }, t.exports = i;
    }, { "../utils": 32 }], 19: [function(e, t, r) {
      var n = e("./Uint8ArrayReader");
      function i(e2) {
        n.call(this, e2);
      }
      e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
        this.checkOffset(e2);
        var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
        return this.index += e2, t2;
      }, t.exports = i;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, t, r) {
      var n = e("./DataReader");
      function i(e2) {
        n.call(this, e2);
      }
      e("../utils").inherits(i, n), i.prototype.byteAt = function(e2) {
        return this.data.charCodeAt(this.zero + e2);
      }, i.prototype.lastIndexOfSignature = function(e2) {
        return this.data.lastIndexOf(e2) - this.zero;
      }, i.prototype.readAndCheckSignature = function(e2) {
        return e2 === this.readData(4);
      }, i.prototype.readData = function(e2) {
        this.checkOffset(e2);
        var t2 = this.data.slice(this.zero + this.index, this.zero + this.index + e2);
        return this.index += e2, t2;
      }, t.exports = i;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, t, r) {
      var n = e("./ArrayReader");
      function i(e2) {
        n.call(this, e2);
      }
      e("../utils").inherits(i, n), i.prototype.readData = function(e2) {
        if (this.checkOffset(e2), 0 === e2)
          return new Uint8Array(0);
        var t2 = this.data.subarray(this.zero + this.index, this.zero + this.index + e2);
        return this.index += e2, t2;
      }, t.exports = i;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, t, r) {
      var n = e("../utils"), i = e("../support"), s = e("./ArrayReader"), a = e("./StringReader"), o = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
      t.exports = function(e2) {
        var t2 = n.getTypeOf(e2);
        return n.checkSupport(t2), "string" !== t2 || i.uint8array ? "nodebuffer" === t2 ? new o(e2) : i.uint8array ? new h(n.transformTo("uint8array", e2)) : new s(n.transformTo("array", e2)) : new a(e2);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, t, r) {
      r.LOCAL_FILE_HEADER = "PK", r.CENTRAL_FILE_HEADER = "PK", r.CENTRAL_DIRECTORY_END = "PK", r.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", r.ZIP64_CENTRAL_DIRECTORY_END = "PK", r.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(e, t, r) {
      var n = e("./GenericWorker"), i = e("../utils");
      function s(e2) {
        n.call(this, "ConvertWorker to " + e2), this.destType = e2;
      }
      i.inherits(s, n), s.prototype.processChunk = function(e2) {
        this.push({ data: i.transformTo(this.destType, e2.data), meta: e2.meta });
      }, t.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, t, r) {
      var n = e("./GenericWorker"), i = e("../crc32");
      function s() {
        n.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      e("../utils").inherits(s, n), s.prototype.processChunk = function(e2) {
        this.streamInfo.crc32 = i(e2.data, this.streamInfo.crc32 || 0), this.push(e2);
      }, t.exports = s;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, t, r) {
      var n = e("../utils"), i = e("./GenericWorker");
      function s(e2) {
        i.call(this, "DataLengthProbe for " + e2), this.propName = e2, this.withStreamInfo(e2, 0);
      }
      n.inherits(s, i), s.prototype.processChunk = function(e2) {
        if (e2) {
          var t2 = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = t2 + e2.data.length;
        }
        i.prototype.processChunk.call(this, e2);
      }, t.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, t, r) {
      var n = e("../utils"), i = e("./GenericWorker");
      function s(e2) {
        i.call(this, "DataWorker");
        var t2 = this;
        this.dataIsReady = false, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = false, e2.then(function(e3) {
          t2.dataIsReady = true, t2.data = e3, t2.max = e3 && e3.length || 0, t2.type = n.getTypeOf(e3), t2.isPaused || t2._tickAndRepeat();
        }, function(e3) {
          t2.error(e3);
        });
      }
      n.inherits(s, i), s.prototype.cleanUp = function() {
        i.prototype.cleanUp.call(this), this.data = null;
      }, s.prototype.resume = function() {
        return !!i.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = true, n.delay(this._tickAndRepeat, [], this)), true);
      }, s.prototype._tickAndRepeat = function() {
        this._tickScheduled = false, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (n.delay(this._tickAndRepeat, [], this), this._tickScheduled = true));
      }, s.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return false;
        var e2 = null, t2 = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            e2 = this.data.substring(this.index, t2);
            break;
          case "uint8array":
            e2 = this.data.subarray(this.index, t2);
            break;
          case "array":
          case "nodebuffer":
            e2 = this.data.slice(this.index, t2);
        }
        return this.index = t2, this.push({ data: e2, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, t.exports = s;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, t, r) {
      function n(e2) {
        this.name = e2 || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = true, this.isFinished = false, this.isLocked = false, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      n.prototype = { push: function(e2) {
        this.emit("data", e2);
      }, end: function() {
        if (this.isFinished)
          return false;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = true;
        } catch (e2) {
          this.emit("error", e2);
        }
        return true;
      }, error: function(e2) {
        return !this.isFinished && (this.isPaused ? this.generatedError = e2 : (this.isFinished = true, this.emit("error", e2), this.previous && this.previous.error(e2), this.cleanUp()), true);
      }, on: function(e2, t2) {
        return this._listeners[e2].push(t2), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(e2, t2) {
        if (this._listeners[e2])
          for (var r2 = 0; r2 < this._listeners[e2].length; r2++)
            this._listeners[e2][r2].call(this, t2);
      }, pipe: function(e2) {
        return e2.registerPrevious(this);
      }, registerPrevious: function(e2) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = e2.streamInfo, this.mergeStreamInfo(), this.previous = e2;
        var t2 = this;
        return e2.on("data", function(e3) {
          t2.processChunk(e3);
        }), e2.on("end", function() {
          t2.end();
        }), e2.on("error", function(e3) {
          t2.error(e3);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = true, this.previous && this.previous.pause(), true);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return false;
        var e2 = this.isPaused = false;
        return this.generatedError && (this.error(this.generatedError), e2 = true), this.previous && this.previous.resume(), !e2;
      }, flush: function() {
      }, processChunk: function(e2) {
        this.push(e2);
      }, withStreamInfo: function(e2, t2) {
        return this.extraStreamInfo[e2] = t2, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var e2 in this.extraStreamInfo)
          Object.prototype.hasOwnProperty.call(this.extraStreamInfo, e2) && (this.streamInfo[e2] = this.extraStreamInfo[e2]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = true, this.previous && this.previous.lock();
      }, toString: function() {
        var e2 = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + e2 : e2;
      } }, t.exports = n;
    }, {}], 29: [function(e, t, r) {
      var h = e("../utils"), i = e("./ConvertWorker"), s = e("./GenericWorker"), u = e("../base64"), n = e("../support"), a = e("../external"), o = null;
      if (n.nodestream)
        try {
          o = e("../nodejs/NodejsStreamOutputAdapter");
        } catch (e2) {
        }
      function l(e2, o2) {
        return new a.Promise(function(t2, r2) {
          var n2 = [], i2 = e2._internalType, s2 = e2._outputType, a2 = e2._mimeType;
          e2.on("data", function(e3, t3) {
            n2.push(e3), o2 && o2(t3);
          }).on("error", function(e3) {
            n2 = [], r2(e3);
          }).on("end", function() {
            try {
              var e3 = function(e4, t3, r3) {
                switch (e4) {
                  case "blob":
                    return h.newBlob(h.transformTo("arraybuffer", t3), r3);
                  case "base64":
                    return u.encode(t3);
                  default:
                    return h.transformTo(e4, t3);
                }
              }(s2, function(e4, t3) {
                var r3, n3 = 0, i3 = null, s3 = 0;
                for (r3 = 0; r3 < t3.length; r3++)
                  s3 += t3[r3].length;
                switch (e4) {
                  case "string":
                    return t3.join("");
                  case "array":
                    return Array.prototype.concat.apply([], t3);
                  case "uint8array":
                    for (i3 = new Uint8Array(s3), r3 = 0; r3 < t3.length; r3++)
                      i3.set(t3[r3], n3), n3 += t3[r3].length;
                    return i3;
                  case "nodebuffer":
                    return Buffer.concat(t3);
                  default:
                    throw new Error("concat : unsupported type '" + e4 + "'");
                }
              }(i2, n2), a2);
              t2(e3);
            } catch (e4) {
              r2(e4);
            }
            n2 = [];
          }).resume();
        });
      }
      function f(e2, t2, r2) {
        var n2 = t2;
        switch (t2) {
          case "blob":
          case "arraybuffer":
            n2 = "uint8array";
            break;
          case "base64":
            n2 = "string";
        }
        try {
          this._internalType = n2, this._outputType = t2, this._mimeType = r2, h.checkSupport(n2), this._worker = e2.pipe(new i(n2)), e2.lock();
        } catch (e3) {
          this._worker = new s("error"), this._worker.error(e3);
        }
      }
      f.prototype = { accumulate: function(e2) {
        return l(this, e2);
      }, on: function(e2, t2) {
        var r2 = this;
        return "data" === e2 ? this._worker.on(e2, function(e3) {
          t2.call(r2, e3.data, e3.meta);
        }) : this._worker.on(e2, function() {
          h.delay(t2, arguments, r2);
        }), this;
      }, resume: function() {
        return h.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(e2) {
        if (h.checkSupport("nodestream"), "nodebuffer" !== this._outputType)
          throw new Error(this._outputType + " is not supported by this method");
        return new o(this, { objectMode: "nodebuffer" !== this._outputType }, e2);
      } }, t.exports = f;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, t, r) {
      if (r.base64 = true, r.array = true, r.string = true, r.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, r.nodebuffer = "undefined" != typeof Buffer, r.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer)
        r.blob = false;
      else {
        var n = new ArrayBuffer(0);
        try {
          r.blob = 0 === new Blob([n], { type: "application/zip" }).size;
        } catch (e2) {
          try {
            var i = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            i.append(n), r.blob = 0 === i.getBlob("application/zip").size;
          } catch (e3) {
            r.blob = false;
          }
        }
      }
      try {
        r.nodestream = !!e("readable-stream").Readable;
      } catch (e2) {
        r.nodestream = false;
      }
    }, { "readable-stream": 16 }], 31: [function(e, t, s) {
      for (var o = e("./utils"), h = e("./support"), r = e("./nodejsUtils"), n = e("./stream/GenericWorker"), u = new Array(256), i = 0; i < 256; i++)
        u[i] = 252 <= i ? 6 : 248 <= i ? 5 : 240 <= i ? 4 : 224 <= i ? 3 : 192 <= i ? 2 : 1;
      u[254] = u[254] = 1;
      function a() {
        n.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function l() {
        n.call(this, "utf-8 encode");
      }
      s.utf8encode = function(e2) {
        return h.nodebuffer ? r.newBufferFrom(e2, "utf-8") : function(e3) {
          var t2, r2, n2, i2, s2, a2 = e3.length, o2 = 0;
          for (i2 = 0; i2 < a2; i2++)
            55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o2 += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
          for (t2 = h.uint8array ? new Uint8Array(o2) : new Array(o2), i2 = s2 = 0; s2 < o2; i2++)
            55296 == (64512 & (r2 = e3.charCodeAt(i2))) && i2 + 1 < a2 && 56320 == (64512 & (n2 = e3.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
          return t2;
        }(e2);
      }, s.utf8decode = function(e2) {
        return h.nodebuffer ? o.transformTo("nodebuffer", e2).toString("utf-8") : function(e3) {
          var t2, r2, n2, i2, s2 = e3.length, a2 = new Array(2 * s2);
          for (t2 = r2 = 0; t2 < s2; )
            if ((n2 = e3[t2++]) < 128)
              a2[r2++] = n2;
            else if (4 < (i2 = u[n2]))
              a2[r2++] = 65533, t2 += i2 - 1;
            else {
              for (n2 &= 2 === i2 ? 31 : 3 === i2 ? 15 : 7; 1 < i2 && t2 < s2; )
                n2 = n2 << 6 | 63 & e3[t2++], i2--;
              1 < i2 ? a2[r2++] = 65533 : n2 < 65536 ? a2[r2++] = n2 : (n2 -= 65536, a2[r2++] = 55296 | n2 >> 10 & 1023, a2[r2++] = 56320 | 1023 & n2);
            }
          return a2.length !== r2 && (a2.subarray ? a2 = a2.subarray(0, r2) : a2.length = r2), o.applyFromCharCode(a2);
        }(e2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2));
      }, o.inherits(a, n), a.prototype.processChunk = function(e2) {
        var t2 = o.transformTo(h.uint8array ? "uint8array" : "array", e2.data);
        if (this.leftOver && this.leftOver.length) {
          if (h.uint8array) {
            var r2 = t2;
            (t2 = new Uint8Array(r2.length + this.leftOver.length)).set(this.leftOver, 0), t2.set(r2, this.leftOver.length);
          } else
            t2 = this.leftOver.concat(t2);
          this.leftOver = null;
        }
        var n2 = function(e3, t3) {
          var r3;
          for ((t3 = t3 || e3.length) > e3.length && (t3 = e3.length), r3 = t3 - 1; 0 <= r3 && 128 == (192 & e3[r3]); )
            r3--;
          return r3 < 0 ? t3 : 0 === r3 ? t3 : r3 + u[e3[r3]] > t3 ? r3 : t3;
        }(t2), i2 = t2;
        n2 !== t2.length && (h.uint8array ? (i2 = t2.subarray(0, n2), this.leftOver = t2.subarray(n2, t2.length)) : (i2 = t2.slice(0, n2), this.leftOver = t2.slice(n2, t2.length))), this.push({ data: s.utf8decode(i2), meta: e2.meta });
      }, a.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, s.Utf8DecodeWorker = a, o.inherits(l, n), l.prototype.processChunk = function(e2) {
        this.push({ data: s.utf8encode(e2.data), meta: e2.meta });
      }, s.Utf8EncodeWorker = l;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, t, a) {
      var o = e("./support"), h = e("./base64"), r = e("./nodejsUtils"), u = e("./external");
      function n(e2) {
        return e2;
      }
      function l(e2, t2) {
        for (var r2 = 0; r2 < e2.length; ++r2)
          t2[r2] = 255 & e2.charCodeAt(r2);
        return t2;
      }
      e("setimmediate"), a.newBlob = function(t2, r2) {
        a.checkSupport("blob");
        try {
          return new Blob([t2], { type: r2 });
        } catch (e2) {
          try {
            var n2 = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return n2.append(t2), n2.getBlob(r2);
          } catch (e3) {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var i = { stringifyByChunk: function(e2, t2, r2) {
        var n2 = [], i2 = 0, s2 = e2.length;
        if (s2 <= r2)
          return String.fromCharCode.apply(null, e2);
        for (; i2 < s2; )
          "array" === t2 || "nodebuffer" === t2 ? n2.push(String.fromCharCode.apply(null, e2.slice(i2, Math.min(i2 + r2, s2)))) : n2.push(String.fromCharCode.apply(null, e2.subarray(i2, Math.min(i2 + r2, s2)))), i2 += r2;
        return n2.join("");
      }, stringifyByChar: function(e2) {
        for (var t2 = "", r2 = 0; r2 < e2.length; r2++)
          t2 += String.fromCharCode(e2[r2]);
        return t2;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return o.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length;
        } catch (e2) {
          return false;
        }
      }(), nodebuffer: function() {
        try {
          return o.nodebuffer && 1 === String.fromCharCode.apply(null, r.allocBuffer(1)).length;
        } catch (e2) {
          return false;
        }
      }() } };
      function s(e2) {
        var t2 = 65536, r2 = a.getTypeOf(e2), n2 = true;
        if ("uint8array" === r2 ? n2 = i.applyCanBeUsed.uint8array : "nodebuffer" === r2 && (n2 = i.applyCanBeUsed.nodebuffer), n2)
          for (; 1 < t2; )
            try {
              return i.stringifyByChunk(e2, r2, t2);
            } catch (e3) {
              t2 = Math.floor(t2 / 2);
            }
        return i.stringifyByChar(e2);
      }
      function f(e2, t2) {
        for (var r2 = 0; r2 < e2.length; r2++)
          t2[r2] = e2[r2];
        return t2;
      }
      a.applyFromCharCode = s;
      var c = {};
      c.string = { string: n, array: function(e2) {
        return l(e2, new Array(e2.length));
      }, arraybuffer: function(e2) {
        return c.string.uint8array(e2).buffer;
      }, uint8array: function(e2) {
        return l(e2, new Uint8Array(e2.length));
      }, nodebuffer: function(e2) {
        return l(e2, r.allocBuffer(e2.length));
      } }, c.array = { string: s, array: n, arraybuffer: function(e2) {
        return new Uint8Array(e2).buffer;
      }, uint8array: function(e2) {
        return new Uint8Array(e2);
      }, nodebuffer: function(e2) {
        return r.newBufferFrom(e2);
      } }, c.arraybuffer = { string: function(e2) {
        return s(new Uint8Array(e2));
      }, array: function(e2) {
        return f(new Uint8Array(e2), new Array(e2.byteLength));
      }, arraybuffer: n, uint8array: function(e2) {
        return new Uint8Array(e2);
      }, nodebuffer: function(e2) {
        return r.newBufferFrom(new Uint8Array(e2));
      } }, c.uint8array = { string: s, array: function(e2) {
        return f(e2, new Array(e2.length));
      }, arraybuffer: function(e2) {
        return e2.buffer;
      }, uint8array: n, nodebuffer: function(e2) {
        return r.newBufferFrom(e2);
      } }, c.nodebuffer = { string: s, array: function(e2) {
        return f(e2, new Array(e2.length));
      }, arraybuffer: function(e2) {
        return c.nodebuffer.uint8array(e2).buffer;
      }, uint8array: function(e2) {
        return f(e2, new Uint8Array(e2.length));
      }, nodebuffer: n }, a.transformTo = function(e2, t2) {
        if (t2 = t2 || "", !e2)
          return t2;
        a.checkSupport(e2);
        var r2 = a.getTypeOf(t2);
        return c[r2][e2](t2);
      }, a.resolve = function(e2) {
        for (var t2 = e2.split("/"), r2 = [], n2 = 0; n2 < t2.length; n2++) {
          var i2 = t2[n2];
          "." === i2 || "" === i2 && 0 !== n2 && n2 !== t2.length - 1 || (".." === i2 ? r2.pop() : r2.push(i2));
        }
        return r2.join("/");
      }, a.getTypeOf = function(e2) {
        return "string" == typeof e2 ? "string" : "[object Array]" === Object.prototype.toString.call(e2) ? "array" : o.nodebuffer && r.isBuffer(e2) ? "nodebuffer" : o.uint8array && e2 instanceof Uint8Array ? "uint8array" : o.arraybuffer && e2 instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, a.checkSupport = function(e2) {
        if (!o[e2.toLowerCase()])
          throw new Error(e2 + " is not supported by this platform");
      }, a.MAX_VALUE_16BITS = 65535, a.MAX_VALUE_32BITS = -1, a.pretty = function(e2) {
        var t2, r2, n2 = "";
        for (r2 = 0; r2 < (e2 || "").length; r2++)
          n2 += "\\x" + ((t2 = e2.charCodeAt(r2)) < 16 ? "0" : "") + t2.toString(16).toUpperCase();
        return n2;
      }, a.delay = function(e2, t2, r2) {
        setImmediate(function() {
          e2.apply(r2 || null, t2 || []);
        });
      }, a.inherits = function(e2, t2) {
        function r2() {
        }
        r2.prototype = t2.prototype, e2.prototype = new r2();
      }, a.extend = function() {
        var e2, t2, r2 = {};
        for (e2 = 0; e2 < arguments.length; e2++)
          for (t2 in arguments[e2])
            Object.prototype.hasOwnProperty.call(arguments[e2], t2) && void 0 === r2[t2] && (r2[t2] = arguments[e2][t2]);
        return r2;
      }, a.prepareContent = function(r2, e2, n2, i2, s2) {
        return u.Promise.resolve(e2).then(function(n3) {
          return o.blob && (n3 instanceof Blob || -1 !== ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(n3))) && "undefined" != typeof FileReader ? new u.Promise(function(t2, r3) {
            var e3 = new FileReader();
            e3.onload = function(e4) {
              t2(e4.target.result);
            }, e3.onerror = function(e4) {
              r3(e4.target.error);
            }, e3.readAsArrayBuffer(n3);
          }) : n3;
        }).then(function(e3) {
          var t2 = a.getTypeOf(e3);
          return t2 ? ("arraybuffer" === t2 ? e3 = a.transformTo("uint8array", e3) : "string" === t2 && (s2 ? e3 = h.decode(e3) : n2 && true !== i2 && (e3 = function(e4) {
            return l(e4, o.uint8array ? new Uint8Array(e4.length) : new Array(e4.length));
          }(e3))), e3) : u.Promise.reject(new Error("Can't read the data of '" + r2 + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, t, r) {
      var n = e("./reader/readerFor"), i = e("./utils"), s = e("./signature"), a = e("./zipEntry"), o = e("./support");
      function h(e2) {
        this.files = [], this.loadOptions = e2;
      }
      h.prototype = { checkSignature: function(e2) {
        if (!this.reader.readAndCheckSignature(e2)) {
          this.reader.index -= 4;
          var t2 = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + i.pretty(t2) + ", expected " + i.pretty(e2) + ")");
        }
      }, isSignature: function(e2, t2) {
        var r2 = this.reader.index;
        this.reader.setIndex(e2);
        var n2 = this.reader.readString(4) === t2;
        return this.reader.setIndex(r2), n2;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var e2 = this.reader.readData(this.zipCommentLength), t2 = o.uint8array ? "uint8array" : "array", r2 = i.transformTo(t2, e2);
        this.zipComment = this.loadOptions.decodeFileName(r2);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var e2, t2, r2, n2 = this.zip64EndOfCentralSize - 44; 0 < n2; )
          e2 = this.reader.readInt(2), t2 = this.reader.readInt(4), r2 = this.reader.readData(t2), this.zip64ExtensibleData[e2] = { id: e2, length: t2, value: r2 };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var e2, t2;
        for (e2 = 0; e2 < this.files.length; e2++)
          t2 = this.files[e2], this.reader.setIndex(t2.localHeaderOffset), this.checkSignature(s.LOCAL_FILE_HEADER), t2.readLocalPart(this.reader), t2.handleUTF8(), t2.processAttributes();
      }, readCentralDir: function() {
        var e2;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(s.CENTRAL_FILE_HEADER); )
          (e2 = new a({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(e2);
        if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var e2 = this.reader.lastIndexOfSignature(s.CENTRAL_DIRECTORY_END);
        if (e2 < 0)
          throw !this.isSignature(0, s.LOCAL_FILE_HEADER) ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory");
        this.reader.setIndex(e2);
        var t2 = e2;
        if (this.checkSignature(s.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === i.MAX_VALUE_16BITS || this.diskWithCentralDirStart === i.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === i.MAX_VALUE_16BITS || this.centralDirRecords === i.MAX_VALUE_16BITS || this.centralDirSize === i.MAX_VALUE_32BITS || this.centralDirOffset === i.MAX_VALUE_32BITS) {
          if (this.zip64 = true, (e2 = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(e2), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, s.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(s.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var r2 = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (r2 += 20, r2 += 12 + this.zip64EndOfCentralSize);
        var n2 = t2 - r2;
        if (0 < n2)
          this.isSignature(t2, s.CENTRAL_FILE_HEADER) || (this.reader.zero = n2);
        else if (n2 < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(n2) + " bytes.");
      }, prepareReader: function(e2) {
        this.reader = n(e2);
      }, load: function(e2) {
        this.prepareReader(e2), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, t.exports = h;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, t, r) {
      var n = e("./reader/readerFor"), s = e("./utils"), i = e("./compressedObject"), a = e("./crc32"), o = e("./utf8"), h = e("./compressions"), u = e("./support");
      function l(e2, t2) {
        this.options = e2, this.loadOptions = t2;
      }
      l.prototype = { isEncrypted: function() {
        return 1 == (1 & this.bitFlag);
      }, useUTF8: function() {
        return 2048 == (2048 & this.bitFlag);
      }, readLocalPart: function(e2) {
        var t2, r2;
        if (e2.skip(22), this.fileNameLength = e2.readInt(2), r2 = e2.readInt(2), this.fileName = e2.readData(this.fileNameLength), e2.skip(r2), -1 === this.compressedSize || -1 === this.uncompressedSize)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if (null === (t2 = function(e3) {
          for (var t3 in h)
            if (Object.prototype.hasOwnProperty.call(h, t3) && h[t3].magic === e3)
              return h[t3];
          return null;
        }(this.compressionMethod)))
          throw new Error("Corrupted zip : compression " + s.pretty(this.compressionMethod) + " unknown (inner file : " + s.transformTo("string", this.fileName) + ")");
        this.decompressed = new i(this.compressedSize, this.uncompressedSize, this.crc32, t2, e2.readData(this.compressedSize));
      }, readCentralPart: function(e2) {
        this.versionMadeBy = e2.readInt(2), e2.skip(2), this.bitFlag = e2.readInt(2), this.compressionMethod = e2.readString(2), this.date = e2.readDate(), this.crc32 = e2.readInt(4), this.compressedSize = e2.readInt(4), this.uncompressedSize = e2.readInt(4);
        var t2 = e2.readInt(2);
        if (this.extraFieldsLength = e2.readInt(2), this.fileCommentLength = e2.readInt(2), this.diskNumberStart = e2.readInt(2), this.internalFileAttributes = e2.readInt(2), this.externalFileAttributes = e2.readInt(4), this.localHeaderOffset = e2.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        e2.skip(t2), this.readExtraFields(e2), this.parseZIP64ExtraField(e2), this.fileComment = e2.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var e2 = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), 0 == e2 && (this.dosPermissions = 63 & this.externalFileAttributes), 3 == e2 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = true);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var e2 = n(this.extraFields[1].value);
          this.uncompressedSize === s.MAX_VALUE_32BITS && (this.uncompressedSize = e2.readInt(8)), this.compressedSize === s.MAX_VALUE_32BITS && (this.compressedSize = e2.readInt(8)), this.localHeaderOffset === s.MAX_VALUE_32BITS && (this.localHeaderOffset = e2.readInt(8)), this.diskNumberStart === s.MAX_VALUE_32BITS && (this.diskNumberStart = e2.readInt(4));
        }
      }, readExtraFields: function(e2) {
        var t2, r2, n2, i2 = e2.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); e2.index + 4 < i2; )
          t2 = e2.readInt(2), r2 = e2.readInt(2), n2 = e2.readData(r2), this.extraFields[t2] = { id: t2, length: r2, value: n2 };
        e2.setIndex(i2);
      }, handleUTF8: function() {
        var e2 = u.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = o.utf8decode(this.fileName), this.fileCommentStr = o.utf8decode(this.fileComment);
        else {
          var t2 = this.findExtraFieldUnicodePath();
          if (null !== t2)
            this.fileNameStr = t2;
          else {
            var r2 = s.transformTo(e2, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(r2);
          }
          var n2 = this.findExtraFieldUnicodeComment();
          if (null !== n2)
            this.fileCommentStr = n2;
          else {
            var i2 = s.transformTo(e2, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(i2);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var e2 = this.extraFields[28789];
        if (e2) {
          var t2 = n(e2.value);
          return 1 !== t2.readInt(1) ? null : a(this.fileName) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var e2 = this.extraFields[25461];
        if (e2) {
          var t2 = n(e2.value);
          return 1 !== t2.readInt(1) ? null : a(this.fileComment) !== t2.readInt(4) ? null : o.utf8decode(t2.readData(e2.length - 5));
        }
        return null;
      } }, t.exports = l;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, t, r) {
      function n(e2, t2, r2) {
        this.name = e2, this.dir = r2.dir, this.date = r2.date, this.comment = r2.comment, this.unixPermissions = r2.unixPermissions, this.dosPermissions = r2.dosPermissions, this._data = t2, this._dataBinary = r2.binary, this.options = { compression: r2.compression, compressionOptions: r2.compressionOptions };
      }
      var s = e("./stream/StreamHelper"), i = e("./stream/DataWorker"), a = e("./utf8"), o = e("./compressedObject"), h = e("./stream/GenericWorker");
      n.prototype = { internalStream: function(e2) {
        var t2 = null, r2 = "string";
        try {
          if (!e2)
            throw new Error("No output type specified.");
          var n2 = "string" === (r2 = e2.toLowerCase()) || "text" === r2;
          "binarystring" !== r2 && "text" !== r2 || (r2 = "string"), t2 = this._decompressWorker();
          var i2 = !this._dataBinary;
          i2 && !n2 && (t2 = t2.pipe(new a.Utf8EncodeWorker())), !i2 && n2 && (t2 = t2.pipe(new a.Utf8DecodeWorker()));
        } catch (e3) {
          (t2 = new h("error")).error(e3);
        }
        return new s(t2, r2, "");
      }, async: function(e2, t2) {
        return this.internalStream(e2).accumulate(t2);
      }, nodeStream: function(e2, t2) {
        return this.internalStream(e2 || "nodebuffer").toNodejsStream(t2);
      }, _compressWorker: function(e2, t2) {
        if (this._data instanceof o && this._data.compression.magic === e2.magic)
          return this._data.getCompressedWorker();
        var r2 = this._decompressWorker();
        return this._dataBinary || (r2 = r2.pipe(new a.Utf8EncodeWorker())), o.createWorkerFrom(r2, e2, t2);
      }, _decompressWorker: function() {
        return this._data instanceof o ? this._data.getContentWorker() : this._data instanceof h ? this._data : new i(this._data);
      } };
      for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], l = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, f = 0; f < u.length; f++)
        n.prototype[u[f]] = l;
      t.exports = n;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, l, t) {
      (function(t2) {
        var r, n, e2 = t2.MutationObserver || t2.WebKitMutationObserver;
        if (e2) {
          var i = 0, s = new e2(u), a = t2.document.createTextNode("");
          s.observe(a, { characterData: true }), r = function() {
            a.data = i = ++i % 2;
          };
        } else if (t2.setImmediate || void 0 === t2.MessageChannel)
          r = "document" in t2 && "onreadystatechange" in t2.document.createElement("script") ? function() {
            var e3 = t2.document.createElement("script");
            e3.onreadystatechange = function() {
              u(), e3.onreadystatechange = null, e3.parentNode.removeChild(e3), e3 = null;
            }, t2.document.documentElement.appendChild(e3);
          } : function() {
            setTimeout(u, 0);
          };
        else {
          var o = new t2.MessageChannel();
          o.port1.onmessage = u, r = function() {
            o.port2.postMessage(0);
          };
        }
        var h = [];
        function u() {
          var e3, t3;
          n = true;
          for (var r2 = h.length; r2; ) {
            for (t3 = h, h = [], e3 = -1; ++e3 < r2; )
              t3[e3]();
            r2 = h.length;
          }
          n = false;
        }
        l.exports = function(e3) {
          1 !== h.push(e3) || n || r();
        };
      }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {}], 37: [function(e, t, r) {
      var i = e("immediate");
      function u() {
      }
      var l = {}, s = ["REJECTED"], a = ["FULFILLED"], n = ["PENDING"];
      function o(e2) {
        if ("function" != typeof e2)
          throw new TypeError("resolver must be a function");
        this.state = n, this.queue = [], this.outcome = void 0, e2 !== u && d(this, e2);
      }
      function h(e2, t2, r2) {
        this.promise = e2, "function" == typeof t2 && (this.onFulfilled = t2, this.callFulfilled = this.otherCallFulfilled), "function" == typeof r2 && (this.onRejected = r2, this.callRejected = this.otherCallRejected);
      }
      function f(t2, r2, n2) {
        i(function() {
          var e2;
          try {
            e2 = r2(n2);
          } catch (e3) {
            return l.reject(t2, e3);
          }
          e2 === t2 ? l.reject(t2, new TypeError("Cannot resolve promise with itself")) : l.resolve(t2, e2);
        });
      }
      function c(e2) {
        var t2 = e2 && e2.then;
        if (e2 && ("object" == typeof e2 || "function" == typeof e2) && "function" == typeof t2)
          return function() {
            t2.apply(e2, arguments);
          };
      }
      function d(t2, e2) {
        var r2 = false;
        function n2(e3) {
          r2 || (r2 = true, l.reject(t2, e3));
        }
        function i2(e3) {
          r2 || (r2 = true, l.resolve(t2, e3));
        }
        var s2 = p(function() {
          e2(i2, n2);
        });
        "error" === s2.status && n2(s2.value);
      }
      function p(e2, t2) {
        var r2 = {};
        try {
          r2.value = e2(t2), r2.status = "success";
        } catch (e3) {
          r2.status = "error", r2.value = e3;
        }
        return r2;
      }
      (t.exports = o).prototype.finally = function(t2) {
        if ("function" != typeof t2)
          return this;
        var r2 = this.constructor;
        return this.then(function(e2) {
          return r2.resolve(t2()).then(function() {
            return e2;
          });
        }, function(e2) {
          return r2.resolve(t2()).then(function() {
            throw e2;
          });
        });
      }, o.prototype.catch = function(e2) {
        return this.then(null, e2);
      }, o.prototype.then = function(e2, t2) {
        if ("function" != typeof e2 && this.state === a || "function" != typeof t2 && this.state === s)
          return this;
        var r2 = new this.constructor(u);
        this.state !== n ? f(r2, this.state === a ? e2 : t2, this.outcome) : this.queue.push(new h(r2, e2, t2));
        return r2;
      }, h.prototype.callFulfilled = function(e2) {
        l.resolve(this.promise, e2);
      }, h.prototype.otherCallFulfilled = function(e2) {
        f(this.promise, this.onFulfilled, e2);
      }, h.prototype.callRejected = function(e2) {
        l.reject(this.promise, e2);
      }, h.prototype.otherCallRejected = function(e2) {
        f(this.promise, this.onRejected, e2);
      }, l.resolve = function(e2, t2) {
        var r2 = p(c, t2);
        if ("error" === r2.status)
          return l.reject(e2, r2.value);
        var n2 = r2.value;
        if (n2)
          d(e2, n2);
        else {
          e2.state = a, e2.outcome = t2;
          for (var i2 = -1, s2 = e2.queue.length; ++i2 < s2; )
            e2.queue[i2].callFulfilled(t2);
        }
        return e2;
      }, l.reject = function(e2, t2) {
        e2.state = s, e2.outcome = t2;
        for (var r2 = -1, n2 = e2.queue.length; ++r2 < n2; )
          e2.queue[r2].callRejected(t2);
        return e2;
      }, o.resolve = function(e2) {
        if (e2 instanceof this)
          return e2;
        return l.resolve(new this(u), e2);
      }, o.reject = function(e2) {
        var t2 = new this(u);
        return l.reject(t2, e2);
      }, o.all = function(e2) {
        var r2 = this;
        if ("[object Array]" !== Object.prototype.toString.call(e2))
          return this.reject(new TypeError("must be an array"));
        var n2 = e2.length, i2 = false;
        if (!n2)
          return this.resolve([]);
        var s2 = new Array(n2), a2 = 0, t2 = -1, o2 = new this(u);
        for (; ++t2 < n2; )
          h2(e2[t2], t2);
        return o2;
        function h2(e3, t3) {
          r2.resolve(e3).then(function(e4) {
            s2[t3] = e4, ++a2 !== n2 || i2 || (i2 = true, l.resolve(o2, s2));
          }, function(e4) {
            i2 || (i2 = true, l.reject(o2, e4));
          });
        }
      }, o.race = function(e2) {
        var t2 = this;
        if ("[object Array]" !== Object.prototype.toString.call(e2))
          return this.reject(new TypeError("must be an array"));
        var r2 = e2.length, n2 = false;
        if (!r2)
          return this.resolve([]);
        var i2 = -1, s2 = new this(u);
        for (; ++i2 < r2; )
          a2 = e2[i2], t2.resolve(a2).then(function(e3) {
            n2 || (n2 = true, l.resolve(s2, e3));
          }, function(e3) {
            n2 || (n2 = true, l.reject(s2, e3));
          });
        var a2;
        return s2;
      };
    }, { immediate: 36 }], 38: [function(e, t, r) {
      var n = {};
      (0, e("./lib/utils/common").assign)(n, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), t.exports = n;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, t, r) {
      var a = e("./zlib/deflate"), o = e("./utils/common"), h = e("./utils/strings"), i = e("./zlib/messages"), s = e("./zlib/zstream"), u = Object.prototype.toString, l = 0, f = -1, c = 0, d = 8;
      function p(e2) {
        if (!(this instanceof p))
          return new p(e2);
        this.options = o.assign({ level: f, method: d, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: c, to: "" }, e2 || {});
        var t2 = this.options;
        t2.raw && 0 < t2.windowBits ? t2.windowBits = -t2.windowBits : t2.gzip && 0 < t2.windowBits && t2.windowBits < 16 && (t2.windowBits += 16), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0;
        var r2 = a.deflateInit2(this.strm, t2.level, t2.method, t2.windowBits, t2.memLevel, t2.strategy);
        if (r2 !== l)
          throw new Error(i[r2]);
        if (t2.header && a.deflateSetHeader(this.strm, t2.header), t2.dictionary) {
          var n2;
          if (n2 = "string" == typeof t2.dictionary ? h.string2buf(t2.dictionary) : "[object ArrayBuffer]" === u.call(t2.dictionary) ? new Uint8Array(t2.dictionary) : t2.dictionary, (r2 = a.deflateSetDictionary(this.strm, n2)) !== l)
            throw new Error(i[r2]);
          this._dict_set = true;
        }
      }
      function n(e2, t2) {
        var r2 = new p(t2);
        if (r2.push(e2, true), r2.err)
          throw r2.msg || i[r2.err];
        return r2.result;
      }
      p.prototype.push = function(e2, t2) {
        var r2, n2, i2 = this.strm, s2 = this.options.chunkSize;
        if (this.ended)
          return false;
        n2 = t2 === ~~t2 ? t2 : true === t2 ? 4 : 0, "string" == typeof e2 ? i2.input = h.string2buf(e2) : "[object ArrayBuffer]" === u.call(e2) ? i2.input = new Uint8Array(e2) : i2.input = e2, i2.next_in = 0, i2.avail_in = i2.input.length;
        do {
          if (0 === i2.avail_out && (i2.output = new o.Buf8(s2), i2.next_out = 0, i2.avail_out = s2), 1 !== (r2 = a.deflate(i2, n2)) && r2 !== l)
            return this.onEnd(r2), !(this.ended = true);
          0 !== i2.avail_out && (0 !== i2.avail_in || 4 !== n2 && 2 !== n2) || ("string" === this.options.to ? this.onData(h.buf2binstring(o.shrinkBuf(i2.output, i2.next_out))) : this.onData(o.shrinkBuf(i2.output, i2.next_out)));
        } while ((0 < i2.avail_in || 0 === i2.avail_out) && 1 !== r2);
        return 4 === n2 ? (r2 = a.deflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === l) : 2 !== n2 || (this.onEnd(l), !(i2.avail_out = 0));
      }, p.prototype.onData = function(e2) {
        this.chunks.push(e2);
      }, p.prototype.onEnd = function(e2) {
        e2 === l && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
      }, r.Deflate = p, r.deflate = n, r.deflateRaw = function(e2, t2) {
        return (t2 = t2 || {}).raw = true, n(e2, t2);
      }, r.gzip = function(e2, t2) {
        return (t2 = t2 || {}).gzip = true, n(e2, t2);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, t, r) {
      var c = e("./zlib/inflate"), d = e("./utils/common"), p = e("./utils/strings"), m = e("./zlib/constants"), n = e("./zlib/messages"), i = e("./zlib/zstream"), s = e("./zlib/gzheader"), _ = Object.prototype.toString;
      function a(e2) {
        if (!(this instanceof a))
          return new a(e2);
        this.options = d.assign({ chunkSize: 16384, windowBits: 0, to: "" }, e2 || {});
        var t2 = this.options;
        t2.raw && 0 <= t2.windowBits && t2.windowBits < 16 && (t2.windowBits = -t2.windowBits, 0 === t2.windowBits && (t2.windowBits = -15)), !(0 <= t2.windowBits && t2.windowBits < 16) || e2 && e2.windowBits || (t2.windowBits += 32), 15 < t2.windowBits && t2.windowBits < 48 && 0 == (15 & t2.windowBits) && (t2.windowBits |= 15), this.err = 0, this.msg = "", this.ended = false, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0;
        var r2 = c.inflateInit2(this.strm, t2.windowBits);
        if (r2 !== m.Z_OK)
          throw new Error(n[r2]);
        this.header = new s(), c.inflateGetHeader(this.strm, this.header);
      }
      function o(e2, t2) {
        var r2 = new a(t2);
        if (r2.push(e2, true), r2.err)
          throw r2.msg || n[r2.err];
        return r2.result;
      }
      a.prototype.push = function(e2, t2) {
        var r2, n2, i2, s2, a2, o2, h = this.strm, u = this.options.chunkSize, l = this.options.dictionary, f = false;
        if (this.ended)
          return false;
        n2 = t2 === ~~t2 ? t2 : true === t2 ? m.Z_FINISH : m.Z_NO_FLUSH, "string" == typeof e2 ? h.input = p.binstring2buf(e2) : "[object ArrayBuffer]" === _.call(e2) ? h.input = new Uint8Array(e2) : h.input = e2, h.next_in = 0, h.avail_in = h.input.length;
        do {
          if (0 === h.avail_out && (h.output = new d.Buf8(u), h.next_out = 0, h.avail_out = u), (r2 = c.inflate(h, m.Z_NO_FLUSH)) === m.Z_NEED_DICT && l && (o2 = "string" == typeof l ? p.string2buf(l) : "[object ArrayBuffer]" === _.call(l) ? new Uint8Array(l) : l, r2 = c.inflateSetDictionary(this.strm, o2)), r2 === m.Z_BUF_ERROR && true === f && (r2 = m.Z_OK, f = false), r2 !== m.Z_STREAM_END && r2 !== m.Z_OK)
            return this.onEnd(r2), !(this.ended = true);
          h.next_out && (0 !== h.avail_out && r2 !== m.Z_STREAM_END && (0 !== h.avail_in || n2 !== m.Z_FINISH && n2 !== m.Z_SYNC_FLUSH) || ("string" === this.options.to ? (i2 = p.utf8border(h.output, h.next_out), s2 = h.next_out - i2, a2 = p.buf2string(h.output, i2), h.next_out = s2, h.avail_out = u - s2, s2 && d.arraySet(h.output, h.output, i2, s2, 0), this.onData(a2)) : this.onData(d.shrinkBuf(h.output, h.next_out)))), 0 === h.avail_in && 0 === h.avail_out && (f = true);
        } while ((0 < h.avail_in || 0 === h.avail_out) && r2 !== m.Z_STREAM_END);
        return r2 === m.Z_STREAM_END && (n2 = m.Z_FINISH), n2 === m.Z_FINISH ? (r2 = c.inflateEnd(this.strm), this.onEnd(r2), this.ended = true, r2 === m.Z_OK) : n2 !== m.Z_SYNC_FLUSH || (this.onEnd(m.Z_OK), !(h.avail_out = 0));
      }, a.prototype.onData = function(e2) {
        this.chunks.push(e2);
      }, a.prototype.onEnd = function(e2) {
        e2 === m.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = d.flattenChunks(this.chunks)), this.chunks = [], this.err = e2, this.msg = this.strm.msg;
      }, r.Inflate = a, r.inflate = o, r.inflateRaw = function(e2, t2) {
        return (t2 = t2 || {}).raw = true, o(e2, t2);
      }, r.ungzip = o;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, t, r) {
      var n = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
      r.assign = function(e2) {
        for (var t2 = Array.prototype.slice.call(arguments, 1); t2.length; ) {
          var r2 = t2.shift();
          if (r2) {
            if ("object" != typeof r2)
              throw new TypeError(r2 + "must be non-object");
            for (var n2 in r2)
              r2.hasOwnProperty(n2) && (e2[n2] = r2[n2]);
          }
        }
        return e2;
      }, r.shrinkBuf = function(e2, t2) {
        return e2.length === t2 ? e2 : e2.subarray ? e2.subarray(0, t2) : (e2.length = t2, e2);
      };
      var i = { arraySet: function(e2, t2, r2, n2, i2) {
        if (t2.subarray && e2.subarray)
          e2.set(t2.subarray(r2, r2 + n2), i2);
        else
          for (var s2 = 0; s2 < n2; s2++)
            e2[i2 + s2] = t2[r2 + s2];
      }, flattenChunks: function(e2) {
        var t2, r2, n2, i2, s2, a;
        for (t2 = n2 = 0, r2 = e2.length; t2 < r2; t2++)
          n2 += e2[t2].length;
        for (a = new Uint8Array(n2), t2 = i2 = 0, r2 = e2.length; t2 < r2; t2++)
          s2 = e2[t2], a.set(s2, i2), i2 += s2.length;
        return a;
      } }, s = { arraySet: function(e2, t2, r2, n2, i2) {
        for (var s2 = 0; s2 < n2; s2++)
          e2[i2 + s2] = t2[r2 + s2];
      }, flattenChunks: function(e2) {
        return [].concat.apply([], e2);
      } };
      r.setTyped = function(e2) {
        e2 ? (r.Buf8 = Uint8Array, r.Buf16 = Uint16Array, r.Buf32 = Int32Array, r.assign(r, i)) : (r.Buf8 = Array, r.Buf16 = Array, r.Buf32 = Array, r.assign(r, s));
      }, r.setTyped(n);
    }, {}], 42: [function(e, t, r) {
      var h = e("./common"), i = true, s = true;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch (e2) {
        i = false;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch (e2) {
        s = false;
      }
      for (var u = new h.Buf8(256), n = 0; n < 256; n++)
        u[n] = 252 <= n ? 6 : 248 <= n ? 5 : 240 <= n ? 4 : 224 <= n ? 3 : 192 <= n ? 2 : 1;
      function l(e2, t2) {
        if (t2 < 65537 && (e2.subarray && s || !e2.subarray && i))
          return String.fromCharCode.apply(null, h.shrinkBuf(e2, t2));
        for (var r2 = "", n2 = 0; n2 < t2; n2++)
          r2 += String.fromCharCode(e2[n2]);
        return r2;
      }
      u[254] = u[254] = 1, r.string2buf = function(e2) {
        var t2, r2, n2, i2, s2, a = e2.length, o = 0;
        for (i2 = 0; i2 < a; i2++)
          55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), o += r2 < 128 ? 1 : r2 < 2048 ? 2 : r2 < 65536 ? 3 : 4;
        for (t2 = new h.Buf8(o), i2 = s2 = 0; s2 < o; i2++)
          55296 == (64512 & (r2 = e2.charCodeAt(i2))) && i2 + 1 < a && 56320 == (64512 & (n2 = e2.charCodeAt(i2 + 1))) && (r2 = 65536 + (r2 - 55296 << 10) + (n2 - 56320), i2++), r2 < 128 ? t2[s2++] = r2 : (r2 < 2048 ? t2[s2++] = 192 | r2 >>> 6 : (r2 < 65536 ? t2[s2++] = 224 | r2 >>> 12 : (t2[s2++] = 240 | r2 >>> 18, t2[s2++] = 128 | r2 >>> 12 & 63), t2[s2++] = 128 | r2 >>> 6 & 63), t2[s2++] = 128 | 63 & r2);
        return t2;
      }, r.buf2binstring = function(e2) {
        return l(e2, e2.length);
      }, r.binstring2buf = function(e2) {
        for (var t2 = new h.Buf8(e2.length), r2 = 0, n2 = t2.length; r2 < n2; r2++)
          t2[r2] = e2.charCodeAt(r2);
        return t2;
      }, r.buf2string = function(e2, t2) {
        var r2, n2, i2, s2, a = t2 || e2.length, o = new Array(2 * a);
        for (r2 = n2 = 0; r2 < a; )
          if ((i2 = e2[r2++]) < 128)
            o[n2++] = i2;
          else if (4 < (s2 = u[i2]))
            o[n2++] = 65533, r2 += s2 - 1;
          else {
            for (i2 &= 2 === s2 ? 31 : 3 === s2 ? 15 : 7; 1 < s2 && r2 < a; )
              i2 = i2 << 6 | 63 & e2[r2++], s2--;
            1 < s2 ? o[n2++] = 65533 : i2 < 65536 ? o[n2++] = i2 : (i2 -= 65536, o[n2++] = 55296 | i2 >> 10 & 1023, o[n2++] = 56320 | 1023 & i2);
          }
        return l(o, n2);
      }, r.utf8border = function(e2, t2) {
        var r2;
        for ((t2 = t2 || e2.length) > e2.length && (t2 = e2.length), r2 = t2 - 1; 0 <= r2 && 128 == (192 & e2[r2]); )
          r2--;
        return r2 < 0 ? t2 : 0 === r2 ? t2 : r2 + u[e2[r2]] > t2 ? r2 : t2;
      };
    }, { "./common": 41 }], 43: [function(e, t, r) {
      t.exports = function(e2, t2, r2, n) {
        for (var i = 65535 & e2 | 0, s = e2 >>> 16 & 65535 | 0, a = 0; 0 !== r2; ) {
          for (r2 -= a = 2e3 < r2 ? 2e3 : r2; s = s + (i = i + t2[n++] | 0) | 0, --a; )
            ;
          i %= 65521, s %= 65521;
        }
        return i | s << 16 | 0;
      };
    }, {}], 44: [function(e, t, r) {
      t.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(e, t, r) {
      var o = function() {
        for (var e2, t2 = [], r2 = 0; r2 < 256; r2++) {
          e2 = r2;
          for (var n = 0; n < 8; n++)
            e2 = 1 & e2 ? 3988292384 ^ e2 >>> 1 : e2 >>> 1;
          t2[r2] = e2;
        }
        return t2;
      }();
      t.exports = function(e2, t2, r2, n) {
        var i = o, s = n + r2;
        e2 ^= -1;
        for (var a = n; a < s; a++)
          e2 = e2 >>> 8 ^ i[255 & (e2 ^ t2[a])];
        return -1 ^ e2;
      };
    }, {}], 46: [function(e, t, r) {
      var h, c = e("../utils/common"), u = e("./trees"), d = e("./adler32"), p = e("./crc32"), n = e("./messages"), l = 0, f = 4, m = 0, _ = -2, g = -1, b = 4, i = 2, v = 8, y = 9, s = 286, a = 30, o = 19, w = 2 * s + 1, k = 15, x = 3, S = 258, z = S + x + 1, C = 42, E = 113, A = 1, I = 2, O = 3, B = 4;
      function R(e2, t2) {
        return e2.msg = n[t2], t2;
      }
      function T(e2) {
        return (e2 << 1) - (4 < e2 ? 9 : 0);
      }
      function D(e2) {
        for (var t2 = e2.length; 0 <= --t2; )
          e2[t2] = 0;
      }
      function F(e2) {
        var t2 = e2.state, r2 = t2.pending;
        r2 > e2.avail_out && (r2 = e2.avail_out), 0 !== r2 && (c.arraySet(e2.output, t2.pending_buf, t2.pending_out, r2, e2.next_out), e2.next_out += r2, t2.pending_out += r2, e2.total_out += r2, e2.avail_out -= r2, t2.pending -= r2, 0 === t2.pending && (t2.pending_out = 0));
      }
      function N(e2, t2) {
        u._tr_flush_block(e2, 0 <= e2.block_start ? e2.block_start : -1, e2.strstart - e2.block_start, t2), e2.block_start = e2.strstart, F(e2.strm);
      }
      function U(e2, t2) {
        e2.pending_buf[e2.pending++] = t2;
      }
      function P(e2, t2) {
        e2.pending_buf[e2.pending++] = t2 >>> 8 & 255, e2.pending_buf[e2.pending++] = 255 & t2;
      }
      function L(e2, t2) {
        var r2, n2, i2 = e2.max_chain_length, s2 = e2.strstart, a2 = e2.prev_length, o2 = e2.nice_match, h2 = e2.strstart > e2.w_size - z ? e2.strstart - (e2.w_size - z) : 0, u2 = e2.window, l2 = e2.w_mask, f2 = e2.prev, c2 = e2.strstart + S, d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
        e2.prev_length >= e2.good_match && (i2 >>= 2), o2 > e2.lookahead && (o2 = e2.lookahead);
        do {
          if (u2[(r2 = t2) + a2] === p2 && u2[r2 + a2 - 1] === d2 && u2[r2] === u2[s2] && u2[++r2] === u2[s2 + 1]) {
            s2 += 2, r2++;
            do {
            } while (u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && u2[++s2] === u2[++r2] && s2 < c2);
            if (n2 = S - (c2 - s2), s2 = c2 - S, a2 < n2) {
              if (e2.match_start = t2, o2 <= (a2 = n2))
                break;
              d2 = u2[s2 + a2 - 1], p2 = u2[s2 + a2];
            }
          }
        } while ((t2 = f2[t2 & l2]) > h2 && 0 != --i2);
        return a2 <= e2.lookahead ? a2 : e2.lookahead;
      }
      function j(e2) {
        var t2, r2, n2, i2, s2, a2, o2, h2, u2, l2, f2 = e2.w_size;
        do {
          if (i2 = e2.window_size - e2.lookahead - e2.strstart, e2.strstart >= f2 + (f2 - z)) {
            for (c.arraySet(e2.window, e2.window, f2, f2, 0), e2.match_start -= f2, e2.strstart -= f2, e2.block_start -= f2, t2 = r2 = e2.hash_size; n2 = e2.head[--t2], e2.head[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
              ;
            for (t2 = r2 = f2; n2 = e2.prev[--t2], e2.prev[t2] = f2 <= n2 ? n2 - f2 : 0, --r2; )
              ;
            i2 += f2;
          }
          if (0 === e2.strm.avail_in)
            break;
          if (a2 = e2.strm, o2 = e2.window, h2 = e2.strstart + e2.lookahead, u2 = i2, l2 = void 0, l2 = a2.avail_in, u2 < l2 && (l2 = u2), r2 = 0 === l2 ? 0 : (a2.avail_in -= l2, c.arraySet(o2, a2.input, a2.next_in, l2, h2), 1 === a2.state.wrap ? a2.adler = d(a2.adler, o2, l2, h2) : 2 === a2.state.wrap && (a2.adler = p(a2.adler, o2, l2, h2)), a2.next_in += l2, a2.total_in += l2, l2), e2.lookahead += r2, e2.lookahead + e2.insert >= x)
            for (s2 = e2.strstart - e2.insert, e2.ins_h = e2.window[s2], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + 1]) & e2.hash_mask; e2.insert && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[s2 + x - 1]) & e2.hash_mask, e2.prev[s2 & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = s2, s2++, e2.insert--, !(e2.lookahead + e2.insert < x)); )
              ;
        } while (e2.lookahead < z && 0 !== e2.strm.avail_in);
      }
      function Z(e2, t2) {
        for (var r2, n2; ; ) {
          if (e2.lookahead < z) {
            if (j(e2), e2.lookahead < z && t2 === l)
              return A;
            if (0 === e2.lookahead)
              break;
          }
          if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 !== r2 && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2)), e2.match_length >= x)
            if (n2 = u._tr_tally(e2, e2.strstart - e2.match_start, e2.match_length - x), e2.lookahead -= e2.match_length, e2.match_length <= e2.max_lazy_match && e2.lookahead >= x) {
              for (e2.match_length--; e2.strstart++, e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart, 0 != --e2.match_length; )
                ;
              e2.strstart++;
            } else
              e2.strstart += e2.match_length, e2.match_length = 0, e2.ins_h = e2.window[e2.strstart], e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + 1]) & e2.hash_mask;
          else
            n2 = u._tr_tally(e2, 0, e2.window[e2.strstart]), e2.lookahead--, e2.strstart++;
          if (n2 && (N(e2, false), 0 === e2.strm.avail_out))
            return A;
        }
        return e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
      }
      function W(e2, t2) {
        for (var r2, n2, i2; ; ) {
          if (e2.lookahead < z) {
            if (j(e2), e2.lookahead < z && t2 === l)
              return A;
            if (0 === e2.lookahead)
              break;
          }
          if (r2 = 0, e2.lookahead >= x && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), e2.prev_length = e2.match_length, e2.prev_match = e2.match_start, e2.match_length = x - 1, 0 !== r2 && e2.prev_length < e2.max_lazy_match && e2.strstart - r2 <= e2.w_size - z && (e2.match_length = L(e2, r2), e2.match_length <= 5 && (1 === e2.strategy || e2.match_length === x && 4096 < e2.strstart - e2.match_start) && (e2.match_length = x - 1)), e2.prev_length >= x && e2.match_length <= e2.prev_length) {
            for (i2 = e2.strstart + e2.lookahead - x, n2 = u._tr_tally(e2, e2.strstart - 1 - e2.prev_match, e2.prev_length - x), e2.lookahead -= e2.prev_length - 1, e2.prev_length -= 2; ++e2.strstart <= i2 && (e2.ins_h = (e2.ins_h << e2.hash_shift ^ e2.window[e2.strstart + x - 1]) & e2.hash_mask, r2 = e2.prev[e2.strstart & e2.w_mask] = e2.head[e2.ins_h], e2.head[e2.ins_h] = e2.strstart), 0 != --e2.prev_length; )
              ;
            if (e2.match_available = 0, e2.match_length = x - 1, e2.strstart++, n2 && (N(e2, false), 0 === e2.strm.avail_out))
              return A;
          } else if (e2.match_available) {
            if ((n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1])) && N(e2, false), e2.strstart++, e2.lookahead--, 0 === e2.strm.avail_out)
              return A;
          } else
            e2.match_available = 1, e2.strstart++, e2.lookahead--;
        }
        return e2.match_available && (n2 = u._tr_tally(e2, 0, e2.window[e2.strstart - 1]), e2.match_available = 0), e2.insert = e2.strstart < x - 1 ? e2.strstart : x - 1, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : e2.last_lit && (N(e2, false), 0 === e2.strm.avail_out) ? A : I;
      }
      function M(e2, t2, r2, n2, i2) {
        this.good_length = e2, this.max_lazy = t2, this.nice_length = r2, this.max_chain = n2, this.func = i2;
      }
      function H() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new c.Buf16(2 * w), this.dyn_dtree = new c.Buf16(2 * (2 * a + 1)), this.bl_tree = new c.Buf16(2 * (2 * o + 1)), D(this.dyn_ltree), D(this.dyn_dtree), D(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new c.Buf16(k + 1), this.heap = new c.Buf16(2 * s + 1), D(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new c.Buf16(2 * s + 1), D(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function G(e2) {
        var t2;
        return e2 && e2.state ? (e2.total_in = e2.total_out = 0, e2.data_type = i, (t2 = e2.state).pending = 0, t2.pending_out = 0, t2.wrap < 0 && (t2.wrap = -t2.wrap), t2.status = t2.wrap ? C : E, e2.adler = 2 === t2.wrap ? 0 : 1, t2.last_flush = l, u._tr_init(t2), m) : R(e2, _);
      }
      function K(e2) {
        var t2 = G(e2);
        return t2 === m && function(e3) {
          e3.window_size = 2 * e3.w_size, D(e3.head), e3.max_lazy_match = h[e3.level].max_lazy, e3.good_match = h[e3.level].good_length, e3.nice_match = h[e3.level].nice_length, e3.max_chain_length = h[e3.level].max_chain, e3.strstart = 0, e3.block_start = 0, e3.lookahead = 0, e3.insert = 0, e3.match_length = e3.prev_length = x - 1, e3.match_available = 0, e3.ins_h = 0;
        }(e2.state), t2;
      }
      function Y(e2, t2, r2, n2, i2, s2) {
        if (!e2)
          return _;
        var a2 = 1;
        if (t2 === g && (t2 = 6), n2 < 0 ? (a2 = 0, n2 = -n2) : 15 < n2 && (a2 = 2, n2 -= 16), i2 < 1 || y < i2 || r2 !== v || n2 < 8 || 15 < n2 || t2 < 0 || 9 < t2 || s2 < 0 || b < s2)
          return R(e2, _);
        8 === n2 && (n2 = 9);
        var o2 = new H();
        return (e2.state = o2).strm = e2, o2.wrap = a2, o2.gzhead = null, o2.w_bits = n2, o2.w_size = 1 << o2.w_bits, o2.w_mask = o2.w_size - 1, o2.hash_bits = i2 + 7, o2.hash_size = 1 << o2.hash_bits, o2.hash_mask = o2.hash_size - 1, o2.hash_shift = ~~((o2.hash_bits + x - 1) / x), o2.window = new c.Buf8(2 * o2.w_size), o2.head = new c.Buf16(o2.hash_size), o2.prev = new c.Buf16(o2.w_size), o2.lit_bufsize = 1 << i2 + 6, o2.pending_buf_size = 4 * o2.lit_bufsize, o2.pending_buf = new c.Buf8(o2.pending_buf_size), o2.d_buf = 1 * o2.lit_bufsize, o2.l_buf = 3 * o2.lit_bufsize, o2.level = t2, o2.strategy = s2, o2.method = r2, K(e2);
      }
      h = [new M(0, 0, 0, 0, function(e2, t2) {
        var r2 = 65535;
        for (r2 > e2.pending_buf_size - 5 && (r2 = e2.pending_buf_size - 5); ; ) {
          if (e2.lookahead <= 1) {
            if (j(e2), 0 === e2.lookahead && t2 === l)
              return A;
            if (0 === e2.lookahead)
              break;
          }
          e2.strstart += e2.lookahead, e2.lookahead = 0;
          var n2 = e2.block_start + r2;
          if ((0 === e2.strstart || e2.strstart >= n2) && (e2.lookahead = e2.strstart - n2, e2.strstart = n2, N(e2, false), 0 === e2.strm.avail_out))
            return A;
          if (e2.strstart - e2.block_start >= e2.w_size - z && (N(e2, false), 0 === e2.strm.avail_out))
            return A;
        }
        return e2.insert = 0, t2 === f ? (N(e2, true), 0 === e2.strm.avail_out ? O : B) : (e2.strstart > e2.block_start && (N(e2, false), e2.strm.avail_out), A);
      }), new M(4, 4, 8, 4, Z), new M(4, 5, 16, 8, Z), new M(4, 6, 32, 32, Z), new M(4, 4, 16, 16, W), new M(8, 16, 32, 32, W), new M(8, 16, 128, 128, W), new M(8, 32, 128, 256, W), new M(32, 128, 258, 1024, W), new M(32, 258, 258, 4096, W)], r.deflateInit = function(e2, t2) {
        return Y(e2, t2, v, 15, 8, 0);
      }, r.deflateInit2 = Y, r.deflateReset = K, r.deflateResetKeep = G, r.deflateSetHeader = function(e2, t2) {
        return e2 && e2.state ? 2 !== e2.state.wrap ? _ : (e2.state.gzhead = t2, m) : _;
      }, r.deflate = function(e2, t2) {
        var r2, n2, i2, s2;
        if (!e2 || !e2.state || 5 < t2 || t2 < 0)
          return e2 ? R(e2, _) : _;
        if (n2 = e2.state, !e2.output || !e2.input && 0 !== e2.avail_in || 666 === n2.status && t2 !== f)
          return R(e2, 0 === e2.avail_out ? -5 : _);
        if (n2.strm = e2, r2 = n2.last_flush, n2.last_flush = t2, n2.status === C)
          if (2 === n2.wrap)
            e2.adler = 0, U(n2, 31), U(n2, 139), U(n2, 8), n2.gzhead ? (U(n2, (n2.gzhead.text ? 1 : 0) + (n2.gzhead.hcrc ? 2 : 0) + (n2.gzhead.extra ? 4 : 0) + (n2.gzhead.name ? 8 : 0) + (n2.gzhead.comment ? 16 : 0)), U(n2, 255 & n2.gzhead.time), U(n2, n2.gzhead.time >> 8 & 255), U(n2, n2.gzhead.time >> 16 & 255), U(n2, n2.gzhead.time >> 24 & 255), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 255 & n2.gzhead.os), n2.gzhead.extra && n2.gzhead.extra.length && (U(n2, 255 & n2.gzhead.extra.length), U(n2, n2.gzhead.extra.length >> 8 & 255)), n2.gzhead.hcrc && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending, 0)), n2.gzindex = 0, n2.status = 69) : (U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 0), U(n2, 9 === n2.level ? 2 : 2 <= n2.strategy || n2.level < 2 ? 4 : 0), U(n2, 3), n2.status = E);
          else {
            var a2 = v + (n2.w_bits - 8 << 4) << 8;
            a2 |= (2 <= n2.strategy || n2.level < 2 ? 0 : n2.level < 6 ? 1 : 6 === n2.level ? 2 : 3) << 6, 0 !== n2.strstart && (a2 |= 32), a2 += 31 - a2 % 31, n2.status = E, P(n2, a2), 0 !== n2.strstart && (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), e2.adler = 1;
          }
        if (69 === n2.status)
          if (n2.gzhead.extra) {
            for (i2 = n2.pending; n2.gzindex < (65535 & n2.gzhead.extra.length) && (n2.pending !== n2.pending_buf_size || (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending !== n2.pending_buf_size)); )
              U(n2, 255 & n2.gzhead.extra[n2.gzindex]), n2.gzindex++;
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), n2.gzindex === n2.gzhead.extra.length && (n2.gzindex = 0, n2.status = 73);
          } else
            n2.status = 73;
        if (73 === n2.status)
          if (n2.gzhead.name) {
            i2 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = n2.gzindex < n2.gzhead.name.length ? 255 & n2.gzhead.name.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
            } while (0 !== s2);
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.gzindex = 0, n2.status = 91);
          } else
            n2.status = 91;
        if (91 === n2.status)
          if (n2.gzhead.comment) {
            i2 = n2.pending;
            do {
              if (n2.pending === n2.pending_buf_size && (n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), F(e2), i2 = n2.pending, n2.pending === n2.pending_buf_size)) {
                s2 = 1;
                break;
              }
              s2 = n2.gzindex < n2.gzhead.comment.length ? 255 & n2.gzhead.comment.charCodeAt(n2.gzindex++) : 0, U(n2, s2);
            } while (0 !== s2);
            n2.gzhead.hcrc && n2.pending > i2 && (e2.adler = p(e2.adler, n2.pending_buf, n2.pending - i2, i2)), 0 === s2 && (n2.status = 103);
          } else
            n2.status = 103;
        if (103 === n2.status && (n2.gzhead.hcrc ? (n2.pending + 2 > n2.pending_buf_size && F(e2), n2.pending + 2 <= n2.pending_buf_size && (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), e2.adler = 0, n2.status = E)) : n2.status = E), 0 !== n2.pending) {
          if (F(e2), 0 === e2.avail_out)
            return n2.last_flush = -1, m;
        } else if (0 === e2.avail_in && T(t2) <= T(r2) && t2 !== f)
          return R(e2, -5);
        if (666 === n2.status && 0 !== e2.avail_in)
          return R(e2, -5);
        if (0 !== e2.avail_in || 0 !== n2.lookahead || t2 !== l && 666 !== n2.status) {
          var o2 = 2 === n2.strategy ? function(e3, t3) {
            for (var r3; ; ) {
              if (0 === e3.lookahead && (j(e3), 0 === e3.lookahead)) {
                if (t3 === l)
                  return A;
                break;
              }
              if (e3.match_length = 0, r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++, r3 && (N(e3, false), 0 === e3.strm.avail_out))
                return A;
            }
            return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
          }(n2, t2) : 3 === n2.strategy ? function(e3, t3) {
            for (var r3, n3, i3, s3, a3 = e3.window; ; ) {
              if (e3.lookahead <= S) {
                if (j(e3), e3.lookahead <= S && t3 === l)
                  return A;
                if (0 === e3.lookahead)
                  break;
              }
              if (e3.match_length = 0, e3.lookahead >= x && 0 < e3.strstart && (n3 = a3[i3 = e3.strstart - 1]) === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3]) {
                s3 = e3.strstart + S;
                do {
                } while (n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && n3 === a3[++i3] && i3 < s3);
                e3.match_length = S - (s3 - i3), e3.match_length > e3.lookahead && (e3.match_length = e3.lookahead);
              }
              if (e3.match_length >= x ? (r3 = u._tr_tally(e3, 1, e3.match_length - x), e3.lookahead -= e3.match_length, e3.strstart += e3.match_length, e3.match_length = 0) : (r3 = u._tr_tally(e3, 0, e3.window[e3.strstart]), e3.lookahead--, e3.strstart++), r3 && (N(e3, false), 0 === e3.strm.avail_out))
                return A;
            }
            return e3.insert = 0, t3 === f ? (N(e3, true), 0 === e3.strm.avail_out ? O : B) : e3.last_lit && (N(e3, false), 0 === e3.strm.avail_out) ? A : I;
          }(n2, t2) : h[n2.level].func(n2, t2);
          if (o2 !== O && o2 !== B || (n2.status = 666), o2 === A || o2 === O)
            return 0 === e2.avail_out && (n2.last_flush = -1), m;
          if (o2 === I && (1 === t2 ? u._tr_align(n2) : 5 !== t2 && (u._tr_stored_block(n2, 0, 0, false), 3 === t2 && (D(n2.head), 0 === n2.lookahead && (n2.strstart = 0, n2.block_start = 0, n2.insert = 0))), F(e2), 0 === e2.avail_out))
            return n2.last_flush = -1, m;
        }
        return t2 !== f ? m : n2.wrap <= 0 ? 1 : (2 === n2.wrap ? (U(n2, 255 & e2.adler), U(n2, e2.adler >> 8 & 255), U(n2, e2.adler >> 16 & 255), U(n2, e2.adler >> 24 & 255), U(n2, 255 & e2.total_in), U(n2, e2.total_in >> 8 & 255), U(n2, e2.total_in >> 16 & 255), U(n2, e2.total_in >> 24 & 255)) : (P(n2, e2.adler >>> 16), P(n2, 65535 & e2.adler)), F(e2), 0 < n2.wrap && (n2.wrap = -n2.wrap), 0 !== n2.pending ? m : 1);
      }, r.deflateEnd = function(e2) {
        var t2;
        return e2 && e2.state ? (t2 = e2.state.status) !== C && 69 !== t2 && 73 !== t2 && 91 !== t2 && 103 !== t2 && t2 !== E && 666 !== t2 ? R(e2, _) : (e2.state = null, t2 === E ? R(e2, -3) : m) : _;
      }, r.deflateSetDictionary = function(e2, t2) {
        var r2, n2, i2, s2, a2, o2, h2, u2, l2 = t2.length;
        if (!e2 || !e2.state)
          return _;
        if (2 === (s2 = (r2 = e2.state).wrap) || 1 === s2 && r2.status !== C || r2.lookahead)
          return _;
        for (1 === s2 && (e2.adler = d(e2.adler, t2, l2, 0)), r2.wrap = 0, l2 >= r2.w_size && (0 === s2 && (D(r2.head), r2.strstart = 0, r2.block_start = 0, r2.insert = 0), u2 = new c.Buf8(r2.w_size), c.arraySet(u2, t2, l2 - r2.w_size, r2.w_size, 0), t2 = u2, l2 = r2.w_size), a2 = e2.avail_in, o2 = e2.next_in, h2 = e2.input, e2.avail_in = l2, e2.next_in = 0, e2.input = t2, j(r2); r2.lookahead >= x; ) {
          for (n2 = r2.strstart, i2 = r2.lookahead - (x - 1); r2.ins_h = (r2.ins_h << r2.hash_shift ^ r2.window[n2 + x - 1]) & r2.hash_mask, r2.prev[n2 & r2.w_mask] = r2.head[r2.ins_h], r2.head[r2.ins_h] = n2, n2++, --i2; )
            ;
          r2.strstart = n2, r2.lookahead = x - 1, j(r2);
        }
        return r2.strstart += r2.lookahead, r2.block_start = r2.strstart, r2.insert = r2.lookahead, r2.lookahead = 0, r2.match_length = r2.prev_length = x - 1, r2.match_available = 0, e2.next_in = o2, e2.input = h2, e2.avail_in = a2, r2.wrap = s2, m;
      }, r.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, t, r) {
      t.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = false;
      };
    }, {}], 48: [function(e, t, r) {
      t.exports = function(e2, t2) {
        var r2, n, i, s, a, o, h, u, l, f, c, d, p, m, _, g, b, v, y, w, k, x, S, z, C;
        r2 = e2.state, n = e2.next_in, z = e2.input, i = n + (e2.avail_in - 5), s = e2.next_out, C = e2.output, a = s - (t2 - e2.avail_out), o = s + (e2.avail_out - 257), h = r2.dmax, u = r2.wsize, l = r2.whave, f = r2.wnext, c = r2.window, d = r2.hold, p = r2.bits, m = r2.lencode, _ = r2.distcode, g = (1 << r2.lenbits) - 1, b = (1 << r2.distbits) - 1;
        e:
          do {
            p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = m[d & g];
            t:
              for (; ; ) {
                if (d >>>= y = v >>> 24, p -= y, 0 === (y = v >>> 16 & 255))
                  C[s++] = 65535 & v;
                else {
                  if (!(16 & y)) {
                    if (0 == (64 & y)) {
                      v = m[(65535 & v) + (d & (1 << y) - 1)];
                      continue t;
                    }
                    if (32 & y) {
                      r2.mode = 12;
                      break e;
                    }
                    e2.msg = "invalid literal/length code", r2.mode = 30;
                    break e;
                  }
                  w = 65535 & v, (y &= 15) && (p < y && (d += z[n++] << p, p += 8), w += d & (1 << y) - 1, d >>>= y, p -= y), p < 15 && (d += z[n++] << p, p += 8, d += z[n++] << p, p += 8), v = _[d & b];
                  r:
                    for (; ; ) {
                      if (d >>>= y = v >>> 24, p -= y, !(16 & (y = v >>> 16 & 255))) {
                        if (0 == (64 & y)) {
                          v = _[(65535 & v) + (d & (1 << y) - 1)];
                          continue r;
                        }
                        e2.msg = "invalid distance code", r2.mode = 30;
                        break e;
                      }
                      if (k = 65535 & v, p < (y &= 15) && (d += z[n++] << p, (p += 8) < y && (d += z[n++] << p, p += 8)), h < (k += d & (1 << y) - 1)) {
                        e2.msg = "invalid distance too far back", r2.mode = 30;
                        break e;
                      }
                      if (d >>>= y, p -= y, (y = s - a) < k) {
                        if (l < (y = k - y) && r2.sane) {
                          e2.msg = "invalid distance too far back", r2.mode = 30;
                          break e;
                        }
                        if (S = c, (x = 0) === f) {
                          if (x += u - y, y < w) {
                            for (w -= y; C[s++] = c[x++], --y; )
                              ;
                            x = s - k, S = C;
                          }
                        } else if (f < y) {
                          if (x += u + f - y, (y -= f) < w) {
                            for (w -= y; C[s++] = c[x++], --y; )
                              ;
                            if (x = 0, f < w) {
                              for (w -= y = f; C[s++] = c[x++], --y; )
                                ;
                              x = s - k, S = C;
                            }
                          }
                        } else if (x += f - y, y < w) {
                          for (w -= y; C[s++] = c[x++], --y; )
                            ;
                          x = s - k, S = C;
                        }
                        for (; 2 < w; )
                          C[s++] = S[x++], C[s++] = S[x++], C[s++] = S[x++], w -= 3;
                        w && (C[s++] = S[x++], 1 < w && (C[s++] = S[x++]));
                      } else {
                        for (x = s - k; C[s++] = C[x++], C[s++] = C[x++], C[s++] = C[x++], 2 < (w -= 3); )
                          ;
                        w && (C[s++] = C[x++], 1 < w && (C[s++] = C[x++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (n < i && s < o);
        n -= w = p >> 3, d &= (1 << (p -= w << 3)) - 1, e2.next_in = n, e2.next_out = s, e2.avail_in = n < i ? i - n + 5 : 5 - (n - i), e2.avail_out = s < o ? o - s + 257 : 257 - (s - o), r2.hold = d, r2.bits = p;
      };
    }, {}], 49: [function(e, t, r) {
      var I = e("../utils/common"), O = e("./adler32"), B = e("./crc32"), R = e("./inffast"), T = e("./inftrees"), D = 1, F = 2, N = 0, U = -2, P = 1, n = 852, i = 592;
      function L(e2) {
        return (e2 >>> 24 & 255) + (e2 >>> 8 & 65280) + ((65280 & e2) << 8) + ((255 & e2) << 24);
      }
      function s() {
        this.mode = 0, this.last = false, this.wrap = 0, this.havedict = false, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new I.Buf16(320), this.work = new I.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function a(e2) {
        var t2;
        return e2 && e2.state ? (t2 = e2.state, e2.total_in = e2.total_out = t2.total = 0, e2.msg = "", t2.wrap && (e2.adler = 1 & t2.wrap), t2.mode = P, t2.last = 0, t2.havedict = 0, t2.dmax = 32768, t2.head = null, t2.hold = 0, t2.bits = 0, t2.lencode = t2.lendyn = new I.Buf32(n), t2.distcode = t2.distdyn = new I.Buf32(i), t2.sane = 1, t2.back = -1, N) : U;
      }
      function o(e2) {
        var t2;
        return e2 && e2.state ? ((t2 = e2.state).wsize = 0, t2.whave = 0, t2.wnext = 0, a(e2)) : U;
      }
      function h(e2, t2) {
        var r2, n2;
        return e2 && e2.state ? (n2 = e2.state, t2 < 0 ? (r2 = 0, t2 = -t2) : (r2 = 1 + (t2 >> 4), t2 < 48 && (t2 &= 15)), t2 && (t2 < 8 || 15 < t2) ? U : (null !== n2.window && n2.wbits !== t2 && (n2.window = null), n2.wrap = r2, n2.wbits = t2, o(e2))) : U;
      }
      function u(e2, t2) {
        var r2, n2;
        return e2 ? (n2 = new s(), (e2.state = n2).window = null, (r2 = h(e2, t2)) !== N && (e2.state = null), r2) : U;
      }
      var l, f, c = true;
      function j(e2) {
        if (c) {
          var t2;
          for (l = new I.Buf32(512), f = new I.Buf32(32), t2 = 0; t2 < 144; )
            e2.lens[t2++] = 8;
          for (; t2 < 256; )
            e2.lens[t2++] = 9;
          for (; t2 < 280; )
            e2.lens[t2++] = 7;
          for (; t2 < 288; )
            e2.lens[t2++] = 8;
          for (T(D, e2.lens, 0, 288, l, 0, e2.work, { bits: 9 }), t2 = 0; t2 < 32; )
            e2.lens[t2++] = 5;
          T(F, e2.lens, 0, 32, f, 0, e2.work, { bits: 5 }), c = false;
        }
        e2.lencode = l, e2.lenbits = 9, e2.distcode = f, e2.distbits = 5;
      }
      function Z(e2, t2, r2, n2) {
        var i2, s2 = e2.state;
        return null === s2.window && (s2.wsize = 1 << s2.wbits, s2.wnext = 0, s2.whave = 0, s2.window = new I.Buf8(s2.wsize)), n2 >= s2.wsize ? (I.arraySet(s2.window, t2, r2 - s2.wsize, s2.wsize, 0), s2.wnext = 0, s2.whave = s2.wsize) : (n2 < (i2 = s2.wsize - s2.wnext) && (i2 = n2), I.arraySet(s2.window, t2, r2 - n2, i2, s2.wnext), (n2 -= i2) ? (I.arraySet(s2.window, t2, r2 - n2, n2, 0), s2.wnext = n2, s2.whave = s2.wsize) : (s2.wnext += i2, s2.wnext === s2.wsize && (s2.wnext = 0), s2.whave < s2.wsize && (s2.whave += i2))), 0;
      }
      r.inflateReset = o, r.inflateReset2 = h, r.inflateResetKeep = a, r.inflateInit = function(e2) {
        return u(e2, 15);
      }, r.inflateInit2 = u, r.inflate = function(e2, t2) {
        var r2, n2, i2, s2, a2, o2, h2, u2, l2, f2, c2, d, p, m, _, g, b, v, y, w, k, x, S, z, C = 0, E = new I.Buf8(4), A = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!e2 || !e2.state || !e2.output || !e2.input && 0 !== e2.avail_in)
          return U;
        12 === (r2 = e2.state).mode && (r2.mode = 13), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, f2 = o2, c2 = h2, x = N;
        e:
          for (; ; )
            switch (r2.mode) {
              case P:
                if (0 === r2.wrap) {
                  r2.mode = 13;
                  break;
                }
                for (; l2 < 16; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (2 & r2.wrap && 35615 === u2) {
                  E[r2.check = 0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0), l2 = u2 = 0, r2.mode = 2;
                  break;
                }
                if (r2.flags = 0, r2.head && (r2.head.done = false), !(1 & r2.wrap) || (((255 & u2) << 8) + (u2 >> 8)) % 31) {
                  e2.msg = "incorrect header check", r2.mode = 30;
                  break;
                }
                if (8 != (15 & u2)) {
                  e2.msg = "unknown compression method", r2.mode = 30;
                  break;
                }
                if (l2 -= 4, k = 8 + (15 & (u2 >>>= 4)), 0 === r2.wbits)
                  r2.wbits = k;
                else if (k > r2.wbits) {
                  e2.msg = "invalid window size", r2.mode = 30;
                  break;
                }
                r2.dmax = 1 << k, e2.adler = r2.check = 1, r2.mode = 512 & u2 ? 10 : 12, l2 = u2 = 0;
                break;
              case 2:
                for (; l2 < 16; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (r2.flags = u2, 8 != (255 & r2.flags)) {
                  e2.msg = "unknown compression method", r2.mode = 30;
                  break;
                }
                if (57344 & r2.flags) {
                  e2.msg = "unknown header flags set", r2.mode = 30;
                  break;
                }
                r2.head && (r2.head.text = u2 >> 8 & 1), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 3;
              case 3:
                for (; l2 < 32; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.head && (r2.head.time = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, E[2] = u2 >>> 16 & 255, E[3] = u2 >>> 24 & 255, r2.check = B(r2.check, E, 4, 0)), l2 = u2 = 0, r2.mode = 4;
              case 4:
                for (; l2 < 16; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                r2.head && (r2.head.xflags = 255 & u2, r2.head.os = u2 >> 8), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0, r2.mode = 5;
              case 5:
                if (1024 & r2.flags) {
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.length = u2, r2.head && (r2.head.extra_len = u2), 512 & r2.flags && (E[0] = 255 & u2, E[1] = u2 >>> 8 & 255, r2.check = B(r2.check, E, 2, 0)), l2 = u2 = 0;
                } else
                  r2.head && (r2.head.extra = null);
                r2.mode = 6;
              case 6:
                if (1024 & r2.flags && (o2 < (d = r2.length) && (d = o2), d && (r2.head && (k = r2.head.extra_len - r2.length, r2.head.extra || (r2.head.extra = new Array(r2.head.extra_len)), I.arraySet(r2.head.extra, n2, s2, d, k)), 512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, r2.length -= d), r2.length))
                  break e;
                r2.length = 0, r2.mode = 7;
              case 7:
                if (2048 & r2.flags) {
                  if (0 === o2)
                    break e;
                  for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.name += String.fromCharCode(k)), k && d < o2; )
                    ;
                  if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                    break e;
                } else
                  r2.head && (r2.head.name = null);
                r2.length = 0, r2.mode = 8;
              case 8:
                if (4096 & r2.flags) {
                  if (0 === o2)
                    break e;
                  for (d = 0; k = n2[s2 + d++], r2.head && k && r2.length < 65536 && (r2.head.comment += String.fromCharCode(k)), k && d < o2; )
                    ;
                  if (512 & r2.flags && (r2.check = B(r2.check, n2, d, s2)), o2 -= d, s2 += d, k)
                    break e;
                } else
                  r2.head && (r2.head.comment = null);
                r2.mode = 9;
              case 9:
                if (512 & r2.flags) {
                  for (; l2 < 16; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (u2 !== (65535 & r2.check)) {
                    e2.msg = "header crc mismatch", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.head && (r2.head.hcrc = r2.flags >> 9 & 1, r2.head.done = true), e2.adler = r2.check = 0, r2.mode = 12;
                break;
              case 10:
                for (; l2 < 32; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                e2.adler = r2.check = L(u2), l2 = u2 = 0, r2.mode = 11;
              case 11:
                if (0 === r2.havedict)
                  return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, 2;
                e2.adler = r2.check = 1, r2.mode = 12;
              case 12:
                if (5 === t2 || 6 === t2)
                  break e;
              case 13:
                if (r2.last) {
                  u2 >>>= 7 & l2, l2 -= 7 & l2, r2.mode = 27;
                  break;
                }
                for (; l2 < 3; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                switch (r2.last = 1 & u2, l2 -= 1, 3 & (u2 >>>= 1)) {
                  case 0:
                    r2.mode = 14;
                    break;
                  case 1:
                    if (j(r2), r2.mode = 20, 6 !== t2)
                      break;
                    u2 >>>= 2, l2 -= 2;
                    break e;
                  case 2:
                    r2.mode = 17;
                    break;
                  case 3:
                    e2.msg = "invalid block type", r2.mode = 30;
                }
                u2 >>>= 2, l2 -= 2;
                break;
              case 14:
                for (u2 >>>= 7 & l2, l2 -= 7 & l2; l2 < 32; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if ((65535 & u2) != (u2 >>> 16 ^ 65535)) {
                  e2.msg = "invalid stored block lengths", r2.mode = 30;
                  break;
                }
                if (r2.length = 65535 & u2, l2 = u2 = 0, r2.mode = 15, 6 === t2)
                  break e;
              case 15:
                r2.mode = 16;
              case 16:
                if (d = r2.length) {
                  if (o2 < d && (d = o2), h2 < d && (d = h2), 0 === d)
                    break e;
                  I.arraySet(i2, n2, s2, d, a2), o2 -= d, s2 += d, h2 -= d, a2 += d, r2.length -= d;
                  break;
                }
                r2.mode = 12;
                break;
              case 17:
                for (; l2 < 14; ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (r2.nlen = 257 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ndist = 1 + (31 & u2), u2 >>>= 5, l2 -= 5, r2.ncode = 4 + (15 & u2), u2 >>>= 4, l2 -= 4, 286 < r2.nlen || 30 < r2.ndist) {
                  e2.msg = "too many length or distance symbols", r2.mode = 30;
                  break;
                }
                r2.have = 0, r2.mode = 18;
              case 18:
                for (; r2.have < r2.ncode; ) {
                  for (; l2 < 3; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.lens[A[r2.have++]] = 7 & u2, u2 >>>= 3, l2 -= 3;
                }
                for (; r2.have < 19; )
                  r2.lens[A[r2.have++]] = 0;
                if (r2.lencode = r2.lendyn, r2.lenbits = 7, S = { bits: r2.lenbits }, x = T(0, r2.lens, 0, 19, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                  e2.msg = "invalid code lengths set", r2.mode = 30;
                  break;
                }
                r2.have = 0, r2.mode = 19;
              case 19:
                for (; r2.have < r2.nlen + r2.ndist; ) {
                  for (; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (b < 16)
                    u2 >>>= _, l2 -= _, r2.lens[r2.have++] = b;
                  else {
                    if (16 === b) {
                      for (z = _ + 2; l2 < z; ) {
                        if (0 === o2)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      if (u2 >>>= _, l2 -= _, 0 === r2.have) {
                        e2.msg = "invalid bit length repeat", r2.mode = 30;
                        break;
                      }
                      k = r2.lens[r2.have - 1], d = 3 + (3 & u2), u2 >>>= 2, l2 -= 2;
                    } else if (17 === b) {
                      for (z = _ + 3; l2 < z; ) {
                        if (0 === o2)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      l2 -= _, k = 0, d = 3 + (7 & (u2 >>>= _)), u2 >>>= 3, l2 -= 3;
                    } else {
                      for (z = _ + 7; l2 < z; ) {
                        if (0 === o2)
                          break e;
                        o2--, u2 += n2[s2++] << l2, l2 += 8;
                      }
                      l2 -= _, k = 0, d = 11 + (127 & (u2 >>>= _)), u2 >>>= 7, l2 -= 7;
                    }
                    if (r2.have + d > r2.nlen + r2.ndist) {
                      e2.msg = "invalid bit length repeat", r2.mode = 30;
                      break;
                    }
                    for (; d--; )
                      r2.lens[r2.have++] = k;
                  }
                }
                if (30 === r2.mode)
                  break;
                if (0 === r2.lens[256]) {
                  e2.msg = "invalid code -- missing end-of-block", r2.mode = 30;
                  break;
                }
                if (r2.lenbits = 9, S = { bits: r2.lenbits }, x = T(D, r2.lens, 0, r2.nlen, r2.lencode, 0, r2.work, S), r2.lenbits = S.bits, x) {
                  e2.msg = "invalid literal/lengths set", r2.mode = 30;
                  break;
                }
                if (r2.distbits = 6, r2.distcode = r2.distdyn, S = { bits: r2.distbits }, x = T(F, r2.lens, r2.nlen, r2.ndist, r2.distcode, 0, r2.work, S), r2.distbits = S.bits, x) {
                  e2.msg = "invalid distances set", r2.mode = 30;
                  break;
                }
                if (r2.mode = 20, 6 === t2)
                  break e;
              case 20:
                r2.mode = 21;
              case 21:
                if (6 <= o2 && 258 <= h2) {
                  e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, R(e2, c2), a2 = e2.next_out, i2 = e2.output, h2 = e2.avail_out, s2 = e2.next_in, n2 = e2.input, o2 = e2.avail_in, u2 = r2.hold, l2 = r2.bits, 12 === r2.mode && (r2.back = -1);
                  break;
                }
                for (r2.back = 0; g = (C = r2.lencode[u2 & (1 << r2.lenbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (g && 0 == (240 & g)) {
                  for (v = _, y = g, w = b; g = (C = r2.lencode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  u2 >>>= v, l2 -= v, r2.back += v;
                }
                if (u2 >>>= _, l2 -= _, r2.back += _, r2.length = b, 0 === g) {
                  r2.mode = 26;
                  break;
                }
                if (32 & g) {
                  r2.back = -1, r2.mode = 12;
                  break;
                }
                if (64 & g) {
                  e2.msg = "invalid literal/length code", r2.mode = 30;
                  break;
                }
                r2.extra = 15 & g, r2.mode = 22;
              case 22:
                if (r2.extra) {
                  for (z = r2.extra; l2 < z; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.length += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                }
                r2.was = r2.length, r2.mode = 23;
              case 23:
                for (; g = (C = r2.distcode[u2 & (1 << r2.distbits) - 1]) >>> 16 & 255, b = 65535 & C, !((_ = C >>> 24) <= l2); ) {
                  if (0 === o2)
                    break e;
                  o2--, u2 += n2[s2++] << l2, l2 += 8;
                }
                if (0 == (240 & g)) {
                  for (v = _, y = g, w = b; g = (C = r2.distcode[w + ((u2 & (1 << v + y) - 1) >> v)]) >>> 16 & 255, b = 65535 & C, !(v + (_ = C >>> 24) <= l2); ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  u2 >>>= v, l2 -= v, r2.back += v;
                }
                if (u2 >>>= _, l2 -= _, r2.back += _, 64 & g) {
                  e2.msg = "invalid distance code", r2.mode = 30;
                  break;
                }
                r2.offset = b, r2.extra = 15 & g, r2.mode = 24;
              case 24:
                if (r2.extra) {
                  for (z = r2.extra; l2 < z; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  r2.offset += u2 & (1 << r2.extra) - 1, u2 >>>= r2.extra, l2 -= r2.extra, r2.back += r2.extra;
                }
                if (r2.offset > r2.dmax) {
                  e2.msg = "invalid distance too far back", r2.mode = 30;
                  break;
                }
                r2.mode = 25;
              case 25:
                if (0 === h2)
                  break e;
                if (d = c2 - h2, r2.offset > d) {
                  if ((d = r2.offset - d) > r2.whave && r2.sane) {
                    e2.msg = "invalid distance too far back", r2.mode = 30;
                    break;
                  }
                  p = d > r2.wnext ? (d -= r2.wnext, r2.wsize - d) : r2.wnext - d, d > r2.length && (d = r2.length), m = r2.window;
                } else
                  m = i2, p = a2 - r2.offset, d = r2.length;
                for (h2 < d && (d = h2), h2 -= d, r2.length -= d; i2[a2++] = m[p++], --d; )
                  ;
                0 === r2.length && (r2.mode = 21);
                break;
              case 26:
                if (0 === h2)
                  break e;
                i2[a2++] = r2.length, h2--, r2.mode = 21;
                break;
              case 27:
                if (r2.wrap) {
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 |= n2[s2++] << l2, l2 += 8;
                  }
                  if (c2 -= h2, e2.total_out += c2, r2.total += c2, c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, a2 - c2) : O(r2.check, i2, c2, a2 - c2)), c2 = h2, (r2.flags ? u2 : L(u2)) !== r2.check) {
                    e2.msg = "incorrect data check", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.mode = 28;
              case 28:
                if (r2.wrap && r2.flags) {
                  for (; l2 < 32; ) {
                    if (0 === o2)
                      break e;
                    o2--, u2 += n2[s2++] << l2, l2 += 8;
                  }
                  if (u2 !== (4294967295 & r2.total)) {
                    e2.msg = "incorrect length check", r2.mode = 30;
                    break;
                  }
                  l2 = u2 = 0;
                }
                r2.mode = 29;
              case 29:
                x = 1;
                break e;
              case 30:
                x = -3;
                break e;
              case 31:
                return -4;
              case 32:
              default:
                return U;
            }
        return e2.next_out = a2, e2.avail_out = h2, e2.next_in = s2, e2.avail_in = o2, r2.hold = u2, r2.bits = l2, (r2.wsize || c2 !== e2.avail_out && r2.mode < 30 && (r2.mode < 27 || 4 !== t2)) && Z(e2, e2.output, e2.next_out, c2 - e2.avail_out) ? (r2.mode = 31, -4) : (f2 -= e2.avail_in, c2 -= e2.avail_out, e2.total_in += f2, e2.total_out += c2, r2.total += c2, r2.wrap && c2 && (e2.adler = r2.check = r2.flags ? B(r2.check, i2, c2, e2.next_out - c2) : O(r2.check, i2, c2, e2.next_out - c2)), e2.data_type = r2.bits + (r2.last ? 64 : 0) + (12 === r2.mode ? 128 : 0) + (20 === r2.mode || 15 === r2.mode ? 256 : 0), (0 == f2 && 0 === c2 || 4 === t2) && x === N && (x = -5), x);
      }, r.inflateEnd = function(e2) {
        if (!e2 || !e2.state)
          return U;
        var t2 = e2.state;
        return t2.window && (t2.window = null), e2.state = null, N;
      }, r.inflateGetHeader = function(e2, t2) {
        var r2;
        return e2 && e2.state ? 0 == (2 & (r2 = e2.state).wrap) ? U : ((r2.head = t2).done = false, N) : U;
      }, r.inflateSetDictionary = function(e2, t2) {
        var r2, n2 = t2.length;
        return e2 && e2.state ? 0 !== (r2 = e2.state).wrap && 11 !== r2.mode ? U : 11 === r2.mode && O(1, t2, n2, 0) !== r2.check ? -3 : Z(e2, t2, n2, n2) ? (r2.mode = 31, -4) : (r2.havedict = 1, N) : U;
      }, r.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, t, r) {
      var D = e("../utils/common"), F = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], N = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], U = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], P = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      t.exports = function(e2, t2, r2, n, i, s, a, o) {
        var h, u, l, f, c, d, p, m, _, g = o.bits, b = 0, v = 0, y = 0, w = 0, k = 0, x = 0, S = 0, z = 0, C = 0, E = 0, A = null, I = 0, O = new D.Buf16(16), B = new D.Buf16(16), R = null, T = 0;
        for (b = 0; b <= 15; b++)
          O[b] = 0;
        for (v = 0; v < n; v++)
          O[t2[r2 + v]]++;
        for (k = g, w = 15; 1 <= w && 0 === O[w]; w--)
          ;
        if (w < k && (k = w), 0 === w)
          return i[s++] = 20971520, i[s++] = 20971520, o.bits = 1, 0;
        for (y = 1; y < w && 0 === O[y]; y++)
          ;
        for (k < y && (k = y), b = z = 1; b <= 15; b++)
          if (z <<= 1, (z -= O[b]) < 0)
            return -1;
        if (0 < z && (0 === e2 || 1 !== w))
          return -1;
        for (B[1] = 0, b = 1; b < 15; b++)
          B[b + 1] = B[b] + O[b];
        for (v = 0; v < n; v++)
          0 !== t2[r2 + v] && (a[B[t2[r2 + v]]++] = v);
        if (d = 0 === e2 ? (A = R = a, 19) : 1 === e2 ? (A = F, I -= 257, R = N, T -= 257, 256) : (A = U, R = P, -1), b = y, c = s, S = v = E = 0, l = -1, f = (C = 1 << (x = k)) - 1, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
          return 1;
        for (; ; ) {
          for (p = b - S, _ = a[v] < d ? (m = 0, a[v]) : a[v] > d ? (m = R[T + a[v]], A[I + a[v]]) : (m = 96, 0), h = 1 << b - S, y = u = 1 << x; i[c + (E >> S) + (u -= h)] = p << 24 | m << 16 | _ | 0, 0 !== u; )
            ;
          for (h = 1 << b - 1; E & h; )
            h >>= 1;
          if (0 !== h ? (E &= h - 1, E += h) : E = 0, v++, 0 == --O[b]) {
            if (b === w)
              break;
            b = t2[r2 + a[v]];
          }
          if (k < b && (E & f) !== l) {
            for (0 === S && (S = k), c += y, z = 1 << (x = b - S); x + S < w && !((z -= O[x + S]) <= 0); )
              x++, z <<= 1;
            if (C += 1 << x, 1 === e2 && 852 < C || 2 === e2 && 592 < C)
              return 1;
            i[l = E & f] = k << 24 | x << 16 | c - s | 0;
          }
        }
        return 0 !== E && (i[c + E] = b - S << 24 | 64 << 16 | 0), o.bits = k, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(e, t, r) {
      t.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(e, t, r) {
      var i = e("../utils/common"), o = 0, h = 1;
      function n(e2) {
        for (var t2 = e2.length; 0 <= --t2; )
          e2[t2] = 0;
      }
      var s = 0, a = 29, u = 256, l = u + 1 + a, f = 30, c = 19, _ = 2 * l + 1, g = 15, d = 16, p = 7, m = 256, b = 16, v = 17, y = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], k = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], S = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], z = new Array(2 * (l + 2));
      n(z);
      var C = new Array(2 * f);
      n(C);
      var E = new Array(512);
      n(E);
      var A = new Array(256);
      n(A);
      var I = new Array(a);
      n(I);
      var O, B, R, T = new Array(f);
      function D(e2, t2, r2, n2, i2) {
        this.static_tree = e2, this.extra_bits = t2, this.extra_base = r2, this.elems = n2, this.max_length = i2, this.has_stree = e2 && e2.length;
      }
      function F(e2, t2) {
        this.dyn_tree = e2, this.max_code = 0, this.stat_desc = t2;
      }
      function N(e2) {
        return e2 < 256 ? E[e2] : E[256 + (e2 >>> 7)];
      }
      function U(e2, t2) {
        e2.pending_buf[e2.pending++] = 255 & t2, e2.pending_buf[e2.pending++] = t2 >>> 8 & 255;
      }
      function P(e2, t2, r2) {
        e2.bi_valid > d - r2 ? (e2.bi_buf |= t2 << e2.bi_valid & 65535, U(e2, e2.bi_buf), e2.bi_buf = t2 >> d - e2.bi_valid, e2.bi_valid += r2 - d) : (e2.bi_buf |= t2 << e2.bi_valid & 65535, e2.bi_valid += r2);
      }
      function L(e2, t2, r2) {
        P(e2, r2[2 * t2], r2[2 * t2 + 1]);
      }
      function j(e2, t2) {
        for (var r2 = 0; r2 |= 1 & e2, e2 >>>= 1, r2 <<= 1, 0 < --t2; )
          ;
        return r2 >>> 1;
      }
      function Z(e2, t2, r2) {
        var n2, i2, s2 = new Array(g + 1), a2 = 0;
        for (n2 = 1; n2 <= g; n2++)
          s2[n2] = a2 = a2 + r2[n2 - 1] << 1;
        for (i2 = 0; i2 <= t2; i2++) {
          var o2 = e2[2 * i2 + 1];
          0 !== o2 && (e2[2 * i2] = j(s2[o2]++, o2));
        }
      }
      function W(e2) {
        var t2;
        for (t2 = 0; t2 < l; t2++)
          e2.dyn_ltree[2 * t2] = 0;
        for (t2 = 0; t2 < f; t2++)
          e2.dyn_dtree[2 * t2] = 0;
        for (t2 = 0; t2 < c; t2++)
          e2.bl_tree[2 * t2] = 0;
        e2.dyn_ltree[2 * m] = 1, e2.opt_len = e2.static_len = 0, e2.last_lit = e2.matches = 0;
      }
      function M(e2) {
        8 < e2.bi_valid ? U(e2, e2.bi_buf) : 0 < e2.bi_valid && (e2.pending_buf[e2.pending++] = e2.bi_buf), e2.bi_buf = 0, e2.bi_valid = 0;
      }
      function H(e2, t2, r2, n2) {
        var i2 = 2 * t2, s2 = 2 * r2;
        return e2[i2] < e2[s2] || e2[i2] === e2[s2] && n2[t2] <= n2[r2];
      }
      function G(e2, t2, r2) {
        for (var n2 = e2.heap[r2], i2 = r2 << 1; i2 <= e2.heap_len && (i2 < e2.heap_len && H(t2, e2.heap[i2 + 1], e2.heap[i2], e2.depth) && i2++, !H(t2, n2, e2.heap[i2], e2.depth)); )
          e2.heap[r2] = e2.heap[i2], r2 = i2, i2 <<= 1;
        e2.heap[r2] = n2;
      }
      function K(e2, t2, r2) {
        var n2, i2, s2, a2, o2 = 0;
        if (0 !== e2.last_lit)
          for (; n2 = e2.pending_buf[e2.d_buf + 2 * o2] << 8 | e2.pending_buf[e2.d_buf + 2 * o2 + 1], i2 = e2.pending_buf[e2.l_buf + o2], o2++, 0 === n2 ? L(e2, i2, t2) : (L(e2, (s2 = A[i2]) + u + 1, t2), 0 !== (a2 = w[s2]) && P(e2, i2 -= I[s2], a2), L(e2, s2 = N(--n2), r2), 0 !== (a2 = k[s2]) && P(e2, n2 -= T[s2], a2)), o2 < e2.last_lit; )
            ;
        L(e2, m, t2);
      }
      function Y(e2, t2) {
        var r2, n2, i2, s2 = t2.dyn_tree, a2 = t2.stat_desc.static_tree, o2 = t2.stat_desc.has_stree, h2 = t2.stat_desc.elems, u2 = -1;
        for (e2.heap_len = 0, e2.heap_max = _, r2 = 0; r2 < h2; r2++)
          0 !== s2[2 * r2] ? (e2.heap[++e2.heap_len] = u2 = r2, e2.depth[r2] = 0) : s2[2 * r2 + 1] = 0;
        for (; e2.heap_len < 2; )
          s2[2 * (i2 = e2.heap[++e2.heap_len] = u2 < 2 ? ++u2 : 0)] = 1, e2.depth[i2] = 0, e2.opt_len--, o2 && (e2.static_len -= a2[2 * i2 + 1]);
        for (t2.max_code = u2, r2 = e2.heap_len >> 1; 1 <= r2; r2--)
          G(e2, s2, r2);
        for (i2 = h2; r2 = e2.heap[1], e2.heap[1] = e2.heap[e2.heap_len--], G(e2, s2, 1), n2 = e2.heap[1], e2.heap[--e2.heap_max] = r2, e2.heap[--e2.heap_max] = n2, s2[2 * i2] = s2[2 * r2] + s2[2 * n2], e2.depth[i2] = (e2.depth[r2] >= e2.depth[n2] ? e2.depth[r2] : e2.depth[n2]) + 1, s2[2 * r2 + 1] = s2[2 * n2 + 1] = i2, e2.heap[1] = i2++, G(e2, s2, 1), 2 <= e2.heap_len; )
          ;
        e2.heap[--e2.heap_max] = e2.heap[1], function(e3, t3) {
          var r3, n3, i3, s3, a3, o3, h3 = t3.dyn_tree, u3 = t3.max_code, l2 = t3.stat_desc.static_tree, f2 = t3.stat_desc.has_stree, c2 = t3.stat_desc.extra_bits, d2 = t3.stat_desc.extra_base, p2 = t3.stat_desc.max_length, m2 = 0;
          for (s3 = 0; s3 <= g; s3++)
            e3.bl_count[s3] = 0;
          for (h3[2 * e3.heap[e3.heap_max] + 1] = 0, r3 = e3.heap_max + 1; r3 < _; r3++)
            p2 < (s3 = h3[2 * h3[2 * (n3 = e3.heap[r3]) + 1] + 1] + 1) && (s3 = p2, m2++), h3[2 * n3 + 1] = s3, u3 < n3 || (e3.bl_count[s3]++, a3 = 0, d2 <= n3 && (a3 = c2[n3 - d2]), o3 = h3[2 * n3], e3.opt_len += o3 * (s3 + a3), f2 && (e3.static_len += o3 * (l2[2 * n3 + 1] + a3)));
          if (0 !== m2) {
            do {
              for (s3 = p2 - 1; 0 === e3.bl_count[s3]; )
                s3--;
              e3.bl_count[s3]--, e3.bl_count[s3 + 1] += 2, e3.bl_count[p2]--, m2 -= 2;
            } while (0 < m2);
            for (s3 = p2; 0 !== s3; s3--)
              for (n3 = e3.bl_count[s3]; 0 !== n3; )
                u3 < (i3 = e3.heap[--r3]) || (h3[2 * i3 + 1] !== s3 && (e3.opt_len += (s3 - h3[2 * i3 + 1]) * h3[2 * i3], h3[2 * i3 + 1] = s3), n3--);
          }
        }(e2, t2), Z(s2, u2, e2.bl_count);
      }
      function X(e2, t2, r2) {
        var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
        for (0 === a2 && (h2 = 138, u2 = 3), t2[2 * (r2 + 1) + 1] = 65535, n2 = 0; n2 <= r2; n2++)
          i2 = a2, a2 = t2[2 * (n2 + 1) + 1], ++o2 < h2 && i2 === a2 || (o2 < u2 ? e2.bl_tree[2 * i2] += o2 : 0 !== i2 ? (i2 !== s2 && e2.bl_tree[2 * i2]++, e2.bl_tree[2 * b]++) : o2 <= 10 ? e2.bl_tree[2 * v]++ : e2.bl_tree[2 * y]++, s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4));
      }
      function V(e2, t2, r2) {
        var n2, i2, s2 = -1, a2 = t2[1], o2 = 0, h2 = 7, u2 = 4;
        for (0 === a2 && (h2 = 138, u2 = 3), n2 = 0; n2 <= r2; n2++)
          if (i2 = a2, a2 = t2[2 * (n2 + 1) + 1], !(++o2 < h2 && i2 === a2)) {
            if (o2 < u2)
              for (; L(e2, i2, e2.bl_tree), 0 != --o2; )
                ;
            else
              0 !== i2 ? (i2 !== s2 && (L(e2, i2, e2.bl_tree), o2--), L(e2, b, e2.bl_tree), P(e2, o2 - 3, 2)) : o2 <= 10 ? (L(e2, v, e2.bl_tree), P(e2, o2 - 3, 3)) : (L(e2, y, e2.bl_tree), P(e2, o2 - 11, 7));
            s2 = i2, u2 = (o2 = 0) === a2 ? (h2 = 138, 3) : i2 === a2 ? (h2 = 6, 3) : (h2 = 7, 4);
          }
      }
      n(T);
      var q = false;
      function J(e2, t2, r2, n2) {
        P(e2, (s << 1) + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
          M(e3), U(e3, r3), U(e3, ~r3), i.arraySet(e3.pending_buf, e3.window, t3, r3, e3.pending), e3.pending += r3;
        }(e2, t2, r2);
      }
      r._tr_init = function(e2) {
        q || (function() {
          var e3, t2, r2, n2, i2, s2 = new Array(g + 1);
          for (n2 = r2 = 0; n2 < a - 1; n2++)
            for (I[n2] = r2, e3 = 0; e3 < 1 << w[n2]; e3++)
              A[r2++] = n2;
          for (A[r2 - 1] = n2, n2 = i2 = 0; n2 < 16; n2++)
            for (T[n2] = i2, e3 = 0; e3 < 1 << k[n2]; e3++)
              E[i2++] = n2;
          for (i2 >>= 7; n2 < f; n2++)
            for (T[n2] = i2 << 7, e3 = 0; e3 < 1 << k[n2] - 7; e3++)
              E[256 + i2++] = n2;
          for (t2 = 0; t2 <= g; t2++)
            s2[t2] = 0;
          for (e3 = 0; e3 <= 143; )
            z[2 * e3 + 1] = 8, e3++, s2[8]++;
          for (; e3 <= 255; )
            z[2 * e3 + 1] = 9, e3++, s2[9]++;
          for (; e3 <= 279; )
            z[2 * e3 + 1] = 7, e3++, s2[7]++;
          for (; e3 <= 287; )
            z[2 * e3 + 1] = 8, e3++, s2[8]++;
          for (Z(z, l + 1, s2), e3 = 0; e3 < f; e3++)
            C[2 * e3 + 1] = 5, C[2 * e3] = j(e3, 5);
          O = new D(z, w, u + 1, l, g), B = new D(C, k, 0, f, g), R = new D(new Array(0), x, 0, c, p);
        }(), q = true), e2.l_desc = new F(e2.dyn_ltree, O), e2.d_desc = new F(e2.dyn_dtree, B), e2.bl_desc = new F(e2.bl_tree, R), e2.bi_buf = 0, e2.bi_valid = 0, W(e2);
      }, r._tr_stored_block = J, r._tr_flush_block = function(e2, t2, r2, n2) {
        var i2, s2, a2 = 0;
        0 < e2.level ? (2 === e2.strm.data_type && (e2.strm.data_type = function(e3) {
          var t3, r3 = 4093624447;
          for (t3 = 0; t3 <= 31; t3++, r3 >>>= 1)
            if (1 & r3 && 0 !== e3.dyn_ltree[2 * t3])
              return o;
          if (0 !== e3.dyn_ltree[18] || 0 !== e3.dyn_ltree[20] || 0 !== e3.dyn_ltree[26])
            return h;
          for (t3 = 32; t3 < u; t3++)
            if (0 !== e3.dyn_ltree[2 * t3])
              return h;
          return o;
        }(e2)), Y(e2, e2.l_desc), Y(e2, e2.d_desc), a2 = function(e3) {
          var t3;
          for (X(e3, e3.dyn_ltree, e3.l_desc.max_code), X(e3, e3.dyn_dtree, e3.d_desc.max_code), Y(e3, e3.bl_desc), t3 = c - 1; 3 <= t3 && 0 === e3.bl_tree[2 * S[t3] + 1]; t3--)
            ;
          return e3.opt_len += 3 * (t3 + 1) + 5 + 5 + 4, t3;
        }(e2), i2 = e2.opt_len + 3 + 7 >>> 3, (s2 = e2.static_len + 3 + 7 >>> 3) <= i2 && (i2 = s2)) : i2 = s2 = r2 + 5, r2 + 4 <= i2 && -1 !== t2 ? J(e2, t2, r2, n2) : 4 === e2.strategy || s2 === i2 ? (P(e2, 2 + (n2 ? 1 : 0), 3), K(e2, z, C)) : (P(e2, 4 + (n2 ? 1 : 0), 3), function(e3, t3, r3, n3) {
          var i3;
          for (P(e3, t3 - 257, 5), P(e3, r3 - 1, 5), P(e3, n3 - 4, 4), i3 = 0; i3 < n3; i3++)
            P(e3, e3.bl_tree[2 * S[i3] + 1], 3);
          V(e3, e3.dyn_ltree, t3 - 1), V(e3, e3.dyn_dtree, r3 - 1);
        }(e2, e2.l_desc.max_code + 1, e2.d_desc.max_code + 1, a2 + 1), K(e2, e2.dyn_ltree, e2.dyn_dtree)), W(e2), n2 && M(e2);
      }, r._tr_tally = function(e2, t2, r2) {
        return e2.pending_buf[e2.d_buf + 2 * e2.last_lit] = t2 >>> 8 & 255, e2.pending_buf[e2.d_buf + 2 * e2.last_lit + 1] = 255 & t2, e2.pending_buf[e2.l_buf + e2.last_lit] = 255 & r2, e2.last_lit++, 0 === t2 ? e2.dyn_ltree[2 * r2]++ : (e2.matches++, t2--, e2.dyn_ltree[2 * (A[r2] + u + 1)]++, e2.dyn_dtree[2 * N(t2)]++), e2.last_lit === e2.lit_bufsize - 1;
      }, r._tr_align = function(e2) {
        P(e2, 2, 3), L(e2, m, z), function(e3) {
          16 === e3.bi_valid ? (U(e3, e3.bi_buf), e3.bi_buf = 0, e3.bi_valid = 0) : 8 <= e3.bi_valid && (e3.pending_buf[e3.pending++] = 255 & e3.bi_buf, e3.bi_buf >>= 8, e3.bi_valid -= 8);
        }(e2);
      };
    }, { "../utils/common": 41 }], 53: [function(e, t, r) {
      t.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(e, t, r) {
      (function(e2) {
        !function(r2, n) {
          if (!r2.setImmediate) {
            var i, s, t2, a, o = 1, h = {}, u = false, l = r2.document, e3 = Object.getPrototypeOf && Object.getPrototypeOf(r2);
            e3 = e3 && e3.setTimeout ? e3 : r2, i = "[object process]" === {}.toString.call(r2.process) ? function(e4) {
              process.nextTick(function() {
                c(e4);
              });
            } : function() {
              if (r2.postMessage && !r2.importScripts) {
                var e4 = true, t3 = r2.onmessage;
                return r2.onmessage = function() {
                  e4 = false;
                }, r2.postMessage("", "*"), r2.onmessage = t3, e4;
              }
            }() ? (a = "setImmediate$" + Math.random() + "$", r2.addEventListener ? r2.addEventListener("message", d, false) : r2.attachEvent("onmessage", d), function(e4) {
              r2.postMessage(a + e4, "*");
            }) : r2.MessageChannel ? ((t2 = new MessageChannel()).port1.onmessage = function(e4) {
              c(e4.data);
            }, function(e4) {
              t2.port2.postMessage(e4);
            }) : l && "onreadystatechange" in l.createElement("script") ? (s = l.documentElement, function(e4) {
              var t3 = l.createElement("script");
              t3.onreadystatechange = function() {
                c(e4), t3.onreadystatechange = null, s.removeChild(t3), t3 = null;
              }, s.appendChild(t3);
            }) : function(e4) {
              setTimeout(c, 0, e4);
            }, e3.setImmediate = function(e4) {
              "function" != typeof e4 && (e4 = new Function("" + e4));
              for (var t3 = new Array(arguments.length - 1), r3 = 0; r3 < t3.length; r3++)
                t3[r3] = arguments[r3 + 1];
              var n2 = { callback: e4, args: t3 };
              return h[o] = n2, i(o), o++;
            }, e3.clearImmediate = f;
          }
          function f(e4) {
            delete h[e4];
          }
          function c(e4) {
            if (u)
              setTimeout(c, 0, e4);
            else {
              var t3 = h[e4];
              if (t3) {
                u = true;
                try {
                  !function(e5) {
                    var t4 = e5.callback, r3 = e5.args;
                    switch (r3.length) {
                      case 0:
                        t4();
                        break;
                      case 1:
                        t4(r3[0]);
                        break;
                      case 2:
                        t4(r3[0], r3[1]);
                        break;
                      case 3:
                        t4(r3[0], r3[1], r3[2]);
                        break;
                      default:
                        t4.apply(n, r3);
                    }
                  }(t3);
                } finally {
                  f(e4), u = false;
                }
              }
            }
          }
          function d(e4) {
            e4.source === r2 && "string" == typeof e4.data && 0 === e4.data.indexOf(a) && c(+e4.data.slice(a.length));
          }
        }("undefined" == typeof self ? void 0 === e2 ? this : e2 : self);
      }).call(this, "undefined" != typeof commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(jszip_min);
var jszip_minExports = jszip_min.exports;
var JSZip = getDefaultExportFromCjs(jszip_minExports);
var validator$2 = {};
var util$3 = {};
(function(exports) {
  const nameStartChar = ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
  const nameChar = nameStartChar + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
  const nameRegexp = "[" + nameStartChar + "][" + nameChar + "]*";
  const regexName = new RegExp("^" + nameRegexp + "$");
  const getAllMatches = function(string, regex) {
    const matches = [];
    let match = regex.exec(string);
    while (match) {
      const allmatches = [];
      allmatches.startIndex = regex.lastIndex - match[0].length;
      const len = match.length;
      for (let index = 0; index < len; index++) {
        allmatches.push(match[index]);
      }
      matches.push(allmatches);
      match = regex.exec(string);
    }
    return matches;
  };
  const isName = function(string) {
    const match = regexName.exec(string);
    return !(match === null || typeof match === "undefined");
  };
  exports.isExist = function(v) {
    return typeof v !== "undefined";
  };
  exports.isEmptyObject = function(obj) {
    return Object.keys(obj).length === 0;
  };
  exports.merge = function(target, a, arrayMode) {
    if (a) {
      const keys = Object.keys(a);
      const len = keys.length;
      for (let i = 0; i < len; i++) {
        if (arrayMode === "strict") {
          target[keys[i]] = [a[keys[i]]];
        } else {
          target[keys[i]] = a[keys[i]];
        }
      }
    }
  };
  exports.getValue = function(v) {
    if (exports.isExist(v)) {
      return v;
    } else {
      return "";
    }
  };
  exports.isName = isName;
  exports.getAllMatches = getAllMatches;
  exports.nameRegexp = nameRegexp;
})(util$3);
var util$2 = util$3;
var defaultOptions$2 = {
  allowBooleanAttributes: false,
  //A tag can have attributes without any value
  unpairedTags: []
};
validator$2.validate = function(xmlData, options) {
  options = Object.assign({}, defaultOptions$2, options);
  const tags = [];
  let tagFound = false;
  let reachedRoot = false;
  if (xmlData[0] === "\uFEFF") {
    xmlData = xmlData.substr(1);
  }
  for (let i = 0; i < xmlData.length; i++) {
    if (xmlData[i] === "<" && xmlData[i + 1] === "?") {
      i += 2;
      i = readPI(xmlData, i);
      if (i.err)
        return i;
    } else if (xmlData[i] === "<") {
      let tagStartPos = i;
      i++;
      if (xmlData[i] === "!") {
        i = readCommentAndCDATA(xmlData, i);
        continue;
      } else {
        let closingTag = false;
        if (xmlData[i] === "/") {
          closingTag = true;
          i++;
        }
        let tagName = "";
        for (; i < xmlData.length && xmlData[i] !== ">" && xmlData[i] !== " " && xmlData[i] !== "	" && xmlData[i] !== "\n" && xmlData[i] !== "\r"; i++) {
          tagName += xmlData[i];
        }
        tagName = tagName.trim();
        if (tagName[tagName.length - 1] === "/") {
          tagName = tagName.substring(0, tagName.length - 1);
          i--;
        }
        if (!validateTagName(tagName)) {
          let msg;
          if (tagName.trim().length === 0) {
            msg = "Invalid space after '<'.";
          } else {
            msg = "Tag '" + tagName + "' is an invalid name.";
          }
          return getErrorObject("InvalidTag", msg, getLineNumberForPosition(xmlData, i));
        }
        const result = readAttributeStr(xmlData, i);
        if (result === false) {
          return getErrorObject("InvalidAttr", "Attributes for '" + tagName + "' have open quote.", getLineNumberForPosition(xmlData, i));
        }
        let attrStr = result.value;
        i = result.index;
        if (attrStr[attrStr.length - 1] === "/") {
          const attrStrStart = i - attrStr.length;
          attrStr = attrStr.substring(0, attrStr.length - 1);
          const isValid = validateAttributeString(attrStr, options);
          if (isValid === true) {
            tagFound = true;
          } else {
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
          }
        } else if (closingTag) {
          if (!result.tagClosed) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
          } else if (attrStr.trim().length > 0) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
          } else if (tags.length === 0) {
            return getErrorObject("InvalidTag", "Closing tag '" + tagName + "' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
          } else {
            const otg = tags.pop();
            if (tagName !== otg.tagName) {
              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
              return getErrorObject(
                "InvalidTag",
                "Expected closing tag '" + otg.tagName + "' (opened in line " + openPos.line + ", col " + openPos.col + ") instead of closing tag '" + tagName + "'.",
                getLineNumberForPosition(xmlData, tagStartPos)
              );
            }
            if (tags.length == 0) {
              reachedRoot = true;
            }
          }
        } else {
          const isValid = validateAttributeString(attrStr, options);
          if (isValid !== true) {
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
          }
          if (reachedRoot === true) {
            return getErrorObject("InvalidXml", "Multiple possible root nodes found.", getLineNumberForPosition(xmlData, i));
          } else if (options.unpairedTags.indexOf(tagName) !== -1)
            ;
          else {
            tags.push({ tagName, tagStartPos });
          }
          tagFound = true;
        }
        for (i++; i < xmlData.length; i++) {
          if (xmlData[i] === "<") {
            if (xmlData[i + 1] === "!") {
              i++;
              i = readCommentAndCDATA(xmlData, i);
              continue;
            } else if (xmlData[i + 1] === "?") {
              i = readPI(xmlData, ++i);
              if (i.err)
                return i;
            } else {
              break;
            }
          } else if (xmlData[i] === "&") {
            const afterAmp = validateAmpersand(xmlData, i);
            if (afterAmp == -1)
              return getErrorObject("InvalidChar", "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
            i = afterAmp;
          } else {
            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
              return getErrorObject("InvalidXml", "Extra text at the end", getLineNumberForPosition(xmlData, i));
            }
          }
        }
        if (xmlData[i] === "<") {
          i--;
        }
      }
    } else {
      if (isWhiteSpace(xmlData[i])) {
        continue;
      }
      return getErrorObject("InvalidChar", "char '" + xmlData[i] + "' is not expected.", getLineNumberForPosition(xmlData, i));
    }
  }
  if (!tagFound) {
    return getErrorObject("InvalidXml", "Start tag expected.", 1);
  } else if (tags.length == 1) {
    return getErrorObject("InvalidTag", "Unclosed tag '" + tags[0].tagName + "'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
  } else if (tags.length > 0) {
    return getErrorObject("InvalidXml", "Invalid '" + JSON.stringify(tags.map((t) => t.tagName), null, 4).replace(/\r?\n/g, "") + "' found.", { line: 1, col: 1 });
  }
  return true;
};
function isWhiteSpace(char) {
  return char === " " || char === "	" || char === "\n" || char === "\r";
}
function readPI(xmlData, i) {
  const start = i;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] == "?" || xmlData[i] == " ") {
      const tagname = xmlData.substr(start, i - start);
      if (i > 5 && tagname === "xml") {
        return getErrorObject("InvalidXml", "XML declaration allowed only at the start of the document.", getLineNumberForPosition(xmlData, i));
      } else if (xmlData[i] == "?" && xmlData[i + 1] == ">") {
        i++;
        break;
      } else {
        continue;
      }
    }
  }
  return i;
}
function readCommentAndCDATA(xmlData, i) {
  if (xmlData.length > i + 5 && xmlData[i + 1] === "-" && xmlData[i + 2] === "-") {
    for (i += 3; i < xmlData.length; i++) {
      if (xmlData[i] === "-" && xmlData[i + 1] === "-" && xmlData[i + 2] === ">") {
        i += 2;
        break;
      }
    }
  } else if (xmlData.length > i + 8 && xmlData[i + 1] === "D" && xmlData[i + 2] === "O" && xmlData[i + 3] === "C" && xmlData[i + 4] === "T" && xmlData[i + 5] === "Y" && xmlData[i + 6] === "P" && xmlData[i + 7] === "E") {
    let angleBracketsCount = 1;
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === "<") {
        angleBracketsCount++;
      } else if (xmlData[i] === ">") {
        angleBracketsCount--;
        if (angleBracketsCount === 0) {
          break;
        }
      }
    }
  } else if (xmlData.length > i + 9 && xmlData[i + 1] === "[" && xmlData[i + 2] === "C" && xmlData[i + 3] === "D" && xmlData[i + 4] === "A" && xmlData[i + 5] === "T" && xmlData[i + 6] === "A" && xmlData[i + 7] === "[") {
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === "]" && xmlData[i + 1] === "]" && xmlData[i + 2] === ">") {
        i += 2;
        break;
      }
    }
  }
  return i;
}
var doubleQuote = '"';
var singleQuote = "'";
function readAttributeStr(xmlData, i) {
  let attrStr = "";
  let startChar = "";
  let tagClosed = false;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
      if (startChar === "") {
        startChar = xmlData[i];
      } else if (startChar !== xmlData[i])
        ;
      else {
        startChar = "";
      }
    } else if (xmlData[i] === ">") {
      if (startChar === "") {
        tagClosed = true;
        break;
      }
    }
    attrStr += xmlData[i];
  }
  if (startChar !== "") {
    return false;
  }
  return {
    value: attrStr,
    index: i,
    tagClosed
  };
}
var validAttrStrRegxp = new RegExp(`(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`, "g");
function validateAttributeString(attrStr, options) {
  const matches = util$2.getAllMatches(attrStr, validAttrStrRegxp);
  const attrNames = {};
  for (let i = 0; i < matches.length; i++) {
    if (matches[i][1].length === 0) {
      return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' has no space in starting.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] !== void 0 && matches[i][4] === void 0) {
      return getErrorObject("InvalidAttr", "Attribute '" + matches[i][2] + "' is without value.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] === void 0 && !options.allowBooleanAttributes) {
      return getErrorObject("InvalidAttr", "boolean attribute '" + matches[i][2] + "' is not allowed.", getPositionFromMatch(matches[i]));
    }
    const attrName = matches[i][2];
    if (!validateAttrName(attrName)) {
      return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is an invalid name.", getPositionFromMatch(matches[i]));
    }
    if (!attrNames.hasOwnProperty(attrName)) {
      attrNames[attrName] = 1;
    } else {
      return getErrorObject("InvalidAttr", "Attribute '" + attrName + "' is repeated.", getPositionFromMatch(matches[i]));
    }
  }
  return true;
}
function validateNumberAmpersand(xmlData, i) {
  let re = /\d/;
  if (xmlData[i] === "x") {
    i++;
    re = /[\da-fA-F]/;
  }
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === ";")
      return i;
    if (!xmlData[i].match(re))
      break;
  }
  return -1;
}
function validateAmpersand(xmlData, i) {
  i++;
  if (xmlData[i] === ";")
    return -1;
  if (xmlData[i] === "#") {
    i++;
    return validateNumberAmpersand(xmlData, i);
  }
  let count = 0;
  for (; i < xmlData.length; i++, count++) {
    if (xmlData[i].match(/\w/) && count < 20)
      continue;
    if (xmlData[i] === ";")
      break;
    return -1;
  }
  return i;
}
function getErrorObject(code, message, lineNumber) {
  return {
    err: {
      code,
      msg: message,
      line: lineNumber.line || lineNumber,
      col: lineNumber.col
    }
  };
}
function validateAttrName(attrName) {
  return util$2.isName(attrName);
}
function validateTagName(tagname) {
  return util$2.isName(tagname);
}
function getLineNumberForPosition(xmlData, index) {
  const lines = xmlData.substring(0, index).split(/\r?\n/);
  return {
    line: lines.length,
    // column number is last line's length + 1, because column numbering starts at 1:
    col: lines[lines.length - 1].length + 1
  };
}
function getPositionFromMatch(match) {
  return match.startIndex + match[1].length;
}
var OptionsBuilder = {};
var defaultOptions$1 = {
  preserveOrder: false,
  attributeNamePrefix: "@_",
  attributesGroupName: false,
  textNodeName: "#text",
  ignoreAttributes: true,
  removeNSPrefix: false,
  // remove NS from tag name or attribute name if true
  allowBooleanAttributes: false,
  //a tag can have attributes without any value
  //ignoreRootElement : false,
  parseTagValue: true,
  parseAttributeValue: false,
  trimValues: true,
  //Trim string values of tag and attributes
  cdataPropName: false,
  numberParseOptions: {
    hex: true,
    leadingZeros: true,
    eNotation: true
  },
  tagValueProcessor: function(tagName, val2) {
    return val2;
  },
  attributeValueProcessor: function(attrName, val2) {
    return val2;
  },
  stopNodes: [],
  //nested tags will not be parsed even for errors
  alwaysCreateTextNode: false,
  isArray: () => false,
  commentPropName: false,
  unpairedTags: [],
  processEntities: true,
  htmlEntities: false,
  ignoreDeclaration: false,
  ignorePiTags: false,
  transformTagName: false,
  transformAttributeName: false,
  updateTag: function(tagName, jPath, attrs) {
    return tagName;
  }
  // skipEmptyListItem: false
};
var buildOptions$1 = function(options) {
  return Object.assign({}, defaultOptions$1, options);
};
OptionsBuilder.buildOptions = buildOptions$1;
OptionsBuilder.defaultOptions = defaultOptions$1;
var XmlNode = class {
  constructor(tagname) {
    this.tagname = tagname;
    this.child = [];
    this[":@"] = {};
  }
  add(key, val2) {
    if (key === "__proto__")
      key = "#__proto__";
    this.child.push({ [key]: val2 });
  }
  addChild(node) {
    if (node.tagname === "__proto__")
      node.tagname = "#__proto__";
    if (node[":@"] && Object.keys(node[":@"]).length > 0) {
      this.child.push({ [node.tagname]: node.child, [":@"]: node[":@"] });
    } else {
      this.child.push({ [node.tagname]: node.child });
    }
  }
};
var xmlNode$1 = XmlNode;
var util$1 = util$3;
function readDocType$1(xmlData, i) {
  const entities = {};
  if (xmlData[i + 3] === "O" && xmlData[i + 4] === "C" && xmlData[i + 5] === "T" && xmlData[i + 6] === "Y" && xmlData[i + 7] === "P" && xmlData[i + 8] === "E") {
    i = i + 9;
    let angleBracketsCount = 1;
    let hasBody = false, comment = false;
    let exp = "";
    for (; i < xmlData.length; i++) {
      if (xmlData[i] === "<" && !comment) {
        if (hasBody && isEntity(xmlData, i)) {
          i += 7;
          [entityName, val, i] = readEntityExp(xmlData, i + 1);
          if (val.indexOf("&") === -1)
            entities[validateEntityName(entityName)] = {
              regx: RegExp(`&${entityName};`, "g"),
              val
            };
        } else if (hasBody && isElement(xmlData, i))
          i += 8;
        else if (hasBody && isAttlist(xmlData, i))
          i += 8;
        else if (hasBody && isNotation(xmlData, i))
          i += 9;
        else
          comment = true;
        angleBracketsCount++;
        exp = "";
      } else if (xmlData[i] === ">") {
        if (comment) {
          if (xmlData[i - 1] === "-" && xmlData[i - 2] === "-") {
            comment = false;
            angleBracketsCount--;
          }
        } else {
          angleBracketsCount--;
        }
        if (angleBracketsCount === 0) {
          break;
        }
      } else if (xmlData[i] === "[") {
        hasBody = true;
      } else {
        exp += xmlData[i];
      }
    }
    if (angleBracketsCount !== 0) {
      throw new Error(`Unclosed DOCTYPE`);
    }
  } else {
    throw new Error(`Invalid Tag instead of DOCTYPE`);
  }
  return { entities, i };
}
function readEntityExp(xmlData, i) {
  let entityName2 = "";
  for (; i < xmlData.length && (xmlData[i] !== "'" && xmlData[i] !== '"'); i++) {
    entityName2 += xmlData[i];
  }
  entityName2 = entityName2.trim();
  if (entityName2.indexOf(" ") !== -1)
    throw new Error("External entites are not supported");
  const startChar = xmlData[i++];
  let val2 = "";
  for (; i < xmlData.length && xmlData[i] !== startChar; i++) {
    val2 += xmlData[i];
  }
  return [entityName2, val2, i];
}
function isEntity(xmlData, i) {
  if (xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "N" && xmlData[i + 4] === "T" && xmlData[i + 5] === "I" && xmlData[i + 6] === "T" && xmlData[i + 7] === "Y")
    return true;
  return false;
}
function isElement(xmlData, i) {
  if (xmlData[i + 1] === "!" && xmlData[i + 2] === "E" && xmlData[i + 3] === "L" && xmlData[i + 4] === "E" && xmlData[i + 5] === "M" && xmlData[i + 6] === "E" && xmlData[i + 7] === "N" && xmlData[i + 8] === "T")
    return true;
  return false;
}
function isAttlist(xmlData, i) {
  if (xmlData[i + 1] === "!" && xmlData[i + 2] === "A" && xmlData[i + 3] === "T" && xmlData[i + 4] === "T" && xmlData[i + 5] === "L" && xmlData[i + 6] === "I" && xmlData[i + 7] === "S" && xmlData[i + 8] === "T")
    return true;
  return false;
}
function isNotation(xmlData, i) {
  if (xmlData[i + 1] === "!" && xmlData[i + 2] === "N" && xmlData[i + 3] === "O" && xmlData[i + 4] === "T" && xmlData[i + 5] === "A" && xmlData[i + 6] === "T" && xmlData[i + 7] === "I" && xmlData[i + 8] === "O" && xmlData[i + 9] === "N")
    return true;
  return false;
}
function validateEntityName(name) {
  if (util$1.isName(name))
    return name;
  else
    throw new Error(`Invalid entity name ${name}`);
}
var DocTypeReader = readDocType$1;
var hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
var numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
if (!Number.parseInt && window.parseInt) {
  Number.parseInt = window.parseInt;
}
if (!Number.parseFloat && window.parseFloat) {
  Number.parseFloat = window.parseFloat;
}
var consider = {
  hex: true,
  leadingZeros: true,
  decimalPoint: ".",
  eNotation: true
  //skipLike: /regex/
};
function toNumber$1(str, options = {}) {
  options = Object.assign({}, consider, options);
  if (!str || typeof str !== "string")
    return str;
  let trimmedStr = str.trim();
  if (options.skipLike !== void 0 && options.skipLike.test(trimmedStr))
    return str;
  else if (options.hex && hexRegex.test(trimmedStr)) {
    return Number.parseInt(trimmedStr, 16);
  } else {
    const match = numRegex.exec(trimmedStr);
    if (match) {
      const sign2 = match[1];
      const leadingZeros = match[2];
      let numTrimmedByZeros = trimZeros(match[3]);
      const eNotation = match[4] || match[6];
      if (!options.leadingZeros && leadingZeros.length > 0 && sign2 && trimmedStr[2] !== ".")
        return str;
      else if (!options.leadingZeros && leadingZeros.length > 0 && !sign2 && trimmedStr[1] !== ".")
        return str;
      else {
        const num = Number(trimmedStr);
        const numStr = "" + num;
        if (numStr.search(/[eE]/) !== -1) {
          if (options.eNotation)
            return num;
          else
            return str;
        } else if (eNotation) {
          if (options.eNotation)
            return num;
          else
            return str;
        } else if (trimmedStr.indexOf(".") !== -1) {
          if (numStr === "0" && numTrimmedByZeros === "")
            return num;
          else if (numStr === numTrimmedByZeros)
            return num;
          else if (sign2 && numStr === "-" + numTrimmedByZeros)
            return num;
          else
            return str;
        }
        if (leadingZeros) {
          if (numTrimmedByZeros === numStr)
            return num;
          else if (sign2 + numTrimmedByZeros === numStr)
            return num;
          else
            return str;
        }
        if (trimmedStr === numStr)
          return num;
        else if (trimmedStr === sign2 + numStr)
          return num;
        return str;
      }
    } else {
      return str;
    }
  }
}
function trimZeros(numStr) {
  if (numStr && numStr.indexOf(".") !== -1) {
    numStr = numStr.replace(/0+$/, "");
    if (numStr === ".")
      numStr = "0";
    else if (numStr[0] === ".")
      numStr = "0" + numStr;
    else if (numStr[numStr.length - 1] === ".")
      numStr = numStr.substr(0, numStr.length - 1);
    return numStr;
  }
  return numStr;
}
var strnum = toNumber$1;
var util = util$3;
var xmlNode = xmlNode$1;
var readDocType = DocTypeReader;
var toNumber = strnum;
var OrderedObjParser$1 = class OrderedObjParser {
  constructor(options) {
    this.options = options;
    this.currentNode = null;
    this.tagsNodeStack = [];
    this.docTypeEntities = {};
    this.lastEntities = {
      "apos": { regex: /&(apos|#39|#x27);/g, val: "'" },
      "gt": { regex: /&(gt|#62|#x3E);/g, val: ">" },
      "lt": { regex: /&(lt|#60|#x3C);/g, val: "<" },
      "quot": { regex: /&(quot|#34|#x22);/g, val: '"' }
    };
    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" };
    this.htmlEntities = {
      "space": { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      "cent": { regex: /&(cent|#162);/g, val: "" },
      "pound": { regex: /&(pound|#163);/g, val: "" },
      "yen": { regex: /&(yen|#165);/g, val: "" },
      "euro": { regex: /&(euro|#8364);/g, val: "" },
      "copyright": { regex: /&(copy|#169);/g, val: "" },
      "reg": { regex: /&(reg|#174);/g, val: "" },
      "inr": { regex: /&(inr|#8377);/g, val: "" },
      "num_dec": { regex: /&#([0-9]{1,7});/g, val: (_, str) => String.fromCharCode(Number.parseInt(str, 10)) },
      "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val: (_, str) => String.fromCharCode(Number.parseInt(str, 16)) }
    };
    this.addExternalEntities = addExternalEntities;
    this.parseXml = parseXml;
    this.parseTextData = parseTextData;
    this.resolveNameSpace = resolveNameSpace;
    this.buildAttributesMap = buildAttributesMap;
    this.isItStopNode = isItStopNode;
    this.replaceEntitiesValue = replaceEntitiesValue$1;
    this.readStopNodeData = readStopNodeData;
    this.saveTextToParentTag = saveTextToParentTag;
    this.addChild = addChild;
  }
};
function addExternalEntities(externalEntities) {
  const entKeys = Object.keys(externalEntities);
  for (let i = 0; i < entKeys.length; i++) {
    const ent = entKeys[i];
    this.lastEntities[ent] = {
      regex: new RegExp("&" + ent + ";", "g"),
      val: externalEntities[ent]
    };
  }
}
function parseTextData(val2, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
  if (val2 !== void 0) {
    if (this.options.trimValues && !dontTrim) {
      val2 = val2.trim();
    }
    if (val2.length > 0) {
      if (!escapeEntities)
        val2 = this.replaceEntitiesValue(val2);
      const newval = this.options.tagValueProcessor(tagName, val2, jPath, hasAttributes, isLeafNode);
      if (newval === null || newval === void 0) {
        return val2;
      } else if (typeof newval !== typeof val2 || newval !== val2) {
        return newval;
      } else if (this.options.trimValues) {
        return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
      } else {
        const trimmedVal = val2.trim();
        if (trimmedVal === val2) {
          return parseValue(val2, this.options.parseTagValue, this.options.numberParseOptions);
        } else {
          return val2;
        }
      }
    }
  }
}
function resolveNameSpace(tagname) {
  if (this.options.removeNSPrefix) {
    const tags = tagname.split(":");
    const prefix = tagname.charAt(0) === "/" ? "/" : "";
    if (tags[0] === "xmlns") {
      return "";
    }
    if (tags.length === 2) {
      tagname = prefix + tags[1];
    }
  }
  return tagname;
}
var attrsRegx = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
function buildAttributesMap(attrStr, jPath, tagName) {
  if (!this.options.ignoreAttributes && typeof attrStr === "string") {
    const matches = util.getAllMatches(attrStr, attrsRegx);
    const len = matches.length;
    const attrs = {};
    for (let i = 0; i < len; i++) {
      const attrName = this.resolveNameSpace(matches[i][1]);
      let oldVal = matches[i][4];
      let aName = this.options.attributeNamePrefix + attrName;
      if (attrName.length) {
        if (this.options.transformAttributeName) {
          aName = this.options.transformAttributeName(aName);
        }
        if (aName === "__proto__")
          aName = "#__proto__";
        if (oldVal !== void 0) {
          if (this.options.trimValues) {
            oldVal = oldVal.trim();
          }
          oldVal = this.replaceEntitiesValue(oldVal);
          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
          if (newVal === null || newVal === void 0) {
            attrs[aName] = oldVal;
          } else if (typeof newVal !== typeof oldVal || newVal !== oldVal) {
            attrs[aName] = newVal;
          } else {
            attrs[aName] = parseValue(
              oldVal,
              this.options.parseAttributeValue,
              this.options.numberParseOptions
            );
          }
        } else if (this.options.allowBooleanAttributes) {
          attrs[aName] = true;
        }
      }
    }
    if (!Object.keys(attrs).length) {
      return;
    }
    if (this.options.attributesGroupName) {
      const attrCollection = {};
      attrCollection[this.options.attributesGroupName] = attrs;
      return attrCollection;
    }
    return attrs;
  }
}
var parseXml = function(xmlData) {
  xmlData = xmlData.replace(/\r\n?/g, "\n");
  const xmlObj = new xmlNode("!xml");
  let currentNode = xmlObj;
  let textData = "";
  let jPath = "";
  for (let i = 0; i < xmlData.length; i++) {
    const ch = xmlData[i];
    if (ch === "<") {
      if (xmlData[i + 1] === "/") {
        const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.");
        let tagName = xmlData.substring(i + 2, closeIndex).trim();
        if (this.options.removeNSPrefix) {
          const colonIndex = tagName.indexOf(":");
          if (colonIndex !== -1) {
            tagName = tagName.substr(colonIndex + 1);
          }
        }
        if (this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }
        if (currentNode) {
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
        }
        const lastTagName = jPath.substring(jPath.lastIndexOf(".") + 1);
        if (tagName && this.options.unpairedTags.indexOf(tagName) !== -1) {
          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
        }
        let propIndex = 0;
        if (lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1) {
          propIndex = jPath.lastIndexOf(".", jPath.lastIndexOf(".") - 1);
          this.tagsNodeStack.pop();
        } else {
          propIndex = jPath.lastIndexOf(".");
        }
        jPath = jPath.substring(0, propIndex);
        currentNode = this.tagsNodeStack.pop();
        textData = "";
        i = closeIndex;
      } else if (xmlData[i + 1] === "?") {
        let tagData = readTagExp(xmlData, i, false, "?>");
        if (!tagData)
          throw new Error("Pi Tag is not closed.");
        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        if (this.options.ignoreDeclaration && tagData.tagName === "?xml" || this.options.ignorePiTags)
          ;
        else {
          const childNode = new xmlNode(tagData.tagName);
          childNode.add(this.options.textNodeName, "");
          if (tagData.tagName !== tagData.tagExp && tagData.attrExpPresent) {
            childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
          }
          this.addChild(currentNode, childNode, jPath);
        }
        i = tagData.closeIndex + 1;
      } else if (xmlData.substr(i + 1, 3) === "!--") {
        const endIndex = findClosingIndex(xmlData, "-->", i + 4, "Comment is not closed.");
        if (this.options.commentPropName) {
          const comment = xmlData.substring(i + 4, endIndex - 2);
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
          currentNode.add(this.options.commentPropName, [{ [this.options.textNodeName]: comment }]);
        }
        i = endIndex;
      } else if (xmlData.substr(i + 1, 2) === "!D") {
        const result = readDocType(xmlData, i);
        this.docTypeEntities = result.entities;
        i = result.i;
      } else if (xmlData.substr(i + 1, 2) === "![") {
        const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
        const tagExp = xmlData.substring(i + 9, closeIndex);
        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        let val2 = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
        if (val2 == void 0)
          val2 = "";
        if (this.options.cdataPropName) {
          currentNode.add(this.options.cdataPropName, [{ [this.options.textNodeName]: tagExp }]);
        } else {
          currentNode.add(this.options.textNodeName, val2);
        }
        i = closeIndex + 2;
      } else {
        let result = readTagExp(xmlData, i, this.options.removeNSPrefix);
        let tagName = result.tagName;
        const rawTagName = result.rawTagName;
        let tagExp = result.tagExp;
        let attrExpPresent = result.attrExpPresent;
        let closeIndex = result.closeIndex;
        if (this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }
        if (currentNode && textData) {
          if (currentNode.tagname !== "!xml") {
            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
          }
        }
        const lastTag = currentNode;
        if (lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1) {
          currentNode = this.tagsNodeStack.pop();
          jPath = jPath.substring(0, jPath.lastIndexOf("."));
        }
        if (tagName !== xmlObj.tagname) {
          jPath += jPath ? "." + tagName : tagName;
        }
        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
          let tagContent = "";
          if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substr(0, tagName.length - 1);
              jPath = jPath.substr(0, jPath.length - 1);
              tagExp = tagName;
            } else {
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            i = result.closeIndex;
          } else if (this.options.unpairedTags.indexOf(tagName) !== -1) {
            i = result.closeIndex;
          } else {
            const result2 = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
            if (!result2)
              throw new Error(`Unexpected end of ${rawTagName}`);
            i = result2.i;
            tagContent = result2.tagContent;
          }
          const childNode = new xmlNode(tagName);
          if (tagName !== tagExp && attrExpPresent) {
            childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
          }
          if (tagContent) {
            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
          }
          jPath = jPath.substr(0, jPath.lastIndexOf("."));
          childNode.add(this.options.textNodeName, tagContent);
          this.addChild(currentNode, childNode, jPath);
        } else {
          if (tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
            if (tagName[tagName.length - 1] === "/") {
              tagName = tagName.substr(0, tagName.length - 1);
              jPath = jPath.substr(0, jPath.length - 1);
              tagExp = tagName;
            } else {
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            if (this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }
            const childNode = new xmlNode(tagName);
            if (tagName !== tagExp && attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath);
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
          } else {
            const childNode = new xmlNode(tagName);
            this.tagsNodeStack.push(currentNode);
            if (tagName !== tagExp && attrExpPresent) {
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath);
            currentNode = childNode;
          }
          textData = "";
          i = closeIndex;
        }
      }
    } else {
      textData += xmlData[i];
    }
  }
  return xmlObj.child;
};
function addChild(currentNode, childNode, jPath) {
  const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"]);
  if (result === false)
    ;
  else if (typeof result === "string") {
    childNode.tagname = result;
    currentNode.addChild(childNode);
  } else {
    currentNode.addChild(childNode);
  }
}
var replaceEntitiesValue$1 = function(val2) {
  if (this.options.processEntities) {
    for (let entityName2 in this.docTypeEntities) {
      const entity = this.docTypeEntities[entityName2];
      val2 = val2.replace(entity.regx, entity.val);
    }
    for (let entityName2 in this.lastEntities) {
      const entity = this.lastEntities[entityName2];
      val2 = val2.replace(entity.regex, entity.val);
    }
    if (this.options.htmlEntities) {
      for (let entityName2 in this.htmlEntities) {
        const entity = this.htmlEntities[entityName2];
        val2 = val2.replace(entity.regex, entity.val);
      }
    }
    val2 = val2.replace(this.ampEntity.regex, this.ampEntity.val);
  }
  return val2;
};
function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
  if (textData) {
    if (isLeafNode === void 0)
      isLeafNode = Object.keys(currentNode.child).length === 0;
    textData = this.parseTextData(
      textData,
      currentNode.tagname,
      jPath,
      false,
      currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
      isLeafNode
    );
    if (textData !== void 0 && textData !== "")
      currentNode.add(this.options.textNodeName, textData);
    textData = "";
  }
  return textData;
}
function isItStopNode(stopNodes, jPath, currentTagName) {
  const allNodesExp = "*." + currentTagName;
  for (const stopNodePath in stopNodes) {
    const stopNodeExp = stopNodes[stopNodePath];
    if (allNodesExp === stopNodeExp || jPath === stopNodeExp)
      return true;
  }
  return false;
}
function tagExpWithClosingIndex(xmlData, i, closingChar = ">") {
  let attrBoundary;
  let tagExp = "";
  for (let index = i; index < xmlData.length; index++) {
    let ch = xmlData[index];
    if (attrBoundary) {
      if (ch === attrBoundary)
        attrBoundary = "";
    } else if (ch === '"' || ch === "'") {
      attrBoundary = ch;
    } else if (ch === closingChar[0]) {
      if (closingChar[1]) {
        if (xmlData[index + 1] === closingChar[1]) {
          return {
            data: tagExp,
            index
          };
        }
      } else {
        return {
          data: tagExp,
          index
        };
      }
    } else if (ch === "	") {
      ch = " ";
    }
    tagExp += ch;
  }
}
function findClosingIndex(xmlData, str, i, errMsg) {
  const closingIndex = xmlData.indexOf(str, i);
  if (closingIndex === -1) {
    throw new Error(errMsg);
  } else {
    return closingIndex + str.length - 1;
  }
}
function readTagExp(xmlData, i, removeNSPrefix, closingChar = ">") {
  const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
  if (!result)
    return;
  let tagExp = result.data;
  const closeIndex = result.index;
  const separatorIndex = tagExp.search(/\s/);
  let tagName = tagExp;
  let attrExpPresent = true;
  if (separatorIndex !== -1) {
    tagName = tagExp.substring(0, separatorIndex);
    tagExp = tagExp.substring(separatorIndex + 1).trimStart();
  }
  const rawTagName = tagName;
  if (removeNSPrefix) {
    const colonIndex = tagName.indexOf(":");
    if (colonIndex !== -1) {
      tagName = tagName.substr(colonIndex + 1);
      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
    }
  }
  return {
    tagName,
    tagExp,
    closeIndex,
    attrExpPresent,
    rawTagName
  };
}
function readStopNodeData(xmlData, tagName, i) {
  const startIndex = i;
  let openTagCount = 1;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === "<") {
      if (xmlData[i + 1] === "/") {
        const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
        let closeTagName = xmlData.substring(i + 2, closeIndex).trim();
        if (closeTagName === tagName) {
          openTagCount--;
          if (openTagCount === 0) {
            return {
              tagContent: xmlData.substring(startIndex, i),
              i: closeIndex
            };
          }
        }
        i = closeIndex;
      } else if (xmlData[i + 1] === "?") {
        const closeIndex = findClosingIndex(xmlData, "?>", i + 1, "StopNode is not closed.");
        i = closeIndex;
      } else if (xmlData.substr(i + 1, 3) === "!--") {
        const closeIndex = findClosingIndex(xmlData, "-->", i + 3, "StopNode is not closed.");
        i = closeIndex;
      } else if (xmlData.substr(i + 1, 2) === "![") {
        const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
        i = closeIndex;
      } else {
        const tagData = readTagExp(xmlData, i, ">");
        if (tagData) {
          const openTagName = tagData && tagData.tagName;
          if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length - 1] !== "/") {
            openTagCount++;
          }
          i = tagData.closeIndex;
        }
      }
    }
  }
}
function parseValue(val2, shouldParse, options) {
  if (shouldParse && typeof val2 === "string") {
    const newval = val2.trim();
    if (newval === "true")
      return true;
    else if (newval === "false")
      return false;
    else
      return toNumber(val2, options);
  } else {
    if (util.isExist(val2)) {
      return val2;
    } else {
      return "";
    }
  }
}
var OrderedObjParser_1 = OrderedObjParser$1;
var node2json = {};
function prettify$1(node, options) {
  return compress(node, options);
}
function compress(arr, options, jPath) {
  let text;
  const compressedObj = {};
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i];
    const property = propName$1(tagObj);
    let newJpath = "";
    if (jPath === void 0)
      newJpath = property;
    else
      newJpath = jPath + "." + property;
    if (property === options.textNodeName) {
      if (text === void 0)
        text = tagObj[property];
      else
        text += "" + tagObj[property];
    } else if (property === void 0) {
      continue;
    } else if (tagObj[property]) {
      let val2 = compress(tagObj[property], options, newJpath);
      const isLeaf = isLeafTag(val2, options);
      if (tagObj[":@"]) {
        assignAttributes(val2, tagObj[":@"], newJpath, options);
      } else if (Object.keys(val2).length === 1 && val2[options.textNodeName] !== void 0 && !options.alwaysCreateTextNode) {
        val2 = val2[options.textNodeName];
      } else if (Object.keys(val2).length === 0) {
        if (options.alwaysCreateTextNode)
          val2[options.textNodeName] = "";
        else
          val2 = "";
      }
      if (compressedObj[property] !== void 0 && compressedObj.hasOwnProperty(property)) {
        if (!Array.isArray(compressedObj[property])) {
          compressedObj[property] = [compressedObj[property]];
        }
        compressedObj[property].push(val2);
      } else {
        if (options.isArray(property, newJpath, isLeaf)) {
          compressedObj[property] = [val2];
        } else {
          compressedObj[property] = val2;
        }
      }
    }
  }
  if (typeof text === "string") {
    if (text.length > 0)
      compressedObj[options.textNodeName] = text;
  } else if (text !== void 0)
    compressedObj[options.textNodeName] = text;
  return compressedObj;
}
function propName$1(obj) {
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (key !== ":@")
      return key;
  }
}
function assignAttributes(obj, attrMap, jpath, options) {
  if (attrMap) {
    const keys = Object.keys(attrMap);
    const len = keys.length;
    for (let i = 0; i < len; i++) {
      const atrrName = keys[i];
      if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
        obj[atrrName] = [attrMap[atrrName]];
      } else {
        obj[atrrName] = attrMap[atrrName];
      }
    }
  }
}
function isLeafTag(obj, options) {
  const { textNodeName } = options;
  const propCount = Object.keys(obj).length;
  if (propCount === 0) {
    return true;
  }
  if (propCount === 1 && (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)) {
    return true;
  }
  return false;
}
node2json.prettify = prettify$1;
var { buildOptions } = OptionsBuilder;
var OrderedObjParser2 = OrderedObjParser_1;
var { prettify } = node2json;
var validator$1 = validator$2;
var XMLParser$1 = class XMLParser {
  constructor(options) {
    this.externalEntities = {};
    this.options = buildOptions(options);
  }
  /**
   * Parse XML dats to JS object 
   * @param {string|Buffer} xmlData 
   * @param {boolean|Object} validationOption 
   */
  parse(xmlData, validationOption) {
    if (typeof xmlData === "string")
      ;
    else if (xmlData.toString) {
      xmlData = xmlData.toString();
    } else {
      throw new Error("XML data is accepted in String or Bytes[] form.");
    }
    if (validationOption) {
      if (validationOption === true)
        validationOption = {};
      const result = validator$1.validate(xmlData, validationOption);
      if (result !== true) {
        throw Error(`${result.err.msg}:${result.err.line}:${result.err.col}`);
      }
    }
    const orderedObjParser = new OrderedObjParser2(this.options);
    orderedObjParser.addExternalEntities(this.externalEntities);
    const orderedResult = orderedObjParser.parseXml(xmlData);
    if (this.options.preserveOrder || orderedResult === void 0)
      return orderedResult;
    else
      return prettify(orderedResult, this.options);
  }
  /**
   * Add Entity which is not by default supported by this library
   * @param {string} key 
   * @param {string} value 
   */
  addEntity(key, value) {
    if (value.indexOf("&") !== -1) {
      throw new Error("Entity value can't have '&'");
    } else if (key.indexOf("&") !== -1 || key.indexOf(";") !== -1) {
      throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'");
    } else if (value === "&") {
      throw new Error("An entity with value '&' is not permitted");
    } else {
      this.externalEntities[key] = value;
    }
  }
};
var XMLParser_1 = XMLParser$1;
var EOL = "\n";
function toXml(jArray, options) {
  let indentation = "";
  if (options.format && options.indentBy.length > 0) {
    indentation = EOL;
  }
  return arrToStr(jArray, options, "", indentation);
}
function arrToStr(arr, options, jPath, indentation) {
  let xmlStr = "";
  let isPreviousElementTag = false;
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i];
    const tagName = propName(tagObj);
    if (tagName === void 0)
      continue;
    let newJPath = "";
    if (jPath.length === 0)
      newJPath = tagName;
    else
      newJPath = `${jPath}.${tagName}`;
    if (tagName === options.textNodeName) {
      let tagText = tagObj[tagName];
      if (!isStopNode(newJPath, options)) {
        tagText = options.tagValueProcessor(tagName, tagText);
        tagText = replaceEntitiesValue(tagText, options);
      }
      if (isPreviousElementTag) {
        xmlStr += indentation;
      }
      xmlStr += tagText;
      isPreviousElementTag = false;
      continue;
    } else if (tagName === options.cdataPropName) {
      if (isPreviousElementTag) {
        xmlStr += indentation;
      }
      xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
      isPreviousElementTag = false;
      continue;
    } else if (tagName === options.commentPropName) {
      xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
      isPreviousElementTag = true;
      continue;
    } else if (tagName[0] === "?") {
      const attStr2 = attr_to_str(tagObj[":@"], options);
      const tempInd = tagName === "?xml" ? "" : indentation;
      let piTextNodeName = tagObj[tagName][0][options.textNodeName];
      piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : "";
      xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr2}?>`;
      isPreviousElementTag = true;
      continue;
    }
    let newIdentation = indentation;
    if (newIdentation !== "") {
      newIdentation += options.indentBy;
    }
    const attStr = attr_to_str(tagObj[":@"], options);
    const tagStart = indentation + `<${tagName}${attStr}`;
    const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
    if (options.unpairedTags.indexOf(tagName) !== -1) {
      if (options.suppressUnpairedNode)
        xmlStr += tagStart + ">";
      else
        xmlStr += tagStart + "/>";
    } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
      xmlStr += tagStart + "/>";
    } else if (tagValue && tagValue.endsWith(">")) {
      xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
    } else {
      xmlStr += tagStart + ">";
      if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
        xmlStr += indentation + options.indentBy + tagValue + indentation;
      } else {
        xmlStr += tagValue;
      }
      xmlStr += `</${tagName}>`;
    }
    isPreviousElementTag = true;
  }
  return xmlStr;
}
function propName(obj) {
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (!obj.hasOwnProperty(key))
      continue;
    if (key !== ":@")
      return key;
  }
}
function attr_to_str(attrMap, options) {
  let attrStr = "";
  if (attrMap && !options.ignoreAttributes) {
    for (let attr in attrMap) {
      if (!attrMap.hasOwnProperty(attr))
        continue;
      let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
      attrVal = replaceEntitiesValue(attrVal, options);
      if (attrVal === true && options.suppressBooleanAttributes) {
        attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
      } else {
        attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
      }
    }
  }
  return attrStr;
}
function isStopNode(jPath, options) {
  jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
  let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
  for (let index in options.stopNodes) {
    if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName)
      return true;
  }
  return false;
}
function replaceEntitiesValue(textValue, options) {
  if (textValue && textValue.length > 0 && options.processEntities) {
    for (let i = 0; i < options.entities.length; i++) {
      const entity = options.entities[i];
      textValue = textValue.replace(entity.regex, entity.val);
    }
  }
  return textValue;
}
var orderedJs2Xml = toXml;
var buildFromOrderedJs = orderedJs2Xml;
var defaultOptions = {
  attributeNamePrefix: "@_",
  attributesGroupName: false,
  textNodeName: "#text",
  ignoreAttributes: true,
  cdataPropName: false,
  format: false,
  indentBy: "  ",
  suppressEmptyNode: false,
  suppressUnpairedNode: true,
  suppressBooleanAttributes: true,
  tagValueProcessor: function(key, a) {
    return a;
  },
  attributeValueProcessor: function(attrName, a) {
    return a;
  },
  preserveOrder: false,
  commentPropName: false,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },
    //it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("'", "g"), val: "&apos;" },
    { regex: new RegExp('"', "g"), val: "&quot;" }
  ],
  processEntities: true,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: false
};
function Builder2(options) {
  this.options = Object.assign({}, defaultOptions, options);
  if (this.options.ignoreAttributes || this.options.attributesGroupName) {
    this.isAttribute = function() {
      return false;
    };
  } else {
    this.attrPrefixLen = this.options.attributeNamePrefix.length;
    this.isAttribute = isAttribute;
  }
  this.processTextOrObjNode = processTextOrObjNode;
  if (this.options.format) {
    this.indentate = indentate;
    this.tagEndChar = ">\n";
    this.newLine = "\n";
  } else {
    this.indentate = function() {
      return "";
    };
    this.tagEndChar = ">";
    this.newLine = "";
  }
}
Builder2.prototype.build = function(jObj) {
  if (this.options.preserveOrder) {
    return buildFromOrderedJs(jObj, this.options);
  } else {
    if (Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1) {
      jObj = {
        [this.options.arrayNodeName]: jObj
      };
    }
    return this.j2x(jObj, 0).val;
  }
};
Builder2.prototype.j2x = function(jObj, level) {
  let attrStr = "";
  let val2 = "";
  for (let key in jObj) {
    if (!Object.prototype.hasOwnProperty.call(jObj, key))
      continue;
    if (typeof jObj[key] === "undefined") {
      if (this.isAttribute(key)) {
        val2 += "";
      }
    } else if (jObj[key] === null) {
      if (this.isAttribute(key)) {
        val2 += "";
      } else if (key[0] === "?") {
        val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
      } else {
        val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
      }
    } else if (jObj[key] instanceof Date) {
      val2 += this.buildTextValNode(jObj[key], key, "", level);
    } else if (typeof jObj[key] !== "object") {
      const attr = this.isAttribute(key);
      if (attr) {
        attrStr += this.buildAttrPairStr(attr, "" + jObj[key]);
      } else {
        if (key === this.options.textNodeName) {
          let newval = this.options.tagValueProcessor(key, "" + jObj[key]);
          val2 += this.replaceEntitiesValue(newval);
        } else {
          val2 += this.buildTextValNode(jObj[key], key, "", level);
        }
      }
    } else if (Array.isArray(jObj[key])) {
      const arrLen = jObj[key].length;
      let listTagVal = "";
      let listTagAttr = "";
      for (let j = 0; j < arrLen; j++) {
        const item = jObj[key][j];
        if (typeof item === "undefined")
          ;
        else if (item === null) {
          if (key[0] === "?")
            val2 += this.indentate(level) + "<" + key + "?" + this.tagEndChar;
          else
            val2 += this.indentate(level) + "<" + key + "/" + this.tagEndChar;
        } else if (typeof item === "object") {
          if (this.options.oneListGroup) {
            const result = this.j2x(item, level + 1);
            listTagVal += result.val;
            if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
              listTagAttr += result.attrStr;
            }
          } else {
            listTagVal += this.processTextOrObjNode(item, key, level);
          }
        } else {
          if (this.options.oneListGroup) {
            let textValue = this.options.tagValueProcessor(key, item);
            textValue = this.replaceEntitiesValue(textValue);
            listTagVal += textValue;
          } else {
            listTagVal += this.buildTextValNode(item, key, "", level);
          }
        }
      }
      if (this.options.oneListGroup) {
        listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);
      }
      val2 += listTagVal;
    } else {
      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
        const Ks = Object.keys(jObj[key]);
        const L = Ks.length;
        for (let j = 0; j < L; j++) {
          attrStr += this.buildAttrPairStr(Ks[j], "" + jObj[key][Ks[j]]);
        }
      } else {
        val2 += this.processTextOrObjNode(jObj[key], key, level);
      }
    }
  }
  return { attrStr, val: val2 };
};
Builder2.prototype.buildAttrPairStr = function(attrName, val2) {
  val2 = this.options.attributeValueProcessor(attrName, "" + val2);
  val2 = this.replaceEntitiesValue(val2);
  if (this.options.suppressBooleanAttributes && val2 === "true") {
    return " " + attrName;
  } else
    return " " + attrName + '="' + val2 + '"';
};
function processTextOrObjNode(object, key, level) {
  const result = this.j2x(object, level + 1);
  if (object[this.options.textNodeName] !== void 0 && Object.keys(object).length === 1) {
    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
  } else {
    return this.buildObjectNode(result.val, key, result.attrStr, level);
  }
}
Builder2.prototype.buildObjectNode = function(val2, key, attrStr, level) {
  if (val2 === "") {
    if (key[0] === "?")
      return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
    else {
      return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
    }
  } else {
    let tagEndExp = "</" + key + this.tagEndChar;
    let piClosingChar = "";
    if (key[0] === "?") {
      piClosingChar = "?";
      tagEndExp = "";
    }
    if ((attrStr || attrStr === "") && val2.indexOf("<") === -1) {
      return this.indentate(level) + "<" + key + attrStr + piClosingChar + ">" + val2 + tagEndExp;
    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
      return this.indentate(level) + `<!--${val2}-->` + this.newLine;
    } else {
      return this.indentate(level) + "<" + key + attrStr + piClosingChar + this.tagEndChar + val2 + this.indentate(level) + tagEndExp;
    }
  }
};
Builder2.prototype.closeTag = function(key) {
  let closeTag = "";
  if (this.options.unpairedTags.indexOf(key) !== -1) {
    if (!this.options.suppressUnpairedNode)
      closeTag = "/";
  } else if (this.options.suppressEmptyNode) {
    closeTag = "/";
  } else {
    closeTag = `></${key}`;
  }
  return closeTag;
};
Builder2.prototype.buildTextValNode = function(val2, key, attrStr, level) {
  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
    return this.indentate(level) + `<![CDATA[${val2}]]>` + this.newLine;
  } else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
    return this.indentate(level) + `<!--${val2}-->` + this.newLine;
  } else if (key[0] === "?") {
    return this.indentate(level) + "<" + key + attrStr + "?" + this.tagEndChar;
  } else {
    let textValue = this.options.tagValueProcessor(key, val2);
    textValue = this.replaceEntitiesValue(textValue);
    if (textValue === "") {
      return this.indentate(level) + "<" + key + attrStr + this.closeTag(key) + this.tagEndChar;
    } else {
      return this.indentate(level) + "<" + key + attrStr + ">" + textValue + "</" + key + this.tagEndChar;
    }
  }
};
Builder2.prototype.replaceEntitiesValue = function(textValue) {
  if (textValue && textValue.length > 0 && this.options.processEntities) {
    for (let i = 0; i < this.options.entities.length; i++) {
      const entity = this.options.entities[i];
      textValue = textValue.replace(entity.regex, entity.val);
    }
  }
  return textValue;
};
function indentate(level) {
  return this.options.indentBy.repeat(level);
}
function isAttribute(name) {
  if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
    return name.substr(this.attrPrefixLen);
  } else {
    return false;
  }
}
var json2xml = Builder2;
var validator = validator$2;
var XMLParser2 = XMLParser_1;
var XMLBuilder = json2xml;
var fxp = {
  XMLParser: XMLParser2,
  XMLValidator: validator,
  XMLBuilder
};
var Comment = class {
  /**
   * Constructs a new BCF Topic Comment instance.
   * @param components - The Components instance.
   * @param text - The initial comment text.
   */
  constructor(components, text) {
    __publicField2(this, "date", /* @__PURE__ */ new Date());
    __publicField2(this, "author");
    __publicField2(this, "guid", UUID.create());
    __publicField2(this, "viewpoint");
    __publicField2(this, "modifiedAuthor");
    __publicField2(this, "modifiedDate");
    __publicField2(this, "topic");
    __publicField2(this, "_components");
    __publicField2(this, "_comment", "");
    this._components = components;
    this._comment = text;
    const manager = this._components.get(BCFTopics);
    this.author = manager.config.author;
  }
  /**
   * Sets the comment text and updates the modified date and author.
   * The author will be the one defined in BCFTopics.config.author
   * @param value - The new comment text.
   */
  set comment(value) {
    var _a;
    const manager = this._components.get(BCFTopics);
    this._comment = value;
    this.modifiedDate = /* @__PURE__ */ new Date();
    this.modifiedAuthor = manager.config.author;
    (_a = this.topic) == null ? void 0 : _a.comments.set(this.guid, this);
  }
  /**
   * Gets the comment text.
   * @returns The comment text.
   */
  get comment() {
    return this._comment;
  }
  /**
   * Serializes the Comment instance into a BCF compliant XML string.
   *
   * @returns A string representing the Comment in BCFv2 XML format.
   */
  serialize() {
    let viewpointTag = null;
    if (this.viewpoint) {
      viewpointTag = `<Viewpoint Guid="${this.viewpoint.guid}"/>`;
    }
    let modifiedDateTag = null;
    if (this.modifiedDate) {
      modifiedDateTag = `<ModifiedDate>${this.modifiedDate.toISOString()}</ModifiedDate>`;
    }
    let modifiedAuthorTag = null;
    if (this.modifiedAuthor) {
      modifiedAuthorTag = `<ModifiedAuthor>${this.modifiedAuthor}</ModifiedAuthor>`;
    }
    return `
      <Comment Guid="${this.guid}">
        <Date>${this.date.toISOString()}</Date>
        <Author>${this.author}</Author>
        <Comment>${this.comment}</Comment>
        ${viewpointTag ?? ""}
        ${modifiedAuthorTag ?? ""}
        ${modifiedDateTag ?? ""}
      </Comment>
    `;
  }
};
var _Topic = class _Topic2 {
  /**
   * Initializes a new instance of the `Topic` class representing a BCF (BIM Collaboration Format) topic.
   * It provides methods and properties to manage and serialize BCF topics.
   *
   * @remarks
   * The default creationUser is the one set in BCFTopics.config.author
   * It should not be created manually. Better use BCFTopics.create().
   *
   * @param components - The `Components` instance that provides access to other components and services.
   */
  constructor(components) {
    __publicField2(this, "guid", UUID.create());
    __publicField2(this, "title", _Topic2.default.title);
    __publicField2(this, "creationDate", /* @__PURE__ */ new Date());
    __publicField2(this, "creationAuthor", "");
    __publicField2(this, "viewpoints", new DataSet());
    __publicField2(this, "relatedTopics", new DataSet());
    __publicField2(this, "comments", new DataMap());
    __publicField2(this, "customData", {});
    __publicField2(this, "description");
    __publicField2(this, "serverAssignedId");
    __publicField2(this, "dueDate");
    __publicField2(this, "modifiedAuthor");
    __publicField2(this, "modifiedDate");
    __publicField2(this, "index");
    __publicField2(this, "_type", _Topic2.default.type);
    __publicField2(this, "_status", _Topic2.default.status);
    __publicField2(this, "_priority", _Topic2.default.priority);
    __publicField2(this, "_stage", _Topic2.default.stage);
    __publicField2(this, "_assignedTo", _Topic2.default.assignedTo);
    __publicField2(this, "_labels", _Topic2.default.labels ?? /* @__PURE__ */ new Set());
    __publicField2(this, "_components");
    this._components = components;
    const manager = components.get(BCFTopics);
    this.creationAuthor = manager.config.author;
    this.relatedTopics.guard = (guid) => guid !== this.guid;
  }
  set type(value) {
    const manager = this._components.get(BCFTopics);
    const { strict, types } = manager.config;
    const valid = strict ? types.has(value) : true;
    if (!valid)
      return;
    this._type = value;
  }
  get type() {
    return this._type;
  }
  set status(value) {
    const manager = this._components.get(BCFTopics);
    const { strict, statuses } = manager.config;
    const valid = strict ? statuses.has(value) : true;
    if (!valid)
      return;
    this._status = value;
  }
  get status() {
    return this._status;
  }
  set priority(value) {
    const manager = this._components.get(BCFTopics);
    if (value) {
      const { strict, priorities } = manager.config;
      const valid = strict ? priorities.has(value) : true;
      if (!valid)
        return;
      this._priority = value;
    } else {
      this._priority = value;
    }
  }
  get priority() {
    return this._priority;
  }
  set stage(value) {
    const manager = this._components.get(BCFTopics);
    if (value) {
      const { strict, stages } = manager.config;
      const valid = strict ? stages.has(value) : true;
      if (!valid)
        return;
      this._stage = value;
    } else {
      this._stage = value;
    }
  }
  get stage() {
    return this._stage;
  }
  set assignedTo(value) {
    const manager = this._components.get(BCFTopics);
    if (value) {
      const { strict, users } = manager.config;
      const valid = strict ? users.has(value) : true;
      if (!valid)
        return;
      this._assignedTo = value;
    } else {
      this._assignedTo = value;
    }
  }
  get assignedTo() {
    return this._assignedTo;
  }
  set labels(value) {
    const manager = this._components.get(BCFTopics);
    const { strict, labels } = manager.config;
    if (strict) {
      const _value = /* @__PURE__ */ new Set();
      for (const label of value) {
        const valid = strict ? labels.has(label) : true;
        if (!valid)
          continue;
        _value.add(label);
      }
      this._labels = _value;
    } else {
      this._labels = value;
    }
  }
  get labels() {
    return this._labels;
  }
  get _managerVersion() {
    const manager = this._components.get(BCFTopics);
    return manager.config.version;
  }
  /**
   * Sets properties of the BCF Topic based on the provided data.
   *
   * @remarks
   * This method iterates over the provided `data` object and updates the corresponding properties of the BCF Topic.
   * It skips the `guid` property as it should not be modified.
   *
   * @param data - An object containing the properties to be updated.
   * @returns The topic
   *
   * @example
   * ```typescript
   * const topic = new Topic(components);
   * topic.set({
   *   title: "New BCF Topic Title",
   *   description: "This is a new description.",
   *   status: "Resolved",
   * });
   * ```
   */
  set(data) {
    const _data = data;
    const _this = this;
    for (const key in data) {
      if (key === "guid")
        continue;
      const value = _data[key];
      if (key in this)
        _this[key] = value;
    }
    const manager = this._components.get(BCFTopics);
    manager.list.set(this.guid, this);
    return this;
  }
  /**
   * Creates a new comment associated with the current topic.
   *
   * @param text - The text content of the comment.
   * @param viewpoint - (Optional) The viewpoint associated with the comment.
   *
   * @returns The newly created comment.
   *
   * @example
   * ```typescript
   * const viewpoint = viewpoints.create(world); // Created with an instance of Viewpoints
   * const topic = topics.create(); // Created with an instance of BCFTopics
   * topic.viewpoints.add(viewpoint);
   * const comment = topic.createComment("This is a new comment", viewpoint);
   * ```
   */
  createComment(text, viewpoint) {
    const comment = new Comment(this._components, text);
    comment.viewpoint = viewpoint;
    comment.topic = this;
    this.comments.set(comment.guid, comment);
    return comment;
  }
  createLabelTags(version = this._managerVersion) {
    let tag = "Labels";
    if (version === "2.1")
      tag = "Labels";
    if (version === "3")
      tag = "Label";
    let tags = [...this.labels].map((label) => `<${tag}>${label}</${tag}>`).join("\n");
    for (const key in this.customData) {
      const value = this.customData[key];
      if (typeof value !== "string")
        continue;
      tags += `
<${tag}>${value}</${tag}>`;
    }
    if (version === "2.1")
      return tags;
    if (version === "3") {
      if (tags.length !== 0)
        return `<Labels>
${tags}
</Labels>`;
      return "<Labels/>";
    }
    return tags;
  }
  createCommentTags(version = this._managerVersion) {
    const tags = [...this.comments.values()].map((comment) => comment.serialize()).join("\n");
    if (version === "2.1")
      return tags;
    if (version === "3") {
      if (tags.length !== 0)
        return `<Comments>
${tags}
</Comments>`;
      return "<Comments/>";
    }
    return tags;
  }
  createViewpointTags(version = this._managerVersion) {
    let tag = "Viewpoints";
    if (version === "2.1")
      tag = "Viewpoints";
    if (version === "3")
      tag = "ViewPoint";
    const manager = this._components.get(Viewpoints);
    const viewpoints = [...this.viewpoints].map((viewpointID) => manager.list.get(viewpointID)).filter((viewpoint) => viewpoint);
    const tags = viewpoints.map((viewpoint) => {
      return `<${tag} Guid="${viewpoint.guid}">
          <Viewpoint>${viewpoint.guid}.bcfv</Viewpoint>
          <Snapshot>${viewpoint.guid}.jpeg</Snapshot>
        </${tag}>
      `;
    }).join("\n");
    if (version === "2.1")
      return tags;
    if (version === "3") {
      if (tags.length !== 0)
        return `<Viewpoints>
${tags}
</Viewpoints>`;
      return "<Viewpoints />";
    }
    return tags;
  }
  createRelatedTopicTags(version = this._managerVersion) {
    const tags = [...this.relatedTopics].map(
      (guid) => `<RelatedTopic Guid="${guid}"></RelatedTopic>
      `
    ).join("\n");
    if (version === "2.1")
      return tags;
    if (version === "3") {
      if (tags.length !== 0)
        return `<RelatedTopics>
${tags}
</RelatedTopics>`;
      return "<RelatedTopics />";
    }
    return tags;
  }
  /**
   * Serializes the BCF Topic instance into an XML string representation based on the official schema.
   *
   * @remarks
   * This method constructs an XML string based on the properties of the BCF Topic instance.
   * It includes the topic's guid, type, status, creation date, creation author, priority, index,
   * modified date, modified author, due date, assigned to, description, stage, labels, related topics,
   * comments, and viewpoints.
   *
   * @returns A string representing the XML serialization of the BCF Topic.
   *
   * @example
   * ```typescript
   * const topic = bcfTopics.create(); // Created with an instance of BCFTopics
   * const xml = topic.serialize();
   * console.log(xml);
   * ```
   */
  serialize() {
    const version = this._managerVersion;
    let serverAssignedIdAttribute = null;
    if (this.serverAssignedId) {
      serverAssignedIdAttribute = `ServerAssignedId="${this.serverAssignedId}"`;
    }
    let priorityTag = null;
    if (this.priority) {
      priorityTag = `<Priority>${this.priority}</Priority>`;
    }
    let indexTag = null;
    if (this.index && version === "2.1") {
      indexTag = `<Index>${this.index}</Index>`;
    }
    let modifiedDateTag = null;
    if (this.modifiedDate) {
      modifiedDateTag = `<ModifiedDate>${this.modifiedDate.toISOString()}</ModifiedDate>`;
    }
    let modifiedAuthorTag = null;
    if (this.modifiedAuthor) {
      modifiedAuthorTag = `<ModifiedAuthor>${this.modifiedAuthor}</ModifiedAuthor>`;
    }
    let dueDateTag = null;
    if (this.dueDate) {
      dueDateTag = `<DueDate>${this.dueDate.toISOString()}</DueDate>`;
    }
    let assignedToTag = null;
    if (this.assignedTo) {
      assignedToTag = `<AssignedTo>${this.assignedTo}</AssignedTo>`;
    }
    let descriptionTag = null;
    if (this.description) {
      descriptionTag = `<Description>${this.description}</Description>`;
    }
    let stageTag = null;
    if (this.stage) {
      stageTag = `<Stage>${this.stage}</Stage>`;
    }
    const commentTags = this.createCommentTags(version);
    const viewpointTags = this.createViewpointTags(version);
    const labelTags = this.createLabelTags(version);
    const relatedTopicTags = this.createRelatedTopicTags(version);
    return `
      <?xml version="1.0" encoding="UTF-8"?>
      <Markup>
        <Topic Guid="${this.guid}" TopicType="${this.type}" TopicStatus="${this.status}" ${serverAssignedIdAttribute ?? ""}>
          <Title>${this.title}</Title>
          <CreationDate>${this.creationDate.toISOString()}</CreationDate>
          <CreationAuthor>${this.creationAuthor}</CreationAuthor>
          ${priorityTag ?? ""}
          ${indexTag ?? ""}
          ${modifiedDateTag ?? ""}
          ${modifiedAuthorTag ?? ""}
          ${dueDateTag ?? ""}
          ${assignedToTag ?? ""}
          ${descriptionTag ?? ""}
          ${stageTag ?? ""}
          ${labelTags}
          ${relatedTopicTags}
          ${version === "3" ? commentTags : ""}
          ${version === "3" ? viewpointTags : ""}
        </Topic>
        ${version === "2.1" ? commentTags : ""}
        ${version === "2.1" ? viewpointTags : ""}
      </Markup>
    `;
  }
};
__publicField2(_Topic, "default", {
  title: "BCF Topic",
  type: "Issue",
  status: "Active"
});
var Topic = _Topic;
var extensionsImporter = (manager, extensionsXML) => {
  if (extensionsXML.trim() === "")
    return;
  const extensions = BCFTopics.xmlParser.parse(extensionsXML).Extensions;
  if (!extensions)
    return;
  const { Priorities, TopicStatuses, TopicTypes, Users } = extensions;
  if (Priorities && Priorities.Priority) {
    const priorities = Array.isArray(Priorities.Priority) ? Priorities.Priority : [Priorities.Priority];
    for (const priority of priorities) {
      manager.config.priorities.add(priority);
    }
  }
  if (TopicStatuses && TopicStatuses.TopicStatus) {
    const statuses = Array.isArray(TopicStatuses.TopicStatus) ? TopicStatuses.TopicStatus : [TopicStatuses.TopicStatus];
    for (const status of statuses) {
      manager.config.statuses.add(status);
    }
  }
  if (TopicTypes && TopicTypes.TopicType) {
    const types = Array.isArray(TopicTypes.TopicType) ? TopicTypes.TopicType : [TopicTypes.TopicType];
    for (const type of types) {
      manager.config.types.add(type);
    }
  }
  if (Users && Users.User) {
    const users = Array.isArray(Users.User) ? Users.User : [Users.User];
    for (const user of users) {
      manager.config.users.add(user);
    }
  }
};
var BCFTopicsConfigManager = class extends Configurator {
  constructor() {
    super(...arguments);
    __publicField2(this, "_config", {
      version: {
        type: "Select",
        options: /* @__PURE__ */ new Set(["2.1", "3"]),
        multiple: false,
        value: ""
      },
      author: {
        type: "Text",
        value: ""
      },
      types: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      statuses: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      priorities: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      labels: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      stages: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      users: {
        type: "TextSet",
        value: /* @__PURE__ */ new Set()
      },
      includeSelectionTag: {
        type: "Boolean",
        value: false
      },
      updateExtensionsOnImport: {
        type: "Boolean",
        value: false
      },
      strict: {
        type: "Boolean",
        value: false
      },
      includeAllExtensionsOnExport: {
        type: "Boolean",
        value: false
      },
      fallbackVersionOnImport: {
        type: "Select",
        multiple: false,
        options: /* @__PURE__ */ new Set(["2.1", "3"]),
        value: ""
      },
      ignoreIncompleteTopicsOnImport: {
        type: "Boolean",
        value: false
      }
    });
  }
  get version() {
    return this._config.version.value;
  }
  set version(value) {
    this._config.version.value = value;
  }
  get author() {
    return this._config.author.value;
  }
  set author(value) {
    this._config.author.value = value;
  }
  get types() {
    return this._config.types.value;
  }
  set types(value) {
    this._config.types.value = value;
  }
  get statuses() {
    return this._config.statuses.value;
  }
  set statuses(value) {
    this._config.statuses.value = value;
  }
  get priorities() {
    return this._config.priorities.value;
  }
  set priorities(value) {
    this._config.priorities.value = value;
  }
  get labels() {
    return this._config.labels.value;
  }
  set labels(value) {
    this._config.labels.value = value;
  }
  get stages() {
    return this._config.stages.value;
  }
  set stages(value) {
    this._config.stages.value = value;
  }
  get users() {
    return this._config.users.value;
  }
  set users(value) {
    this._config.users.value = value;
  }
  get includeSelectionTag() {
    return this._config.includeSelectionTag.value;
  }
  set includeSelectionTag(value) {
    this._config.includeSelectionTag.value = value;
  }
  get updateExtensionsOnImport() {
    return this._config.updateExtensionsOnImport.value;
  }
  set updateExtensionsOnImport(value) {
    this._config.updateExtensionsOnImport.value = value;
  }
  get strict() {
    return this._config.strict.value;
  }
  set strict(value) {
    this._config.strict.value = value;
  }
  get includeAllExtensionsOnExport() {
    return this._config.includeAllExtensionsOnExport.value;
  }
  set includeAllExtensionsOnExport(value) {
    this._config.includeAllExtensionsOnExport.value = value;
  }
  get fallbackVersionOnImport() {
    return this._config.fallbackVersionOnImport.value;
  }
  set fallbackVersionOnImport(value) {
    this._config.fallbackVersionOnImport.value = value;
  }
  get ignoreIncompleteTopicsOnImport() {
    return this._config.ignoreIncompleteTopicsOnImport.value;
  }
  set ignoreIncompleteTopicsOnImport(value) {
    this._config.ignoreIncompleteTopicsOnImport.value = value;
  }
};
var _BCFTopics = class _BCFTopics2 extends Component {
  constructor() {
    super(...arguments);
    __publicField2(this, "enabled", false);
    __publicField2(this, "_defaultConfig", {
      author: "jhon.doe@example.com",
      version: "2.1",
      types: /* @__PURE__ */ new Set([
        "Clash",
        "Failure",
        "Fault",
        "Inquiry",
        "Issue",
        "Remark",
        "Request"
      ]),
      statuses: /* @__PURE__ */ new Set(["Active", "In Progress", "Done", "In Review", "Closed"]),
      priorities: /* @__PURE__ */ new Set(["On hold", "Minor", "Normal", "Major", "Critical"]),
      labels: /* @__PURE__ */ new Set(),
      stages: /* @__PURE__ */ new Set(),
      users: /* @__PURE__ */ new Set(),
      includeSelectionTag: false,
      updateExtensionsOnImport: true,
      strict: false,
      includeAllExtensionsOnExport: true,
      fallbackVersionOnImport: "2.1",
      ignoreIncompleteTopicsOnImport: false
    });
    __publicField2(this, "config", new BCFTopicsConfigManager(
      this,
      this.components,
      "BCF Topics",
      _BCFTopics2.uuid
    ));
    __publicField2(this, "list", new DataMap());
    __publicField2(this, "onSetup", new Event());
    __publicField2(this, "isSetup", false);
    __publicField2(this, "onBCFImported", new Event());
    __publicField2(this, "onDisposed", new Event());
  }
  setup(config) {
    if (this.isSetup)
      return;
    const fullConfig = { ...this._defaultConfig, ...config };
    this.config.version = fullConfig.version;
    this.config.author = fullConfig.author;
    this.config.types = fullConfig.types;
    this.config.statuses = fullConfig.statuses;
    this.config.priorities = fullConfig.priorities;
    this.config.labels = fullConfig.labels;
    this.config.stages = fullConfig.stages;
    this.config.users = fullConfig.users;
    this.config.includeSelectionTag = fullConfig.includeSelectionTag;
    this.config.updateExtensionsOnImport = fullConfig.updateExtensionsOnImport;
    this.config.strict = fullConfig.strict;
    this.config.includeAllExtensionsOnExport = fullConfig.includeAllExtensionsOnExport;
    this.config.fallbackVersionOnImport = fullConfig.fallbackVersionOnImport || "";
    this.config.ignoreIncompleteTopicsOnImport = fullConfig.ignoreIncompleteTopicsOnImport;
    this.isSetup = true;
    this.enabled = true;
    this.onSetup.trigger();
  }
  /**
   * Creates a new BCFTopic instance and adds it to the list.
   *
   * @param data - Optional partial BCFTopic object to initialize the new topic with.
   * If not provided, default values will be used.
   * @returns The newly created BCFTopic instance.
   */
  create(data) {
    const topic = new Topic(this.components);
    if (data) {
      topic.guid = data.guid ?? topic.guid;
      topic.set(data);
    } else {
      this.list.set(topic.guid, topic);
    }
    return topic;
  }
  /**
   * Disposes of the BCFTopics component and triggers the onDisposed event.
   *
   * @remarks
   * This method clears the list of topics and triggers the onDisposed event.
   * It also resets the onDisposed event listener.
   */
  dispose() {
    this.list.dispose();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  /**
   * Retrieves the unique set of topic types used across all topics.
   *
   * @returns A Set containing the unique topic types.
   */
  get usedTypes() {
    const types = [...this.list].map(([_, topic]) => topic.type);
    return new Set(types);
  }
  /**
   * Retrieves the unique set of topic statuses used across all topics.
   *
   * @returns A Set containing the unique topic statuses.
   */
  get usedStatuses() {
    const statuses = [...this.list].map(([_, topic]) => topic.status);
    return new Set(statuses);
  }
  /**
   * Retrieves the unique set of topic priorities used across all topics.
   *
   * @returns A Set containing the unique topic priorities.
   * Note: This method filters out any null or undefined priorities.
   */
  get usedPriorities() {
    const priorities = [...this.list].map(([_, topic]) => topic.priority).filter((priority) => priority);
    return new Set(priorities);
  }
  /**
   * Retrieves the unique set of topic stages used across all topics.
   *
   * @returns A Set containing the unique topic stages.
   * Note: This method filters out any null or undefined stages.
   */
  get usedStages() {
    const stages = [...this.list].map(([_, topic]) => topic.stage).filter((stage) => stage);
    return new Set(stages);
  }
  /**
   * Retrieves the unique set of users associated with topics.
   *
   * @returns A Set containing the unique users.
   * Note: This method collects users from the creation author, assigned to, modified author, and comment authors.
   */
  get usedUsers() {
    const users = [];
    for (const [_, topic] of this.list) {
      users.push(topic.creationAuthor);
      if (topic.assignedTo)
        users.push(topic.assignedTo);
      if (topic.modifiedAuthor)
        users.push(topic.modifiedAuthor);
      for (const [_2, comment] of topic.comments) {
        users.push(comment.author);
        if (comment.modifiedAuthor)
          users.push(comment.modifiedAuthor);
      }
    }
    return new Set(users);
  }
  /**
   * Retrieves the unique set of labels used across all topics.
   *
   * @returns A Set containing the unique labels.
   */
  get usedLabels() {
    const labels = [];
    for (const [_, topic] of this.list)
      labels.push(...topic.labels);
    return new Set(labels);
  }
  /**
   * Updates the set of extensions (types, statuses, priorities, labels, stages, users) based on the current topics.
   * This method iterates through each topic in the list and adds its properties to the corresponding sets in the config.
   */
  updateExtensions() {
    for (const [_, topic] of this.list) {
      for (const label of topic.labels)
        this.config.labels.add(label);
      this.config.types.add(topic.type);
      if (topic.priority)
        this.config.priorities.add(topic.priority);
      if (topic.stage)
        this.config.stages.add(topic.stage);
      this.config.statuses.add(topic.status);
      this.config.users.add(topic.creationAuthor);
      if (topic.assignedTo)
        this.config.users.add(topic.assignedTo);
      if (topic.modifiedAuthor)
        this.config.users.add(topic.modifiedAuthor);
      for (const [_2, comment] of topic.comments) {
        this.config.users.add(comment.author);
        if (comment.modifiedAuthor)
          this.config.users.add(comment.modifiedAuthor);
      }
    }
  }
  /**
   * Updates the references to viewpoints in the topics.
   * This function iterates through each topic and checks if the viewpoints exist in the viewpoints list.
   * If a viewpoint does not exist, it is removed from the topic's viewpoints.
   */
  updateViewpointReferences() {
    const viewpoints = this.components.get(Viewpoints);
    for (const [_, topic] of this.list) {
      for (const viewpointID of topic.viewpoints) {
        const exists = viewpoints.list.has(viewpointID);
        if (!exists)
          topic.viewpoints.delete(viewpointID);
      }
    }
  }
  /**
   * Exports the given topics to a BCF (Building Collaboration Format) zip file.
   *
   * @param topics - The topics to export. Defaults to all topics in the list.
   * @returns A promise that resolves to a Blob containing the exported BCF zip file.
   */
  async export(topics = this.list.values()) {
    const zip = new JSZip();
    zip.file(
      "bcf.version",
      `<?xml version="1.0" encoding="UTF-8"?>
    <Version VersionId="${this.config.version}" xsi:noNamespaceSchemaLocation="https://raw.githubusercontent.com/buildingSMART/BCF-XML/release_3_0/Schemas/version.xsd"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    </Version>`
    );
    zip.file("bcf.extensions", this.serializeExtensions());
    const image = await fetch(
      "https://thatopen.github.io/engine_components/resources/favicon.ico"
    );
    const imgBlob = await image.arrayBuffer();
    const viewpoints = this.components.get(Viewpoints);
    for (const topic of topics) {
      const topicFolder = zip.folder(topic.guid);
      topicFolder.file("markup.bcf", topic.serialize());
      for (const viewpointID of topic.viewpoints) {
        const viewpoint = viewpoints.list.get(viewpointID);
        if (!viewpoint)
          continue;
        topicFolder.file(`${viewpointID}.jpeg`, imgBlob, {
          binary: true
        });
        topicFolder.file(`${viewpointID}.bcfv`, await viewpoint.serialize());
      }
    }
    const content = await zip.generateAsync({ type: "blob" });
    return content;
  }
  serializeExtensions() {
    const types = [...this.config.types].map((type) => `<TopicType>${type}</TopicType>`).join("\n");
    const statuses = [...this.config.statuses].map((status) => `<TopicStatus>${status}</TopicStatus>`).join("\n");
    const priorities = [...this.config.priorities].map((priority) => `<Priority>${priority}</Priority>`).join("\n");
    const labels = [...this.config.labels].map((label) => `<TopicLabel>${label}</TopicLabel>`).join("\n");
    const stages = [...this.config.stages].map((stage) => `<Stage>${stage}</Stage>`).join("\n");
    const users = [...this.config.users].map((user) => `<User>${user}</User>`).join("\n");
    return `
      <?xml version="1.0" encoding="UTF-8"?>
      <Extensions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="your-schema-location.xsd">
        ${types.length !== 0 ? `<TopicTypes>
${types}
</TopicTypes>` : ""}
        ${statuses.length !== 0 ? `<TopicStatuses>
${statuses}
</TopicStatuses>` : ""}
        ${priorities.length !== 0 ? `<Priorities>
${priorities}
</Priorities>` : ""}
        ${labels.length !== 0 ? `<TopicLabels>
${labels}
</TopicLabels>` : ""}
        ${stages.length !== 0 ? `<Stages>
${stages}
</Stages>` : ""}
        ${users.length !== 0 ? `<Users>
${users}
</Users>` : ""}
      </Extensions>
    `;
  }
  processMarkupComment(markupComment) {
    const {
      Guid,
      Date: CommentDate,
      Author,
      Comment: CommentText,
      Viewpoint: Viewpoint2
    } = markupComment;
    if (!(Guid && CommentDate && Author && Comment))
      return null;
    const viewpoints = this.components.get(Viewpoints);
    const comment = new Comment(this.components, CommentText ?? "");
    comment.guid = Guid;
    comment.date = new Date(CommentDate);
    comment.author = Author;
    comment.viewpoint = (Viewpoint2 == null ? void 0 : Viewpoint2.Guid) ? viewpoints.list.get(Viewpoint2.Guid) : void 0;
    comment.modifiedAuthor = markupComment.ModifiedAuthor;
    comment.modifiedDate = markupComment.ModifiedDate ? new Date(markupComment.ModifiedDate) : void 0;
    return comment;
  }
  getMarkupComments(markup, version) {
    var _a;
    let data;
    if (version === "2.1")
      data = markup.Comment;
    if (version === "3")
      data = (_a = markup.Topic.Comments) == null ? void 0 : _a.Comment;
    if (!data)
      return [];
    data = Array.isArray(data) ? data : [data];
    const comments = data.map((comment) => this.processMarkupComment(comment)).filter((comment) => comment);
    const array = Array.isArray(comments) ? comments : [comments];
    return array;
  }
  getMarkupLabels(markup, version) {
    var _a;
    let data;
    if (version === "2.1")
      data = markup.Topic.Labels;
    if (version === "3")
      data = (_a = markup.Topic.Labels) == null ? void 0 : _a.Label;
    if (!data)
      return [];
    const labels = Array.isArray(data) ? data : [data];
    return labels;
  }
  getMarkupViewpoints(markup, version) {
    var _a;
    let data;
    if (version === "2.1")
      data = markup.Viewpoints;
    if (version === "3")
      data = (_a = markup.Topic.Viewpoints) == null ? void 0 : _a.ViewPoint;
    if (!data)
      return [];
    data = Array.isArray(data) ? data : [data];
    return data;
  }
  getMarkupRelatedTopics(markup, version) {
    var _a;
    let data;
    if (version === "2.1")
      data = markup.Topic.RelatedTopic;
    if (version === "3")
      data = (_a = markup.Topic.RelatedTopics) == null ? void 0 : _a.RelatedTopic;
    if (!data)
      return [];
    const topics = Array.isArray(data) ? data : [data];
    return topics.map((topic) => topic.Guid);
  }
  /**
   * Loads BCF (Building Collaboration Format) data into the engine.
   *
   * @param world - The default world where the viewpoints are going to be created.
   * @param data - The BCF data to load.
   *
   * @returns A promise that resolves to an object containing the created viewpoints and topics.
   *
   * @throws An error if the BCF version is not supported.
   */
  async load(data, world) {
    var _a;
    const {
      fallbackVersionOnImport,
      ignoreIncompleteTopicsOnImport,
      updateExtensionsOnImport
    } = this.config;
    const zip = new JSZip();
    await zip.loadAsync(data);
    const files = Object.values(zip.files);
    let version = fallbackVersionOnImport;
    const versionFile = files.find((file) => file.name.endsWith(".version"));
    if (versionFile) {
      const versionXML = await versionFile.async("string");
      const bcfVersion = _BCFTopics2.xmlParser.parse(versionXML).Version.VersionId;
      version = String(bcfVersion);
    }
    if (!(version && (version === "2.1" || version === "3"))) {
      throw new Error(`BCFTopics: ${version} is not supported.`);
    }
    const extensionsFile = files.find(
      (file) => file.name.endsWith(".extensions")
    );
    if (updateExtensionsOnImport && extensionsFile) {
      const extensionsXML = await extensionsFile.async("string");
      extensionsImporter(this, extensionsXML);
    }
    const createdViewpoints = [];
    const viewpoints = this.components.get(Viewpoints);
    const viewpointFiles = files.filter((file) => file.name.endsWith(".bcfv"));
    for (const viewpointFile of viewpointFiles) {
      const xml = await viewpointFile.async("string");
      const visualizationInfo = _BCFTopics2.xmlParser.parse(xml).VisualizationInfo;
      if (!visualizationInfo) {
        console.warn("Missing VisualizationInfo in Viewpoint");
        continue;
      }
      const bcfViewpoint = {};
      const {
        Guid,
        ClippingPlanes,
        Components: Components2,
        OrthogonalCamera,
        PerspectiveCamera: PerspectiveCamera2
      } = visualizationInfo;
      if (Guid)
        bcfViewpoint.guid = Guid;
      if (Components2) {
        const { Selection, Visibility } = Components2;
        if (Selection && Selection.Component) {
          const components = Array.isArray(Selection.Component) ? Selection.Component : [Selection.Component];
          bcfViewpoint.selectionComponents = components.map((component) => component.IfcGuid).filter((guid) => guid);
        }
        if (Visibility && "DefaultVisibility" in Visibility) {
          bcfViewpoint.defaultVisibility = Visibility.DefaultVisibility;
        }
        if (Visibility && Visibility.Exceptions && "Component" in Visibility.Exceptions) {
          const { Component: Component2 } = Visibility.Exceptions;
          const components = Array.isArray(Component2) ? Component2 : [Component2];
          bcfViewpoint.exceptionComponents = components.map((component) => component.IfcGuid).filter((guid) => guid);
        }
        let ViewSetupHints;
        if (version === "2.1") {
          ViewSetupHints = Components2.ViewSetupHints;
        }
        if (version === "3") {
          ViewSetupHints = (_a = Components2.Visibility) == null ? void 0 : _a.ViewSetupHints;
        }
        if (ViewSetupHints) {
          if ("OpeningsVisible" in ViewSetupHints) {
            bcfViewpoint.openingsVisible = ViewSetupHints.OpeningsVisible;
          }
          if ("SpacesVisible" in ViewSetupHints) {
            bcfViewpoint.spacesVisible = ViewSetupHints.SpacesVisible;
          }
          if ("SpaceBoundariesVisible" in ViewSetupHints) {
            bcfViewpoint.spaceBoundariesVisible = ViewSetupHints.SpaceBoundariesVisible;
          }
        }
      }
      if (OrthogonalCamera || PerspectiveCamera2) {
        const camera = visualizationInfo.PerspectiveCamera ?? visualizationInfo.OrthogonalCamera;
        const { CameraViewPoint, CameraDirection } = camera;
        const position = new Vector3(
          Number(CameraViewPoint.X),
          Number(CameraViewPoint.Z),
          Number(-CameraViewPoint.Y)
        );
        const direction = new Vector3(
          Number(CameraDirection.X),
          Number(CameraDirection.Z),
          Number(-CameraDirection.Y)
        );
        const viewpointCamera = {
          position: { x: position.x, y: position.y, z: position.z },
          direction: { x: direction.x, y: direction.y, z: direction.z },
          aspectRatio: "AspectRatio" in camera ? camera.AspectRatio : 1
          // Temporal simplification
        };
        if ("ViewToWorldScale" in camera) {
          bcfViewpoint.camera = {
            ...viewpointCamera,
            viewToWorldScale: camera.ViewToWorldScale
          };
        }
        if ("FieldOfView" in camera) {
          bcfViewpoint.camera = {
            ...viewpointCamera,
            fov: camera.FieldOfView
          };
        }
      }
      const viewpoint = new Viewpoint(this.components, world, {
        data: bcfViewpoint,
        setCamera: false
      });
      if (Components2) {
        const { Coloring } = Components2;
        if (Coloring && Coloring.Color) {
          const colors = Array.isArray(Coloring.Color) ? Coloring.Color : [Coloring.Color];
          for (const colorData of colors) {
            const { Color: Color2, Component: Component2 } = colorData;
            const components = Array.isArray(Component2) ? Component2 : [Component2];
            const guids = components.map((component) => component.IfcGuid);
            viewpoint.componentColors.set(Color2, guids);
          }
        }
      }
      createdViewpoints.push(viewpoint);
      if (ClippingPlanes) {
        const clipper = this.components.get(Clipper);
        const planes = Array.isArray(ClippingPlanes.ClippingPlane) ? ClippingPlanes.ClippingPlane : [ClippingPlanes.ClippingPlane];
        for (const plane of planes) {
          const { Location, Direction } = plane;
          if (!(Location && Direction))
            continue;
          const location = new Vector3(
            Location.X,
            Location.Z,
            -Location.Y
          );
          const direction = new Vector3(
            Direction.X,
            -Direction.Z,
            Direction.Y
          );
          const clippingPlane = clipper.createFromNormalAndCoplanarPoint(
            world,
            direction,
            location
          );
          clippingPlane.visible = false;
          clippingPlane.enabled = false;
          viewpoint.clippingPlanes.add(clippingPlane);
        }
      }
    }
    const topicRelations = {};
    const topics = [];
    const markupFiles = files.filter((file) => file.name.endsWith(".bcf"));
    for (const markupFile of markupFiles) {
      const xml = await markupFile.async("string");
      const markup = _BCFTopics2.xmlParser.parse(xml).Markup;
      const markupTopic = markup.Topic;
      const {
        Guid,
        TopicType,
        TopicStatus,
        Title,
        CreationDate,
        CreationAuthor
      } = markupTopic;
      if (ignoreIncompleteTopicsOnImport) {
        if (!(Guid && TopicType && TopicStatus && Title && CreationDate && CreationAuthor))
          continue;
      }
      const topic = new Topic(this.components);
      topic.guid = Guid ?? topic.guid;
      const relatedTopics = this.getMarkupRelatedTopics(markup, version);
      topicRelations[topic.guid] = new Set(relatedTopics);
      topic.type = TopicType ?? topic.type;
      topic.status = TopicStatus ?? topic.status;
      topic.title = Title ?? topic.title;
      topic.creationDate = CreationDate ? new Date(CreationDate) : topic.creationDate;
      topic.creationAuthor = CreationAuthor ?? topic.creationAuthor;
      topic.serverAssignedId = markupTopic.ServerAssignedId;
      topic.priority = markupTopic.Priority;
      topic.index = markupTopic.Index;
      topic.modifiedDate = markupTopic.ModifiedDate ? new Date(markupTopic.ModifiedDate) : void 0;
      topic.modifiedAuthor = markupTopic.ModifiedAuthor;
      topic.dueDate = markupTopic.DueDate ? new Date(markupTopic.DueDate) : void 0;
      topic.assignedTo = markupTopic.AssignedTo;
      topic.description = markupTopic.Description;
      topic.stage = markupTopic.Stage;
      const labels = this.getMarkupLabels(markup, version);
      for (const label of labels)
        topic.labels.add(label);
      const comments = this.getMarkupComments(markup, version);
      for (const comment of comments)
        topic.comments.set(comment.guid, comment);
      const markupViewpoints = this.getMarkupViewpoints(markup, version);
      for (const markupViewpoint of markupViewpoints) {
        if (!(markupViewpoint && markupViewpoint.Guid))
          continue;
        const viewpoint = viewpoints.list.get(markupViewpoint.Guid);
        if (viewpoint)
          topic.viewpoints.add(viewpoint.guid);
      }
      this.list.set(topic.guid, topic);
      topics.push(topic);
    }
    for (const topicID in topicRelations) {
      const topic = this.list.get(topicID);
      if (!topic)
        continue;
      const relations = topicRelations[topicID];
      for (const guid of relations) {
        topic.relatedTopics.add(guid);
      }
    }
    this.onBCFImported.trigger(topics);
    return { viewpoints: createdViewpoints, topics };
  }
};
__publicField2(_BCFTopics, "uuid", "de977976-e4f6-4e4f-a01a-204727839802");
__publicField2(_BCFTopics, "xmlParser", new fxp.XMLParser({
  allowBooleanAttributes: true,
  attributeNamePrefix: "",
  ignoreAttributes: false,
  ignoreDeclaration: true,
  ignorePiTags: true,
  numberParseOptions: { leadingZeros: true, hex: true },
  parseAttributeValue: true,
  preserveOrder: false,
  processEntities: false,
  removeNSPrefix: true,
  trimValues: true
}));
var BCFTopics = _BCFTopics;
var _BoundingBoxer = class _BoundingBoxer2 extends Component {
  constructor(components) {
    super(components);
    __publicField2(this, "enabled", true);
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "_absoluteMin");
    __publicField2(this, "_absoluteMax");
    __publicField2(this, "_meshes", []);
    this.components.add(_BoundingBoxer2.uuid, this);
    this._absoluteMin = _BoundingBoxer2.newBound(true);
    this._absoluteMax = _BoundingBoxer2.newBound(false);
  }
  /**
   * A static method to calculate the dimensions of a given bounding box.
   *
   * @param bbox - The bounding box to calculate the dimensions for.
   * @returns An object containing the width, height, depth, and center of the bounding box.
   */
  static getDimensions(bbox) {
    const { min, max } = bbox;
    const width = Math.abs(max.x - min.x);
    const height = Math.abs(max.y - min.y);
    const depth = Math.abs(max.z - min.z);
    const center = new Vector3();
    center.subVectors(max, min).divideScalar(2).add(min);
    return { width, height, depth, center };
  }
  /**
   * A static method to create a new bounding box boundary.
   *
   * @param positive - A boolean indicating whether to create a boundary for positive or negative values.
   * @returns A new THREE.Vector3 representing the boundary.
   *
   * @remarks
   * This method is used to create a new boundary for calculating bounding boxes.
   * It sets the x, y, and z components of the returned vector to positive or negative infinity,
   * depending on the value of the `positive` parameter.
   *
   * @example
   * ```typescript
   * const positiveBound = BoundingBoxer.newBound(true);
   * console.log(positiveBound); // Output: Vector3 { x: Infinity, y: Infinity, z: Infinity }
   *
   * const negativeBound = BoundingBoxer.newBound(false);
   * console.log(negativeBound); // Output: Vector3 { x: -Infinity, y: -Infinity, z: -Infinity }
   * ```
   */
  static newBound(positive) {
    const factor = positive ? 1 : -1;
    return new Vector3(
      factor * Number.MAX_VALUE,
      factor * Number.MAX_VALUE,
      factor * Number.MAX_VALUE
    );
  }
  /**
   * A static method to calculate the bounding box of a set of points.
   *
   * @param points - An array of THREE.Vector3 representing the points.
   * @param min - An optional THREE.Vector3 representing the minimum bounds. If not provided, it will be calculated.
   * @param max - An optional THREE.Vector3 representing the maximum bounds. If not provided, it will be calculated.
   * @returns A THREE.Box3 representing the bounding box of the given points.
   *
   * @remarks
   * This method calculates the bounding box of a set of points by iterating through each point and updating the minimum and maximum bounds accordingly.
   * If the `min` or `max` parameters are provided, they will be used as the initial bounds. Otherwise, the initial bounds will be set to positive and negative infinity.
   *
   * @example
   * ```typescript
   * const points = [
   *   new THREE.Vector3(1, 2, 3),
   *   new THREE.Vector3(4, 5, 6),
   *   new THREE.Vector3(7, 8, 9),
   * ];
   *
   * const bbox = BoundingBoxer.getBounds(points);
   * console.log(bbox); // Output: Box3 { min: Vector3 { x: 1, y: 2, z: 3 }, max: Vector3 { x: 7, y: 8, z: 9 } }
   * ```
   */
  static getBounds(points, min, max) {
    const maxPoint = max || this.newBound(false);
    const minPoint = min || this.newBound(true);
    for (const point of points) {
      if (point.x < minPoint.x)
        minPoint.x = point.x;
      if (point.y < minPoint.y)
        minPoint.y = point.y;
      if (point.z < minPoint.z)
        minPoint.z = point.z;
      if (point.x > maxPoint.x)
        maxPoint.x = point.x;
      if (point.y > maxPoint.y)
        maxPoint.y = point.y;
      if (point.z > maxPoint.z)
        maxPoint.z = point.z;
    }
    return new Box3(min, max);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    const disposer = this.components.get(Disposer);
    for (const mesh of this._meshes) {
      disposer.destroy(mesh);
    }
    this._meshes = [];
    this.onDisposed.trigger(_BoundingBoxer2.uuid);
    this.onDisposed.reset();
  }
  /**
   * Returns the bounding box of the calculated fragments.
   *
   * @returns A new THREE.Box3 instance representing the bounding box.
   *
   * @remarks
   * This method clones the internal minimum and maximum vectors and returns a new THREE.Box3 instance.
   * The returned box represents the bounding box of the calculated fragments.
   *
   * @example
   * ```typescript
   * const boundingBox = boundingBoxer.get();
   * console.log(boundingBox); // Output: Box3 { min: Vector3 { x: -10, y: -10, z: -10 }, max: Vector3 { x: 10, y: 10, z: 10 } }
   * ```
   */
  get() {
    const min = this._absoluteMin.clone();
    const max = this._absoluteMax.clone();
    return new Box3(min, max);
  }
  /**
   * Calculates and returns a sphere that encompasses the entire bounding box.
   *
   * @returns A new THREE.Sphere instance representing the calculated sphere.
   *
   * @remarks
   * This method calculates the center and radius of a sphere that encompasses the entire bounding box.
   * The center is calculated as the midpoint between the minimum and maximum bounds of the bounding box.
   * The radius is calculated as the distance from the center to the minimum bound.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * const boundingSphere = boundingBoxer.getSphere();
   * console.log(boundingSphere); // Output: Sphere { center: Vector3 { x: 0, y: 0, z: 0 }, radius: 10 }
   * ```
   */
  getSphere() {
    const min = this._absoluteMin.clone();
    const max = this._absoluteMax.clone();
    const dx = Math.abs((max.x - min.x) / 2);
    const dy = Math.abs((max.y - min.y) / 2);
    const dz = Math.abs((max.z - min.z) / 2);
    const center = new Vector3(min.x + dx, min.y + dy, min.z + dz);
    const radius = center.distanceTo(min);
    return new Sphere(center, radius);
  }
  /**
   * Returns a THREE.Mesh instance representing the bounding box.
   *
   * @returns A new THREE.Mesh instance representing the bounding box.
   *
   * @remarks
   * This method calculates the dimensions of the bounding box using the `getDimensions` method.
   * It then creates a new THREE.BoxGeometry with the calculated dimensions.
   * A new THREE.Mesh is created using the box geometry, and it is added to the `_meshes` array.
   * The position of the mesh is set to the center of the bounding box.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * const boundingBoxMesh = boundingBoxer.getMesh();
   * scene.add(boundingBoxMesh);
   * ```
   */
  getMesh() {
    const bbox = new Box3(this._absoluteMin, this._absoluteMax);
    const dimensions = _BoundingBoxer2.getDimensions(bbox);
    const { width, height, depth, center } = dimensions;
    const box = new BoxGeometry(width, height, depth);
    const mesh = new Mesh(box);
    this._meshes.push(mesh);
    mesh.position.copy(center);
    return mesh;
  }
  /**
   * Resets the internal minimum and maximum vectors to positive and negative infinity, respectively.
   * This method is used to prepare the BoundingBoxer for a new set of fragments.
   *
   * @remarks
   * This method is called when a new set of fragments is added to the BoundingBoxer.
   * It ensures that the bounding box calculations are accurate and up-to-date.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * // ...
   * boundingBoxer.reset();
   * ```
   */
  reset() {
    this._absoluteMin = _BoundingBoxer2.newBound(true);
    this._absoluteMax = _BoundingBoxer2.newBound(false);
  }
  /**
   * Adds a FragmentsGroup to the BoundingBoxer.
   *
   * @param group - The FragmentsGroup to add.
   *
   * @remarks
   * This method iterates through each fragment in the provided FragmentsGroup,
   * and calls the `addMesh` method for each fragment's mesh.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.add(fragmentsGroup);
   * ```
   */
  add(group) {
    for (const frag of group.items) {
      this.addMesh(frag.mesh);
    }
  }
  /**
   * Adds a mesh to the BoundingBoxer and calculates the bounding box.
   *
   * @param mesh - The mesh to add. It can be an instance of THREE.InstancedMesh, THREE.Mesh, or FRAGS.CurveMesh.
   * @param itemIDs - An optional iterable of numbers representing the item IDs.
   *
   * @remarks
   * This method calculates the bounding box of the provided mesh and updates the internal minimum and maximum vectors.
   * If the mesh is an instance of THREE.InstancedMesh, it calculates the bounding box for each instance.
   * If the mesh is an instance of FRAGS.FragmentMesh and itemIDs are provided, it calculates the bounding box for the specified item IDs.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * boundingBoxer.addMesh(mesh);
   * ```
   */
  addMesh(mesh, itemIDs) {
    if (!mesh.geometry.index) {
      return;
    }
    const bbox = _BoundingBoxer2.getFragmentBounds(mesh);
    mesh.updateMatrixWorld();
    const meshTransform = mesh.matrixWorld;
    const instanceTransform = new Matrix4();
    const isInstanced = mesh instanceof InstancedMesh;
    const instances = /* @__PURE__ */ new Set();
    if (mesh instanceof FragmentMesh) {
      if (!itemIDs) {
        itemIDs = mesh.fragment.ids;
      }
      for (const itemID of itemIDs) {
        const ids = mesh.fragment.getInstancesIDs(itemID);
        if (!ids)
          continue;
        for (const id of ids) {
          instances.add(id);
        }
      }
    } else {
      instances.add(0);
    }
    for (const instance of instances) {
      const min = bbox.min.clone();
      const max = bbox.max.clone();
      if (isInstanced) {
        mesh.getMatrixAt(instance, instanceTransform);
        min.applyMatrix4(instanceTransform);
        max.applyMatrix4(instanceTransform);
      }
      min.applyMatrix4(meshTransform);
      max.applyMatrix4(meshTransform);
      if (min.x < this._absoluteMin.x)
        this._absoluteMin.x = min.x;
      if (min.y < this._absoluteMin.y)
        this._absoluteMin.y = min.y;
      if (min.z < this._absoluteMin.z)
        this._absoluteMin.z = min.z;
      if (min.x > this._absoluteMax.x)
        this._absoluteMax.x = min.x;
      if (min.y > this._absoluteMax.y)
        this._absoluteMax.y = min.y;
      if (min.z > this._absoluteMax.z)
        this._absoluteMax.z = min.z;
      if (max.x > this._absoluteMax.x)
        this._absoluteMax.x = max.x;
      if (max.y > this._absoluteMax.y)
        this._absoluteMax.y = max.y;
      if (max.z > this._absoluteMax.z)
        this._absoluteMax.z = max.z;
      if (max.x < this._absoluteMin.x)
        this._absoluteMin.x = max.x;
      if (max.y < this._absoluteMin.y)
        this._absoluteMin.y = max.y;
      if (max.z < this._absoluteMin.z)
        this._absoluteMin.z = max.z;
    }
  }
  /**
   * Uses a FragmentIdMap to add its meshes to the bb calculation.
   *
   * This method iterates through the provided `fragmentIdMap`, retrieves the corresponding fragment from the `FragmentsManager`,
   * and then calls the `addMesh` method for each fragment's mesh, passing the expression IDs as the second parameter.
   *
   * @param fragmentIdMap - A mapping of fragment IDs to their corresponding expression IDs.
   *
   * @remarks
   * This method is used to add a mapping of fragment IDs to their corresponding expression IDs.
   * It ensures that the bounding box calculations are accurate and up-to-date by updating the internal minimum and maximum vectors.
   *
   * @example
   * ```typescript
   * const boundingBoxer = components.get(BoundingBoxer);
   * const fragmentIdMap: FRAGS.FragmentIdMap = {
   *   '5991fa75-2eef-4825-90b3-85177f51a9c9': [123, 245, 389],
   *   '3469077e-39bf-4fc9-b3e6-4a1d78ad52b0': [454, 587, 612],
   * };
   * boundingBoxer.addFragmentIdMap(fragmentIdMap);
   * ```
   */
  addFragmentIdMap(fragmentIdMap) {
    const fragments = this.components.get(FragmentsManager);
    for (const fragmentID in fragmentIdMap) {
      const fragment = fragments.list.get(fragmentID);
      if (!fragment)
        continue;
      const expressIDs = fragmentIdMap[fragmentID];
      this.addMesh(fragment.mesh, expressIDs);
    }
  }
  static getFragmentBounds(mesh) {
    const position = mesh.geometry.attributes.position;
    const maxNum = Number.MAX_VALUE;
    const minNum = -maxNum;
    const min = new Vector3(maxNum, maxNum, maxNum);
    const max = new Vector3(minNum, minNum, minNum);
    if (!mesh.geometry.index) {
      throw new Error("Geometry must be indexed!");
    }
    const indices = Array.from(mesh.geometry.index.array);
    for (let i = 0; i < indices.length; i++) {
      if (i % 3 === 0) {
        if (indices[i] === 0 && indices[i + 1] === 0 && indices[i + 2] === 0) {
          i += 2;
          continue;
        }
      }
      const index = indices[i];
      const x = position.getX(index);
      const y = position.getY(index);
      const z = position.getZ(index);
      if (x < min.x)
        min.x = x;
      if (y < min.y)
        min.y = y;
      if (z < min.z)
        min.z = z;
      if (x > max.x)
        max.x = x;
      if (y > max.y)
        max.y = y;
      if (z > max.z)
        max.z = z;
    }
    return new Box3(min, max);
  }
};
__publicField2(_BoundingBoxer, "uuid", "d1444724-dba6-4cdd-a0c7-68ee1450d166");
var BoundingBoxer = _BoundingBoxer;
var _IfcIsolator = class _IfcIsolator2 extends Component {
  constructor(components) {
    super(components);
    __publicField2(this, "enabled", true);
    components.add(_IfcIsolator2.uuid, this);
  }
  async getIsolatedElements(webIfc, modelID, elementIDs) {
    const isolatedElementIDs = /* @__PURE__ */ new Set();
    function addElementAndReferences(elementID) {
      if (isolatedElementIDs.has(elementID))
        return;
      const element = webIfc.GetLine(modelID, elementID);
      if (!element)
        return;
      isolatedElementIDs.add(elementID);
      for (const prop in element) {
        const value = element[prop];
        if (value && value.constructor.name === "Handle" && value.value > 0) {
          addElementAndReferences(value.value);
        } else if (Array.isArray(value)) {
          value.forEach((refID) => {
            if (refID && refID.constructor.name === "Handle" && refID.value > 0) {
              addElementAndReferences(refID.value);
            }
          });
        }
      }
    }
    for (const elementID of elementIDs) {
      addElementAndReferences(elementID);
    }
    const arr = [];
    for (const elementID of isolatedElementIDs) {
      arr.push(elementID);
    }
    arr.sort((a, b) => {
      return a - b;
    });
    const isolatedElements = [];
    arr.forEach((elementID) => {
      const element = webIfc.GetLine(modelID, elementID);
      isolatedElements.push(element);
    });
    return isolatedElements;
  }
  /**
   * Exports isolated elements to the new model.
   * @param webIfc The instance of [web-ifc](https://github.com/ThatOpen/engine_web-ifc) to use.
   * @param modelID ID of the new IFC model.
   * @param isolatedElements The array of isolated elements
   */
  async export(webIfc, modelID, isolatedElements) {
    isolatedElements.forEach((element) => {
      webIfc.WriteLine(modelID, element);
    });
    const data = webIfc.SaveModel(modelID);
    return data;
  }
  async splitIfc(webIfc, ifcFile, idsToExtract) {
    const ifcBuffer = new Uint8Array(ifcFile);
    const modelID = webIfc.OpenModel(ifcBuffer);
    const isolated = await this.getIsolatedElements(
      webIfc,
      modelID,
      idsToExtract
    );
    const newModelID = webIfc.CreateModel({ schema: Schemas.IFC2X3 });
    const data = await this.export(webIfc, newModelID, isolated);
    return data;
  }
};
__publicField2(_IfcIsolator, "uuid", "6eb0ba2f-71c0-464e-bcec-2d7c335186b2");
var IfcIsolator = _IfcIsolator;
var _IfcFinderQuery = class _IfcFinderQuery2 {
  constructor(components) {
    __publicField2(this, "onProgress", new Event());
    __publicField2(this, "inclusive", false);
    __publicField2(this, "rules", []);
    __publicField2(this, "ids", {});
    __publicField2(this, "needsUpdate", /* @__PURE__ */ new Map());
    __publicField2(this, "components");
    this.components = components;
  }
  /**
   * Imports a query given its data. This data can be generating using its {@link IfcFinderQuery.export} method.
   *
   * @param components the instance of {@link Components} used by this app.
   * @param data the data of the query to import as a serializable object.
   */
  static import(components, data) {
    const newQuery = _IfcFinderQuery2.importers.get(data.type);
    if (!newQuery) {
      console.warn(`Invalid query data:.`, data);
      return null;
    }
    return newQuery(components, data);
  }
  /**
   * Imports the given serialized rules. Only use this when writing your own custom query. See the other queries provided by the library for reference.
   *
   * @param serializedRules the rules to be parsed.
   */
  static importRules(serializedRules) {
    const rules = [];
    for (const serializedRule of serializedRules) {
      const rule = {};
      for (const id in serializedRule) {
        const item = serializedRule[id];
        if (item.regexp) {
          rule[id] = new RegExp(item.value);
        } else {
          rule[id] = item;
        }
      }
      rules.push(rule);
    }
    return rules;
  }
  /**
   * Imports the given IDs. Only use this when writing your own custom query. See the other queries provided by the library for reference.
   *
   * @param data the serialized object representing the query whose IDs to parse.
   */
  static importIds(data) {
    const ids = {};
    for (const modelID in data.ids) {
      ids[modelID] = new Set(data.ids[modelID]);
    }
    return ids;
  }
  /**
   * Clears the data of the given model. If not specified, clears all the data.
   *
   * @param modelID ID of the model whose data to clear.
   */
  clear(modelID) {
    if (modelID === void 0) {
      this.ids = {};
      this.needsUpdate.clear();
      return;
    }
    delete this.ids[modelID];
    this.needsUpdate.delete(modelID);
  }
  addID(modelID, id) {
    if (!this.ids[modelID]) {
      this.ids[modelID] = /* @__PURE__ */ new Set();
    }
    this.ids[modelID].add(id);
  }
  getData() {
    const ids = {};
    for (const modelID in this.ids) {
      ids[modelID] = Array.from(this.ids[modelID]);
    }
    const rules = this.exportRules();
    return {
      name: this.name,
      inclusive: this.inclusive,
      type: "IfcFinderQuery",
      ids,
      rules
    };
  }
  exportRules() {
    const rules = [];
    for (const rule of this.rules) {
      const serializedRule = {};
      for (const id in rule) {
        const item = rule[id];
        if (item instanceof RegExp) {
          serializedRule[id] = { regexp: true, value: item.source };
        } else {
          serializedRule[id] = item;
        }
      }
      rules.push(serializedRule);
    }
    return rules;
  }
  findInFile(modelID, file) {
    return new Promise((resolve) => {
      const reader = new FileReader();
      const decoder = new TextDecoder("utf-8");
      const chunkSize = 1e4 * 1024;
      const offset = 1e3;
      let start = 0;
      const endLineToken = /;/;
      const readTextPart = () => {
        if (start >= file.size) {
          resolve();
          return;
        }
        const end = Math.min(start + chunkSize + offset, file.size);
        const slice = file.slice(start, end);
        reader.readAsArrayBuffer(slice);
      };
      reader.onload = () => {
        if (!(reader.result instanceof ArrayBuffer)) {
          return;
        }
        const buffer = new Uint8Array(reader.result);
        const snippet = decoder.decode(buffer);
        const lines = snippet.split(endLineToken);
        lines.shift();
        this.findInLines(modelID, lines);
        this.onProgress.trigger(start / file.size);
        start += chunkSize;
        readTextPart();
      };
      readTextPart();
    });
  }
  getIdFromLine(line) {
    const idString = line.slice(line.indexOf("#") + 1, line.indexOf("="));
    return parseInt(idString, 10);
  }
  testRules(line) {
    let category = null;
    let attrValues = null;
    let attrNames = null;
    let filtersPass = false;
    for (const rule of this.rules) {
      if (rule.type === "category") {
        if (category === null) {
          category = this.getCategoryFromLine(line);
          if (category === null) {
            if (!this.inclusive) {
              break;
            } else {
              continue;
            }
          }
        }
        if (!rule.value.test(category)) {
          if (!this.inclusive) {
            filtersPass = false;
            break;
          } else {
            continue;
          }
        }
        filtersPass = true;
        continue;
      }
      if (attrValues === null) {
        attrValues = this.getAttributesFromLine(line);
        if (attrValues === null) {
          if (!this.inclusive) {
            filtersPass = false;
            break;
          } else {
            continue;
          }
        }
      }
      if (category === null) {
        category = this.getCategoryFromLine(line);
        if (category === null) {
          if (!this.inclusive) {
            filtersPass = false;
            break;
          } else {
            continue;
          }
        }
      }
      if (attrNames === null) {
        attrNames = Object.keys(new IFC4[category]());
        attrNames = attrNames.slice(2);
        if (attrNames === null) {
          if (!this.inclusive) {
            filtersPass = false;
            break;
          } else {
            continue;
          }
        }
      }
      if (rule.type === "property") {
        const { name, value } = rule;
        if (!value.test(line)) {
          if (!this.inclusive) {
            filtersPass = false;
            break;
          } else {
            continue;
          }
        }
        let someNameValueMatch = false;
        for (let i = 0; i < attrValues.length; i++) {
          const attrValue = attrValues[i];
          const attrName = attrNames[i];
          if (value.test(attrValue) && name.test(attrName)) {
            someNameValueMatch = true;
            break;
          }
        }
        if (!someNameValueMatch) {
          if (!this.inclusive) {
            filtersPass = false;
            break;
          }
        } else {
          filtersPass = true;
        }
      }
      if (rule.type === "operator") {
        const { name, value, operator } = rule;
        let someNameValueMatch = false;
        for (let i = 0; i < attrValues.length; i++) {
          const attrName = attrNames[i];
          const attrValue = attrValues[i].replace(
            /IFCLENGTHMEASURE\(|IFCVOLUMEMEASURE\(|\)/g,
            ""
          );
          if (name.test(attrName)) {
            if (operator === "=" && parseFloat(attrValue) === value) {
              someNameValueMatch = true;
              break;
            } else if (operator === "<" && parseFloat(attrValue) < value) {
              someNameValueMatch = true;
              break;
            } else if (operator === ">" && parseFloat(attrValue) > value) {
              someNameValueMatch = true;
              break;
            } else if (operator === ">=" && parseFloat(attrValue) >= value) {
              someNameValueMatch = true;
              break;
            } else if (operator === "<=" && parseFloat(attrValue) <= value) {
              someNameValueMatch = true;
              break;
            }
          }
        }
        if (!someNameValueMatch) {
          if (!this.inclusive) {
            filtersPass = false;
            break;
          }
        } else {
          filtersPass = true;
        }
      }
    }
    return filtersPass;
  }
  getCategoryFromLine(line) {
    const start = line.indexOf("=") + 1;
    const end = line.indexOf("(");
    const category = line.slice(start, end).trim();
    const name = ifcCategoryCase[category];
    if (!name) {
      return null;
    }
    return name;
  }
  getAttributesFromLine(line) {
    const matchRegex = /\((.*)\)/;
    const match = line.match(matchRegex);
    if (!(match && match[1])) {
      return null;
    }
    const splitRegex = /,(?![^()]*\))/g;
    const attrs = match[1].split(splitRegex).map((part) => part.trim());
    return attrs;
  }
};
__publicField2(_IfcFinderQuery, "importers", /* @__PURE__ */ new Map());
var IfcFinderQuery = _IfcFinderQuery;
var IfcQueryGroup = class {
  constructor(components) {
    __publicField2(this, "list", /* @__PURE__ */ new Map());
    __publicField2(this, "id", MathUtils.generateUUID());
    __publicField2(this, "mode", "intersect");
    __publicField2(this, "_components");
    this._components = components;
  }
  /**
   * The list of unique queries contained in this group.
   */
  get queries() {
    return new Set(this.list.values());
  }
  /**
   * The items of all the queries contained in this group. The returned data depends on {@link IfcQueryGroup.mode}.
   */
  get items() {
    const maps = [];
    for (const query of this.queries) {
      maps.push(query.items);
    }
    if (this.mode === "combine") {
      return FragmentUtils.combine(maps);
    }
    return FragmentUtils.intersect(maps);
  }
  /**
   * Adds a new query to this group.
   * @param query the query to add.
   */
  add(query) {
    if (this.list.has(query.name)) {
      throw new Error(
        `This group already has a query with the name ${query.name}.`
      );
    }
    this.list.set(query.name, query);
  }
  /**
   * Clears the data of the given modelID of all queries contained in this group. If no modelID is provided, clears all data.
   * @param modelID the model whose data to remove.
   */
  clear(modelID) {
    for (const query of this.queries) {
      query.clear(modelID);
    }
  }
  /**
   * Imports data that has been previously exported through {@link IfcQueryGroup.export}.
   * @param data the serializable object used to persist a group's data.
   */
  import(data) {
    this.mode = data.mode;
    this.id = data.id;
    for (const id in data.queries) {
      const query = IfcFinderQuery.import(this._components, data.queries[id]);
      if (query) {
        this.list.set(id, query);
      }
    }
  }
  /**
   * Exports all the data of this group, so that it can be persisted and imported later using {@link IfcQueryGroup.import}.
   */
  export() {
    const queries = {};
    for (const [id, query] of this.list) {
      queries[id] = query.export();
    }
    return {
      mode: this.mode,
      id: this.id,
      queries
    };
  }
  /**
   * Updates all the queries contained in this group that need an update for the given file. It will skip those where {@link IfcFinderQuery.needsUpdate} is false.
   * @param modelID the identifier used to refer to the given file.
   * @param file the file to process.
   */
  async update(modelID, file) {
    for (const query of this.queries) {
      const needsUpdate = query.needsUpdate.get(modelID);
      if (needsUpdate === void 0 || needsUpdate) {
        await query.update(modelID, file);
      }
    }
  }
};
var _IfcBasicQuery = class _IfcBasicQuery2 extends IfcFinderQuery {
  constructor(components, data) {
    super(components);
    __publicField2(this, "name");
    this.name = data.name;
    this.rules = data.rules;
    this.inclusive = data.inclusive;
  }
  /**
   * {@link IfcFinderQuery.items}
   */
  get items() {
    const fragments = this.components.get(FragmentsManager);
    const maps = [];
    for (const modelID in this.ids) {
      const ids = this.ids[modelID];
      const found = fragments.groups.get(modelID);
      if (!found) {
        console.warn(`Model ${modelID} not found!`);
        continue;
      }
      const map = found.getFragmentMap(ids);
      maps.push(map);
    }
    return FragmentUtils.combine(maps);
  }
  /**
   * {@link IfcFinderQuery.export}
   */
  export() {
    const data = this.getData();
    data.type = _IfcBasicQuery2.type;
    return data;
  }
  /**
   * {@link IfcFinderQuery.update}
   */
  async update(modelID, file) {
    this.ids[modelID] = /* @__PURE__ */ new Set();
    await this.findInFile(modelID, file);
    this.needsUpdate.set(modelID, false);
  }
  findInLines(modelID, lines) {
    for (const line of lines) {
      const filtersPass = this.testRules(line);
      if (filtersPass) {
        const id = this.getIdFromLine(line);
        this.addID(modelID, id);
      }
    }
  }
};
__publicField2(_IfcBasicQuery, "type", "IfcBasicQuery");
var IfcBasicQuery = _IfcBasicQuery;
IfcFinderQuery.importers.set(
  IfcBasicQuery.type,
  (components, data) => {
    const query = new IfcBasicQuery(components, {
      name: data.name,
      rules: IfcFinderQuery.importRules(data.rules),
      inclusive: data.inclusive
    });
    query.ids = IfcFinderQuery.importIds(data);
    return query;
  }
);
var _IfcPropertyQuery = class _IfcPropertyQuery2 extends IfcFinderQuery {
  constructor(components, data) {
    super(components);
    __publicField2(this, "name");
    __publicField2(this, "psets", []);
    this.name = data.name;
    this.rules = data.rules;
    this.inclusive = data.inclusive;
  }
  /**
   * {@link IfcFinderQuery.items}
   */
  get items() {
    const indexer = this.components.get(IfcRelationsIndexer);
    const fragments = this.components.get(FragmentsManager);
    const maps = [];
    for (const modelID in this.ids) {
      const model = fragments.groups.get(modelID);
      if (!model) {
        console.log(`Model not found: ${modelID}.`);
        continue;
      }
      const ids = this.ids[modelID];
      for (const id of ids) {
        const elements = indexer.getEntityRelations(
          modelID,
          id,
          "DefinesOcurrence"
        );
        if (elements) {
          const map = model.getFragmentMap(elements);
          maps.push(map);
        }
      }
    }
    return FragmentUtils.combine(maps);
  }
  /**
   * {@link IfcFinderQuery.export}
   */
  export() {
    const data = this.getData();
    data.type = _IfcPropertyQuery2.type;
    return data;
  }
  /**
   * {@link IfcFinderQuery.update}
   */
  async update(modelID, file) {
    await this.findInFile(modelID, file);
    const psetIDs = /* @__PURE__ */ new Set();
    for (const pset of this.psets) {
      const attrs = this.getAttributesFromLine(pset);
      if (attrs === null) {
        continue;
      }
      const idsString = attrs[4].replace("(", "[").replace(")", "]").replace(/#/g, "");
      const containedPropertySingleValues = JSON.parse(idsString);
      for (const id of containedPropertySingleValues) {
        const ids = this.ids[modelID];
        if (ids && ids.has(id)) {
          const psetID = this.getIdFromLine(pset);
          psetIDs.add(psetID);
          break;
        }
      }
    }
    this.ids[modelID] = psetIDs;
    this.psets = [];
    this.needsUpdate.set(modelID, false);
  }
  findInLines(modelID, lines) {
    for (const line of lines) {
      const category = this.getCategoryFromLine(line);
      if (category === "IfcPropertySet") {
        this.psets.push(line);
        continue;
      }
      if (category !== "IfcPropertySingleValue") {
        continue;
      }
      const filtersPass = this.testRules(line);
      if (filtersPass) {
        const id = this.getIdFromLine(line);
        this.addID(modelID, id);
      }
    }
  }
};
__publicField2(_IfcPropertyQuery, "type", "IfcPropertyQuery");
var IfcPropertyQuery = _IfcPropertyQuery;
IfcFinderQuery.importers.set(
  IfcPropertyQuery.type,
  (components, data) => {
    const query = new IfcPropertyQuery(components, {
      name: data.name,
      inclusive: data.inclusive,
      rules: IfcFinderQuery.importRules(data.rules)
    });
    query.ids = IfcFinderQuery.importIds(data);
    return query;
  }
);
var _IfcFinder = class _IfcFinder2 extends Component {
  constructor(components) {
    super(components);
    __publicField2(this, "enabled", true);
    __publicField2(this, "list", /* @__PURE__ */ new Map());
    components.add(_IfcFinder2.uuid, this);
  }
  /**
   * List of all queries from all created {@link IfcQueryGroup} instances.
   */
  get queries() {
    const queries = /* @__PURE__ */ new Set();
    for (const [, group] of this.list) {
      for (const query of group.queries) {
        queries.add(query);
      }
    }
    return queries;
  }
  /**
   * Imports all the query groups provided in the given data. You can generate this data to save the result of queries and persist it over time.
   * @param data The data containing the serialized query groups to import.
   */
  import(data) {
    for (const id in data) {
      const group = new IfcQueryGroup(this.components);
      group.import(data[id]);
      this.list.set(id, group);
    }
  }
  /**
   * Exports all the query groups created. You can then import this data back using the import method.
   */
  export() {
    const result = {};
    for (const [id, group] of this.list) {
      result[id] = group.export();
    }
    return result;
  }
  /**
   * Creates a new {@link IfcQueryGroup}.
   */
  create() {
    const group = new IfcQueryGroup(this.components);
    this.list.set(group.id, group);
    return group;
  }
  /**
   * Creates the {@link IfcQueryGroup} with the given ID.
   */
  delete(id) {
    this.list.delete(id);
  }
  /**
   * Deletes all {@link IfcQueryGroup} instances.
   */
  clear() {
    this.list.clear();
  }
};
__publicField2(_IfcFinder, "uuid", "0da7ad77-f734-42ca-942f-a074adfd1e3a");
var IfcFinder = _IfcFinder;
var _Classifier = class _Classifier2 extends Component {
  constructor(components) {
    super(components);
    __publicField2(this, "enabled", true);
    __publicField2(this, "list", {});
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "onFragmentsDisposed", (data) => {
      const { groupID, fragmentIDs } = data;
      for (const systemName in this.list) {
        const system = this.list[systemName];
        const groupNames = Object.keys(system);
        if (groupNames.includes(groupID)) {
          delete system[groupID];
          if (Object.values(system).length === 0) {
            delete this.list[systemName];
          }
        } else {
          for (const groupName of groupNames) {
            const group = system[groupName];
            for (const fragmentID of fragmentIDs) {
              delete group.map[fragmentID];
            }
            if (Object.values(group).length === 0) {
              delete system[groupName];
            }
          }
        }
      }
    });
    components.add(_Classifier2.uuid, this);
    const fragmentManager = components.get(FragmentsManager);
    fragmentManager.onFragmentsDisposed.add(this.onFragmentsDisposed);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.list = {};
    const fragmentManager = this.components.get(FragmentsManager);
    fragmentManager.onFragmentsDisposed.remove(this.onFragmentsDisposed);
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  /**
   * Removes a fragment from the classification based on its unique identifier (guid).
   * This method iterates through all classification systems and classes, and deletes the fragment with the specified guid from the respective group.
   *
   * @param guid - The unique identifier of the fragment to be removed.
   */
  remove(guid) {
    for (const systemName in this.list) {
      const system = this.list[systemName];
      for (const groupName in system) {
        const group = system[groupName];
        delete group.map[guid];
      }
    }
  }
  /**
   * Finds and returns fragments based on the provided filter criteria.
   * If no filter is provided, it returns all fragments.
   *
   * @param filter - An optional object containing filter criteria.
   * The keys of the object represent the classification system names,
   * and the values are arrays of class names to match.
   *
   * @returns A map of fragment GUIDs to their respective express IDs,
   * where the express IDs are filtered based on the provided filter criteria.
   *
   * @throws Will throw an error if the fragments map is malformed.
   */
  find(filter) {
    const fragments = this.components.get(FragmentsManager);
    if (!filter) {
      const result2 = {};
      for (const [id, fragment] of fragments.list) {
        result2[id] = new Set(fragment.ids);
      }
      return result2;
    }
    const filterCount = Object.keys(filter).length;
    const models = {};
    for (const name in filter) {
      const values = filter[name];
      if (!this.list[name]) {
        console.warn(`Classification ${name} does not exist.`);
        continue;
      }
      for (const value of values) {
        const found = this.list[name][value];
        if (found) {
          for (const guid in found.map) {
            if (!models[guid]) {
              models[guid] = /* @__PURE__ */ new Map();
            }
            for (const id of found.map[guid]) {
              const matchCount = models[guid].get(id);
              if (matchCount === void 0) {
                models[guid].set(id, 1);
              } else {
                models[guid].set(id, matchCount + 1);
              }
            }
          }
        }
      }
    }
    const result = {};
    for (const guid in models) {
      const model = models[guid];
      for (const [id, numberOfMatches] of model) {
        if (numberOfMatches === void 0) {
          throw new Error("Malformed fragments map!");
        }
        if (numberOfMatches === filterCount) {
          if (!result[guid]) {
            result[guid] = /* @__PURE__ */ new Set();
          }
          result[guid].add(id);
        }
      }
    }
    return result;
  }
  /**
   * Classifies fragments based on their modelID.
   *
   * @param modelID - The unique identifier of the model to classify fragments by.
   * @param group - The FragmentsGroup containing the fragments to be classified.
   *
   * @remarks
   * This method iterates through the fragments in the provided group,
   * and classifies them based on their modelID.
   * The classification is stored in the `list.models` property,
   * with the modelID as the key and a map of fragment IDs to their respective express IDs as the value.
   *
   */
  byModel(modelID, group) {
    if (!this.list.models) {
      this.list.models = {};
    }
    const modelsClassification = this.list.models;
    if (!modelsClassification[modelID]) {
      modelsClassification[modelID] = { map: {}, id: null, name: modelID };
    }
    const currentModel = modelsClassification[modelID];
    for (const [expressID, data] of group.data) {
      const keys = data[0];
      for (const key of keys) {
        const fragID = group.keyFragments.get(key);
        if (!fragID)
          continue;
        if (!currentModel.map[fragID]) {
          currentModel.map[fragID] = /* @__PURE__ */ new Set();
        }
        currentModel.map[fragID].add(expressID);
      }
    }
  }
  /**
   * Classifies fragments based on their PredefinedType property.
   *
   * @param group - The FragmentsGroup containing the fragments to be classified.
   *
   * @remarks
   * This method iterates through the properties of the fragments in the provided group,
   * and classifies them based on their PredefinedType property.
   * The classification is stored in the `list.predefinedTypes` property,
   * with the PredefinedType as the key and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found.
   */
  async byPredefinedType(group) {
    var _a;
    if (!this.list.predefinedTypes) {
      this.list.predefinedTypes = {};
    }
    const currentTypes = this.list.predefinedTypes;
    const ids = group.getAllPropertiesIDs();
    for (const id of ids) {
      const entity = await group.getProperties(id);
      if (!entity)
        continue;
      const predefinedType = String((_a = entity.PredefinedType) == null ? void 0 : _a.value).toUpperCase();
      if (!currentTypes[predefinedType]) {
        currentTypes[predefinedType] = {
          map: {},
          id: null,
          name: predefinedType
        };
      }
      const currentType = currentTypes[predefinedType];
      for (const [_expressID, data] of group.data) {
        const keys = data[0];
        for (const key of keys) {
          const fragmentID = group.keyFragments.get(key);
          if (!fragmentID) {
            throw new Error("Fragment ID not found!");
          }
          if (!currentType.map[fragmentID]) {
            currentType.map[fragmentID] = /* @__PURE__ */ new Set();
          }
          const currentFragment = currentType.map[fragmentID];
          currentFragment.add(entity.expressID);
        }
      }
    }
  }
  /**
   * Classifies fragments based on their entity type.
   *
   * @param group - The FragmentsGroup containing the fragments to be classified.
   *
   * @remarks
   * This method iterates through the relations of the fragments in the provided group,
   * and classifies them based on their entity type.
   * The classification is stored in the `list.entities` property,
   * with the entity type as the key and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found.
   */
  byEntity(group) {
    if (!this.list.entities) {
      this.list.entities = {};
    }
    for (const [expressID, data] of group.data) {
      const rels = data[1];
      const type = rels[1];
      const entity = IfcCategoryMap[type];
      this.saveItem(group, "entities", entity, expressID);
    }
  }
  /**
   * Classifies fragments based on a specific IFC relationship.
   *
   * @param group - The FragmentsGroup containing the fragments to be classified.
   * @param ifcRel - The IFC relationship number to classify fragments by.
   * @param systemName - The name of the classification system to store the classification.
   *
   * @remarks
   * This method iterates through the relations of the fragments in the provided group,
   * and classifies them based on the specified IFC relationship.
   * The classification is stored in the `list` property under the specified system name,
   * with the relationship name as the class name and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found or if the IFC relationship is not valid.
   */
  async byIfcRel(group, ifcRel, systemName) {
    if (!IfcPropertiesUtils.isRel(ifcRel))
      return;
    await IfcPropertiesUtils.getRelationMap(
      group,
      ifcRel,
      async (relatingID, relatedIDs) => {
        const { name: relatingName } = await IfcPropertiesUtils.getEntityName(
          group,
          relatingID
        );
        for (const expressID of relatedIDs) {
          this.saveItem(
            group,
            systemName,
            relatingName ?? "NO REL NAME",
            expressID
          );
        }
      }
    );
  }
  /**
   * Classifies fragments based on their spatial structure in the IFC model.
   *
   * @param model - The FragmentsGroup containing the fragments to be classified.
   * @param config - The configuration for the classifier. It includes "useProperties", which is true by default
   * (if false, the classification will use the expressIDs instead of the names), and "isolate", which will make
   * the classifier just pick the WEBIFC categories provided.
   *
   * @remarks
   * This method iterates through the relations of the fragments in the provided group,
   * and classifies them based on their spatial structure in the IFC model.
   * The classification is stored in the `list` property under the system name "spatialStructures",
   * with the relationship name as the class name and a map of fragment IDs to their respective express IDs as the value.
   *
   * @throws Will throw an error if the fragment ID is not found or if the model relations do not exist.
   */
  async bySpatialStructure(model, config = {}) {
    var _a, _b;
    const indexer = this.components.get(IfcRelationsIndexer);
    const modelRelations = indexer.relationMaps[model.uuid];
    if (!modelRelations) {
      throw new Error(
        `Classifier: model relations of ${model.name || model.uuid} have to exists to group by spatial structure.`
      );
    }
    const systemName = config.systemName ?? "spatialStructures";
    const noProps = config.useProperties === void 0;
    const useProperties = noProps || config.useProperties;
    for (const [expressID] of modelRelations) {
      if (config.isolate) {
        const data = model.data.get(expressID);
        if (!data)
          continue;
        const category = data[1][1];
        if (category === void 0 || !config.isolate.has(category)) {
          continue;
        }
      }
      const spatialRels = indexer.getEntityRelations(
        model,
        expressID,
        "Decomposes"
      );
      if (spatialRels) {
        for (const id of spatialRels) {
          let relName2 = id.toString();
          if (useProperties) {
            const spatialRelAttrs = await model.getProperties(id);
            if (!spatialRelAttrs) {
              continue;
            }
            relName2 = (_a = spatialRelAttrs.Name) == null ? void 0 : _a.value;
          }
          this.saveItem(model, systemName, relName2, expressID, id);
        }
      }
      const rels = indexer.getEntityRelations(
        model,
        expressID,
        "ContainsElements"
      );
      if (!rels) {
        continue;
      }
      let relName = expressID.toString();
      if (useProperties) {
        const relAttrs = await model.getProperties(expressID);
        if (!relAttrs) {
          continue;
        }
        relName = (_b = relAttrs.Name) == null ? void 0 : _b.value;
      }
      for (const id of rels) {
        this.saveItem(model, systemName, relName, id, expressID);
        const decompositionRelations = indexer.getEntityRelations(
          model,
          Number(id),
          "IsDecomposedBy"
        );
        if (!decompositionRelations) {
          continue;
        }
        for (const decomposedID of decompositionRelations) {
          this.saveItem(model, systemName, relName, decomposedID, expressID);
        }
      }
    }
  }
  /**
   * Sets the color of the specified fragments.
   *
   * @param items - A map of fragment IDs to their respective express IDs.
   * @param color - The color to set for the fragments.
   * @param override - A boolean indicating whether to override the existing color of the fragments.
   *
   * @remarks
   * This method iterates through the provided fragment IDs, retrieves the corresponding fragments,
   * and sets their color using the `setColor` method of the FragmentsGroup class.
   *
   * @throws Will throw an error if the fragment with the specified ID is not found.
   */
  setColor(items, color, override = false) {
    const fragments = this.components.get(FragmentsManager);
    for (const fragID in items) {
      const found = fragments.list.get(fragID);
      if (!found)
        continue;
      const ids = items[fragID];
      found.setColor(color, ids, override);
    }
  }
  /**
   * Resets the color of the specified fragments to their original color.
   *
   * @param items - A map of fragment IDs to their respective express IDs.
   *
   * @remarks
   * This method iterates through the provided fragment IDs, retrieves the corresponding fragments,
   * and resets their color using the `resetColor` method of the FragmentsGroup class.
   *
   * @throws Will throw an error if the fragment with the specified ID is not found.
   */
  resetColor(items) {
    const fragments = this.components.get(FragmentsManager);
    for (const fragID in items) {
      const found = fragments.list.get(fragID);
      if (!found)
        continue;
      const ids = items[fragID];
      found.resetColor(ids);
    }
  }
  /**
   * Exports the computed classification to persists them and import them back
   * later for faster loading.
   */
  export() {
    const exported = {};
    for (const systemName in this.list) {
      exported[systemName] = {};
      const system = this.list[systemName];
      for (const groupName in system) {
        const group = system[groupName];
        exported[systemName][groupName] = {
          map: FragmentUtils.export(group.map),
          name: group.name,
          id: group.id
        };
      }
    }
    return exported;
  }
  /**
   * Imports a classification previously exported with .export().
   * @param data the serialized classification to import.
   */
  import(data) {
    for (const systemName in data) {
      if (!this.list[systemName]) {
        this.list[systemName] = {};
      }
      const system = data[systemName];
      for (const groupName in system) {
        const group = system[groupName];
        this.list[systemName][groupName] = {
          map: FragmentUtils.import(group.map),
          name: group.name,
          id: group.id
        };
      }
    }
  }
  saveItem(group, systemName, className, expressID, parentID = null) {
    if (!this.list[systemName]) {
      this.list[systemName] = {};
    }
    const keys = group.data.get(expressID);
    if (!keys)
      return;
    for (const key of keys[0]) {
      const fragmentID = group.keyFragments.get(key);
      if (fragmentID) {
        const system = this.list[systemName];
        if (!system[className]) {
          system[className] = { map: {}, id: parentID, name: className };
        }
        if (!system[className].map[fragmentID]) {
          system[className].map[fragmentID] = /* @__PURE__ */ new Set();
        }
        system[className].map[fragmentID].add(expressID);
      }
    }
  }
};
__publicField2(_Classifier, "uuid", "e25a7f3c-46c4-4a14-9d3d-5115f24ebeb7");
var Classifier = _Classifier;
var _Exploder = class _Exploder2 extends Component {
  constructor(components) {
    super(components);
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "enabled", true);
    __publicField2(this, "height", 10);
    __publicField2(this, "groupName", "spatialStructures");
    __publicField2(this, "list", /* @__PURE__ */ new Set());
    components.add(_Exploder2.uuid, this);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.list.clear();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  /**
   * Sets the explosion state of the fragments.
   *
   * @param active - A boolean indicating whether to activate or deactivate the explosion.
   *
   * @remarks
   * This method applies a vertical transformation to the fragments based on the `active` parameter.
   * If `active` is true, the fragments are moved upwards by a distance determined by the `height` property.
   * If `active` is false, the fragments are moved back to their original position.
   *
   * The method also keeps track of the exploded items using the `list` set.
   *
   * @throws Will throw an error if the `Classifier` or `FragmentsManager` components are not found in the `components` system.
   */
  set(active) {
    if (!this.enabled)
      return;
    const classifier = this.components.get(Classifier);
    const fragments = this.components.get(FragmentsManager);
    const factor = active ? 1 : -1;
    let i = 0;
    const groups = classifier.list[this.groupName];
    const yTransform = new Matrix4();
    for (const groupName in groups) {
      yTransform.elements[13] = i * factor * this.height;
      for (const fragID in groups[groupName].map) {
        const fragment = fragments.list.get(fragID);
        const itemsID = groupName + fragID;
        const areItemsExploded = this.list.has(itemsID);
        if (!fragment || active && areItemsExploded || !active && !areItemsExploded) {
          continue;
        }
        if (active) {
          this.list.add(itemsID);
        } else {
          this.list.delete(itemsID);
        }
        const ids = groups[groupName].map[fragID];
        fragment.applyTransform(ids, yTransform);
        fragment.mesh.computeBoundingSphere();
        fragment.mesh.computeBoundingBox();
      }
      i++;
    }
  }
};
__publicField2(_Exploder, "uuid", "d260618b-ce88-4c7d-826c-6debb91de3e2");
var Exploder = _Exploder;
var _Hider = class _Hider2 extends Component {
  constructor(components) {
    super(components);
    __publicField2(this, "enabled", true);
    this.components.add(_Hider2.uuid, this);
  }
  /**
   * Sets the visibility of fragments within the 3D scene.
   * If no `items` parameter is provided, all fragments will be set to the specified visibility.
   * If `items` is provided, only the specified fragments will be affected.
   *
   * @param visible - The visibility state to set for the fragments.
   * @param items - An optional map of fragment IDs and their corresponding sub-fragment IDs to be affected.
   * If not provided, all fragments will be affected.
   *
   * @returns {void}
   */
  set(visible, items) {
    const fragments = this.components.get(FragmentsManager);
    if (!items) {
      for (const [_id, fragment] of fragments.list) {
        if (fragment) {
          fragment.setVisibility(visible);
          this.updateCulledVisibility(fragment);
        }
      }
      return;
    }
    for (const fragID in items) {
      const ids = items[fragID];
      const fragment = fragments.list.get(fragID);
      if (fragment) {
        fragment.setVisibility(visible, ids);
        this.updateCulledVisibility(fragment);
      }
    }
  }
  /**
   * Isolates fragments within the 3D scene by hiding all other fragments and showing only the specified ones.
   * It calls the `set` method twice: first to hide all fragments, and then to show only the specified ones.
   *
   * @param items - A map of fragment IDs and their corresponding sub-fragment IDs to be isolated.
   * If not provided, all fragments will be isolated.
   *
   * @returns {void}
   */
  isolate(items) {
    this.set(false);
    this.set(true, items);
  }
  updateCulledVisibility(fragment) {
    const cullers = this.components.get(Cullers);
    for (const [_id, culler] of cullers.list) {
      const culled = culler.colorMeshes.get(fragment.id);
      if (culled) {
        culled.count = fragment.mesh.count;
      }
    }
  }
};
__publicField2(_Hider, "uuid", "dd9ccf2d-8a21-4821-b7f6-2949add16a29");
var Hider = _Hider;
var IfcStreamingSettings = class extends IfcFragmentSettings {
  constructor() {
    super(...arguments);
    __publicField2(this, "minGeometrySize", 10);
    __publicField2(this, "minAssetsSize", 1e3);
    __publicField2(this, "maxTriangles", null);
  }
};
var _IfcGeometryTiler = class _IfcGeometryTiler2 extends Component {
  constructor(components) {
    super(components);
    __publicField2(this, "onGeometryStreamed", new AsyncEvent());
    __publicField2(this, "onAssetStreamed", new AsyncEvent());
    __publicField2(this, "onProgress", new AsyncEvent());
    __publicField2(this, "onIfcLoaded", new AsyncEvent());
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "settings", new IfcStreamingSettings());
    __publicField2(this, "enabled", true);
    __publicField2(this, "webIfc", new IfcAPI2());
    __publicField2(this, "_nextAvailableID", 0);
    __publicField2(this, "_splittedGeometries", /* @__PURE__ */ new Map());
    __publicField2(this, "_spatialTree", new SpatialStructure());
    __publicField2(this, "_metaData", new IfcMetadataReader());
    __publicField2(this, "_visitedGeometries", /* @__PURE__ */ new Map());
    __publicField2(this, "_streamSerializer", new StreamSerializer());
    __publicField2(this, "_geometries", /* @__PURE__ */ new Map());
    __publicField2(this, "_geometryCount", 0);
    __publicField2(this, "_civil", new CivilReader());
    __publicField2(this, "_groupSerializer", new Serializer());
    __publicField2(this, "_assets", []);
    __publicField2(this, "_meshesWithHoles", /* @__PURE__ */ new Set());
    this.components.add(_IfcGeometryTiler2.uuid, this);
    this.settings.excludedCategories.add(IFCOPENINGELEMENT);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.onIfcLoaded.reset();
    this.onGeometryStreamed.reset();
    this.onAssetStreamed.reset();
    this.webIfc = null;
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  /**
   * This method streams the IFC file from a given buffer.
   *
   * @param data - The Uint8Array containing the IFC file data.
   * @returns A Promise that resolves when the streaming process is complete.
   *
   * @remarks
   * This method cleans up any resources after the streaming process is complete.
   *
   * @example
   * ```typescript
   * const ifcData = await fetch('path/to/ifc/file.ifc');
   * const rawBuffer = await response.arrayBuffer();
   * const ifcBuffer = new Uint8Array(rawBuffer);
   * await ifcGeometryTiler.streamFromBuffer(ifcBuffer);
   * ```
   */
  async streamFromBuffer(data) {
    await this.readIfcFile(data);
    await this.streamAllGeometries();
    this.cleanUp();
  }
  /**
   * This method streams the IFC file from a given callback.
   *
   * @param loadCallback - The callback function that will be used to load the IFC file.
   * @returns A Promise that resolves when the streaming process is complete.
   *
   * @remarks
   * This method cleans up any resources after the streaming process is complete.
   *
   */
  async streamFromCallBack(loadCallback) {
    await this.streamIfcFile(loadCallback);
    await this.streamAllGeometries();
    this.cleanUp();
  }
  async readIfcFile(data) {
    const { path, absolute, logLevel } = this.settings.wasm;
    this.webIfc.SetWasmPath(path, absolute);
    await this.webIfc.Init();
    if (logLevel) {
      this.webIfc.SetLogLevel(logLevel);
    }
    this.webIfc.OpenModel(data, this.settings.webIfc);
    this._nextAvailableID = this.webIfc.GetMaxExpressID(0);
  }
  async streamIfcFile(loadCallback) {
    const { path, absolute, logLevel } = this.settings.wasm;
    this.webIfc.SetWasmPath(path, absolute);
    await this.webIfc.Init();
    if (logLevel) {
      this.webIfc.SetLogLevel(logLevel);
    }
    this.webIfc.OpenModelFromCallback(loadCallback, this.settings.webIfc);
    this._nextAvailableID = this.webIfc.GetMaxExpressID(0);
  }
  async streamAllGeometries() {
    console.log("Converting geometries to tiles...");
    const { minGeometrySize, minAssetsSize } = this.settings;
    this._spatialTree.setUp(this.webIfc);
    const allIfcEntities = this.webIfc.GetIfcEntityList(0);
    const chunks = [[]];
    const group = new FragmentsGroup3();
    group.ifcMetadata = {
      name: "",
      description: "",
      ...this._metaData.getNameInfo(this.webIfc),
      ...this._metaData.getDescriptionInfo(this.webIfc),
      schema: this.webIfc.GetModelSchema(0) || "IFC2X3",
      maxExpressID: this.webIfc.GetMaxExpressID(0)
    };
    let counter = 0;
    let index = 0;
    for (const type of allIfcEntities) {
      if (!this.webIfc.IsIfcElement(type) && type !== IFCSPACE) {
        continue;
      }
      if (this.settings.excludedCategories.has(type)) {
        continue;
      }
      const result = this.webIfc.GetLineIDsWithType(0, type);
      const size = result.size();
      for (let i = 0; i < size; i++) {
        if (counter > minGeometrySize) {
          counter = 0;
          index++;
          chunks.push([]);
        }
        const itemID = result.get(i);
        chunks[index].push(itemID);
        const props = this.webIfc.GetLine(0, itemID);
        if (props.GlobalId) {
          const globalID = (props == null ? void 0 : props.GlobalId.value) || (props == null ? void 0 : props.GlobalId);
          group.globalToExpressIDs.set(globalID, itemID);
        }
        const level = this._spatialTree.itemsByFloor[itemID] || 0;
        group.data.set(itemID, [[], [level, type]]);
        counter++;
      }
    }
    this._spatialTree.cleanUp();
    let nextProgress = 0.01;
    let chunkCounter = 0;
    for (const chunk of chunks) {
      chunkCounter++;
      this.webIfc.StreamMeshes(0, chunk, (mesh) => {
        this.getMesh(this.webIfc, mesh, group);
      });
      if (this._geometryCount > this.settings.minGeometrySize) {
        await this.streamGeometries();
      }
      if (this._assets.length > minAssetsSize) {
        await this.streamAssets();
      }
      const currentProgress = chunkCounter / chunks.length;
      if (currentProgress > nextProgress) {
        nextProgress += 0.01;
        nextProgress = Math.max(nextProgress, currentProgress);
        await this.onProgress.trigger(Math.round(nextProgress * 100) / 100);
      }
    }
    if (this._geometryCount) {
      await this.streamGeometries();
    }
    if (this._assets.length) {
      await this.streamAssets();
    }
    const { opaque, transparent } = group.geometryIDs;
    for (const [id, { index: index2, uuid }] of this._visitedGeometries) {
      group.keyFragments.set(index2, uuid);
      const geometryID = id > 1 ? opaque : transparent;
      geometryID.set(id, index2);
    }
    SpatialIdsFinder.get(group, this.webIfc);
    const matrix = this.webIfc.GetCoordinationMatrix(0);
    group.coordinationMatrix.fromArray(matrix);
    group.civilData = this._civil.read(this.webIfc);
    const buffer = this._groupSerializer.export(group);
    await this.onIfcLoaded.trigger(buffer);
    group.dispose(true);
  }
  cleanUp() {
    try {
      this.webIfc.Dispose();
    } catch (e) {
    }
    this.webIfc = null;
    this.webIfc = new IfcAPI2();
    this._visitedGeometries.clear();
    this._geometries.clear();
    this._assets = [];
    this._meshesWithHoles.clear();
  }
  getMesh(webIfc, mesh, group) {
    const size = mesh.geometries.size();
    const id = mesh.expressID;
    const asset = { id, geometries: [] };
    for (let i = 0; i < size; i++) {
      const geometry = mesh.geometries.get(i);
      const geometryID = geometry.geometryExpressID;
      const isOpaque = geometry.color.w === 1;
      const factor = isOpaque ? 1 : -1;
      const transpGeometryID = geometryID * factor;
      if (!this._visitedGeometries.has(transpGeometryID)) {
        this.getGeometry(webIfc, geometryID, isOpaque);
      }
      this.registerGeometryData(
        group,
        id,
        geometry,
        asset,
        geometryID,
        transpGeometryID
      );
      const splits = this._splittedGeometries.get(geometryID);
      if (splits) {
        for (const split of splits) {
          this.registerGeometryData(group, id, geometry, asset, split, split);
        }
      }
    }
    this._assets.push(asset);
  }
  getGeometry(webIfc, id, isOpaque) {
    const geometry = webIfc.GetGeometry(0, id);
    const index = webIfc.GetIndexArray(
      geometry.GetIndexData(),
      geometry.GetIndexDataSize()
    );
    const vertexData = webIfc.GetVertexArray(
      geometry.GetVertexData(),
      geometry.GetVertexDataSize()
    );
    const position = new Float32Array(vertexData.length / 2);
    const normal = new Float32Array(vertexData.length / 2);
    for (let i = 0; i < vertexData.length; i += 6) {
      position[i / 2] = vertexData[i];
      position[i / 2 + 1] = vertexData[i + 1];
      position[i / 2 + 2] = vertexData[i + 2];
      normal[i / 2] = vertexData[i + 3];
      normal[i / 2 + 1] = vertexData[i + 4];
      normal[i / 2 + 2] = vertexData[i + 5];
    }
    const factor = isOpaque ? 1 : -1;
    if (index.length === 0) {
      const boundingBox22 = new Float32Array([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        1
      ]);
      this._geometries.set(id, {
        position,
        normal,
        index,
        boundingBox: boundingBox22,
        hasHoles: false
      });
      const geomIndex = this._visitedGeometries.size;
      const uuid = MathUtils.generateUUID();
      const transpGeometryID = id * factor;
      this._visitedGeometries.set(transpGeometryID, { uuid, index: geomIndex });
      this._geometryCount++;
      geometry.delete();
      return;
    }
    const maxTris = this.settings.maxTriangles || index.length / 3;
    const maxIndexSize = maxTris * 3;
    let firstSplit = true;
    for (let i = 0; i < index.length; i += maxIndexSize) {
      const distanceToEnd = index.length - i;
      const distance = Math.min(distanceToEnd, maxIndexSize);
      const end = i + distance;
      const splittedIndexArray = [];
      const splittedPosArray = [];
      const splittedNorArray = [];
      let indexCounter = 0;
      for (let j = i; j < end; j++) {
        splittedIndexArray.push(indexCounter++);
        const previousIndex = index[j];
        splittedPosArray.push(position[previousIndex * 3]);
        splittedPosArray.push(position[previousIndex * 3 + 1]);
        splittedPosArray.push(position[previousIndex * 3 + 2]);
        splittedNorArray.push(normal[previousIndex * 3]);
        splittedNorArray.push(normal[previousIndex * 3 + 1]);
        splittedNorArray.push(normal[previousIndex * 3 + 2]);
      }
      const splittedIndex = new Uint32Array(splittedIndexArray);
      const splittedPosition = new Float32Array(splittedPosArray);
      const splittedNormal = new Float32Array(splittedNorArray);
      const obb32 = obbFromPoints(splittedPosition);
      const boundingBox22 = new Float32Array(obb32.transformation.elements);
      const hasHoles = false;
      const geometryID = firstSplit ? id : this._nextAvailableID++;
      this._geometries.set(geometryID, {
        position: splittedPosition,
        normal: splittedNormal,
        index: splittedIndex,
        boundingBox: boundingBox22,
        hasHoles
      });
      if (!firstSplit) {
        if (!this._splittedGeometries.has(id)) {
          this._splittedGeometries.set(id, /* @__PURE__ */ new Set());
        }
        const splits = this._splittedGeometries.get(id);
        splits.add(geometryID);
      }
      const geomIndex = this._visitedGeometries.size;
      const uuid = MathUtils.generateUUID();
      const transpGeometryID = geometryID * factor;
      this._visitedGeometries.set(transpGeometryID, { uuid, index: geomIndex });
      this._geometryCount++;
      firstSplit = false;
    }
    geometry.delete();
  }
  async streamAssets() {
    await this.onAssetStreamed.trigger(this._assets);
    this._assets = null;
    this._assets = [];
  }
  async streamGeometries() {
    const exportMap = /* @__PURE__ */ new Map();
    for (const [id, value] of this._geometries) {
      exportMap.set(id, value);
      if (exportMap.size > this.settings.minGeometrySize) {
        await this.outputGeometries(exportMap);
      }
    }
    await this.outputGeometries(exportMap);
    this._geometries.clear();
    this._geometryCount = 0;
  }
  async outputGeometries(exportMap) {
    let buffer = this._streamSerializer.export(exportMap);
    let data = {};
    for (const [id, { boundingBox: boundingBox22, hasHoles }] of exportMap) {
      data[id] = { boundingBox: boundingBox22, hasHoles };
    }
    await this.onGeometryStreamed.trigger({ data, buffer });
    data = null;
    buffer = null;
    exportMap.clear();
  }
  registerGeometryData(group, itemID, geometry, asset, geometryID, transpGeometryID) {
    const geometryData = this._visitedGeometries.get(transpGeometryID);
    if (geometryData === void 0) {
      throw new Error("Error getting geometry data for streaming!");
    }
    const data = group.data.get(itemID);
    if (!data) {
      throw new Error("Data not found!");
    }
    data[0].push(geometryData.index);
    const { x, y, z, w } = geometry.color;
    const color = [x, y, z, w];
    const transformation = geometry.flatTransformation;
    asset.geometries.push({ color, geometryID, transformation });
  }
};
__publicField2(_IfcGeometryTiler, "uuid", "d9999a00-e1f5-4d3f-8cfe-c56e08609764");
var IfcGeometryTiler = _IfcGeometryTiler;
var PropertiesStreamingSettings = class extends IfcFragmentSettings {
  constructor() {
    super(...arguments);
    __publicField2(this, "propertiesSize", 100);
  }
};
var IfcPropertiesTiler = class extends Component {
  constructor() {
    super(...arguments);
    __publicField2(this, "onPropertiesStreamed", new AsyncEvent());
    __publicField2(this, "onProgress", new AsyncEvent());
    __publicField2(this, "onIndicesStreamed", new AsyncEvent());
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "enabled", true);
    __publicField2(this, "settings", new PropertiesStreamingSettings());
    __publicField2(this, "webIfc", new IfcAPI2());
  }
  /** {@link Disposable.dispose} */
  async dispose() {
    this.onIndicesStreamed.reset();
    this.onPropertiesStreamed.reset();
    this.webIfc = null;
    this.onDisposed.reset();
  }
  /**
   * This method converts properties from an IFC file to tiles given its data as a Uint8Array.
   *
   * @param data - The Uint8Array containing the IFC file data.
   * @returns A Promise that resolves when the streaming process is complete.
   */
  async streamFromBuffer(data) {
    await this.readIfcFile(data);
    await this.streamAllProperties();
    this.cleanUp();
  }
  /**
   * This method converts properties from an IFC file to tiles using a given callback function to read the file.
   *
   * @param loadCallback - A callback function that loads the IFC file data.
   * @returns A Promise that resolves when the streaming process is complete.
   */
  async streamFromCallBack(loadCallback) {
    await this.streamIfcFile(loadCallback);
    await this.streamAllProperties();
    this.cleanUp();
  }
  async readIfcFile(data) {
    const { path, absolute, logLevel } = this.settings.wasm;
    this.webIfc.SetWasmPath(path, absolute);
    await this.webIfc.Init();
    if (logLevel) {
      this.webIfc.SetLogLevel(logLevel);
    }
    this.webIfc.OpenModel(data, this.settings.webIfc);
  }
  async streamIfcFile(loadCallback) {
    const { path, absolute, logLevel } = this.settings.wasm;
    this.webIfc.SetWasmPath(path, absolute);
    await this.webIfc.Init();
    if (logLevel) {
      this.webIfc.SetLogLevel(logLevel);
    }
    this.webIfc.OpenModelFromCallback(loadCallback, this.settings.webIfc);
  }
  async streamAllProperties() {
    const { propertiesSize } = this.settings;
    const allIfcEntities = new Set(this.webIfc.GetIfcEntityList(0));
    const spatialStructure = /* @__PURE__ */ new Set([
      IFCPROJECT,
      IFCSITE,
      IFCBUILDING,
      IFCBUILDINGSTOREY,
      IFCSPACE
    ]);
    for (const type of spatialStructure) {
      allIfcEntities.add(type);
    }
    let nextProgress = 0.01;
    let typeCounter = 0;
    for (const type of allIfcEntities) {
      typeCounter++;
      if (GeometryTypes.has(type)) {
        continue;
      }
      const isSpatial = spatialStructure.has(type);
      const ids = this.webIfc.GetLineIDsWithType(0, type);
      const idCount = ids.size();
      let count = 0;
      for (let i = 0; i < idCount - propertiesSize; i += propertiesSize) {
        const data = {};
        for (let j = 0; j < propertiesSize; j++) {
          count++;
          const nextProperty = ids.get(i + j);
          try {
            const property = this.webIfc.GetLine(0, nextProperty, isSpatial);
            data[property.expressID] = property;
          } catch (e) {
            console.log(`Could not get property: ${nextProperty}`);
          }
        }
        await this.onPropertiesStreamed.trigger({ type, data });
      }
      if (count !== idCount) {
        const data = {};
        for (let i = count; i < idCount; i++) {
          const nextProperty = ids.get(i);
          try {
            const property = this.webIfc.GetLine(0, nextProperty, isSpatial);
            data[property.expressID] = property;
          } catch (e) {
            console.log(`Could not get property: ${nextProperty}`);
          }
        }
        await this.onPropertiesStreamed.trigger({ type, data });
      }
      const currentProgress = typeCounter / allIfcEntities.size;
      if (currentProgress > nextProgress) {
        nextProgress = Math.round(nextProgress * 100) / 100;
        await this.onProgress.trigger(nextProgress);
        nextProgress += 0.01;
      }
    }
    await this.onProgress.trigger(1);
    const relations = this.components.get(IfcRelationsIndexer);
    const rels = await relations.processFromWebIfc(this.webIfc, 0);
    await this.onIndicesStreamed.trigger(rels);
  }
  cleanUp() {
    this.webIfc.Dispose();
    this.webIfc = null;
    this.webIfc = new IfcAPI2();
  }
};
__publicField2(IfcPropertiesTiler, "uuid", "88d2c89c-ce32-47d7-8cb6-d51e4b311a0b");
var Viewpoint = class {
  constructor(components, world, _config) {
    __publicField2(this, "title");
    __publicField2(this, "guid", UUID.create());
    __publicField2(this, "clippingPlanes", new DataSet());
    __publicField2(this, "camera", {
      aspectRatio: 1,
      fov: 60,
      direction: { x: 0, y: 0, z: 0 },
      position: { x: 0, y: 0, z: 0 }
    });
    __publicField2(this, "exceptionComponents", new DataSet());
    __publicField2(this, "selectionComponents", new DataSet());
    __publicField2(this, "componentColors", new DataMap());
    __publicField2(this, "spacesVisible", false);
    __publicField2(this, "spaceBoundariesVisible", false);
    __publicField2(this, "openingsVisible", false);
    __publicField2(this, "defaultVisibility", true);
    __publicField2(this, "_components");
    __publicField2(this, "world");
    const config = { setCamera: true, ..._config };
    const { data, setCamera } = config;
    this._components = components;
    this.world = world;
    if (data) {
      this.guid = data.guid ?? this.guid;
      this.set(data);
    }
    if (setCamera)
      this.updateCamera();
  }
  get _selectionModelIdMap() {
    const fragments = this._components.get(FragmentsManager);
    const modelIdMap = {};
    for (const [id, model] of fragments.groups) {
      if (!(id in modelIdMap))
        modelIdMap[id] = /* @__PURE__ */ new Set();
      for (const globalId of this.selectionComponents) {
        const expressID = model.globalToExpressIDs.get(globalId);
        if (expressID)
          modelIdMap[id].add(expressID);
      }
    }
    return modelIdMap;
  }
  get _exceptionModelIdMap() {
    const fragments = this._components.get(FragmentsManager);
    const modelIdMap = {};
    for (const [id, model] of fragments.groups) {
      if (!(id in modelIdMap))
        modelIdMap[id] = /* @__PURE__ */ new Set();
      for (const globalId of this.exceptionComponents) {
        const expressID = model.globalToExpressIDs.get(globalId);
        if (expressID)
          modelIdMap[id].add(expressID);
      }
    }
    return modelIdMap;
  }
  /**
   * A list of components that should be selected (highlighted) when displaying a viewpoint.
   * @returns The fragmentIdMap for components marked as selections.
   */
  get selection() {
    const fragments = this._components.get(FragmentsManager);
    const fragmentIdMap = fragments.modelIdToFragmentIdMap(
      this._selectionModelIdMap
    );
    return fragmentIdMap;
  }
  /**
   * A list of components to hide when defaultVisibility = true or to show when defaultVisibility = false
   * @returns The fragmentIdMap for components marked as exceptions.
   */
  get exception() {
    const fragments = this._components.get(FragmentsManager);
    const fragmentIdMap = fragments.modelIdToFragmentIdMap(
      this._exceptionModelIdMap
    );
    return fragmentIdMap;
  }
  /**
   * Retrieves the projection type of the viewpoint's camera.
   *
   * @returns A string representing the projection type of the viewpoint's camera.
   *          It can be either 'Perspective' or 'Orthographic'.
   */
  get projection() {
    if ("fov" in this.camera)
      return "Perspective";
    return "Orthographic";
  }
  /**
   * Retrieves the position vector of the viewpoint's camera.
   *
   * @remarks
   * The position vector represents the camera's position in the world coordinate system.
   * The function applies the base coordinate system transformation to the position vector.
   *
   * @returns A THREE.Vector3 representing the position of the viewpoint's camera.
   */
  get position() {
    const fragments = this._components.get(FragmentsManager);
    const { position } = this.camera;
    const { x, y, z } = position;
    const vector = new Vector3(x, y, z);
    fragments.applyBaseCoordinateSystem(vector, new Matrix4());
    return vector;
  }
  /**
   * Retrieves the direction vector of the viewpoint's camera.
   *
   * @remarks
   * The direction vector represents the direction in which the camera is pointing.
   * It is calculated by extracting the x, y, and z components from the camera's direction property.
   *
   * @returns A THREE.Vector3 representing the direction of the viewpoint's camera.
   */
  get direction() {
    const { direction } = this.camera;
    const { x, y, z } = direction;
    const vector = new Vector3(x, y, z);
    return vector;
  }
  get _managerVersion() {
    const manager = this._components.get(BCFTopics);
    return manager.config.version;
  }
  /**
   * Retrieves the list of BCF topics associated with the current viewpoint.
   *
   * @remarks
   * This function retrieves the BCFTopics manager from the components,
   * then filters the list of topics to find those associated with the current viewpoint.
   *
   * @returns An array of BCF topics associated with the current viewpoint.
   */
  get topics() {
    const manager = this._components.get(BCFTopics);
    const topicsList = [...manager.list.values()];
    const topics = topicsList.filter(
      (topic) => topic.viewpoints.has(this.guid)
    );
    return topics;
  }
  /**
   * Adds components to the viewpoint based on the provided fragment ID map.
   *
   * @param fragmentIdMap - A map containing fragment IDs as keys and arrays of express IDs as values.
   */
  addComponentsFromMap(fragmentIdMap) {
    const fragments = this._components.get(FragmentsManager);
    const guids = fragments.fragmentIdMapToGuids(fragmentIdMap);
    this.selectionComponents.add(...guids);
    const manager = this._components.get(Viewpoints);
    manager.list.set(this.guid, this);
  }
  /**
   * Replace the properties of the viewpoint with the provided data.
   *
   * @remarks The guid will be ommited as it shouldn't change after it has been initially set.
   * @remarks The existing selection and exception components will be fully replaced in case new ones are provided.
   *
   * @param data - An object containing the properties to be set.
   *               The properties not included in the object will remain unchanged.
   *
   * @returns The viewpoint instance with the updated properties.
   */
  set(data) {
    const _data = data;
    const _this = this;
    for (const key in data) {
      if (key === "guid")
        continue;
      const value = _data[key];
      if (key === "selectionComponents") {
        this.selectionComponents.clear();
        this.selectionComponents.add(...value);
        continue;
      }
      if (key === "exceptionComponents") {
        this.exceptionComponents.clear();
        this.exceptionComponents.add(...value);
        continue;
      }
      if (key in this)
        _this[key] = value;
    }
    const manager = this._components.get(Viewpoints);
    manager.list.set(this.guid, this);
    return this;
  }
  /**
   * Sets the viewpoint of the camera in the world.
   *
   * @remarks
   * This function calculates the target position based on the viewpoint information.
   * It sets the visibility of the viewpoint components and then applies the viewpoint using the camera's controls.
   *
   * @param transition - Indicates whether the camera movement should have a transition effect.
   *                      Default value is `true`.
   *
   * @throws An error if the world's camera does not have camera controls.
   *
   * @returns A Promise that resolves when the camera has been set.
   */
  async go(world, transition = true) {
    const { camera } = world ?? this.world;
    if (!camera.hasCameraControls()) {
      throw new Error(
        "Viewpoint: the world's camera need controls to set the viewpoint."
      );
    }
    if (camera instanceof OrthoPerspectiveCamera) {
      camera.projection.set(this.projection);
    }
    const basePosition = new Vector3(
      this.camera.position.x,
      this.camera.position.y,
      this.camera.position.z
    );
    const baseTarget = new Vector3(
      this.camera.direction.x,
      this.camera.direction.y,
      this.camera.direction.z
    );
    if (basePosition.equals(new Vector3()) && baseTarget.equals(new Vector3())) {
      return;
    }
    const position = this.position;
    const direction = this.direction;
    let target = {
      x: position.x + direction.x * 80,
      y: position.y + direction.y * 80,
      z: position.z + direction.z * 80
    };
    const selection = this.selection;
    if (Object.keys(selection).length === 0) {
      const raycasters = this._components.get(Raycasters);
      const raycaster = raycasters.get(this.world);
      const result = raycaster.castRayFromVector(position, this.direction);
      if (result)
        target = result.point;
    } else {
      const bb = this._components.get(BoundingBoxer);
      bb.reset();
      bb.addFragmentIdMap(selection);
      target = bb.getSphere().center;
      bb.reset();
    }
    await camera.controls.setLookAt(
      position.x,
      position.y,
      position.z,
      target.x,
      target.y,
      target.z,
      transition
    );
  }
  /**
   * Updates the camera settings of the viewpoint based on the current world's camera and renderer.
   *
   * @remarks
   * This function retrieves the camera's position, direction, and aspect ratio from the world's camera and renderer.
   * It then calculates the camera's perspective or orthographic settings based on the camera type.
   * Finally, it updates the viewpoint's camera settings and updates the viewpoint to the Viewpoints manager.
   *
   * @throws An error if the world's camera does not have camera controls.
   * @throws An error if the world's renderer is not available.
   */
  updateCamera(world) {
    const { camera, renderer } = world ?? this.world;
    if (!renderer) {
      throw new Error("Viewpoint: the world needs to have a renderer!");
    }
    if (!camera.hasCameraControls()) {
      throw new Error("Viewpoint: world's camera need camera controls!");
    }
    const position = new Vector3();
    camera.controls.getPosition(position);
    const threeCamera = camera.three;
    const direction = new Vector3(0, 0, -1).applyEuler(
      threeCamera.rotation
    );
    const { width, height } = renderer.getSize();
    let aspectRatio = width / height;
    if (Number.isNaN(aspectRatio))
      aspectRatio = 1;
    const fragments = this._components.get(FragmentsManager);
    position.applyMatrix4(fragments.baseCoordinationMatrix.clone().invert());
    const partialCamera = {
      aspectRatio,
      position: { x: position.x, y: position.y, z: position.z },
      direction: { x: direction.x, y: direction.y, z: direction.z }
    };
    if (threeCamera instanceof PerspectiveCamera) {
      this.camera = {
        ...partialCamera,
        fov: threeCamera.fov
      };
    } else if (threeCamera instanceof OrthographicCamera) {
      this.camera = {
        ...partialCamera,
        viewToWorldScale: threeCamera.top - threeCamera.bottom
      };
    }
    const manager = this._components.get(Viewpoints);
    manager.list.set(this.guid, this);
  }
  applyVisibility() {
    const hider = this._components.get(Hider);
    hider.set(this.defaultVisibility);
    hider.set(!this.defaultVisibility, this.exception);
    hider.set(true, this.selection);
  }
  /**
   * Applies color to the components in the viewpoint based on their GUIDs.
   *
   * This function iterates through the `componentColors` map, retrieves the fragment IDs
   * corresponding to each color, and then uses the `Classifier` to apply the color to those fragments.
   *
   * @remarks
   * The color is applied using the `Classifier.setColor` method, which sets the color of the specified fragments.
   * The color is provided as a hexadecimal string, prefixed with a '#'.
   */
  applyColors() {
    const manager = this._components.get(Viewpoints);
    const fragments = this._components.get(FragmentsManager);
    const classifier = this._components.get(Classifier);
    for (const [color, guids] of this.componentColors) {
      const fragmentIdMap = fragments.guidToFragmentIdMap(guids);
      classifier.setColor(fragmentIdMap, color, manager.config.overwriteColors);
    }
  }
  /**
   * Resets the colors of all components in the viewpoint to their original color.
   */
  resetColors() {
    const fragments = this._components.get(FragmentsManager);
    const classifier = this._components.get(Classifier);
    for (const [_, guids] of this.componentColors) {
      const fragmentIdMap = fragments.guidToFragmentIdMap(guids);
      classifier.resetColor(fragmentIdMap);
    }
  }
  async createComponentTags(from) {
    var _a, _b;
    const fragments = this._components.get(FragmentsManager);
    const manager = this._components.get(BCFTopics);
    let tags = "";
    if (manager.config.includeSelectionTag) {
      const modelIdMap = from === "selection" ? this._selectionModelIdMap : this._exceptionModelIdMap;
      for (const modelID in modelIdMap) {
        const model = fragments.groups.get(modelID);
        if (!model)
          continue;
        const expressIDs = modelIdMap[modelID];
        for (const expressID of expressIDs) {
          const attrs = await model.getProperties(expressID);
          if (!attrs)
            continue;
          const globalID = (_a = attrs.GlobalId) == null ? void 0 : _a.value;
          if (!globalID)
            continue;
          const tag = (_b = attrs.Tag) == null ? void 0 : _b.value;
          let tagAttribute = null;
          if (tag)
            tagAttribute = `AuthoringToolId="${tag}"`;
          tags += `
<Component IfcGuid="${globalID}" ${tagAttribute ?? ""} />`;
        }
      }
    } else {
      tags = [...this.selectionComponents].map((globalId) => `<Component IfcGuid="${globalId}" />`).join(`
`);
    }
    return tags;
  }
  createColorTags() {
    let colorTags = "";
    for (const [color, components] of this.componentColors.entries()) {
      const hex = `#${color.getHexString()}`;
      const tags = components.map((globalId) => `
<Component IfcGuid="${globalId}" />`).join("\n");
      colorTags += `<Color Color="${hex}">
${tags}
</Color>`;
    }
    if (colorTags.length !== 0) {
      return `<Coloring>
${colorTags}
</Coloring>`;
    }
    return `<Coloring />`;
  }
  /**
   * Serializes the viewpoint into a buildingSMART compliant XML string for export.
   *
   * @param version - The version of the BCF Manager to use for serialization.
   *                   If not provided, the current version of the manager will be used.
   *
   * @returns A Promise that resolves to an XML string representing the viewpoint.
   *          The XML string follows the BCF VisualizationInfo schema.
   *
   * @throws An error if the world's camera does not have camera controls.
   * @throws An error if the world's renderer is not available.
   */
  async serialize(version = this._managerVersion) {
    const fragments = this._components.get(FragmentsManager);
    const position = this.position;
    position.applyMatrix4(fragments.baseCoordinationMatrix.clone().invert());
    const direction = this.direction;
    direction.normalize();
    const rotationMatrix = new Matrix4().makeRotationX(Math.PI / 2);
    const upVector = direction.clone().applyMatrix4(rotationMatrix);
    upVector.normalize();
    const cameraViewpointXML = `<CameraViewPoint>
      <X>${position.x}</X>
      <Y>${-position.z}</Y>
      <Z>${position.y}</Z>
    </CameraViewPoint>`;
    const cameraDirectionXML = `<CameraDirection>
      <X>${direction.x}</X>
      <Y>${-direction.z}</Y>
      <Z>${direction.y}</Z>
    </CameraDirection>`;
    const cameraUpVectorXML = `<CameraUpVector>
      <X>${upVector.x}</X>
      <Y>${-upVector.z}</Y>
      <Z>${upVector.y}</Z>
    </CameraUpVector>`;
    const cameraRatioXML = `<AspectRatio>${this.camera.aspectRatio}</AspectRatio>`;
    let cameraXML = "";
    if ("viewToWorld" in this.camera) {
      cameraXML = `<OrthogonalCamera>
        ${cameraViewpointXML}
        ${cameraDirectionXML}
        ${cameraUpVectorXML}
        ${cameraRatioXML}
        <ViewToWorldScale>${this.camera.viewToWorld}</ViewToWorldScale>
      </OrthogonalCamera>`;
    } else if ("fov" in this.camera) {
      cameraXML = `<PerspectiveCamera>
        ${cameraViewpointXML}
        ${cameraDirectionXML}
        ${cameraUpVectorXML}
        ${cameraRatioXML}
        <FieldOfView>${this.camera.fov}</FieldOfView>
      </PerspectiveCamera>`;
    }
    const viewSetupHints = `<ViewSetupHints SpacesVisible="${this.spacesVisible ?? false}" SpaceBoundariesVisible="${this.spaceBoundariesVisible ?? false}" OpeningsVisible="${this.openingsVisible ?? false}" />`;
    const selectionTags = (await this.createComponentTags("selection")).trim();
    const exceptionTags = (await this.createComponentTags("exception")).trim();
    const colorTags = this.createColorTags();
    return `<?xml version="1.0" encoding="UTF-8"?>
    <VisualizationInfo Guid="${this.guid}">
      <Components>
        ${version === "2.1" ? viewSetupHints : ""}
        ${selectionTags.length !== 0 ? `<Selection>${selectionTags}</Selection>` : ""}
        <Visibility DefaultVisibility="${this.defaultVisibility}">
          ${version === "3" ? viewSetupHints : ""}
          ${exceptionTags.length !== 0 ? `<Exceptions>${exceptionTags}</Exceptions>` : ""}
        </Visibility>
        ${colorTags}
      </Components>
      ${cameraXML}
    </VisualizationInfo>`;
  }
};
var ViewpointsConfigManager = class extends Configurator {
  constructor() {
    super(...arguments);
    __publicField2(this, "_config", {
      overwriteColors: {
        value: false,
        type: "Boolean"
      }
    });
  }
  get overwriteColors() {
    return this._config.overwriteColors.value;
  }
  set overwriteColors(value) {
    this._config.overwriteColors.value = value;
  }
};
var _Viewpoints = class _Viewpoints2 extends Component {
  constructor(components) {
    super(components);
    __publicField2(this, "enabled", true);
    __publicField2(this, "list", new DataMap());
    __publicField2(this, "isSetup", false);
    __publicField2(this, "onSetup", new Event());
    __publicField2(this, "config", new ViewpointsConfigManager(
      this,
      this.components,
      "Viewpoints",
      _Viewpoints2.uuid
    ));
    __publicField2(this, "onDisposed", new Event());
    components.add(_Viewpoints2.uuid, this);
  }
  /**
   * Creates a new Viewpoint instance and adds it to the list.
   *
   * @param world - The world in which the Viewpoint will be created.
   * @param data - Optional partial data for the Viewpoint. If not provided, default data will be used.
   *
   * @returns The newly created Viewpoint instance.
   */
  create(world, data) {
    const viewpoint = new Viewpoint(this.components, world, { data });
    if (!data)
      this.list.set(viewpoint.guid, viewpoint);
    return viewpoint;
  }
  setup() {
  }
  /**
   * Disposes of the Viewpoints component and its associated resources.
   *
   * This method is responsible for cleaning up any resources held by the Viewpoints component,
   * such as disposing of the DataMap of Viewpoint instances and triggering and resetting the
   * onDisposed event.
   */
  dispose() {
    this.list.dispose();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
};
__publicField2(_Viewpoints, "uuid", "ee867824-a796-408d-8aa0-4e5962a83c66");
var Viewpoints = _Viewpoints;
var MiniMapConfigManager = class extends Configurator {
  constructor() {
    super(...arguments);
    __publicField2(this, "_config", {
      visible: {
        value: true,
        type: "Boolean"
      },
      lockRotation: {
        value: true,
        type: "Boolean"
      },
      zoom: {
        type: "Number",
        interpolable: true,
        value: 0.05,
        min: 1e-3,
        max: 5
      },
      frontOffset: {
        type: "Number",
        interpolable: true,
        value: 0,
        min: 0,
        max: 100
      },
      sizeX: {
        type: "Number",
        interpolable: true,
        value: 320,
        min: 20,
        max: 5e3
      },
      sizeY: {
        type: "Number",
        interpolable: true,
        value: 160,
        min: 20,
        max: 5e3
      },
      backgroundColor: {
        value: new Color(),
        type: "Color"
      }
    });
  }
  /**
   * Whether the minimap is visible or not.
   */
  get visible() {
    return this._config.visible.value;
  }
  /**
   * Whether the minimap is visible or not.
   */
  set visible(value) {
    this._config.visible.value = value;
    const style = this._component.renderer.domElement.style;
    style.display = value ? "block" : "none";
  }
  /**
   * Whether to lock the rotation of the top camera in the minimap.
   */
  get lockRotation() {
    return this._config.lockRotation.value;
  }
  /**
   * Whether to lock the rotation of the top camera in the minimap.
   */
  set lockRotation(value) {
    this._config.lockRotation.value = value;
    this._component.lockRotation = value;
  }
  /**
   * The zoom of the camera in the minimap.
   */
  get zoom() {
    return this._config.zoom.value;
  }
  /**
   * The zoom of the camera in the minimap.
   */
  set zoom(value) {
    this._config.zoom.value = value;
    this._component.zoom = value;
  }
  /**
   * The front offset of the minimap.
   * It determines how much the minimap's view is offset from the camera's view.
   * By pushing the map to the front, what the user sees on screen corresponds with what they see on the map
   */
  get frontOffset() {
    return this._config.frontOffset.value;
  }
  /**
   * The front offset of the minimap.
   * It determines how much the minimap's view is offset from the camera's view.
   * By pushing the map to the front, what the user sees on screen corresponds with what they see on the map
   */
  set frontOffset(value) {
    this._config.frontOffset.value = value;
    this._component.frontOffset = value;
  }
  /**
   * The horizontal dimension of the minimap.
   */
  get sizeX() {
    return this._config.sizeX.value;
  }
  /**
   * The horizontal dimension of the minimap.
   */
  set sizeX(value) {
    this._config.sizeX.value = value;
    const { sizeX, sizeY } = this._config;
    const size = new Vector2(sizeX.value, sizeY.value);
    this._component.resize(size);
  }
  /**
   * The vertical dimension of the minimap.
   */
  get sizeY() {
    return this._config.sizeY.value;
  }
  /**
   * The vertical dimension of the minimap.
   */
  set sizeY(value) {
    this._config.sizeY.value = value;
    const { sizeX, sizeY } = this._config;
    const size = new Vector2(sizeX.value, sizeY.value);
    this._component.resize(size);
  }
  /**
   * The color of the background of the minimap.
   */
  get backgroundColor() {
    return this._config.backgroundColor.value;
  }
  /**
   * The color of the background of the minimap.
   */
  set backgroundColor(value) {
    this._config.backgroundColor.value = value;
    this._component.backgroundColor = value;
  }
};
var MiniMap = class {
  constructor(world, components) {
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "onAfterUpdate", new Event());
    __publicField2(this, "onBeforeUpdate", new Event());
    __publicField2(this, "onResize", new Event());
    __publicField2(this, "onSetup", new Event());
    __publicField2(this, "frontOffset", 0);
    __publicField2(this, "overrideMaterial", new MeshDepthMaterial());
    __publicField2(this, "backgroundColor", new Color(395274));
    __publicField2(this, "renderer");
    __publicField2(this, "enabled", true);
    __publicField2(this, "world");
    __publicField2(this, "config");
    __publicField2(this, "isSetup", false);
    __publicField2(this, "_defaultConfig", {
      visible: true,
      lockRotation: false,
      zoom: 0.05,
      frontOffset: 0,
      sizeX: 320,
      sizeY: 160,
      backgroundColor: new Color(395274)
    });
    __publicField2(this, "_lockRotation", true);
    __publicField2(this, "_size", new Vector2(320, 160));
    __publicField2(this, "_camera");
    __publicField2(this, "_plane");
    __publicField2(this, "_tempVector1", new Vector3());
    __publicField2(this, "_tempVector2", new Vector3());
    __publicField2(this, "_tempTarget", new Vector3());
    __publicField2(this, "down", new Vector3(0, -1, 0));
    __publicField2(this, "updatePlanes", () => {
      if (!this.world.renderer) {
        throw new Error("The given world must have a renderer!");
      }
      const planes = [];
      const renderer = this.world.renderer.three;
      for (const plane of renderer.clippingPlanes) {
        planes.push(plane);
      }
      planes.push(this._plane);
      this.renderer.clippingPlanes = planes;
    });
    this.world = world;
    if (!this.world.renderer) {
      throw new Error("The given world must have a renderer!");
    }
    this.renderer = new WebGLRenderer();
    this.renderer.setSize(this._size.x, this._size.y);
    const frustumSize = 1;
    const aspect = this._size.x / this._size.y;
    this._camera = new OrthographicCamera(
      frustumSize * aspect / -2,
      frustumSize * aspect / 2,
      frustumSize / 2,
      frustumSize / -2
    );
    this.world.renderer.onClippingPlanesUpdated.add(this.updatePlanes);
    this._camera.position.set(0, 200, 0);
    this._camera.zoom = 0.1;
    this._camera.rotation.x = -Math.PI / 2;
    this._plane = new Plane(this.down, 200);
    this.updatePlanes();
    this.config = new MiniMapConfigManager(this, components, "MiniMap");
  }
  /**
   * Gets or sets whether the minimap rotation is locked.
   * When rotation is locked, the minimap will always face the same direction as the camera.
   */
  get lockRotation() {
    return this._lockRotation;
  }
  /**
   * Sets whether the minimap rotation is locked.
   * When rotation is locked, the minimap will always face the same direction as the camera.
   * @param active - If `true`, rotation is locked. If `false`, rotation is not locked.
   */
  set lockRotation(active) {
    this._lockRotation = active;
    if (active) {
      this._camera.rotation.z = 0;
    }
  }
  /**
   * Gets the current zoom level of the minimap.
   * The zoom level determines how much of the world is visible on the minimap.
   * @returns The current zoom level of the minimap.
   */
  get zoom() {
    return this._camera.zoom;
  }
  /**
   * Sets the zoom level of the minimap.
   * The zoom level determines how much of the world is visible on the minimap.
   * @param value - The new zoom level of the minimap.
   */
  set zoom(value) {
    this._camera.zoom = value;
    this._camera.updateProjectionMatrix();
  }
  /** {@link Disposable.dispose} */
  dispose() {
    this.enabled = false;
    this.onBeforeUpdate.reset();
    this.onAfterUpdate.reset();
    this.onResize.reset();
    this.overrideMaterial.dispose();
    this.renderer.forceContextLoss();
    this.renderer.dispose();
    this.onDisposed.trigger();
    this.onDisposed.reset();
  }
  /** Returns the camera used by the MiniMap */
  get() {
    return this._camera;
  }
  /** {@link Updateable.update} */
  update() {
    if (!this.enabled)
      return;
    this.onBeforeUpdate.trigger();
    const scene = this.world.scene.three;
    const camera = this.world.camera;
    if (!camera.hasCameraControls()) {
      throw new Error("The given world must use camera controls!");
    }
    if (!(scene instanceof Scene)) {
      throw new Error("The given world must have a THREE.Scene as a root!");
    }
    const controls = camera.controls;
    controls.getPosition(this._tempVector1);
    this._camera.position.x = this._tempVector1.x;
    this._camera.position.z = this._tempVector1.z;
    if (this.frontOffset !== 0) {
      controls.getTarget(this._tempVector2);
      this._tempVector2.sub(this._tempVector1);
      this._tempVector2.normalize().multiplyScalar(this.frontOffset);
      this._camera.position.x += this._tempVector2.x;
      this._camera.position.z += this._tempVector2.z;
    }
    if (!this._lockRotation) {
      controls.getTarget(this._tempTarget);
      const angle = Math.atan2(
        this._tempTarget.x - this._tempVector1.x,
        this._tempTarget.z - this._tempVector1.z
      );
      this._camera.rotation.z = angle + Math.PI;
    }
    this._plane.set(this.down, this._tempVector1.y);
    const previousBackground = scene.background;
    scene.background = this.backgroundColor;
    this.renderer.render(scene, this._camera);
    scene.background = previousBackground;
    this.onAfterUpdate.trigger();
  }
  /** {@link Resizeable.getSize} */
  getSize() {
    return this._size;
  }
  /** {@link Resizeable.resize} */
  resize(size = this._size) {
    this._size.copy(size);
    this.renderer.setSize(size.x, size.y);
    const aspect = size.x / size.y;
    const frustumSize = 1;
    this._camera.left = frustumSize * aspect / -2;
    this._camera.right = frustumSize * aspect / 2;
    this._camera.top = frustumSize / 2;
    this._camera.bottom = -1 / 2;
    this._camera.updateProjectionMatrix();
    this.onResize.trigger(size);
  }
  /** {@link Configurable.setup} */
  setup(config) {
    const fullConfig = { ...this._defaultConfig, ...config };
    this.config.visible = true;
    this.config.lockRotation = fullConfig.lockRotation;
    this.config.zoom = fullConfig.zoom;
    this.config.frontOffset = fullConfig.frontOffset;
    this.config.sizeX = fullConfig.sizeX;
    this.config.sizeY = fullConfig.sizeY;
    this.config.backgroundColor = fullConfig.backgroundColor;
    this.isSetup = true;
    this.onSetup.trigger();
  }
};
var _MiniMaps = class _MiniMaps2 extends Component {
  constructor(components) {
    super(components);
    __publicField2(this, "onAfterUpdate", new Event());
    __publicField2(this, "onBeforeUpdate", new Event());
    __publicField2(this, "onDisposed", new Event());
    __publicField2(this, "onSetup", new Event());
    __publicField2(this, "enabled", true);
    __publicField2(this, "list", /* @__PURE__ */ new Map());
    this.components.add(_MiniMaps2.uuid, this);
  }
  /**
   * Creates a new {@link MiniMap} instance associated with the given world.
   * If a {@link MiniMap} instance already exists for the given world, an error will be thrown.
   *
   * @param world - The {@link World} for which to create a {@link MiniMap} instance.
   * @returns The newly created {@link MiniMap} instance.
   * @throws Will throw an error if a {@link MiniMap} instance already exists for the given world.
   */
  create(world) {
    if (this.list.has(world.uuid)) {
      throw new Error("This world already has a minimap!");
    }
    const map = new MiniMap(world, this.components);
    this.list.set(world.uuid, map);
    return map;
  }
  /**
   * Deletes a {@link MiniMap} instance associated with the given world ID.
   * If a {@link MiniMap} instance does not exist for the given ID, nothing happens.
   *
   * @param id - The unique identifier of the world for which to delete the {@link MiniMap} instance.
   * @returns {void}
   */
  delete(id) {
    const map = this.list.get(id);
    if (map) {
      map.dispose();
    }
    this.list.delete(id);
  }
  /** {@link Disposable.dispose} */
  dispose() {
    for (const [_id, map] of this.list) {
      map.dispose();
    }
    this.list.clear();
    this.onDisposed.trigger();
  }
  /** {@link Updateable.update} */
  update() {
    for (const [_id, map] of this.list) {
      map.update();
    }
  }
};
__publicField2(_MiniMaps, "uuid", "39ad6aad-84c8-4adf-a1e0-7f25313a9e7f");
var MiniMaps = _MiniMaps;
var _MeasurementUtils = class _MeasurementUtils2 extends Component {
  constructor(components) {
    super(components);
    __publicField2(this, "enabled", true);
    components.add(_MeasurementUtils2.uuid, this);
  }
  /**
   * Utility method to calculate the distance from a point to a line segment.
   *
   * @param point - The point from which to calculate the distance.
   * @param lineStart - The start point of the line segment.
   * @param lineEnd - The end point of the line segment.
   * @param clamp - If true, the distance will be clamped to the line segment's length.
   * @returns The distance from the point to the line segment.
   */
  static distanceFromPointToLine(point, lineStart, lineEnd, clamp2 = false) {
    const tempLine = new Line3();
    const tempPoint = new Vector3();
    tempLine.set(lineStart, lineEnd);
    tempLine.closestPointToPoint(point, clamp2, tempPoint);
    return tempPoint.distanceTo(point);
  }
  /**
   * Method to get the face of a mesh that contains a given triangle index.
   * It also returns the edges of the found face and their indices.
   *
   * @param mesh - The mesh to get the face from. It must be indexed.
   * @param triangleIndex - The index of the triangle within the mesh.
   * @param instance - The instance of the mesh (optional).
   * @returns An object containing the edges of the found face and their indices, or null if no face was found.
   */
  getFace(mesh, triangleIndex, instance) {
    if (!mesh.geometry.index) {
      throw new Error("Geometry must be indexed!");
    }
    const allEdges = /* @__PURE__ */ new Map();
    const indices = mesh.geometry.index.array;
    const { plane: targetPlane } = this.getFaceData(
      triangleIndex,
      instance,
      mesh
    );
    const coplanarFacesIndices = [];
    for (let faceIndex = 0; faceIndex < indices.length / 3; faceIndex++) {
      const { plane, edges } = this.getFaceData(faceIndex, instance, mesh);
      if (plane.equals(targetPlane)) {
        coplanarFacesIndices.push({ index: faceIndex, edges });
        for (const { id, points, distance } of edges) {
          allEdges.set(id, { points, distance });
        }
      }
    }
    let nextFaceID = 0;
    const edgeFaceMap = /* @__PURE__ */ new Map();
    const faceEdgesMap = /* @__PURE__ */ new Map();
    for (const { index, edges } of coplanarFacesIndices) {
      const commonEdgesFaces = /* @__PURE__ */ new Map();
      for (const { id: edge } of edges) {
        if (edgeFaceMap.has(edge)) {
          const commonFace = edgeFaceMap.get(edge);
          commonEdgesFaces.set(edge, commonFace);
        }
      }
      const edgesIDs = edges.map((edge) => edge.id);
      if (!commonEdgesFaces.size) {
        const faceID = nextFaceID++;
        for (const { id: edge } of edges) {
          edgeFaceMap.set(edge, faceID);
        }
        faceEdgesMap.set(faceID, {
          edges: new Set(edgesIDs),
          indices: /* @__PURE__ */ new Set([index])
        });
        continue;
      }
      let firstFaceID = null;
      const otherFaces = /* @__PURE__ */ new Set();
      const edgesToAdd = new Set(edgesIDs);
      for (const [edge, faceID] of commonEdgesFaces) {
        if (firstFaceID === null) {
          firstFaceID = faceID;
        } else if (faceID !== firstFaceID) {
          otherFaces.add(faceID);
        }
        edgeFaceMap.delete(edge);
        const { edges: foundFaceEdges } = faceEdgesMap.get(faceID);
        foundFaceEdges.delete(edge);
        edgesToAdd.delete(edge);
      }
      if (firstFaceID === null) {
        throw new Error("Error computing face!");
      }
      const firstFace = faceEdgesMap.get(firstFaceID);
      const { indices: firstFaceIndices } = firstFace;
      firstFaceIndices.add(index);
      for (const edge of edgesToAdd) {
        edgeFaceMap.set(edge, firstFaceID);
        const { edges: firstFaceEdges } = firstFace;
        firstFaceEdges.add(edge);
      }
      for (const faceID of otherFaces) {
        const otherFace = faceEdgesMap.get(faceID);
        const { edges: otherEdges, indices: otherIndices } = otherFace;
        const firstFace2 = faceEdgesMap.get(firstFaceID);
        const { edges: firstEdges, indices: firstIndices } = firstFace2;
        for (const edge of otherEdges) {
          firstEdges.add(edge);
          edgeFaceMap.set(edge, firstFaceID);
        }
        for (const index2 of otherIndices) {
          firstIndices.add(index2);
        }
        faceEdgesMap.delete(faceID);
      }
    }
    for (const [_faceID, { indices: indices2, edges }] of faceEdgesMap) {
      if (indices2.has(triangleIndex)) {
        const foundEdges = [];
        for (const edgeID of edges) {
          const foundEdge = allEdges.get(edgeID);
          foundEdges.push(foundEdge);
        }
        return { edges: foundEdges, indices: indices2 };
      }
    }
    return null;
  }
  /**
   * Method to get the vertices and normal of a mesh face at a given index.
   * It also applies instance transformation if provided.
   *
   * @param mesh - The mesh to get the face from. It must be indexed.
   * @param faceIndex - The index of the face within the mesh.
   * @param instance - The instance of the mesh (optional).
   * @returns An object containing the vertices and normal of the face.
   * @throws Will throw an error if the geometry is not indexed.
   */
  getVerticesAndNormal(mesh, faceIndex, instance) {
    if (!mesh.geometry.index) {
      throw new Error("Geometry must be indexed!");
    }
    const indices = mesh.geometry.index.array;
    const pos = mesh.geometry.attributes.position.array;
    const nor = mesh.geometry.attributes.normal.array;
    const i1 = indices[faceIndex * 3] * 3;
    const i2 = indices[faceIndex * 3 + 1] * 3;
    const i3 = indices[faceIndex * 3 + 2] * 3;
    const p1 = new Vector3(pos[i1], pos[i1 + 1], pos[i1 + 2]);
    const p2 = new Vector3(pos[i2], pos[i2 + 1], pos[i2 + 2]);
    const p3 = new Vector3(pos[i3], pos[i3 + 1], pos[i3 + 2]);
    const n1 = new Vector3(nor[i1], nor[i1 + 1], nor[i1 + 2]);
    const n2 = new Vector3(nor[i2], nor[i2 + 1], nor[i2 + 2]);
    const n3 = new Vector3(nor[i3], nor[i3 + 1], nor[i3 + 2]);
    const averageNx = (n1.x + n2.x + n3.x) / 3;
    const averageNy = (n1.y + n2.y + n3.y) / 3;
    const averageNz = (n1.z + n2.z + n3.z) / 3;
    const faceNormal = new Vector3(averageNx, averageNy, averageNz);
    if (instance !== void 0 && mesh instanceof InstancedMesh) {
      const transform = new Matrix4();
      mesh.getMatrixAt(instance, transform);
      const rotation = new Matrix4();
      rotation.extractRotation(transform);
      faceNormal.applyMatrix4(rotation);
      p1.applyMatrix4(transform);
      p2.applyMatrix4(transform);
      p3.applyMatrix4(transform);
    }
    return { p1, p2, p3, faceNormal };
  }
  /**
   * Method to round the vector's components to a specified number of decimal places.
   * This is used to ensure numerical precision in edge detection.
   *
   * @param vector - The vector to round.
   * @returns The vector with rounded components.
   */
  round(vector) {
    const factor = 1e3;
    vector.x = Math.trunc(vector.x * factor) / factor;
    vector.y = Math.trunc(vector.y * factor) / factor;
    vector.z = Math.trunc(vector.z * factor) / factor;
  }
  /**
   * Calculates the volume of a set of fragments.
   *
   * @param frags - A map of fragment IDs to their corresponding item IDs.
   * @returns The total volume of the fragments and the bounding sphere.
   *
   * @remarks
   * This method creates a set of instanced meshes from the given fragments and item IDs.
   * It then calculates the volume of each mesh and returns the total volume and its bounding sphere.
   *
   * @throws Will throw an error if the geometry of the meshes is not indexed.
   * @throws Will throw an error if the fragment manager is not available.
   */
  getVolumeFromFragments(frags) {
    const fragments = this.components.get(FragmentsManager);
    const tempMatrix22 = new Matrix4();
    const meshes = [];
    for (const fragID in frags) {
      const fragment = fragments.list.get(fragID);
      if (!fragment)
        continue;
      const itemIDs = frags[fragID];
      let instanceCount = 0;
      for (const id of itemIDs) {
        const instances = fragment.getInstancesIDs(id);
        if (!instances)
          continue;
        instanceCount += instances.size;
      }
      const mesh = new InstancedMesh(
        fragment.mesh.geometry,
        void 0,
        instanceCount
      );
      let counter = 0;
      for (const id of itemIDs) {
        const instances = fragment.getInstancesIDs(id);
        if (!instances)
          continue;
        for (const instance of instances) {
          fragment.mesh.getMatrixAt(instance, tempMatrix22);
          mesh.setMatrixAt(counter++, tempMatrix22);
        }
      }
      meshes.push(mesh);
    }
    const result = this.getVolumeFromMeshes(meshes);
    for (const mesh of meshes) {
      mesh.geometry = null;
      mesh.material = [];
      mesh.dispose();
    }
    return result;
  }
  /**
   * Calculates the total volume of a set of meshes.
   *
   * @param meshes - An array of meshes or instanced meshes to calculate the volume from.
   * @returns The total volume of the meshes and the bounding sphere.
   *
   * @remarks
   * This method calculates the volume of each mesh in the provided array and returns the total volume
   * and its bounding sphere.
   *
   */
  getVolumeFromMeshes(meshes) {
    let volume = 0;
    for (const mesh of meshes) {
      volume += this.getVolumeOfMesh(mesh);
    }
    return volume;
  }
  getFaceData(faceIndex, instance, mesh) {
    const found = this.getVerticesAndNormal(mesh, faceIndex, instance);
    const { p1, p2, p3, faceNormal } = found;
    this.round(p1);
    this.round(p2);
    this.round(p3);
    this.round(faceNormal);
    const vertices = [
      { id: `${p1.x}|${p1.y}|${p1.z}`, value: p1 },
      { id: `${p2.x}|${p2.y}|${p2.z}`, value: p2 },
      { id: `${p3.x}|${p3.y}|${p3.z}`, value: p3 }
    ];
    vertices.sort((a, b) => {
      if (a.id < b.id) {
        return -1;
      }
      if (a.id > b.id) {
        return 1;
      }
      return 0;
    });
    const [
      { id: id1, value: v1 },
      { id: id2, value: v2 },
      { id: id3, value: v3 }
    ] = vertices;
    const edges = [
      {
        id: `${id1}|${id2}`,
        distance: v1.distanceTo(v2),
        points: [v1, v2]
      },
      {
        id: `${id2}|${id3}`,
        distance: v2.distanceTo(v3),
        points: [v2, v3]
      },
      {
        id: `${id1}|${id3}`,
        distance: v1.distanceTo(v3),
        points: [v1, v3]
      }
    ];
    const plane = new Plane();
    plane.setFromNormalAndCoplanarPoint(faceNormal, p1);
    plane.constant = Math.round(plane.constant * 10) / 10;
    return { plane, edges };
  }
  // https://stackoverflow.com/a/1568551
  getVolumeOfMesh(mesh) {
    let volume = 0;
    const p1 = new Vector3();
    const p2 = new Vector3();
    const p3 = new Vector3();
    const { index } = mesh.geometry;
    const pos = mesh.geometry.attributes.position.array;
    if (!index) {
      console.warn("Geometry must be indexed to compute its volume!");
      return 0;
    }
    const instances = [];
    if (mesh instanceof InstancedMesh) {
      for (let i = 0; i < mesh.count; i++) {
        const matrix = new Matrix4();
        mesh.getMatrixAt(i, matrix);
        instances.push(matrix);
      }
    } else {
      instances.push(new Matrix4().identity());
    }
    const { matrixWorld } = mesh;
    for (let i = 0; i < index.array.length - 2; i += 3) {
      for (const instance of instances) {
        const transform = instance.multiply(matrixWorld);
        const i1 = index.array[i] * 3;
        const i2 = index.array[i + 1] * 3;
        const i3 = index.array[i + 2] * 3;
        p1.set(pos[i1], pos[i1 + 1], pos[i1 + 2]).applyMatrix4(transform);
        p2.set(pos[i2], pos[i2 + 1], pos[i2 + 2]).applyMatrix4(transform);
        p3.set(pos[i3], pos[i3 + 1], pos[i3 + 2]).applyMatrix4(transform);
        volume += this.getSignedVolumeOfTriangle(p1, p2, p3);
      }
    }
    return Math.abs(volume);
  }
  getSignedVolumeOfTriangle(p1, p2, p3) {
    const v321 = p3.x * p2.y * p1.z;
    const v231 = p2.x * p3.y * p1.z;
    const v312 = p3.x * p1.y * p2.z;
    const v132 = p1.x * p3.y * p2.z;
    const v213 = p2.x * p1.y * p3.z;
    const v123 = p1.x * p2.y * p3.z;
    return 1 / 6 * (-v321 + v231 + v312 - v132 - v213 + v123);
  }
};
__publicField2(_MeasurementUtils, "uuid", "267ca032-672f-4cb0-afa9-d24e904f39d6");
var MeasurementUtils = _MeasurementUtils;
var IDSFacet = class {
  constructor(components) {
    __publicField2(this, "cardinality", "required");
    __publicField2(this, "instructions");
    __publicField2(this, "evalRequirement", (value, facetParameter, parameter, checks) => {
      const checkLog = {
        parameter,
        currentValue: value,
        requiredValue: facetParameter.parameter,
        pass: false
      };
      if (checks)
        this.addCheckResult(checkLog, checks);
      let pass = false;
      if (facetParameter.type === "simple") {
        pass = value === facetParameter.parameter;
      }
      if (facetParameter.type === "enumeration") {
        pass = facetParameter.parameter.includes(value);
      }
      if (facetParameter.type === "pattern") {
        const regex = new RegExp(facetParameter.parameter);
        pass = regex.test(String(value));
      }
      if (facetParameter.type === "length") {
        const { min, length, max } = facetParameter.parameter;
        if (length !== void 0) {
          pass = String(value).length === length;
        }
        if (min !== void 0) {
          pass = String(value).length >= min;
        }
        if (max !== void 0) {
          pass = String(value).length <= max;
        }
      }
      if (facetParameter.type === "bounds" && typeof value === "number") {
        const { min, minInclusive, max, maxInclusive } = facetParameter.parameter;
        let minPass = true;
        let maxPass = true;
        if (min !== void 0) {
          minPass = minInclusive ? value >= min : value > min;
        }
        if (max !== void 0) {
          maxPass = maxInclusive ? value <= max : value < max;
        }
        pass = minPass && maxPass;
      }
      if (this.cardinality === "prohibited")
        pass = !pass;
      if (this.cardinality === "optional")
        pass = true;
      checkLog.pass = pass;
      return checkLog.pass;
    });
    __publicField2(this, "testResult", []);
    this.components = components;
  }
  addCheckResult(check, checks) {
    const index = checks.findIndex(
      ({ parameter }) => parameter === check.parameter
    );
    if (index !== -1) {
      checks[index] = check;
    } else {
      checks.push(check);
    }
  }
  saveResult(attrs, pass) {
    const { GlobalId } = attrs;
    if (!GlobalId)
      return;
    const { value: guid } = GlobalId;
    const result = {
      expressID: guid,
      pass,
      checks: [],
      cardinality: this.cardinality
    };
    this.testResult.push(result);
  }
};
var getParameterXML = (name, parameter) => {
  let parameterXML = "";
  if (!parameter)
    return parameterXML;
  if (parameter.type === "simple") {
    parameterXML = `<simpleValue>${parameter.parameter}</simpleValue>`;
  }
  if (parameter.type === "enumeration") {
    const value = parameter.parameter;
    parameterXML = `<xs:restriction base="xs:string">
    ${value.map((v) => `<xs:enumeration value="${v}" />`).join("\n")}
    </xs:restriction>`;
  }
  if (parameter.type === "pattern") {
    const value = parameter.parameter;
    parameterXML = `<xs:restriction base="xs:string">
      <xs:pattern value="${value}" />
    </xs:restriction>`;
  }
  if (parameter.type === "bounds") {
    const { min, minInclusive, max, maxInclusive } = parameter.parameter;
    let minTag = "";
    if (min !== void 0) {
      minTag = `<xs:min${minInclusive ? "Inclusive" : "Exclusive"} value="${min}">`;
    }
    let maxTag = "";
    if (max !== void 0) {
      maxTag = `<xs:max${maxInclusive ? "Inclusive" : "Exclusive"} value="${max}">`;
    }
    parameterXML = `<xs:restriction base="xs:double">
      ${minTag}
      ${maxTag}
    </xs:restriction>`;
  }
  if (parameter.type === "length") {
    const { length, min, max } = parameter.parameter;
    let lengthTag = "";
    if (length !== void 0 && min === void 0 && max === void 0) {
      lengthTag = `<xs:length value="${length}" />`;
    }
    let minTag = "";
    if (min !== void 0 && length === void 0) {
      minTag = `<xs:minLength value="${min}" />`;
    }
    let maxTag = "";
    if (max !== void 0 && length === void 0) {
      maxTag = `<xs:maxLength value="${max}" />`;
    }
    parameterXML = `<xs:restriction base="xs:string">
      ${lengthTag}
      ${minTag}
      ${maxTag}
    </xs:restriction>`;
  }
  const xml = `<${name[0].toLowerCase() + name.slice(1)}>
    ${parameterXML}
  </${name[0].toLowerCase() + name.slice(1)}>`;
  return xml;
};
var IDSAttribute = class extends IDSFacet {
  constructor(components, name) {
    super(components);
    __publicField2(this, "facetType", "Attribute");
    __publicField2(this, "name");
    __publicField2(this, "value");
    this.name = name;
  }
  serialize(type) {
    const nameXML = getParameterXML("Name", this.name);
    const valueXML = getParameterXML("Value", this.value);
    let attributes = "";
    if (type === "requirement") {
      attributes += `cardinality="${this.cardinality}"`;
      attributes += this.instructions ? `instructions="${this.instructions}"` : "";
    }
    return `<attribute ${attributes}>
  ${nameXML}
  ${valueXML}
</attribute>`;
  }
  // This can be very ineficcient as we do not have an easy way to get an entity based on an attribute
  // Right now, all entities must be iterated.
  // When the new IfcEntitiesFinder comes, this can become easier.
  // This may be greatly increase in performance if the applicability has any of the other facets and this is applied the latest
  async getEntities() {
    return [];
  }
  // async getEntities(
  //   model: FRAGS.FragmentsGroup,
  //   collector: FRAGS.IfcProperties = {},
  // ) {
  //   return [];
  //   // for (const expressID in model) {
  //   //   if (collector[expressID]) continue;
  //   //   const entity = model[expressID];
  //   //   // Check if the attribute exists
  //   //   const attribute = entity[this.name];
  //   //   const attributeExists = !!attribute;
  //   //   // Check if the attribute value matches
  //   //   let valueMatches = true;
  //   //   if (attributeExists && this.value && this.value.value) {
  //   //     if (this.value.type === "simpleValue") {
  //   //       valueMatches = attribute.value === this.value.value;
  //   //     }
  //   //     if (this.value.type === "restriction") {
  //   //       const regex = new RegExp(this.value.value);
  //   //       valueMatches = regex.test(attribute.value);
  //   //     }
  //   //   }
  //   //   if (attributeExists && valueMatches) {
  //   //     collector[entity.expressID] = entity;
  //   //   }
  //   // }
  // }
  // https://github.com/buildingSMART/IDS/tree/development/Documentation/ImplementersDocumentation/TestCases/attribute
  // Test cases from buildingSMART repo have been tested and they all match with the expected result
  // All invalid cases have been treated as failures
  // FragmentsGroup do not hold some of the entities used in the tests
  async test(entities) {
    var _a;
    this.testResult = [];
    for (const _expressID in entities) {
      const expressID = Number(_expressID);
      const attrs = entities[expressID];
      const checks = [];
      const result2 = {
        guid: (_a = attrs.GlobalId) == null ? void 0 : _a.value,
        expressID,
        pass: false,
        checks,
        cardinality: this.cardinality
      };
      this.testResult.push(result2);
      const attrNames = Object.keys(attrs);
      const matchingAttributes = attrNames.filter((name) => {
        const nameMatches = this.evalRequirement(name, this.name, "Name");
        const attrValue = attrs[name];
        if (nameMatches && attrValue === null) {
          if (this.cardinality === "optional" || this.cardinality === "prohibited") {
            return true;
          }
          return false;
        }
        if (nameMatches && (attrValue == null ? void 0 : attrValue.type) === 3 && attrValue.value === 2) {
          return false;
        }
        if (nameMatches && Array.isArray(attrValue) && attrValue.length === 0) {
          return false;
        }
        if (nameMatches && (attrValue == null ? void 0 : attrValue.type) === 1 && attrValue.value.trim() === "") {
          return false;
        }
        return nameMatches;
      });
      const attributeMatches = matchingAttributes.length > 0;
      checks.push({
        parameter: "Name",
        currentValue: attributeMatches ? matchingAttributes[0] : null,
        requiredValue: this.name.parameter,
        pass: this.cardinality === "prohibited" ? !attributeMatches : attributeMatches
      });
      if (this.value) {
        if (matchingAttributes[0]) {
          const attribute = attrs[matchingAttributes[0]];
          const isRef = (attribute == null ? void 0 : attribute.type) === 5;
          if (isRef) {
            checks.push({
              parameter: "Value",
              currentValue: null,
              requiredValue: this.value.parameter,
              pass: this.cardinality === "prohibited"
            });
          } else {
            this.evalRequirement(
              attribute ? attribute.value : null,
              this.value,
              "Value",
              checks
            );
          }
        } else {
          checks.push({
            parameter: "Value",
            currentValue: null,
            requiredValue: this.value.parameter,
            pass: this.cardinality === "prohibited"
          });
        }
      }
      result2.pass = checks.every(({ pass }) => pass);
    }
    const result = [...this.testResult];
    this.testResult = [];
    return result;
  }
};
var IDSClassification = class extends IDSFacet {
  constructor(components, system) {
    super(components);
    __publicField2(this, "facetType", "Classification");
    __publicField2(this, "system");
    __publicField2(this, "value");
    __publicField2(this, "uri");
    this.system = system;
  }
  serialize(type) {
    const systemXML = getParameterXML("System", this.system);
    const valueXML = getParameterXML("Value", this.value);
    let attributes = "";
    if (type === "requirement") {
      attributes += `cardinality="${this.cardinality}"`;
      attributes += this.uri ? `uri=${this.uri}` : "";
      attributes += this.instructions ? `instructions="${this.instructions}"` : "";
    }
    return `<classification ${attributes}>
  ${systemXML}
  ${valueXML}
</classification>`;
  }
  async getEntities(model, collector = {}) {
    var _a;
    const result = [];
    const references = await model.getAllPropertiesOfType(
      IFCCLASSIFICATIONREFERENCE
    );
    const classifications = await model.getAllPropertiesOfType(
      IFCCLASSIFICATION
    );
    const systems = { ...references, ...classifications };
    const matchingClassifications = [];
    for (const id in systems) {
      const classificationID = Number(id);
      const attrs = await model.getProperties(classificationID);
      if (!attrs)
        continue;
      const referencedSourceID = (_a = attrs.ReferencedSource) == null ? void 0 : _a.value;
      if (!referencedSourceID)
        continue;
      const classificationAttrs = await model.getProperties(referencedSourceID);
      if (!classificationAttrs)
        continue;
      const systemMatches = this.evalSystem(classificationAttrs);
      if (!systemMatches)
        continue;
      const valueMatches = this.evalValue(attrs);
      if (!valueMatches)
        continue;
      const uriMatches = this.evalURI(attrs);
      if (!uriMatches)
        continue;
      matchingClassifications.push(classificationID);
    }
    const indexer = this.components.get(IfcRelationsIndexer);
    for (const classificationID of matchingClassifications) {
      const expressIDs = indexer.getEntitiesWithRelation(
        model,
        "HasAssociations",
        classificationID
      );
      for (const expressID of expressIDs) {
        if (expressID in collector)
          continue;
        const attrs = await model.getProperties(expressID);
        if (!attrs)
          continue;
        collector[expressID] = attrs;
        result.push(expressID);
      }
    }
    return result;
  }
  async test(entities, model) {
    var _a;
    this.testResult = [];
    for (const _expressID in entities) {
      const expressID = Number(_expressID);
      const attrs = entities[expressID];
      const checks = [];
      const result2 = {
        guid: (_a = attrs.GlobalId) == null ? void 0 : _a.value,
        expressID,
        pass: false,
        checks,
        cardinality: this.cardinality
      };
      this.testResult.push(result2);
      let missingClassification = true;
      const elementClassifications = await this.getSystems(model, expressID);
      const allSystemNames = elementClassifications.map((classification) => this.getSystemName(classification)).filter((system) => system);
      for (const classificationAttrs of elementClassifications) {
        const systemMatches = this.evalSystem(classificationAttrs, checks);
        if (!systemMatches)
          continue;
        missingClassification = false;
        if (!(this.value && this.system))
          break;
        if (classificationAttrs.type !== IFCCLASSIFICATIONREFERENCE) {
          continue;
        }
        const valueMatches = !this.value || this.evalValue(classificationAttrs, checks);
        const uriMatches = !this.uri || this.evalURI(classificationAttrs, checks);
        if (valueMatches && uriMatches)
          break;
      }
      if (missingClassification) {
        this.addCheckResult(
          {
            parameter: "System",
            currentValue: allSystemNames,
            requiredValue: this.system,
            pass: this.cardinality === "optional"
          },
          checks
        );
      }
      result2.pass = checks.every(({ pass }) => pass);
    }
    const result = [...this.testResult];
    this.testResult = [];
    return result;
  }
  async processReferencedSource(model, attrs) {
    var _a;
    const sourceID = (_a = attrs.ReferencedSource) == null ? void 0 : _a.value;
    if (!sourceID)
      return null;
    const sourceAttrs = await model.getProperties(sourceID);
    if (!sourceAttrs)
      return null;
    if (sourceAttrs.type === IFCCLASSIFICATIONREFERENCE) {
      sourceAttrs.ReferencedSource = await this.processReferencedSource(
        model,
        sourceAttrs
      );
    }
    return sourceAttrs;
  }
  async getSystems(model, expressID) {
    var _a;
    const result = [];
    const indexer = this.components.get(IfcRelationsIndexer);
    const ocurrenceAssociations = indexer.getEntityRelations(
      model,
      expressID,
      "HasAssociations"
    );
    if (ocurrenceAssociations) {
      for (const id of ocurrenceAssociations) {
        const attrs = await model.getProperties(id);
        if (!attrs)
          continue;
        if (attrs.type === IFCCLASSIFICATION) {
          result.push(attrs);
        }
        if (attrs.type === IFCCLASSIFICATIONREFERENCE) {
          attrs.ReferencedSource = await this.processReferencedSource(
            model,
            attrs
          );
          if (attrs.ReferencedSource)
            result.push(attrs);
        }
      }
    }
    const occurrenceSystems = result.map((attrs) => {
      var _a2, _b, _c;
      if (attrs.type === IFCCLASSIFICATION) {
        return (_a2 = attrs.Name) == null ? void 0 : _a2.value;
      }
      if (attrs.type === IFCCLASSIFICATIONREFERENCE) {
        return (_c = (_b = attrs.ReferencedSource) == null ? void 0 : _b.Name) == null ? void 0 : _c.value;
      }
      return null;
    }).filter((name) => name);
    const types = indexer.getEntityRelations(model, expressID, "IsTypedBy");
    if (!(types && types[0]))
      return result;
    const type = types[0];
    const typeAssociations = indexer.getEntityRelations(
      model,
      type,
      "HasAssociations"
    );
    if (typeAssociations) {
      for (const id of typeAssociations) {
        const attrs = await model.getProperties(id);
        if (!attrs)
          continue;
        if (attrs.type === IFCCLASSIFICATION) {
          if (occurrenceSystems.includes((_a = attrs.Name) == null ? void 0 : _a.value))
            continue;
          result.push(attrs);
        }
        if (attrs.type === IFCCLASSIFICATIONREFERENCE) {
          attrs.ReferencedSource = await this.processReferencedSource(
            model,
            attrs
          );
          if (attrs.ReferencedSource)
            result.push(attrs);
        }
      }
    }
    return result;
  }
  getSystemName(attrs) {
    var _a, _b, _c, _d;
    if (attrs.type === IFCCLASSIFICATION) {
      return (_a = attrs.Name) == null ? void 0 : _a.value;
    }
    if (attrs.type === IFCCLASSIFICATIONREFERENCE) {
      if (((_b = attrs.ReferencedSource) == null ? void 0 : _b.type) === IFCCLASSIFICATIONREFERENCE) {
        return this.getSystemName(attrs.ReferencedSource);
      }
      if (((_c = attrs.ReferencedSource) == null ? void 0 : _c.type) === IFCCLASSIFICATION) {
        return (_d = attrs.ReferencedSource.Name) == null ? void 0 : _d.value;
      }
    }
    return null;
  }
  getAllReferenceIdentifications(attrs) {
    if (attrs.type !== IFCCLASSIFICATIONREFERENCE)
      return null;
    const identifications = [];
    if (attrs.Identification)
      identifications.push(attrs.Identification.value);
    if (attrs.ReferencedSource) {
      const identification = this.getAllReferenceIdentifications(
        attrs.ReferencedSource
      );
      if (identification)
        identifications.push(...identification);
    }
    return identifications;
  }
  evalSystem(attrs, checks) {
    const name = this.getSystemName(attrs);
    return this.evalRequirement(name, this.system, "System", checks);
  }
  evalValue(attrs, checks) {
    if (!this.value)
      return true;
    const identifications = this.getAllReferenceIdentifications(attrs);
    if (!identifications)
      return false;
    const identifier = identifications.find((id) => {
      if (!this.value)
        return false;
      return this.evalRequirement(id, this.value, "Value");
    });
    if (checks) {
      this.addCheckResult(
        {
          parameter: "Value",
          currentValue: identifier ?? null,
          requiredValue: this.value,
          pass: !!identifier
        },
        checks
      );
    }
    return !!identifier;
  }
  evalURI(attrs, checks) {
    var _a;
    if (!this.uri)
      return true;
    const result = this.evalRequirement(
      (_a = attrs.Location) == null ? void 0 : _a.value,
      {
        type: "simple",
        parameter: this.uri
      },
      "URI",
      checks
    );
    return result;
  }
};
var IDSEntity = class extends IDSFacet {
  constructor(components, name) {
    super(components);
    __publicField2(this, "facetType", "Entity");
    __publicField2(this, "name");
    __publicField2(this, "predefinedType");
    this.name = name;
  }
  serialize(type) {
    const nameXML = getParameterXML("Name", this.name);
    const predefinedTypeXML = getParameterXML("Name", this.predefinedType);
    let attributes = "";
    if (type === "requirement") {
      attributes += `cardinality="${this.cardinality}"`;
      attributes += this.instructions ? `instructions="${this.instructions}"` : "";
    }
    return `<entity ${attributes}>
  ${nameXML}
  ${predefinedTypeXML}
</entity>`;
  }
  // IFCSURFACESTYLEREFRACTION is not present in the FragmentsGroup
  // IFCSURFACESTYLERENDERING is not present in the FragmentsGroup
  async getEntities(model, collector = {}) {
    const types = Object.entries(IfcCategoryMap);
    const typeIDs = [];
    for (const [type] of types) {
      const validName = await this.evalName({ type });
      if (!validName)
        continue;
      typeIDs.push(Number(type));
    }
    let entities = {};
    for (const id of typeIDs) {
      const elements = await model.getAllPropertiesOfType(id);
      if (elements)
        entities = { ...entities, ...elements };
    }
    if (!this.predefinedType) {
      for (const expressID in entities) {
        if (expressID in collector)
          continue;
        collector[expressID] = entities[expressID];
      }
      return Object.keys(entities).map(Number);
    }
    const result = [];
    for (const _expressID in entities) {
      const expressID = Number(_expressID);
      if (expressID in collector)
        continue;
      const attrs = entities[expressID];
      const validPredefinedType = await this.evalPredefinedType(model, attrs);
      if (validPredefinedType) {
        collector[expressID] = attrs;
        result.push(expressID);
      }
    }
    return result;
  }
  async test(entities, model) {
    var _a;
    this.testResult = [];
    for (const _expressID in entities) {
      const expressID = Number(_expressID);
      const attrs = entities[expressID];
      const checks = [];
      const result = {
        guid: (_a = attrs.GlobalId) == null ? void 0 : _a.value,
        expressID,
        pass: false,
        checks,
        cardinality: this.cardinality
      };
      this.testResult.push(result);
      await this.evalName(attrs, checks);
      await this.evalPredefinedType(model, attrs, checks);
      result.pass = checks.every(({ pass }) => pass);
    }
    return this.testResult;
  }
  async evalName(attrs, checks) {
    const entityName2 = IfcCategoryMap[attrs.type];
    const result = this.evalRequirement(entityName2, this.name, "Name", checks);
    return result;
  }
  async evalPredefinedType(model, attrs, checks) {
    var _a, _b, _c, _d;
    if (!this.predefinedType)
      return null;
    const indexer = this.components.get(IfcRelationsIndexer);
    const isRequirementUserDefined = typeof this.predefinedType.parameter === "string" && this.predefinedType.parameter === "USERDEFINED";
    let value = (_a = attrs.PredefinedType) == null ? void 0 : _a.value;
    if (value === "USERDEFINED" && !isRequirementUserDefined) {
      const attrNames = Object.keys(attrs);
      const result2 = attrNames.find(
        (str) => /^((?!Predefined).)*Type$/.test(str)
      );
      value = result2 ? (_b = attrs[result2]) == null ? void 0 : _b.value : "USERDEFINED";
    }
    if (!value) {
      const types = indexer.getEntityRelations(
        model,
        attrs.expressID,
        "IsTypedBy"
      );
      if (types && types[0]) {
        const typeAttrs = await model.getProperties(types[0]);
        if (typeAttrs) {
          value = (_c = typeAttrs.PredefinedType) == null ? void 0 : _c.value;
          if (value === "USERDEFINED" && !isRequirementUserDefined) {
            const attrNames = Object.keys(typeAttrs);
            const result2 = attrNames.find(
              (str) => /^((?!Predefined).)*Type$/.test(str)
            );
            value = result2 ? (_d = typeAttrs[result2]) == null ? void 0 : _d.value : "USERDEFINED";
          }
        }
      }
    }
    const result = this.evalRequirement(
      value,
      this.predefinedType,
      "PredefinedType",
      checks
    );
    return result;
  }
};
var IDSProperty = class extends IDSFacet {
  constructor(components, propertySet, baseName) {
    super(components);
    __publicField2(this, "facetType", "Property");
    __publicField2(this, "propertySet");
    __publicField2(this, "baseName");
    __publicField2(this, "value");
    __publicField2(this, "dataType");
    __publicField2(this, "uri");
    __publicField2(this, "_unsupportedTypes", [
      IFCCOMPLEXPROPERTY,
      IFCPHYSICALCOMPLEXQUANTITY
    ]);
    this.propertySet = propertySet;
    this.baseName = baseName;
  }
  serialize(type) {
    const propertySetXML = getParameterXML("PropertySet", this.propertySet);
    const baseNameXML = getParameterXML("BaseName", this.baseName);
    const valueXML = getParameterXML("Value", this.value);
    const dataTypeXML = this.dataType ? `dataType=${this.dataType}` : "";
    let attributes = "";
    if (type === "requirement") {
      attributes += `cardinality="${this.cardinality}"`;
      attributes += this.uri ? `uri=${this.uri}` : "";
      attributes += this.instructions ? `instructions="${this.instructions}"` : "";
    }
    return `<property ${dataTypeXML} ${attributes}>
  ${propertySetXML}
  ${baseNameXML}
  ${valueXML}
</property>`;
  }
  async getEntities(model, collector = {}) {
    var _a, _b;
    let sets = {};
    const psets = await model.getAllPropertiesOfType(IFCPROPERTYSET);
    sets = { ...sets, ...psets };
    const qsets = await model.getAllPropertiesOfType(IFCELEMENTQUANTITY);
    sets = { ...sets, ...qsets };
    if (Object.keys(sets).length === 0)
      return [];
    const matchingSets = [];
    for (const _setID in sets) {
      const setID = Number(_setID);
      const attrs = await model.getProperties(setID);
      if (!attrs)
        continue;
      const nameMatches = ((_a = attrs.Name) == null ? void 0 : _a.value) === this.propertySet.parameter;
      if (!nameMatches)
        continue;
      let propsListName;
      if (attrs.type === IFCPROPERTYSET)
        propsListName = "HasProperties";
      if (attrs.type === IFCELEMENTQUANTITY)
        propsListName = "Quantities";
      if (!propsListName)
        continue;
      for (const handle of attrs[propsListName]) {
        const propAttrs = await model.getProperties(handle.value);
        if (!propAttrs)
          continue;
        const propNameMatches = ((_b = propAttrs.Name) == null ? void 0 : _b.value) === this.baseName.parameter;
        if (!propNameMatches)
          continue;
        if (this.value) {
          const valueKey = Object.keys(propAttrs).find(
            (name) => name.endsWith("Value")
          );
          if (!valueKey)
            continue;
          const valueMatches = propAttrs[valueKey].value === this.value.parameter;
          if (!valueMatches)
            continue;
        }
        matchingSets.push(setID);
      }
    }
    const indexer = this.components.get(IfcRelationsIndexer);
    for (const setID of matchingSets) {
      const expressIDs = indexer.getEntitiesWithRelation(
        model,
        "IsDefinedBy",
        setID
      );
      for (const expressID of expressIDs) {
        if (expressID in collector)
          continue;
        const attrs = await model.getProperties(expressID);
        if (!attrs)
          continue;
        collector[expressID] = attrs;
      }
    }
    return [];
  }
  async test(entities, model) {
    var _a;
    this.testResult = [];
    for (const _expressID in entities) {
      const expressID = Number(_expressID);
      const attrs = entities[expressID];
      const checks = [];
      const result2 = {
        guid: (_a = attrs.GlobalId) == null ? void 0 : _a.value,
        expressID,
        pass: false,
        checks,
        cardinality: this.cardinality
      };
      this.testResult.push(result2);
      const sets = await this.getPsets(model, expressID);
      const matchingSets = sets.filter((set) => {
        const result3 = this.evalRequirement(
          set.Name ?? null,
          this.propertySet,
          "PropertySet"
        );
        if (!result3)
          return false;
        checks.push({
          currentValue: set.Name,
          parameter: "PropertySet",
          pass: true,
          requiredValue: this.propertySet.parameter
        });
        return true;
      });
      if (matchingSets.length === 0) {
        checks.push({
          currentValue: null,
          parameter: "PropertySet",
          pass: false,
          requiredValue: this.propertySet.parameter
        });
        continue;
      }
      for (const set of matchingSets) {
        if (!("Properties" in set)) {
          checks.push({
            currentValue: null,
            parameter: "BaseName",
            pass: false,
            requiredValue: this.baseName.parameter
          });
          continue;
        }
        const items = set.Properties;
        const matchingItems = items.filter((item) => {
          var _a2;
          if (this._unsupportedTypes.includes(item.type)) {
            return false;
          }
          const result3 = this.evalRequirement(
            ((_a2 = item.Name) == null ? void 0 : _a2.value) ?? null,
            this.baseName,
            "BaseName"
          );
          if (!result3)
            return false;
          checks.push({
            currentValue: item.Name.value,
            parameter: "BaseName",
            pass: true,
            requiredValue: this.baseName.parameter
          });
          return true;
        });
        if (matchingItems.length === 0) {
          checks.push({
            currentValue: null,
            parameter: "BaseName",
            pass: false,
            requiredValue: this.baseName.parameter
          });
          continue;
        }
        for (const item of matchingItems) {
          this.evalValue(item, checks);
          this.evalDataType(item, checks);
          this.evalURI();
        }
      }
      result2.pass = checks.every(({ pass }) => pass);
    }
    const result = [...this.testResult];
    this.testResult = [];
    return result;
  }
  getItemsAttrName(type) {
    let propsListName;
    if (type === IFCPROPERTYSET)
      propsListName = "HasProperties";
    if (type === IFCELEMENTQUANTITY)
      propsListName = "Quantities";
    return propsListName;
  }
  getValueKey(attrs) {
    return Object.keys(attrs).find(
      (name) => name.endsWith("Value") || name.endsWith("Values")
    );
  }
  async simplifyPset(model, attrs, propsListName) {
    var _a;
    const props = [];
    const list = attrs[propsListName];
    if (!list)
      return attrs;
    for (const { value } of list) {
      const propAttrs = await model.getProperties(value);
      if (propAttrs)
        props.push(propAttrs);
    }
    const attrsClone = {
      Name: (_a = attrs.Name) == null ? void 0 : _a.value,
      Properties: props,
      type: attrs.type
    };
    return attrsClone;
  }
  async getTypePsets(model, expressID) {
    const sets = [];
    const indexer = this.components.get(IfcRelationsIndexer);
    const types = indexer.getEntityRelations(model, expressID, "IsTypedBy");
    if (!(types && types[0]))
      return sets;
    const typeAttrs = await model.getProperties(types[0]);
    if (!(typeAttrs && "HasPropertySets" in typeAttrs && Array.isArray(typeAttrs.HasPropertySets))) {
      return sets;
    }
    for (const { value } of typeAttrs.HasPropertySets) {
      const psetAttrs = await model.getProperties(value);
      if (!(psetAttrs && "HasProperties" in psetAttrs && Array.isArray(psetAttrs.HasProperties))) {
        continue;
      }
      const pset = await this.simplifyPset(model, psetAttrs, "HasProperties");
      sets.push(pset);
    }
    return sets;
  }
  async getPsets(model, expressID) {
    var _a;
    const typePsets = await this.getTypePsets(model, expressID);
    const indexer = this.components.get(IfcRelationsIndexer);
    const definitions = indexer.getEntityRelations(
      model,
      expressID,
      "IsDefinedBy"
    );
    if (!definitions)
      return typePsets;
    const sets = [];
    for (const definitionID of definitions) {
      const attrs = await model.getProperties(definitionID);
      if (!attrs)
        continue;
      const propsListName = this.getItemsAttrName(attrs.type);
      if (!propsListName)
        continue;
      const occurencePset = await this.simplifyPset(
        model,
        attrs,
        propsListName
      );
      const typePset = typePsets.find(
        ({ Name }) => Name === occurencePset.Name
      );
      if (typePset) {
        for (const prop of typePset.Properties) {
          const name = (_a = prop.Name) == null ? void 0 : _a.value;
          const existingProp = occurencePset.Properties.find(
            ({ Name }) => Name.value === name
          );
          if (!existingProp)
            occurencePset.Properties.push(prop);
        }
      }
      sets.push(occurencePset);
    }
    return sets;
  }
  // IFCPROPERTYBOUNDEDVALUE are not supported yet
  // IFCPROPERTYTABLEVALUE are not supported yet
  // Work must to be done to convert numerical value units to IDS-nominated standard units https://github.com/buildingSMART/IDS/blob/development/Documentation/UserManual/units.md
  evalValue(attrs, checks) {
    const valueKey = this.getValueKey(attrs);
    const valueAttr = attrs[valueKey];
    if (this.value) {
      if (!valueAttr) {
        checks == null ? void 0 : checks.push({
          parameter: "Value",
          currentValue: null,
          pass: false,
          requiredValue: this.value.parameter
        });
        return false;
      }
      const facetValue = structuredClone(this.value);
      if (valueAttr.name === "IFCLABEL" && facetValue.type === "simple") {
        facetValue.parameter = String(facetValue.parameter);
      }
      if ((attrs.type === IFCPROPERTYLISTVALUE || attrs.type === IFCPROPERTYENUMERATEDVALUE) && Array.isArray(valueAttr)) {
        const values = valueAttr.map((value) => value.value);
        const matchingValue = valueAttr.find((value) => {
          if (!facetValue)
            return false;
          return this.evalRequirement(value.value, facetValue, "Value");
        });
        checks == null ? void 0 : checks.push({
          currentValue: values,
          pass: !!matchingValue,
          parameter: "Value",
          requiredValue: facetValue.parameter
        });
        return !!matchingValue;
      }
      const result = this.evalRequirement(
        valueAttr.value,
        facetValue,
        "Value",
        checks
      );
      return result;
    }
    if (!valueKey)
      return true;
    if (valueAttr.type === 3 && valueAttr.value === 2) {
      checks == null ? void 0 : checks.push({
        parameter: "Value",
        currentValue: null,
        pass: false,
        requiredValue: null
      });
      return false;
    }
    if (valueAttr.type === 1 && valueAttr.value.trim() === "") {
      checks == null ? void 0 : checks.push({
        parameter: "Value",
        currentValue: "",
        pass: false,
        requiredValue: null
      });
      return false;
    }
    return true;
  }
  evalDataType(attrs, checks) {
    if (!this.dataType)
      return true;
    const valueKey = this.getValueKey(attrs);
    const valueAttr = attrs[valueKey];
    if (!valueAttr) {
      checks == null ? void 0 : checks.push({
        parameter: "DataType",
        currentValue: null,
        pass: false,
        requiredValue: this.dataType
      });
      return false;
    }
    if ((attrs.type === IFCPROPERTYLISTVALUE || attrs.type === IFCPROPERTYENUMERATEDVALUE) && Array.isArray(valueAttr) && valueAttr[0]) {
      const valueType = valueAttr[0].name;
      const result2 = this.evalRequirement(
        valueType,
        {
          type: "simple",
          parameter: this.dataType
        },
        "DataType",
        checks
      );
      return result2;
    }
    const result = this.evalRequirement(
      valueAttr.name,
      {
        type: "simple",
        parameter: this.dataType
      },
      "DataType",
      checks
    );
    return result;
  }
  evalURI() {
    return true;
  }
};
var IDSSpecification = class {
  constructor(components, name, ifcVersion) {
    __publicField2(this, "name");
    __publicField2(this, "ifcVersion", /* @__PURE__ */ new Set());
    __publicField2(this, "identifier", UUID.create());
    __publicField2(this, "description");
    __publicField2(this, "instructions");
    __publicField2(this, "requirementsDescription");
    __publicField2(this, "applicability", new DataSet());
    __publicField2(this, "requirements", new DataSet());
    __publicField2(this, "components");
    this.components = components;
    this.name = name;
    for (const version of ifcVersion) {
      this.ifcVersion.add(version);
    }
  }
  set(data) {
    const _data = data;
    const _this = this;
    for (const key in data) {
      if (key === "identifier")
        continue;
      const value = _data[key];
      if (key in this)
        _this[key] = value;
    }
    const manager = this.components.get(IDSSpecifications);
    manager.list.set(this.identifier, this);
    return this;
  }
  /**
   * Tests the model to test against the specification's requirements.
   *
   * @param model - The model to be tested.
   * @returns An array representing the test results.
   * If no requirements are defined for the specification, an empty array is returned.
   */
  async test(model) {
    let result = [];
    if (this.requirements.size === 0)
      return result;
    const entities = {};
    for (const facet of this.applicability) {
      await facet.getEntities(model, entities);
    }
    const requirement = [...this.requirements][0];
    result = await requirement.test(entities, model);
    return result;
  }
  /**
   * Serializes the IDSSpecification instance into XML format.
   *
   * @remarks This method is not meant to be used directly. It is used by the IDSSpecifications component.
   *
   * @returns The XML representation of the IDSSpecification.
   */
  serialize() {
    const name = `name="${this.name}"`;
    const identifier = this.identifier ? `identifier="${this.identifier}"` : "";
    const description = this.description ? `description="${this.description}"` : "";
    const instructions = this.instructions ? `instructions="${this.instructions}"` : "";
    const xml = `<specification ifcVersion="${[...this.ifcVersion].join(" ")}" ${name} ${identifier} ${description} ${instructions}>
      <applicability minOccurs="1" maxOccurs="unbounded">
        ${[...this.applicability].map((facet) => facet.serialize("applicability")).join("\n")}
      </applicability>
      <requirements>
        ${[...this.requirements].map((facet) => facet.serialize("requirement")).join("\n")}
      </requirements>
    </specification>`;
    return xml;
  }
};
var getParameterValue = (property) => {
  if (!property)
    return void 0;
  const result = {};
  if ("simpleValue" in property) {
    result.type = "simple";
    result.parameter = property.simpleValue;
  }
  if ("restriction" in property) {
    const restriction = property.restriction;
    if ("pattern" in restriction) {
      result.type = "pattern";
      result.parameter = restriction.pattern.value;
    }
    if ("enumeration" in restriction) {
      result.type = "enumeration";
      const enumeration = restriction.enumeration.map(
        ({ value }) => value
      );
      result.parameter = enumeration;
    }
  }
  if (result.parameter === void 0)
    return void 0;
  return result;
};
var createEntityFacets = (components, elements) => {
  const facets = [];
  for (const element of elements) {
    const nameParameter = element.name;
    const name = getParameterValue(nameParameter);
    if (!name)
      continue;
    const facet = new IDSEntity(components, name);
    if (element.cardinality)
      facet.cardinality = element.cardinality;
    facet.predefinedType = getParameterValue(element.predefinedType);
    facet.instructions = element.instructions;
    facets.push(facet);
  }
  return facets;
};
var createAttributeFacets = (components, elements) => {
  const facets = [];
  for (const element of elements) {
    const nameParameter = element.name;
    const name = getParameterValue(nameParameter);
    if (!name)
      continue;
    const facet = new IDSAttribute(components, name);
    if (element.cardinality)
      facet.cardinality = element.cardinality;
    facet.value = getParameterValue(element.value);
    facet.instructions = element.instructions;
    facets.push(facet);
  }
  return facets;
};
var createClassificationFacets = (components, elements) => {
  const facets = [];
  for (const element of elements) {
    const systemParameter = element.system;
    const system = getParameterValue(systemParameter);
    if (!system)
      continue;
    const facet = new IDSClassification(components, system);
    if (element.cardinality)
      facet.cardinality = element.cardinality;
    const value = getParameterValue(element.value);
    if ((value == null ? void 0 : value.type) === "simple") {
      value.parameter = String(value.parameter);
    }
    if ((value == null ? void 0 : value.type) === "enumeration" && Array.isArray(value.parameter)) {
      value.parameter = value.parameter.map(String);
    }
    facet.value = value;
    facet.uri = element.uri;
    facet.instructions = element.instructions;
    facets.push(facet);
  }
  return facets;
};
var createPropertyFacets = (components, elements) => {
  const facets = [];
  for (const element of elements) {
    const psetParameter = element.propertySet;
    const baseNameParameter = element.baseName;
    const pset = getParameterValue(psetParameter);
    const baseName = getParameterValue(baseNameParameter);
    if (!(baseName && pset))
      continue;
    const facet = new IDSProperty(components, pset, baseName);
    if (element.cardinality)
      facet.cardinality = element.cardinality;
    const value = getParameterValue(element.value);
    if ((value == null ? void 0 : value.type) === "enumeration" && Array.isArray(value.parameter)) {
      value.parameter = value.parameter.map(String);
    }
    facet.value = value;
    facet.dataType = element.dataType;
    facet.uri = element.uri;
    facet.instructions = element.instructions;
    facets.push(facet);
  }
  return facets;
};
var _IDSSpecifications = class _IDSSpecifications2 extends Component {
  constructor(components) {
    super(components);
    __publicField2(this, "enabled", true);
    __publicField2(this, "list", new DataMap());
    components.add(_IDSSpecifications2.uuid, this);
  }
  /**
   * Retrieves a FragmentIdMap based on the given IDSCheckResult array.
   * The map separates the IDs into two categories: pass and fail.
   *
   * @param model - The FragmentsGroup model from which to retrieve the fragment map.
   * @param result - An array of IDSCheckResult objects, each representing a check result.
   *
   * @returns An object containing two properties:
   * - `pass`: A FragmentIdMap that passed the checks.
   * - `fail`: A FragmentIdMap that failed the checks.
   */
  getFragmentIdMap(model, result) {
    const passResults = result.filter((check) => check.pass);
    const passIDs = passResults.map((check) => check.expressID);
    const pass = model.getFragmentMap(passIDs);
    const failResults = result.filter((check) => !check.pass);
    const failIDs = failResults.map((check) => check.expressID);
    const fail = model.getFragmentMap(failIDs);
    return { pass, fail };
  }
  /**
   * Creates a new IDSSpecification instance and adds it to the list.
   *
   * @param name - The name of the IDSSpecification.
   * @param ifcVersion - An array of IfcVersion values that the specification supports.
   *
   * @returns The newly created IDSSpecification instance.
   */
  create(name, ifcVersion, identifier) {
    const specification = new IDSSpecification(
      this.components,
      name,
      ifcVersion
    );
    if (identifier)
      specification.identifier = identifier;
    this.list.set(specification.identifier, specification);
    return specification;
  }
  /**
   * Parses and processes an XML string containing Information Delivery Specification (IDS) data.
   * It creates IDSSpecification instances based on the parsed data and returns them in an array.
   * Also, the instances are added to the list array.
   *
   * @param data - The XML string to parse.
   *
   * @returns An array of IDSSpecification instances created from the parsed data.
   */
  load(data) {
    const result = [];
    const ids = _IDSSpecifications2.xmlParser.parse(data).ids;
    const { specifications } = ids;
    if (specifications && specifications.specification) {
      const specs = Array.isArray(specifications.specification) ? specifications.specification : [specifications.specification];
      for (const spec of specs) {
        const { name, ifcVersion, description, instructions, identifier } = spec;
        if (!(name && ifcVersion))
          continue;
        const applicabilities = [];
        const reqs = [];
        const { applicability, requirements } = spec;
        if (applicability) {
          const { maxOccurs, ...rest } = applicability;
          const facets = Array.isArray(rest) ? rest : [rest];
          for (const facet of facets) {
            for (const facetName in facet) {
              const elements = Array.isArray(facet[facetName]) ? facet[facetName] : [facet[facetName]];
              if (facetName === "entity") {
                const facets2 = createEntityFacets(this.components, elements);
                applicabilities.push(...facets2);
              }
            }
          }
        }
        let requirementsDescription;
        if (requirements) {
          const { maxOccurs, ...rest } = requirements;
          requirementsDescription = requirements.description;
          const facets = Array.isArray(rest) ? rest : [rest];
          for (const facet of facets) {
            for (const facetName in facet) {
              const elements = Array.isArray(facet[facetName]) ? facet[facetName] : [facet[facetName]];
              if (facetName === "entity") {
                const facets2 = createEntityFacets(this.components, elements);
                reqs.push(...facets2);
              }
              if (facetName === "attribute") {
                const facets2 = createAttributeFacets(this.components, elements);
                reqs.push(...facets2);
              }
              if (facetName === "classification") {
                const facets2 = createClassificationFacets(
                  this.components,
                  elements
                );
                reqs.push(...facets2);
              }
              if (facetName === "property") {
                const facets2 = createPropertyFacets(this.components, elements);
                reqs.push(...facets2);
              }
            }
          }
        }
        if (applicabilities.length > 0 && reqs.length > 0) {
          const specification = this.create(
            name,
            ifcVersion.split(/\s+/),
            identifier
          );
          specification.description = description;
          specification.instructions = instructions;
          specification.requirementsDescription = requirementsDescription;
          specification.applicability.add(...applicabilities);
          specification.requirements.add(...reqs);
          result.push(specification);
        }
      }
    }
    return result;
  }
  /**
   * Exports the IDSSpecifications data into an XML string.
   *
   * @param info - The metadata information for the exported XML.
   * @param specifications - An optional iterable of IDSSpecification instances to export.
   * If not provided, all specifications in the list will be exported.
   *
   * @returns A string containing the exported IDSSpecifications data in XML format.
   */
  export(info, specifications = this.list.values()) {
    const _specifications = specifications ?? this.list;
    const xml = `<ids xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://standards.buildingsmart.org/IDS http://standards.buildingsmart.org/IDS/1.0/ids.xsd" xmlns:ids="http://standards.buildingsmart.org/IDS">
  <!-- Made with That Open Engine ${Components.release} (https://github.com/thatopen/engine_components) -->
  <info>
    <title>${info.title}</title>
    ${info.copyright ? `<copyright>${info.copyright}</copyright>` : ""}
    ${info.version ? `<version>${info.version}</version>` : ""}
    ${info.description ? `<description>${info.description}</description>` : ""}
    ${info.author ? `<author>${info.author}</author>` : ""}
    ${info.date ? `<date>${info.date.toISOString().split("T")[0]}</date>` : ""}
    ${info.purpose ? `<purpose>${info.purpose}</purpose>` : ""}
    ${info.milestone ? `<milestone>${info.milestone}</milestone>` : ""}
  </info>
  <specifications>
    ${[..._specifications].map((spec) => spec.serialize()).join("\n")}
  </specifications>
</ids>`;
    return xml;
  }
};
__publicField2(_IDSSpecifications, "uuid", "9f0b9f78-9b2e-481a-b766-2fbfd01f342c");
__publicField2(_IDSSpecifications, "xmlParser", new fxp.XMLParser({
  allowBooleanAttributes: true,
  attributeNamePrefix: "",
  ignoreAttributes: false,
  ignoreDeclaration: true,
  ignorePiTags: true,
  numberParseOptions: { leadingZeros: true, hex: true },
  parseAttributeValue: true,
  preserveOrder: false,
  processEntities: false,
  removeNSPrefix: true,
  trimValues: true
}));
var IDSSpecifications = _IDSSpecifications;
export {
  AsyncEvent,
  BCFTopics,
  BCFTopicsConfigManager,
  Base,
  BaseCamera,
  BaseRenderer,
  BaseScene,
  BaseWorldItem,
  BoundingBoxer,
  Classifier,
  Clipper,
  Comment,
  Component,
  ComponentWithUI,
  Components,
  ConfigManager,
  Configurator,
  ControlsUtils,
  CullerRenderer,
  Cullers,
  DataMap,
  DataSet,
  Disposer,
  Event,
  EventManager,
  Exploder,
  FirstPersonMode,
  FragmentsManager,
  GeometryTypes,
  Grids,
  Hider,
  IDSAttribute,
  IDSClassification,
  IDSEntity,
  IDSFacet,
  IDSProperty,
  IDSSpecification,
  IDSSpecifications,
  IfcBasicQuery,
  IfcCategories,
  IfcCategoryMap,
  IfcElements,
  IfcFinder,
  IfcFinderQuery,
  IfcFragmentSettings,
  IfcGeometryTiler,
  IfcIsolator,
  IfcJsonExporter,
  IfcLoader,
  IfcPropertiesManager,
  IfcPropertiesTiler,
  IfcPropertiesUtils,
  IfcPropertyQuery,
  IfcRelationsIndexer,
  IfcStreamingSettings,
  MaterialsUtils,
  MeasurementUtils,
  MeshCullerRenderer,
  MiniMap,
  MiniMapConfigManager,
  MiniMaps,
  Mouse,
  OrbitMode,
  OrthoPerspectiveCamera,
  PlanMode,
  ProjectionManager,
  PropertiesStreamingSettings,
  Raycasters,
  SectionGenerator,
  ShadowedScene,
  SimpleCamera,
  SimpleGrid,
  SimpleGridConfigManager,
  SimplePlane,
  SimpleRaycaster,
  SimpleRenderer,
  SimpleScene,
  SimpleSceneConfigManager,
  SimpleWorld,
  Topic,
  UUID,
  VertexPicker,
  Viewpoint,
  Viewpoints,
  Worlds,
  extensionsImporter,
  ifcCategoryCase,
  ifcRelAttrsPosition,
  ifcRelClassNames,
  isPointInFrontOfPlane,
  obbFromPoints,
  readPixelsAsync,
  relToAttributesMap
};
/*! Bundled license information:

@thatopen/components/dist/index.mjs:
  (*!
   * camera-controls
   * https://github.com/yomotsu/camera-controls
   * (c) 2017 @yomotsu
   * Released under the MIT License.
   *)
  (*!
  
  JSZip v3.10.1 - A JavaScript class for generating and reading zip files
  <http://stuartk.com/jszip>
  
  (c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
  Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.
  
  JSZip uses the library pako released under the MIT license :
  https://github.com/nodeca/pako/blob/main/LICENSE
  *)
*/
//# sourceMappingURL=@thatopen_components.js.map
